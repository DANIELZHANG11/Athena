Directory Structure:
./
    雅典娜开发技术文档汇总/
    figma做的首页/
        guidelines/
        styles/
        components/
            ui/
            figma/
    web/
        android/
            gradle/
                wrapper/
            capacitor-cordova-android-plugins/
                src/
                    main/
                        java/
                        res/
            app/
                src/
                    test/
                        java/
                            com/
                                getcapacitor/
                                    myapp/
                    androidTest/
                        java/
                            com/
                                getcapacitor/
                                    myapp/
                    main/
                        assets/
                            public/
                                locales/
                                    zh-CN/
                                    en/
                                INDEXJPG/
                                assets/
                        java/
                            com/
                                athena/
                                    reader/
                        res/
                            drawable-port-xxhdpi/
                            mipmap-anydpi-v26/
                            drawable-port-hdpi/
                            mipmap-mdpi/
                            xml/
                            drawable-port-mdpi/
                            drawable-land-xhdpi/
                            mipmap-hdpi/
                            values/
                            drawable-port-xhdpi/
                            mipmap-xhdpi/
                            drawable-v24/
                            drawable/
                            drawable-land-xxhdpi/
                            drawable-port-xxxhdpi/
                            mipmap-xxhdpi/
                            drawable-land-mdpi/
                            drawable-land-xxxhdpi/
                            drawable-land-hdpi/
                            layout/
                            mipmap-xxxhdpi/
        src/
            landing/
            test/
            locales/
                zh-CN/
                en-US/
            lib/
                powersync/
                    hooks/
            config/
            __tests__/
            i18n/
            dev/
            contexts/
            figma/
            pages/
                debug/
                admin/
                auth/
                app/
                    home/
            hooks/
                data/
            styles/
            layouts/
            types/
            components/
                reader/
                ui/
                BookCard/
                auth/
                account/
                layouts/
                upload/
                base/
            stores/
        translations/
        plugins/
        scripts/
        public/
            locales/
                zh-CN/
                en/
            INDEXJPG/
            icons/
        cypress/
            e2e/
            support/
    scripts/
    tests/
    data_ssd/
        valkey/
        opensearch/
            nodes/
                0/
                    indices/
                        WiN-fdvRR7uiQo7lZYF8kQ/
                            0/
                                _state/
                                translog/
                                index/
                            _state/
                        Iqsm2Nn9RviIEMu4BjYDTA/
                            0/
                                _state/
                                translog/
                                index/
                            _state/
                        bfCVHYc8T5u888-ZEOexmw/
                            0/
                                _state/
                                translog/
                                index/
                            _state/
                        ZaLkIBtgTZKEDHgC4r1l1w/
                            0/
                                _state/
                                translog/
                                index/
                            _state/
                    _state/
        hf_cache/
    .github/
        workflows/
    backups/
    api/
        .pytest_cache/
            v/
                cache/
        .hf_cache/
        scripts/
        tests/
        alembic/
            versions/
        app/
            tasks/
            routes/
            services/
            books/
    monitoring/
        dashboards/
    .trae/
        rules/
        documents/
    .mypy_cache/
        3.14/
            _typeshed/
            logging/
            json/
            zipfile/
                _path/
            http/
            urllib/
            multiprocessing/
            os/
            alembic/
                ddl/
                autogenerate/
                operations/
                script/
                runtime/
                util/
            tomli/
            sys/
            concurrent/
                futures/
            api/
                scripts/
                alembic/
                    versions/
                app/
                    services/
            ctypes/
            sqlalchemy/
                connectors/
                event/
                sql/
                orm/
                pool/
                dialects/
                    oracle/
                    mysql/
                    postgresql/
                    mssql/
                future/
                ext/
                    asyncio/
                engine/
                util/
            zoneinfo/
            email/
                mime/
            collections/
            importlib/
                resources/
                metadata/
            asyncio/
        3.11/
            _typeshed/
            logging/
            json/
            zipfile/
            http/
            urllib/
            multiprocessing/
            os/
            sys/
            concurrent/
                futures/
            api/
                alembic/
                app/
            ctypes/
            email/
                mime/
            collections/
            importlib/
                resources/
                metadata/
            asyncio/
    .agent/
        rules/
    docker/
        opensearch/
        pgbouncer/
        powersync/
        nginx/
        postgres/
        frpc/
    contracts/
        api/
            v1/

==================================================



==================================================
FILE_PATH: docker-compose.prod.yml
==================================================

# =========================================================================
# Athena 生产环境 Docker Compose 配置（带独立 Nginx + FRP）
# =========================================================================
# 说明：
# - 此配置用于生产环境部署
# - 包含独立的 Nginx 反向代理和 FRP 内网穿透
# - 使用方法：docker-compose -f docker-compose.prod.yml up -d
# =========================================================================

services:
  # Nginx 反向代理（替代 Traefik）
  nginx:
    build:
      context: ./docker/nginx
    container_name: athena_nginx
    restart: unless-stopped
    ports:
      - "48080:80"    # HTTP
      - "48443:443"   # HTTPS（生产环境使用）
    volumes:
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./web/dist:/usr/share/nginx/html:ro  # 前端静态文件
      - nginx_logs:/var/log/nginx
    depends_on:
      - api
      - powersync
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"

  # FRP 客户端（内网穿透）
  frpc:
    build:
      context: ./docker/frpc
    container_name: athena_frpc
    restart: unless-stopped
    volumes:
      - ./docker/frpc/frpc.toml:/etc/frp/frpc.toml:ro
    depends_on:
      - nginx
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "2"

  # API 服务（FastAPI）
  api:
    build:
      context: ./api
    container_name: athena_api
    restart: unless-stopped
    env_file:
      - .env
      - .env.local
      - .env.infisical
    environment:
      ES_URL: http://opensearch:9200
      REDIS_URL: redis://valkey:6379
      REDIS_HOST: valkey
      REDIS_PORT: 6379
      SENTRY_DSN: ""
      DATABASE_URL: postgresql+asyncpg://athena:${POSTGRES_PASSWORD}@pgbouncer:6432/athena
      CELERY_BROKER_URL: redis://valkey:6379/0
      CELERY_BACKEND_URL: redis://valkey:6379/1
      MINIO_PUBLIC_ENDPOINT: http://localhost:48333
      MINIO_ENDPOINT: seaweed:8333
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      MINIO_BUCKET: athena
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL}
      SMTP_USE_SSL: ${SMTP_USE_SSL}
      PAY_FAKE_WEBHOOK_SECRET: devsecret
    depends_on:
      - pgbouncer
      - valkey
      - opensearch
    networks:
      - athena-network
    extra_hosts:
      - "host.docker.internal:host-gateway"
    volumes:
      - ./api:/app
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"

  # 其他服务继承自 docker-compose.yml...
  # 这里只列出生产环境特有的服务
  # 其他服务使用: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

volumes:
  nginx_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/athena/nginx_logs

networks:
  athena-network:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1


==================================================
FILE_PATH: docker-compose.yml
==================================================

services:
  traefik:
    image: zukubq0aouv2k2.xuanyuan.run/traefik:latest
    command:
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.web.address=:80
      - --api.insecure=true
    environment:
      # 设置 Docker API 版本以匹配主机
      - DOCKER_API_VERSION=1.44
    ports:
      - "48080:80"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      - api
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  api:
    build:
      context: ./api
    env_file:
      - .env
    environment:
      ES_URL: http://opensearch:9200
      REDIS_URL: redis://valkey:6379
      REDIS_HOST: valkey
      REDIS_PORT: 6379
      SENTRY_DSN: ""
      DATABASE_URL: postgresql+asyncpg://athena:${POSTGRES_PASSWORD}@pgbouncer:6432/athena
      CELERY_BROKER_URL: redis://valkey:6379/0
      CELERY_BACKEND_URL: redis://valkey:6379/1
      # JWT 认证密钥 - 必须与 PowerSync 一致
      AUTH_SECRET: ${AUTH_SECRET:-dev_powersync_secret_change_in_production}
      # 认证会话配置 (App-First 模式)
      ACCESS_EXPIRE: ${ACCESS_EXPIRE:-86400}
      REFRESH_EXPIRE: ${REFRESH_EXPIRE:-2592000}
      MINIO_PUBLIC_ENDPOINT: http://localhost:8333
      MINIO_ENDPOINT: seaweed:8333
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      MINIO_BUCKET: athena
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL}
      SMTP_USE_SSL: ${SMTP_USE_SSL}
      PAY_FAKE_WEBHOOK_SECRET: devsecret
    labels:
      - traefik.enable=true
      - traefik.http.routers.api.rule=Host(`api.youdomin.com`)
      - traefik.http.routers.api.entrypoints=web
      - traefik.http.services.api.loadbalancer.server.port=8000
      - traefik.http.middlewares.api-ratelimit.ratelimit.average=100
      - traefik.http.middlewares.api-ratelimit.ratelimit.burst=50
      - traefik.http.routers.api.middlewares=api-ratelimit
      - traefik.http.routers.api-local.rule=Host(`localhost`)
      - traefik.http.routers.api-local.entrypoints=web
      - traefik.http.routers.api-local.middlewares=api-ratelimit
      - traefik.http.routers.api-local.service=api
    depends_on:
      - pgbouncer
    ports:
      - "48000:8000"
    extra_hosts:
      - "host.docker.internal:host-gateway"
    volumes:
      - ./api:/app
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  backup:
    image: zukubq0aouv2k2.xuanyuan.run/postgres:16
    profiles: [ "manual" ]
    entrypoint: [ "bash", "-lc", "pg_dump -h postgres -U ${POSTGRES_USER} -d ${POSTGRES_DB} | gzip > /backups/athena_$(date +%Y%m%d_%H%M).sql.gz" ]
    environment:
      - PGPASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - ./backups:/backups
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  postgres:
    image: zukubq0aouv2k2.xuanyuan.run/ankane/pgvector:latest
    environment:
      - POSTGRES_USER=athena
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=athena
      # 启用 replication
      - POSTGRES_INITDB_ARGS=--auth-host=scram-sha-256
    command:
      - "postgres"
      - "-c"
      - "wal_level=logical"
      - "-c"
      - "max_replication_slots=10"
      - "-c"
      - "max_wal_senders=10"
      - "-c"
      - "hba_file=/etc/postgresql/pg_hba.conf"
    volumes:
      - pg_data:/var/lib/postgresql/data
      - ./docker/postgres/pg_hba.conf:/etc/postgresql/pg_hba.conf:ro
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "athena" ]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  valkey:
    image: zukubq0aouv2k2.xuanyuan.run/redis:7
    command: [ "redis-server", "--appendonly", "yes" ]
    volumes:
      - valkey_data:/data
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  seaweed:
    image: zukubq0aouv2k2.xuanyuan.run/chrislusf/seaweedfs:latest
    command: [ "server", "-s3", "-s3.port=8333", "-s3.allowedOrigins=*", "-dir=/data" ]
    ports:
      - "48333:8333"
      - "48888:8888"
    volumes:
      - seaweed_data:/data
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  opensearch:
    # 使用自定义构建以包含 IK/Pinyin/STConvert 插件
    build:
      context: ./docker/opensearch
    image: athena-opensearch:custom
    environment:
      - discovery.type=single-node
      - DISABLE_SECURITY_PLUGIN=true
      - OPENSEARCH_JAVA_OPTS=-Xms512m -Xmx512m
    ports:
      - "49200:9200"
    volumes:
      - opensearch_data:/usr/share/opensearch/data
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:9200/_cluster/health" ]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  pgbouncer:
    image: zukubq0aouv2k2.xuanyuan.run/bitnami/pgbouncer:1.22.0
    environment:
      # Bitnami PgBouncer 配置 - 使用 md5 认证
      - POSTGRESQL_HOST=postgres
      - POSTGRESQL_PORT=5432
      - POSTGRESQL_USERNAME=athena
      - POSTGRESQL_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRESQL_DATABASE=athena
      - PGBOUNCER_DATABASE=athena
      - PGBOUNCER_PORT=6432
      - PGBOUNCER_AUTH_TYPE=md5
      - PGBOUNCER_POOL_MODE=session
      - PGBOUNCER_MAX_CLIENT_CONN=200
      - PGBOUNCER_DEFAULT_POOL_SIZE=20
      - PGBOUNCER_IGNORE_STARTUP_PARAMETERS=extra_float_digits,search_path
      # 使用自定义 userlist.txt (含 md5 hash)
      - PGBOUNCER_USERLIST_FILE=/bitnami/pgbouncer/conf/userlist.txt
    volumes:
      - ./docker/pgbouncer/userlist.txt:/bitnami/pgbouncer/conf/userlist.txt:ro
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - athena-network
    healthcheck:
      test: ["CMD", "/bin/sh", "-c", "timeout 2 bash -c '</dev/tcp/localhost/6432' || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"

  # -------------------------------------------------------------------------
  # MongoDB (PowerSync 存储后端)
  # -------------------------------------------------------------------------
  mongo:
    image: zukubq0aouv2k2.xuanyuan.run/mongo:7
    command: ["--replSet", "rs0", "--bind_ip_all"]
    ports:
      - "47017:27017"
    volumes:
      - mongo_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "rs.status().ok || rs.initiate({_id:'rs0',members:[{_id:0,host:'mongo:27017'}]}).ok"]
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"

  # -------------------------------------------------------------------------
  # PowerSync Service (App-First 同步引擎)
  # @see 09 - APP-FIRST架构改造计划.md - Phase 1
  # -------------------------------------------------------------------------
  powersync:
    image: zukubq0aouv2k2.xuanyuan.run/journeyapps/powersync-service:latest
    ports:
      - "${POWERSYNC_PORT:-48080}:8080"
      - "49091:9090"  # Prometheus metrics
    environment:
      # PowerSync 要求 PS_ 前缀的环境变量
      - PS_DATABASE_URI=postgresql://athena:${POSTGRES_PASSWORD}@postgres:5432/athena
      - PS_SUPABASE_JWT_SECRET=${AUTH_SECRET:-dev_powersync_secret_change_in_production}
      - PS_MONGO_URI=mongodb://mongo:27017/powersync?replicaSet=rs0
      - PS_LOG_LEVEL=${POWERSYNC_LOG_LEVEL:-info}
      # 兼容性保留
      - POWERSYNC_JWT_SECRET=${AUTH_SECRET:-dev_powersync_secret_change_in_production}
      - POWERSYNC_UPLOAD_ENABLED=${POWERSYNC_UPLOAD_ENABLED:-true}
      - POWERSYNC_LOG_LEVEL=${POWERSYNC_LOG_LEVEL:-info}
    volumes:
      - ./docker/powersync/powersync.yaml:/app/powersync.yaml:ro
      - ./docker/powersync/sync_rules.yaml:/app/sync_rules.yaml:ro
    depends_on:
      postgres:
        condition: service_healthy
      mongo:
        condition: service_healthy
    healthcheck:
      # PowerSync 正确的健康检查端点是 /probes/liveness
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:8080/probes/liveness', r => process.exit(r.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1))"]
      interval: 15s
      timeout: 10s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"

  calibre:
    image: zukubq0aouv2k2.xuanyuan.run/linuxserver/calibre:latest
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Asia/Shanghai
    volumes:
      - calibre_config:/config
      - calibre_books:/books
      - ./scripts/calibre-convert-watcher.sh:/scripts/convert-watcher.sh:ro
    ports:
      - "48081:8080"
      - "48082:8081"
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
  # Calibre 转换监控器 - 监听转换请求并执行 ebook-convert
  calibre-watcher:
    image: zukubq0aouv2k2.xuanyuan.run/linuxserver/calibre:latest
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Asia/Shanghai
    volumes:
      - calibre_books:/books
      - ./scripts/calibre-convert-watcher.sh:/scripts/convert-watcher.sh:ro
    # 启动时运行 watcher 脚本
    entrypoint: ["/bin/bash", "/scripts/convert-watcher.sh"]
    command: []
    depends_on:
      - calibre
    restart: unless-stopped
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "2"

  # Calibre 元数据提取监控器 - 使用 ebook-meta 即时提取非 EPUB/PDF 的元数据和封面
  calibre-metadata:
    image: zukubq0aouv2k2.xuanyuan.run/linuxserver/calibre:latest
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Asia/Shanghai
    volumes:
      - calibre_books:/books
      - ./scripts/calibre-metadata-watcher.sh:/scripts/metadata-watcher.sh:ro
    entrypoint: ["/bin/bash", "/scripts/metadata-watcher.sh"]
    command: []
    depends_on:
      - calibre
    restart: unless-stopped
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "2"

  worker:
    build:
      context: ./api
      args:
        SKIP_HEAVY: "false"  # 安装 PaddleOCR + BGE-M3 + EdgeTTS
    environment:
      - CELERY_BROKER_URL=redis://valkey:6379/0
      - CELERY_BACKEND_URL=redis://valkey:6379/1
      - DATABASE_URL=postgresql+asyncpg://athena:${POSTGRES_PASSWORD}@pgbouncer:6432/athena
      - MINIO_ENDPOINT=seaweed:8333
      - MINIO_ACCESS_KEY=${MINIO_ROOT_USER}
      - MINIO_SECRET_KEY=${MINIO_ROOT_PASSWORD}
      - MINIO_BUCKET=athena
      - CALIBRE_CONVERT_DIR=/calibre_books
      # OCR 配置 (PP-OCRv5 mobile)
      - OCR_USE_GPU=true
      - OCR_GPU_MEM=4000
      - OCR_CPU_THREADS=8
      - OCR_LANG=ch
      # Embedding 配置 (BGE-M3)
      - EMBEDDING_MODEL_NAME=BAAI/bge-m3
      - HF_HOME=/app/.hf_cache
      # GPU 内存控制 (RTX 3060 12GB: PaddleOCR ~3GB + BGE-M3 ~3GB)
      - FLAGS_fraction_of_gpu_memory_to_use=0.5
    # 3 Workers (RTX 3060 12GB GPU，最佳并发)
    # PaddleOCR + BGE-M3 约占用 6-7GB，剩余约 5GB 用于推理缓冲
    command: ["celery", "-A", "app.celery_app.celery_app", "worker", "-l", "INFO", "--concurrency=3", "--pool=prefork", "--max-tasks-per-child=100"]
    depends_on:
      - valkey
      - pgbouncer
      - seaweed
      - opensearch
    volumes:
      - ./api:/app
      - calibre_books:/calibre_books
      - hf_cache:/app/.hf_cache
    # GPU 支持（需要 nvidia-docker）
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]
    networks:
      - athena-network
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "3"
# =========================================================================
# 数据卷配置 - SSD + HDD 混合存储方案
# =========================================================================
# 存储策略说明：
# 1. 高性能需求（随机读写频繁）-> SSD (/home/vitiana/Athena/data_ssd/)
#    - PostgreSQL: 数据库事务日志，IOPS 敏感
#    - OpenSearch: 全文索引，查询性能要求高
#    - Valkey (Redis): AOF 持久化，写入频繁
#    - HuggingFace Cache: 模型加载时间敏感
#
# 2. 大容量需求（顺序读写为主）-> bcache HDD (/data/athena/)
#    - SeaweedFS: 对象存储，大文件存储
#    - Calibre: 电子书库，大文件存储
#    - Tolgee: 低频访问的翻译数据库
#
# 性能测试结果：
#   - SSD 顺序写: 932 MB/s, 随机读 4K: 11,200 IOPS
#   - bcache 顺序写: 575 MB/s (writearound 模式)
# =========================================================================

volumes:
  # --- 高性能存储（SSD）---
  pg_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/vitiana/Athena/data_ssd/postgres
  
  valkey_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/vitiana/Athena/data_ssd/valkey
  
  opensearch_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/vitiana/Athena/data_ssd/opensearch
  
  hf_cache:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /home/vitiana/Athena/data_ssd/hf_cache
  
  # --- 大容量存储（bcache HDD）---
  seaweed_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/athena/seaweed
  
  calibre_books:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/athena/calibre_books
  
  calibre_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/athena/calibre_config

  # MongoDB 数据（PowerSync 存储）
  mongo_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /data/athena/mongo


networks:
  athena-network:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1


==================================================
FILE_PATH: web/package.json
==================================================

{
  "name": "athena-web",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint \"src/**/*.{ts,tsx}\"",
    "typecheck": "tsc --noEmit",
    "i18n:no-hardcode": "node scripts/no-hardcode.cjs",
    "i18n:sync": "node scripts/i18n-sync.cjs",
    "e2e": "cypress run",
    "prettier:check": "prettier -c \"src/**/*.{ts,tsx,json,css,md}\"",
    "test:ci": "vitest run --coverage",
    "contracts:lint": "npx -y @redocly/cli lint ../contracts/api/v1/**/*.yaml",
    "e2e:axe": "cypress run --spec cypress/e2e/axe.cy.ts",
    "e2e:flows": "cypress run --spec cypress/e2e/billing.cy.ts,cypress/e2e/docs.cy.ts",
    "test": "vitest",
    "coverage": "vitest --coverage"
  },
  "dependencies": {
    "@journeyapps/wa-sqlite": "^1.4.1",
    "@powersync/react": "^1.8.2",
    "@powersync/web": "^1.30.0",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-aspect-ratio": "^1.1.8",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-hover-card": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-menubar": "^1.1.16",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-progress": "^1.1.8",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toggle": "^1.1.10",
... (JSON truncated) ...

==================================================
FILE_PATH: web/tsconfig.json
==================================================

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": false,
    "skipLibCheck": true,
    "types": [
      "vite/client",
      "vite-plugin-pwa/client",
      "node"
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "noEmit": true
  },
  "include": [
    "src"
  ]
}

==================================================
FILE_PATH: web/vite.config.ts
==================================================

/**
 * Vite 构建配置
 * - React 插件与 PWA 集成
 * - `@` 别名指向 `src`
 * - 本地开发代理 `/api` 与 `/s3`
 * - 【离线优先】自定义 Service Worker 配置
 */
import { defineConfig } from 'vite'
import { fileURLToPath, URL } from 'node:url'
import react from '@vitejs/plugin-react'
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      // 【离线优先】使用自定义 Service Worker
      strategies: 'injectManifest',
      srcDir: 'src',
      filename: 'sw.ts',
      injectRegister: 'auto',
      manifest: {
        name: '雅典娜阅读器',
        short_name: 'Athena',
        description: '智能阅读 · 离线优先的电子书阅读器',
        start_url: '/',
        display: 'standalone',
        background_color: '#ffffff',
        theme_color: '#4f46e5',
        icons: [
          {
            src: '/icons/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: '/icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
          {
            src: '/icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'maskable',
          },
        ],
        categories: ['books', 'education', 'productivity'],
        shortcuts: [
          {
            name: '我的书库',
            short_name: '书库',
            url: '/library',
            icons: [{ src: '/icons/library-96x96.png', sizes: '96x96' }],
          },
          {
            name: '继续阅读',
            short_name: '阅读',
            url: '/reader/last',
            icons: [{ src: '/icons/reader-96x96.png', sizes: '96x96' }],
          },
        ],
      },
      // Workbox 配置（用于 injectManifest 模式）
      injectManifest: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,json,woff,woff2}'],
        maximumFileSizeToCacheInBytes: 5 * 1024 * 1024, // 5MB
      },
      devOptions: {
        enabled: true, // 开发模式下启用 PWA
        type: 'module',
      },
    }),
  ],
  resolve: {
    alias: [
      { find: '@', replacement: fileURLToPath(new URL('./src', import.meta.url)) }
    ]
  },
  worker: {
    format: 'es',
    plugins: () => [react()],
  },
  build: {
    target: 'esnext',
    rollupOptions: {
      output: {
        manualChunks: {
          'powersync': ['@powersync/web', '@powersync/react'],
          'sqlite': ['@journeyapps/wa-sqlite'],
        },
      },
    },
  },
  optimizeDeps: {
    exclude: ['@journeyapps/wa-sqlite', '@powersync/web'],
    esbuildOptions: {
      target: 'esnext',
    },
  },
  server: {
    port: 48173,
    host: '0.0.0.0', // 允许外部访问（Android 模拟器）
    hmr: { 
      protocol: 'ws',
      host: '192.168.0.122', // 使用服务器 IP，让 Android 模拟器能连接
      port: 48173
    },
    proxy: {
      '/api': {
        target: 'http://localhost:48000',
        changeOrigin: true,
        ws: true
      },
      // PowerSync 代理 - 让 Android 可以通过 Vite 访问
      '/powersync': {
        target: 'http://localhost:48090',
        changeOrigin: true,
        ws: true,
        rewrite: (path) => path.replace(/^\/powersync/, '')
      },
      '/s3': {
        target: 'http://localhost:48333',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/s3/, '')
      }
    }
  }
})


==================================================
FILE_PATH: web/src/Price.tsx
==================================================

import { useEffect, useState } from 'react'
import i18n from './i18n'

export default function Price() {
  const [price, setPrice] = useState<{ amount_minor: number; currency: string } | null>(null)
  useEffect(() => {
    const cur = i18n.language === 'zh-CN' ? 'CNY' : 'USD'
    fetch(`/api/v1/pricing/plans?currency=${cur}`)
      .then((r) => r.json())
      .then((j) => {
        const proMonthly = (j.data || []).find((x: any) => x.plan_code === 'pro' && x.period === 'monthly')
        if (proMonthly) setPrice({ amount_minor: proMonthly.amount_minor, currency: proMonthly.currency })
      })
      .catch(() => {})
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [i18n.language])
  if (!price) return null
  const factor = price.currency === 'JPY' ? 1 : 100
  const amount = price.amount_minor / factor
  const fmt = new Intl.NumberFormat(i18n.language, { style: 'currency', currency: price.currency })
  return <div style={{ marginTop: 16 }}>{fmt.format(amount)}/mo</div>
}

==================================================
FILE_PATH: web/src/App.tsx
==================================================

import { BrowserRouter, Routes, Route } from 'react-router-dom'
import LandingLayout from './layouts/LandingLayout'
import AuthLayout from './layouts/AuthLayout'
import AppLayout from './layouts/AppLayout'
import HomePage from './pages/HomePage'
import LibraryPage from './pages/LibraryPage'
import AIConversationsPage from './pages/AIConversationsPage'
import SearchPage from './pages/SearchPage'
import NotesPage from './pages/NotesPage'
import ProfilePage from './pages/ProfilePage'
import DocEditor from './pages/DocEditor'
import TTSPage from './pages/TTSPage'
import BillingPage from './pages/BillingPage'
import RecentlyDeletedPage from './pages/RecentlyDeletedPage'
import Login from './pages/auth/Login'
import Register from './pages/auth/Register'
import AuthGuard from './components/auth/AuthGuard'
import ReadNowPage from './pages/ReadNowPage'
import { Navigate } from 'react-router-dom'
import AppHome from './pages/app/Home'
import ReaderPage from './pages/ReaderPage'
import { useTokenRefresh } from './hooks/useTokenRefresh'
import { NoteConflictProvider } from './contexts/NoteConflictContext'
import { PowerSyncProvider } from './lib/powersync'

import SelfCheckPage from './pages/debug/SelfCheckPage'

/**
 * 应用路由入口
 *
 * 说明：
 * - 使用 `react-router-dom` 管理三层路由：Landing、Auth、App
 * - `AuthGuard` 保护应用内页，未登录将重定向至登录页
 * - `useTokenRefresh` 启用后台 Token 定时刷新，降低 401 风险
 * - `PowerSyncProvider` 启用 App-First 离线同步 (受 Feature Flag 控制)
 * - 所有页面组件仅通过路由装载，避免在入口处做业务逻辑
 */
export default function App() {
  // 启用后台自动 token 刷新
  useTokenRefresh()

  return (
    <PowerSyncProvider>
      <NoteConflictProvider>
        <BrowserRouter>
          <Routes>
            <Route path="/" element={<LandingLayout />}>
              <Route index element={<HomePage />} />
            </Route>
            <Route element={<AuthLayout />}>
              <Route path="/login" element={<Login />} />
              <Route path="/register" element={<Register />} />
            </Route>
            <Route path="/app" element={<AppLayout />}>
              <Route index element={<Navigate to="/app/home" replace />} />
              <Route path="home" element={<AuthGuard><AppHome /></AuthGuard>} />
              <Route path="read-now" element={<AuthGuard><ReadNowPage /></AuthGuard>} />
              <Route path="library" element={<AuthGuard><LibraryPage /></AuthGuard>} />
              <Route path="ai-conversations" element={<AuthGuard><AIConversationsPage /></AuthGuard>} />
              <Route path="search" element={<AuthGuard><SearchPage /></AuthGuard>} />
              <Route path="notes" element={<AuthGuard><NotesPage /></AuthGuard>} />
              <Route path="profile" element={<AuthGuard><ProfilePage /></AuthGuard>} />
              <Route path="docs/:docId" element={<AuthGuard><DocEditor /></AuthGuard>} />
              <Route path="read/:bookId" element={<AuthGuard><ReaderPage /></AuthGuard>} />
              <Route path="tts" element={<AuthGuard><TTSPage /></AuthGuard>} />
              <Route path="billing" element={<AuthGuard><BillingPage /></AuthGuard>} />
              <Route path="recently-deleted" element={<AuthGuard><RecentlyDeletedPage /></AuthGuard>} />
                          {/* 开发调试路由（仅开发环境） */}
              <Route path="debug/self-check" element={<SelfCheckPage />} />
            </Route>
          </Routes>
        </BrowserRouter>
      </NoteConflictProvider>
    </PowerSyncProvider>
  )
}


==================================================
FILE_PATH: web/src/i18n.ts
==================================================

/**
 * 国际化配置 (App-First / 离线优先)
 *
 * 说明：
 * - 通过 `import.meta.glob` 预加载本地 JSON 翻译资源
 * - 完全离线可用，无需外部服务
 * - 支持 zh-CN / en-US 双语言
 *
 * @see 00 - AI 编码宪法与规范AI_Coding_Constitution_and_Rules.md 第五章
 */
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'

// 动态加载所有翻译文件
const modules = import.meta.glob('./locales/*/*.json', { eager: true })

const resources: Record<string, Record<string, any>> = {}

for (const path in modules) {
  const match = path.match(/\.\/locales\/([^/]+)\/([^/]+)\.json$/)
  if (match) {
    const [, lang, ns] = match
    if (!resources[lang]) resources[lang] = {}
    resources[lang][ns] = (modules[path] as any).default || modules[path]
  }
}

// 语言检测优先级：localStorage > 浏览器语言 > 默认 zh-CN
const storedLng = typeof window !== 'undefined' 
  ? localStorage.getItem('i18nextLng') 
  : undefined

const browserLng = typeof navigator !== 'undefined' 
  ? (navigator.language?.startsWith('zh') ? 'zh-CN' : navigator.language?.startsWith('en') ? 'en-US' : undefined)
  : undefined

const defaultLng = storedLng || browserLng || 'zh-CN'

// 初始化 i18next
i18n
  .use(initReactI18next)
  .init({
    resources,
    lng: defaultLng,
    fallbackLng: 'en-US',
    ns: ['common', 'landing', 'auth'],
    defaultNS: 'common',
    interpolation: {
      escapeValue: false
    },
    load: 'currentOnly',
    debug: import.meta.env.DEV,
    react: {
      useSuspense: false
    }
  })

export default i18n


==================================================
FILE_PATH: web/src/main.tsx
==================================================

/**
 * 应用启动入口
 *
 * 说明：
 * - 初始化国际化与全局样式
 * - 可选注册 PWA 服务工作线程（Service Worker，测试环境/Cypress 禁用）
 * - 使用 React 18 `createRoot` 挂载应用
 */

// ⚠️ Web Locks Polyfill 必须最先加载，在任何 PowerSync 代码之前
import { installWebLocksPolyfill } from './lib/webLocksPolyfill'
installWebLocksPolyfill()

import React from 'react'
import { createRoot } from 'react-dom/client'
import './i18n'
import './index.css'
import './styles/figma.css'
import App from './App'
import { registerSW } from 'virtual:pwa-register'
if (typeof window !== 'undefined' && !('Cypress' in window) && !import.meta.env.VITE_DISABLE_PWA) {
  registerSW({ immediate: true })
}
const el = document.getElementById('root')
if (el) {
  createRoot(el).render(<App />)
}


==================================================
FILE_PATH: web/src/index.css
==================================================

@import "tailwindcss";

/* 全局移动端优化 */
html {
  overflow-x: hidden;
  width: 100%;
  max-width: 100%;
}

body {
  overflow-x: hidden;
  width: 100%;
  max-width: 100%;
  position: relative;
}

#root {
  overflow-x: hidden;
  width: 100%;
  max-width: 100%;
}

/* 防止所有元素超出屏幕宽度 */
* {
  max-width: 100vw;
}

@layer utilities {
  .mask-linear-fade {
    mask-image: linear-gradient(to right, transparent 0%, black 2%, black 98%, transparent 100%);
    -webkit-mask-image: linear-gradient(to right, transparent 0%, black 2%, black 98%, transparent 100%);
  }
}

==================================================
FILE_PATH: web/src/sw.ts
==================================================

/**
 * sw.ts - 自定义 Service Worker
 * 
 * 缓存策略:
 * - 静态资源: CacheFirst（长期缓存）
 * - API 请求: NetworkFirst（优先网络，失败回退缓存）
 * - 图片资源: CacheFirst + 过期清理
 * - 书籍内容: CacheOnly（离线阅读核心）
 * 
 * @see App-First改造计划.md - Phase 4.1
 */

/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
  NetworkOnly,
} from 'workbox-strategies'
import { ExpirationPlugin } from 'workbox-expiration'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'
// BackgroundSyncPlugin 已移除 - PowerSync 负责所有数据同步

declare const self: ServiceWorkerGlobalScope

// 版本号（用于缓存命名空间）
// 每次重大更改时递增版本号以强制缓存刷新
const SW_VERSION = '1.1.0'

// 缓存名称
const CACHE_NAMES = {
  static: `athena-static-v${SW_VERSION}`,
  api: `athena-api-v${SW_VERSION}`,
  images: `athena-images-v${SW_VERSION}`,
  books: `athena-books-v${SW_VERSION}`,
}

// Precache manifest (由 vite-plugin-pwa 自动注入)
precacheAndRoute(self.__WB_MANIFEST)

// 清理旧版本缓存
cleanupOutdatedCaches()

// =====================
// 静态资源缓存策略
// =====================

// JS/CSS 文件 - CacheFirst
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new CacheFirst({
    cacheName: CACHE_NAMES.static,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 天
      }),
    ],
  })
)

// 字体文件 - CacheFirst
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: CACHE_NAMES.static,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 年
      }),
    ],
  })
)

// =====================
// 图片缓存策略
// =====================

/**
 * 图片缓存策略
 * 
 * ⚠️ CORS 注意事项：
 * - 跨域图片（如 S3）如果没有正确的 CORS 头，会返回 Opaque Response (status=0)
 * - Opaque Response 会占用大量配额（浏览器按 ~7MB/张计算）
 * - 确保 S3 配置了 Access-Control-Allow-Origin: * 
 * - 或在 <img> 标签使用 crossorigin="anonymous"
 * 
 * 当前策略：
 * - 只缓存 status=200 的透明响应，跳过 opaque response (status=0)
 * - 这样可以避免配额爆满，但离线时跨域图片可能不可用
 */

// 同源图片（封面、本地图片）- CacheFirst
registerRoute(
  ({ request, url }) => {
    const isImage = request.destination === 'image' ||
      url.pathname.includes('/covers/') ||
      url.pathname.includes('/images/')
    // 只缓存同源图片，避免跨域 opaque response 问题
    const isSameOrigin = url.origin === self.location.origin
    return isImage && isSameOrigin
  },
  new CacheFirst({
    cacheName: CACHE_NAMES.images,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200], // 只缓存成功的透明响应，不缓存 opaque (0)
      }),
      new ExpirationPlugin({
        maxEntries: 500,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
        purgeOnQuotaError: true, // 存储空间不足时自动清理
      }),
    ],
  })
)

// 跨域图片（S3 等）- StaleWhileRevalidate + 严格过滤
registerRoute(
  ({ request, url }) => {
    const isImage = request.destination === 'image'
    const isCrossOrigin = url.origin !== self.location.origin
    // 只处理已知的可信域名（如你的 S3 bucket）
    const isTrustedCDN = url.hostname.includes('amazonaws.com') ||
      url.hostname.includes('cloudfront.net') ||
      url.hostname.includes('supabase')
    return isImage && isCrossOrigin && isTrustedCDN
  },
  new StaleWhileRevalidate({
    cacheName: CACHE_NAMES.images,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [200], // 严格只缓存透明响应
      }),
      new ExpirationPlugin({
        maxEntries: 200, // 跨域图片限制更少
        maxAgeSeconds: 3 * 24 * 60 * 60, // 3 天
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// =====================
// API 缓存策略
// =====================

// 用户资料 - NetworkFirst（离线时显示缓存）
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/v1/profile'),
  new NetworkFirst({
    cacheName: CACHE_NAMES.api,
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
      }),
    ],
  })
)

// AI 对话列表 - NetworkFirst（离线时显示缓存）
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/v1/ai/conversations'),
  new NetworkFirst({
    cacheName: CACHE_NAMES.api,
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
      }),
    ],
  })
)

// 首页数据 - NetworkFirst
registerRoute(
  ({ url }) =>
    url.pathname.startsWith('/api/v1/home') ||
    url.pathname.startsWith('/api/v1/dashboard'),
  new NetworkFirst({
    cacheName: CACHE_NAMES.api,
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 24 * 60 * 60, // 1 天
      }),
    ],
  })
)

// 书籍列表 - NetworkFirst（/api/v1/books 不带后续路径）
registerRoute(
  ({ url, request }) => {
    // 只匹配 GET 请求的书籍列表
    if (request.method !== 'GET') return false
    // 精确匹配 /api/v1/books 或 /api/v1/books?...
    return url.pathname === '/api/v1/books' ||
      url.pathname.startsWith('/api/v1/library')
  },
  new NetworkFirst({
    cacheName: CACHE_NAMES.api,
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60, // 1 天
      }),
    ],
  })
)

// 单本书籍元数据 - NetworkFirst（/api/v1/books/{id}）
// 用于阅读器初始化时获取书籍信息
registerRoute(
  ({ url, request }) => {
    if (request.method !== 'GET') return false
    // 匹配 /api/v1/books/{uuid} 格式（不包含 /cover, /content, /download 等子路径）
    const match = url.pathname.match(/^\/api\/v1\/books\/[a-f0-9-]+$/)
    return !!match
  },
  new NetworkFirst({
    cacheName: CACHE_NAMES.api,
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 天
      }),
    ],
  })
)

// 书籍封面 - CacheFirst（/api/v1/books/{id}/cover）
registerRoute(
  ({ url, request }) => {
    if (request.method !== 'GET') return false
    return url.pathname.match(/^\/api\/v1\/books\/[a-f0-9-]+\/cover/) !== null
  },
  new CacheFirst({
    cacheName: CACHE_NAMES.images,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 天
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// 阅读进度 - StaleWhileRevalidate
registerRoute(
  ({ url }) => url.pathname.includes('/reading-progress'),
  new StaleWhileRevalidate({
    cacheName: CACHE_NAMES.api,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
)


// 认证相关 - NetworkOnly（不缓存）
registerRoute(
  ({ url }) =>
    url.pathname.startsWith('/api/auth') ||
    url.pathname.startsWith('/api/login') ||
    url.pathname.startsWith('/api/logout'),
  new NetworkOnly()
)

// =====================
// 书籍内容缓存策略
// =====================

// 书籍内容（EPUB/PDF 等）- CacheFirst（离线阅读核心）
registerRoute(
  ({ url }) =>
    url.pathname.match(/^\/api\/v1\/books\/[a-f0-9-]+\/(content|download)/) !== null,
  new CacheFirst({
    cacheName: CACHE_NAMES.books,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50, // 最多缓存 50 本书
        maxAgeSeconds: 90 * 24 * 60 * 60, // 90 天
        purgeOnQuotaError: true,
      }),
    ],
  })
)

// =====================
// Service Worker 生命周期
// =====================

// 安装事件
self.addEventListener('install', () => {
  console.log('[SW] Installing version:', SW_VERSION)
  // 立即激活，不等待旧 SW 关闭
  self.skipWaiting()
})

// 激活事件
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating version:', SW_VERSION)

  // 清理旧版本缓存
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            // 删除不在当前版本缓存列表中的缓存
            return !Object.values(CACHE_NAMES).includes(cacheName) &&
              cacheName.startsWith('athena-')
          })
          .map((cacheName) => {
            console.log('[SW] Deleting old cache:', cacheName)
            return caches.delete(cacheName)
          })
      )
    })
  )

  // 立即控制所有客户端
  self.clients.claim()
})

// 消息处理
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[SW] Skip waiting requested')
    self.skipWaiting()
  }

  if (event.data && event.data.type === 'GET_VERSION') {
    event.ports[0]?.postMessage({ version: SW_VERSION })
  }

  if (event.data && event.data.type === 'CLEAR_CACHE') {
    const { cacheName } = event.data
    if (cacheName && CACHE_NAMES[cacheName as keyof typeof CACHE_NAMES]) {
      caches.delete(CACHE_NAMES[cacheName as keyof typeof CACHE_NAMES])
        .then(() => {
          console.log('[SW] Cache cleared:', cacheName)
          event.ports[0]?.postMessage({ success: true })
        })
    }
  }
})

// 推送通知（预留）
self.addEventListener('push', (event) => {
  if (!event.data) return

  const data = event.data.json()
  console.log('[SW] Push received:', data)

  event.waitUntil(
    self.registration.showNotification(data.title || '雅典娜', {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: data.tag || 'athena-notification',
      data: data.data,
    })
  )
})

// 通知点击
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification clicked:', event.notification.tag)
  event.notification.close()

  const urlToOpen = event.notification.data?.url || '/'

  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // 如果已有窗口打开，聚焦它
        for (const client of clientList) {
          if (client.url === urlToOpen && 'focus' in client) {
            return client.focus()
          }
        }
        // 否则打开新窗口
        if (self.clients.openWindow) {
          return self.clients.openWindow(urlToOpen)
        }
      })
  )
})

console.log('[SW] Service Worker loaded, version:', SW_VERSION)


==================================================
FILE_PATH: web/src/landing/FeatureHighlight.tsx
==================================================

import { motion } from 'framer-motion'

interface FeatureHighlightProps {
  title: string
  description: string
  imageSrc?: string
  imageAlt?: string
  layout?: 'horizontal' | 'vertical'
}

export default function FeatureHighlight({ title, description, imageSrc, imageAlt = '', layout = 'horizontal' }: FeatureHighlightProps) {
  return (
    <div className="py-16 bg-white">
      <div className="max-w-6xl mx-auto px-6">
        <div className={layout === 'horizontal' ? 'grid grid-cols-1 md:grid-cols-2 gap-12 items-center' : 'text-center'}>
          <motion.div initial={{ y: 60, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8 }}>
            <h3 className="text-3xl md:text-4xl text-gray-900 mb-6" style={{ fontWeight: 700, lineHeight: 1.1 }}>{title}</h3>
            <p className="text-lg md:text-xl text-gray-600 leading-relaxed">{description}</p>
          </motion.div>
          {imageSrc && (
            <motion.div initial={{ y: 80, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8, delay: 0.2 }} className="flex justify-center">
              <img src={imageSrc} alt={imageAlt} className="max-w-full h-auto rounded-2xl shadow-xl" />
            </motion.div>
          )}
        </div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/DeviceCompatibility.tsx
==================================================

import { motion } from 'framer-motion'
import { Smartphone, Tablet, Monitor, Watch, Tv, Speaker } from 'lucide-react'
import { useTranslation } from 'react-i18next'

export default function DeviceCompatibility() {
  const { t } = useTranslation('landing')

  const devices = [
    { icon: Smartphone, label: t('deviceCompatibility.devices.iphone') },
    { icon: Tablet, label: t('deviceCompatibility.devices.ipad') },
    { icon: Monitor, label: t('deviceCompatibility.devices.mac') },
    { icon: Watch, label: t('deviceCompatibility.devices.watch') },
    { icon: Tv, label: t('deviceCompatibility.devices.tv') },
    { icon: Speaker, label: t('deviceCompatibility.devices.carplay') },
  ]

  return (
    <div className="py-32 bg-gray-50">
      <div className="max-w-6xl mx-auto px-6">
        <motion.div initial={{ y: 60, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8 }} className="text-center mb-20">
          <h2 className="text-5xl md:text-6xl text-gray-900 mb-6" style={{ fontWeight: 700, lineHeight: 1.1 }}>{t('deviceCompatibility.titleLine1')}</h2>
          <h2 className="text-5xl md:text-6xl text-gray-900 mb-8" style={{ fontWeight: 700, lineHeight: 1.1 }}>{t('deviceCompatibility.titleLine2')}</h2>
        </motion.div>
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-8 md:gap-12">
          {devices.map((device, index) => {
            const Icon = device.icon
            return (
              <motion.div key={index} initial={{ y: 60, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.6, delay: index * 0.1 }} className="flex flex-col items-center text-center group">
                <div className="w-20 h-20 md:w-24 md:h-24 mb-4 flex items-center justify-center rounded-full bg-white shadow-lg group-hover:shadow-xl transition-shadow">
                  <Icon className="w-10 h-10 md:w-12 md:h-12 text-gray-700" />
                </div>
                <p className="text-lg text-gray-900" style={{ fontWeight: 600 }}>{device.label}</p>
              </motion.div>
            )
          })}
        </div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/Hero.tsx
==================================================

import { motion } from 'framer-motion'
import { useEffect } from 'react'
import DeviceShowcase from './DeviceShowcase'
import { useTranslation } from 'react-i18next'

export default function Hero() {
  const { t } = useTranslation('landing')
  useEffect(() => { const timer = setTimeout(() => { }, 2000); return () => clearTimeout(timer) }, [])
  return (
    <div className="relative bg-white text-gray-900 overflow-hidden pt-20 pb-0">
      <div className="max-w-6xl mx-auto px-6 text-center">
        <motion.div
          initial={{ scale: 5, y: 200, opacity: 1 }}
          animate={{ scale: 1, y: 0, opacity: 1 }}
          transition={{ duration: 1.5, ease: [0.22, 1, 0.36, 1] }}
          className="mb-12 flex justify-center"
        >
          <img src="/logosvg.png" alt="Athena Reader Logo" className="w-20 h-20 object-contain" />
        </motion.div>
        <motion.div
          initial={{ y: 60, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          transition={{ delay: 1.3, duration: 0.8, ease: [0.22, 1, 0.36, 1] }}
        >
          <h1 className="text-6xl md:text-7xl text-gray-900 mb-8" style={{ fontWeight: 700, lineHeight: 1.05, letterSpacing: '-0.015em', textShadow: '0 8px 24px rgba(0,0,0,0.12)' }}>{t('hero.title')}</h1>
        </motion.div>
        <motion.div
          initial={{ y: 50, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          transition={{ delay: 1.6, duration: 0.8, ease: [0.22, 1, 0.36, 1] }}
          className="mb-20"
        >
          <p className="text-xl md:text-2xl text-gray-600 max-w-4xl mx-auto leading-relaxed">
            {t('hero.subtitle')}
          </p>
        </motion.div>
        <DeviceShowcase />
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/BookGrid.tsx
==================================================

import { motion } from 'framer-motion'
import { useTranslation } from 'react-i18next'

interface Book { id: number; title: string; author: string; image: string }

const filenames = [
  '光纤传感原理与技术-冯亭.jpg',
  '古典吉他基础大教程-王迪平.jpg',
  '嘘！别被老板知道-圈圈.jpg',
  '孙子兵法与三十六计-张辉力.jpg',
  '怎么办？-路易·阿尔都塞.jpg',
  '战后三部曲-沃尔夫冈·克彭.jpg',
  '梦先生-罗贝尔·潘热.jpg',
  '法国与晚清中国-葛夫平.jpg',
  '海洋微生物学(第三版)-张晓华.jpg',
  '知识的繁荣与危机-戴维·温伯格.jpg',
  '空衣橱-安妮·埃尔诺.jpg',
  '精密机械设计(第四版)-许贤泽.jpg',
  '纸上谈爱 _ 情书里的父母爱情-张冲波.jpg',
  '终始：社会学的民俗学（1926-1950）-岳永逸.jpg',
  '给麻风病人的吻（2025版）-弗朗索瓦·莫里亚克.jpg',
  '美国与晚清中国（1894～1911）-崔志海.jpg',
  '肌肉！肌肉！预防和逆转疾病，健康长寿的科学指南-加布里埃尔·里昂博士.jpg',
  '裂谷-泉.jpg',
  '食人资本主义-南希·弗雷泽.jpg',
  '鱼出现的夜晚：乔·R.兰斯代尔短篇小说集-乔·R.兰斯代尔.jpg'
]

const bookCovers: Book[] = filenames.map((fn, idx) => {
  const base = fn.replace(/\.jpg$/i, '')
  const dash = base.lastIndexOf('-')
  const title = dash >= 0 ? base.slice(0, dash).trim() : base
  const author = dash >= 0 ? base.slice(dash + 1).trim() : ''
  return { id: idx + 1, title, author, image: `/INDEXJPG/${fn}` }
})

export default function BookGrid() {
  const { t } = useTranslation('landing')
  const itemsAll = bookCovers
  const Card = ({ book }: { book: Book }) => (
    <div className="book-card rounded-lg shadow-lg transition-transform duration-medium hover:scale-x-[1.08] hover:scale-y-[1.12] hover:shadow-2xl hover:z-10 relative flex flex-col items-center justify-start p-1 md:p-2 cursor-default" style={{ width: 180, willChange: 'transform', background: '#fff' }}>
      <div className="w-full rounded-md overflow-hidden" style={{ aspectRatio: '2 / 3', background: '#f3f4f6' }}>
        <img src={book.image} alt={book.title} className="w-full h-full object-cover" />
      </div>
      <div className="w-full text-center mt-1">
        <div className="text-[10px] md:text-sm mb-0.5" style={{ fontWeight: 700, color: '#111', lineHeight: 1.2 }}>{book.title}</div>
        <div className="text-[8px] md:text-xs" style={{ fontWeight: 500, color: '#555', opacity: 0.9 }}>{book.author}</div>
      </div>
    </div>
  )
  const Track = ({ items, delay }: { items: Book[]; delay: number }) => (
    <div className="marquee-row marquee-mask">
      <motion.div className="marquee-track" initial={{ x: '0%' }} animate={{ x: ['0%', '-50%'] }} transition={{ duration: 90, ease: 'linear', repeat: Infinity, delay }}>
        {items.map((b) => <Card key={`a-${b.id}`} book={b} />)}
        {items.map((b) => <Card key={`b-${b.id}`} book={b} />)}
      </motion.div>
    </div>
  )
  return (
    <div className="py-24 bg-gray-50">
      <div className="max-w-7xl mx-auto px-6">
        <motion.div initial={{ y: 60, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8 }} className="text-center mb-16">
          <h2 className="text-5xl md:text-6xl text-gray-900 mb-6" style={{ fontWeight: 700, lineHeight: 1.1 }}>{t('bookGrid.titleLine1')}</h2>
          <h2 className="text-5xl md:text-6xl text-gray-900 mb-8" style={{ fontWeight: 700, lineHeight: 1.1 }}>{t('bookGrid.titleLine2')}</h2>
          <p className="text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed">{t('bookGrid.description')}</p>
        </motion.div>
        <motion.div initial={{ y: 80, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8, delay: 0.2 }}>
          <Track items={itemsAll} delay={0} />
        </motion.div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/CTASection.tsx
==================================================

import { motion } from 'framer-motion'
import { useTranslation } from 'react-i18next'

export default function CTASection() {
  const { t } = useTranslation('landing')
  return (
    <div className="py-32 bg-gradient-to-b from-white to-gray-50">
      <div className="max-w-4xl mx-auto px-6 text-center">
        <motion.div initial={{ y: 60, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8 }}>
          <div className="mb-8 flex justify-center">
            <img src="/logosvg.png" alt="Athena Reader Logo" className="w-16 h-16 object-contain" />
          </div>
          <h2 className="text-5xl md:text-6xl text-gray-900 mb-8" style={{ fontWeight: 700, lineHeight: 1.1 }}>{t('ctaSection.title')}</h2>
          <p className="text-xl md:text-2xl text-gray-600 max-w-3xl mx-auto leading-relaxed mb-12">
            {t('ctaSection.description')}
          </p>
          <motion.div initial={{ y: 40, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true }} transition={{ duration: 0.6, delay: 0.2 }}>
            <a href="#" className="inline-block text-lg text-blue-600 hover:underline" style={{ fontWeight: 600 }}>{t('ctaSection.learnMore')}</a>
          </motion.div>
        </motion.div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/Footer.tsx
==================================================

import { motion } from 'framer-motion'
import { useTranslation } from 'react-i18next'

export default function Footer() {
  const { t } = useTranslation('landing')

  return (
    <footer className="bg-gray-50 text-gray-600 py-12 border-t border-gray-200">
      <div className="max-w-7xl mx-auto px-6">
        <motion.div initial={{ opacity: 0 }} whileInView={{ opacity: 1 }} viewport={{ once: true }} transition={{ duration: 0.6 }} className="text-center mb-8">
          <p className="text-sm mb-4">{t('footer.disclaimer')}</p>
        </motion.div>
        <motion.div initial={{ opacity: 0 }} whileInView={{ opacity: 1 }} viewport={{ once: true }} transition={{ duration: 0.6, delay: 0.2 }} className="border-t border-gray-200 pt-8">
          <div className="grid grid-cols-2 md:grid-cols-5 gap-8 mb-8 text-sm">
            <div>
              <h4 className="text-gray-900 mb-3" style={{ fontWeight: 600 }}>{t('footer.shopAndLearn.title')}</h4>
              <ul className="space-y-2">
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.shopAndLearn.store')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.shopAndLearn.mac')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.shopAndLearn.iPad')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.shopAndLearn.iPhone')}</a></li>
              </ul>
            </div>
            <div>
              <h4 className="text-gray-900 mb-3" style={{ fontWeight: 600 }}>{t('footer.services.title')}</h4>
              <ul className="space-y-2">
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.services.reader')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.services.music')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.services.tv')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.services.arcade')}</a></li>
              </ul>
            </div>
            <div>
              <h4 className="text-gray-900 mb-3" style={{ fontWeight: 600 }}>{t('footer.account.title')}</h4>
              <ul className="space-y-2">
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.account.manageId')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.account.account')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.account.icloud')}</a></li>
              </ul>
            </div>
            <div>
              <h4 className="text-gray-900 mb-3" style={{ fontWeight: 600 }}>{t('footer.store.title')}</h4>
              <ul className="space-y-2">
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.store.findStore')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.store.geniusBar')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.store.shoppingHelp')}</a></li>
              </ul>
            </div>
            <div>
              <h4 className="text-gray-900 mb-3" style={{ fontWeight: 600 }}>{t('footer.about.title')}</h4>
              <ul className="space-y-2">
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.about.newsroom')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.about.leadership')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.about.careers')}</a></li>
                <li><a href="#" className="hover:text-gray-900 transition-colors">{t('footer.about.contact')}</a></li>
              </ul>
            </div>
          </div>
          <div className="text-sm text-gray-500 pt-6 border-t border-gray-200">
            <p className="mb-4" dangerouslySetInnerHTML={{
              __html: t('footer.moreWays', {
                findStore: `<a href="#" class="text-blue-600 hover:underline">${t('footer.store.findStore')}</a>`,
                otherRetailer: `<a href="#" class="text-blue-600 hover:underline">${t('footer.otherRetailer')}</a>`
              })
            }} />
            <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
              <p>{t('footer.copyright')}</p>
              <div className="flex gap-4">
                <a href="#" className="hover:text-gray-900 transition-colors">{t('footer.privacyPolicy')}</a>
                <span>|</span>
                <a href="#" className="hover:text-gray-900 transition-colors">{t('footer.termsOfUse')}</a>
                <span>|</span>
                <a href="#" className="hover:text-gray-900 transition-colors">{t('footer.siteMap')}</a>
              </div>
            </div>
          </div>
        </motion.div>
      </div>
    </footer>
  )
}

==================================================
FILE_PATH: web/src/landing/FAQ.tsx
==================================================

import { motion } from 'framer-motion'
import { ChevronRight } from 'lucide-react'

const faqs = [
  { question: 'What is Athena Reader?' },
  { question: 'How does Family Sharing work with Athena Reader?' },
  { question: 'Can I get Athena Reader on my device?' },
  { question: 'Can I get audiobooks on Athena Reader?' },
  { question: 'Can I share books from Athena Reader with my friends?' },
  { question: 'If I buy a book on one device, can I read it on another?' },
]

export default function FAQ() {
  return (
    <div className="py-32 bg-white">
      <div className="max-w-3xl mx-auto px-6">
        <motion.div initial={{ y: 60, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8 }} className="text-center mb-16">
          <h2 className="text-5xl md:text-6xl text-gray-900 mb-6" style={{ fontWeight: 700, lineHeight: 1.1 }}>Questions? Answers.</h2>
        </motion.div>
        <motion.div initial={{ y: 80, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8, delay: 0.2 }} className="space-y-1">
          {faqs.map((faq, index) => (
            <motion.div key={index} initial={{ y: 40, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-50px' }} transition={{ duration: 0.6, delay: 0.3 + index * 0.05 }} className="bg-gray-50 hover:bg-gray-100 transition-colors cursor-pointer group">
              <div className="flex items-center justify-between p-6">
                <p className="text-lg text-gray-900" style={{ fontWeight: 600 }}>{faq.question}</p>
                <ChevronRight className="w-6 h-6 text-gray-400 group-hover:text-gray-600 transition-colors flex-shrink-0 ml-4" />
              </div>
            </motion.div>
          ))}
        </motion.div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/FeatureCards.tsx
==================================================

import { motion } from 'framer-motion'
import { Cloud, Sparkles, FileText, Headphones } from 'lucide-react'
import { useTranslation } from 'react-i18next'

export default function FeatureCards() {
  const { t } = useTranslation('landing')

  const features = [
    { icon: <Cloud className="w-10 h-10" />, key: 'sync', accent: '#007AFF' },
    { icon: <Sparkles className="w-10 h-10" />, key: 'ai', accent: '#5856D6' },
    { icon: <FileText className="w-10 h-10" />, key: 'notes', accent: '#34C759' },
    { icon: <Headphones className="w-10 h-10" />, key: 'listen', accent: '#FF9500' },
  ]

  return (
    <div className="py-32 bg-white">
      <div className="max-w-7xl mx-auto px-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          {features.map((feature, index) => (
            <motion.div key={index} initial={{ y: 80, opacity: 0 }} whileInView={{ y: 0, opacity: 1 }} viewport={{ once: true, margin: '-100px' }} transition={{ duration: 0.8, delay: index * 0.15 }} className="bg-gray-50 rounded-3xl p-10 hover:bg-gray-100 transition-colors group">
              <motion.div
                className="mb-6 inline-flex items-center justify-center w-20 h-20 md:w-24 md:h-24 rounded-full bg-white shadow-lg group-hover:shadow-xl transition-shadow"
                initial={{ y: -40, scale: 0.85, opacity: 0 }}
                whileInView={{ y: [-40, 0, -18, 0, -10, 0, -6, 0], scale: [0.85, 1, 1, 1, 1, 1, 1, 1], opacity: [0, 1, 1, 1, 1, 1, 1, 1] }}
                viewport={{ once: true, margin: '-100px' }}
                transition={{
                  y: { duration: 1.6, times: [0, 0.35, 0.55, 0.7, 0.82, 0.9, 0.96, 1], ease: 'easeOut', delay: 0.15 + index * 0.1 },
                  scale: { duration: 1.6, times: [0, 0.35, 0.55, 0.7, 0.82, 0.9, 0.96, 1], ease: 'easeOut', delay: 0.15 + index * 0.1 },
                  opacity: { duration: 1.6, times: [0, 0.35, 0.55, 0.7, 0.82, 0.9, 0.96, 1], ease: 'easeOut', delay: 0.15 + index * 0.1 }
                }}
                whileHover={{ y: [-2, -8, 0] }}
              >
                <div className="text-black">{feature.icon}</div>
              </motion.div>
              <h3 className="text-3xl text-gray-900 mb-4" style={{ fontWeight: 600 }}>{t(`features.${feature.key}.title`)}</h3>
              <p className="text-lg text-gray-600 leading-relaxed">{t(`features.${feature.key}.description`)}</p>
            </motion.div>
          ))}
        </div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/landing/DeviceShowcase.tsx
==================================================

import { motion, useScroll, useTransform } from 'framer-motion'
import { useRef } from 'react'

const deviceImages = [
  'https://images.unsplash.com/photo-1657639039662-9edac2e6a40b?w=300&h=650&fit=crop',
  'https://images.unsplash.com/photo-1683355879142-8a750ffa9ab6?w=300&h=650&fit=crop',
  'https://images.unsplash.com/photo-1589591872987-12784bb24d90?w=300&h=650&fit=crop',
  'https://images.unsplash.com/photo-1752079432635-12b7b68966ee?w=300&h=650&fit=crop',
  'https://images.unsplash.com/photo-1763013258650-c92b085726c4?w=300&h=650&fit=crop',
]

export default function DeviceShowcase() {
  const containerRef = useRef<HTMLDivElement>(null)
  const { scrollYProgress } = useScroll({ target: containerRef, offset: ['start end', 'end start'] })
  const device2Y = useTransform(scrollYProgress, [0.2, 0.6], [-60, 0])
  const device4Y = useTransform(scrollYProgress, [0.2, 0.6], [-60, 0])
  return (
    <div ref={containerRef} className="relative bg-white pb-20 overflow-visible">
      <div className="max-w-7xl mx-auto px-6">
        <div className="flex justify-center items-end gap-2 md:gap-3 relative">
          {deviceImages.map((image, index) => {
            let initialX = 0
            if (index === 0) initialX = -400
            if (index === 1) initialX = -200
            if (index === 3) initialX = 200
            if (index === 4) initialX = 400
            const initialY = 300
            return (
              <motion.div key={index} initial={{ x: initialX, y: initialY, opacity: 0 }} animate={{ x: 0, y: 0, opacity: 1 }} transition={{ duration: 1.4, delay: 2.0 + Math.abs(index - 2) * 0.12, ease: [0.22, 1, 0.36, 1] }} className="relative flex-shrink-0" style={{ width: '220px' }}>
                <motion.div
                  className="relative rounded-[38px] overflow-hidden"
                  style={{
                    y: index === 1 ? device2Y : index === 3 ? device4Y : 0,
                    height: '440px',
                    background: 'linear-gradient(180deg, #121314 0%, #0a0b0c 100%)',
                    boxShadow:
                      '0 18px 36px rgba(0,0,0,0.28), 0 8px 16px rgba(0,0,0,0.18), inset 0 0 0 1px rgba(255,255,255,0.04)'
                  } as any}
                >
                  <div className="absolute inset-0 rounded-[38px] z-10 pointer-events-none" style={{ boxShadow: 'inset 0 0 0 2px rgba(0,0,0,0.8), inset 0 1px 2px rgba(255,255,255,0.06)' }} />
                  <div className="absolute inset-0 rounded-[38px] border-[7px] border-black/95 z-10 pointer-events-none" />
                  <div className="absolute top-3 left-1/2 -translate-x-1/2 z-20" style={{ width: '88px', height: '26px', borderRadius: 9999, background: 'linear-gradient(180deg, #0b0c0d 0%, #000 100%)', boxShadow: 'inset 0 -2px 3px rgba(255,255,255,0.08), inset 0 0 0 1px rgba(255,255,255,0.06)' }} />
                  <div className="absolute inset-[7px] rounded-[32px] overflow-hidden">
                    <img src={image} alt={`Device ${index + 1}`} className="w-full h-full object-cover" />
                    <div className="absolute inset-0 rounded-[32px] pointer-events-none" style={{ background: 'linear-gradient(20deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0) 35%, rgba(255,255,255,0) 70%, rgba(255,255,255,0.06) 100%)' }} />
                    <div className="absolute inset-0 rounded-[32px] pointer-events-none" style={{ boxShadow: 'inset 0 0 0 1px rgba(255,255,255,0.06), inset 0 20px 40px rgba(255,255,255,0.06)' }} />
                  </div>
                </motion.div>
              </motion.div>
            )
          })}
        </div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/test/setup.ts
==================================================

/**
 * Vitest 全局 Setup 文件
 * 
 * 为测试环境提供必要的 polyfills：
 * - fake-indexeddb：为 jsdom 环境提供 IndexedDB API
 */
import 'fake-indexeddb/auto'

// 可选：重置 Dexie 状态（避免测试间互相影响）
// 注意：Dexie 实例需要在每个测试中独立管理


==================================================
FILE_PATH: web/src/locales/zh-CN/auth.json
==================================================

{
    "title": "Sign in to Athena",
    "subtitle": "New users will be automatically registered. No separate sign-up required.",
    "email": "Email",
    "code": "Verification Code",
    "send_code": "Send Verification Code",
    "resend_code": "Resend",
    "send_failed": "Failed to send verification code. Please try again.",
    "code_sent": "Verification code sent successfully!",
    "check_spam": "Please check your inbox. If you don't see it, check your spam folder.",
    "login": "Sign In",
    "logging_in": "Signing in...",
    "login_failed": "Login failed. Please check your verification code.",
    "register": "Create Account",
    "tip_check_backend": "Please check backend logs for the verification code in development.",
    "token_refreshing": "Token 刷新中...",
    "token_refresh_failed": "Token 刷新失败，请重新登录",
    "session_expired": "登录已过期",
    "checking_auth": "验证登录状态..."
}

==================================================
FILE_PATH: web/src/locales/zh-CN/landing.json
==================================================

{
  "hero": {
    "title": "Read, listen, discover.",
    "subtitle": "Your personal library. Beautifully organized.",
    "cta_free": "Start for Free",
    "cta_login": "Sign In"
  },
  "features": {
    "sync": {
      "title": "Seamless Cloud Sync",
      "description": "Pick up right where you left off, on any device."
    },
    "ai": {
      "title": "AI-Powered Insights",
      "description": "Transform your highlights into knowledge with intelligent conversations."
    },
    "notes": {
      "title": "Effortless Note-Taking",
      "description": "Capture your thoughts instantly. Never lose a brilliant idea."
    },
    "listen": {
      "title": "Listen Anywhere",
      "description": "Turn any book into an audiobook with TTS technology."
    }
  },
  "bookGrid": {
    "titleLine1": "A library you'll want",
    "titleLine2": "to get lost in.",
    "description": "With millions of titles across every genre, there's something for everyone. Discover bestsellers, classics, and hidden gems curated just for you.",
    "browseAll": "Browse All"
  },
  "deviceCompatibility": {
    "titleLine1": "Read and listen on",
    "titleLine2": "your favorite devices.",
    "devices": {
      "iphone": "iPhone",
      "ipad": "iPad",
      "mac": "Mac",
      "watch": "Apple Watch",
      "tv": "Apple TV",
      "carplay": "CarPlay"
    }
  },
  "featureHighlight": {
    "title": "Curation you'll love",
    "description": "Discover bestsellers, classics, and hidden gems curated just for you."
  },
  "ctaSection": {
    "title": "Get started with Athena Reader today.",
    "description": "A reading app is a handy tool for readers who want to keep track of the books they're reading and access curated content from their favorite authors. Athena Reader is an essential companion for book lovers everywhere.",
... (JSON truncated) ...

==================================================
FILE_PATH: web/src/locales/zh-CN/common.json
==================================================

{
    "homepage.title": "Athena",
    "homepage.subtitle": "Reading & AI assistant for everyone",
    "homepage.cta": "Get Started",
    "homepage.lang.switch": "Language",
    "profile.title": "Profile",
    "profile.get": "Fetch Profile",
    "profile.name": "Display Name",
    "profile.save": "Save",
    "upload.title": "上传书籍",
    "upload.filename": "Filename",
    "upload.fingerprint": "Fingerprint",
    "upload.start": "开始上传",
    "upload.status": "Status",
    "upload.download": "Download",
    "upload.cta": "上传书籍",
    "upload.pick_file": "选择本地文件",
    "upload.drag_or_click": "拖拽文件到这里，或点击选择",
    "upload.drop_here": "释放文件",
    "upload.choose_another": "选择其他文件",
    "upload.confirm_cancel": "正在上传中，确定要取消吗？",
    "upload.supported_formats": "支持格式: {{formats}}",
    "upload.max_size": "最大文件大小: {{size}}",
    "upload.stage.idle": "准备上传",
    "upload.stage.hashing": "计算文件哈希...",
    "upload.stage.initializing": "初始化上传...",
    "upload.stage.uploading": "上传文件中...",
    "upload.stage.completing": "处理中...",
    "upload.stage.done": "上传完成！",
    "upload.stage.error": "上传失败",
    "upload.error.init_failed": "初始化上传失败，请重试。",
    "upload.error.put_failed": "文件上传失败，请检查网络连接。",
    "upload.error.complete_failed": "上传完成但处理失败。",
    "upload.error.quota_exceeded": "已达上传限制，请升级会员或删除书籍。",
    "upload.error.file_too_large": "文件太大，最大支持: {{size}}",
    "upload.error.invalid_format": "不支持的文件格式。",
    "upload.error.network_error": "网络错误，请检查网络连接。",
    "upload.error.cancelled": "上传已取消。",
    "upload.error.unknown": "上传过程中发生未知错误。",
    "upload.uploading": "上传中...",
    "upload.processing": "处理书籍中...",
    "upload.success": "书籍上传成功！",
    "ai.title": "AI Chat",
    "ai.prompt": "Enter prompt",
    "ai.start": "Start",
    "ai.new_conversation": "新对话",
    "ai.welcome": "有什么我可以帮助你的？",
    "ai.hint": "试着问我关于你书籍的问题",
    "ai.no_conversations": "暂无对话",
    "doc.version": "Version",
... (JSON truncated) ...

==================================================
FILE_PATH: web/src/locales/en-US/auth.json
==================================================

{
    "title": "Sign in to Athena",
    "subtitle": "New users will be automatically registered. No separate sign-up required.",
    "email": "Email",
    "code": "Verification Code",
    "send_code": "Send Verification Code",
    "resend_code": "Resend",
    "send_failed": "Failed to send verification code. Please try again.",
    "code_sent": "Verification code sent successfully!",
    "check_spam": "Please check your inbox. If you don't see it, check your spam folder.",
    "login": "Sign In",
    "logging_in": "Signing in...",
    "login_failed": "Login failed. Please check your verification code.",
    "register": "Create Account",
    "tip_check_backend": "Please check backend logs for the verification code in development.",
    "token_refreshing": "Refreshing token...",
    "token_refresh_failed": "Token refresh failed, please login again",
    "session_expired": "Session expired",
    "checking_auth": "Checking authentication..."
}

==================================================
FILE_PATH: web/src/locales/en-US/landing.json
==================================================

{
  "hero": {
    "title": "Read, listen, discover.",
    "subtitle": "Your personal library. Beautifully organized.",
    "cta_free": "Start for Free",
    "cta_login": "Sign In"
  },
  "features": {
    "sync": {
      "title": "Seamless Cloud Sync",
      "description": "Pick up right where you left off, on any device."
    },
    "ai": {
      "title": "AI-Powered Insights",
      "description": "Transform your highlights into knowledge with intelligent conversations."
    },
    "notes": {
      "title": "Effortless Note-Taking",
      "description": "Capture your thoughts instantly. Never lose a brilliant idea."
    },
    "listen": {
      "title": "Listen Anywhere",
      "description": "Turn any book into an audiobook with TTS technology."
    }
  },
  "bookGrid": {
    "titleLine1": "A library you'll want",
    "titleLine2": "to get lost in.",
    "description": "With millions of titles across every genre, there's something for everyone. Discover bestsellers, classics, and hidden gems curated just for you.",
    "browseAll": "Browse All"
  },
  "deviceCompatibility": {
    "titleLine1": "Read and listen on",
    "titleLine2": "your favorite devices.",
    "devices": {
      "iphone": "iPhone",
      "ipad": "iPad",
      "mac": "Mac",
      "watch": "Apple Watch",
      "tv": "Apple TV",
      "carplay": "CarPlay"
    }
  },
  "featureHighlight": {
    "title": "Curation you'll love",
    "description": "Discover bestsellers, classics, and hidden gems curated just for you."
  },
  "ctaSection": {
    "title": "Get started with Athena Reader today.",
    "description": "A reading app is a handy tool for readers who want to keep track of the books they're reading and access curated content from their favorite authors. Athena Reader is an essential companion for book lovers everywhere.",
... (JSON truncated) ...

==================================================
FILE_PATH: web/src/locales/en-US/common.json
==================================================

{
    "homepage.title": "Athena",
    "homepage.subtitle": "Reading & AI assistant for everyone",
    "homepage.cta": "Get Started",
    "homepage.lang.switch": "Language",
    "profile.title": "Profile",
    "profile.get": "Fetch Profile",
    "profile.name": "Display Name",
    "profile.save": "Save",
    "upload.title": "Upload Book",
    "upload.filename": "Filename",
    "upload.fingerprint": "Fingerprint",
    "upload.start": "Start Upload",
    "upload.status": "Status",
    "upload.download": "Download",
    "upload.cta": "Upload Book",
    "upload.pick_file": "Pick Local File",
    "upload.drag_or_click": "Drag and drop a file here, or click to select",
    "upload.drop_here": "Drop file here",
    "upload.choose_another": "Choose Another",
    "upload.confirm_cancel": "Upload in progress. Are you sure you want to cancel?",
    "upload.supported_formats": "Supported formats: {{formats}}",
    "upload.max_size": "Maximum file size: {{size}}",
    "upload.stage.idle": "Ready to upload",
    "upload.stage.hashing": "Calculating file hash...",
    "upload.stage.initializing": "Initializing upload...",
    "upload.stage.uploading": "Uploading file...",
    "upload.stage.completing": "Finishing up...",
    "upload.stage.done": "Upload complete!",
    "upload.stage.error": "Upload failed",
    "upload.error.init_failed": "Failed to initialize upload. Please try again.",
    "upload.error.put_failed": "Failed to upload file. Please check your connection.",
    "upload.error.complete_failed": "Upload completed but processing failed.",
    "upload.error.quota_exceeded": "Upload limit reached. Please upgrade or delete books.",
    "upload.error.file_too_large": "File is too large. Maximum size: {{size}}",
    "upload.error.invalid_format": "Unsupported file format.",
    "upload.error.network_error": "Network error. Please check your connection.",
    "upload.error.cancelled": "Upload cancelled.",
    "upload.error.unknown": "An unknown error occurred during upload.",
    "upload.uploading": "Uploading...",
    "upload.processing": "Processing book...",
    "upload.success": "Book uploaded successfully!",
    "ai.title": "AI Chat",
    "ai.prompt": "Enter prompt",
    "ai.start": "Start",
    "doc.version": "Version",
    "doc.send": "Send",
    "doc.conflicts": "Conflicts",
    "doc.recover": "Recover Draft",
    "export.title": "Export Service",
... (JSON truncated) ...

==================================================
FILE_PATH: web/src/lib/color-utils.ts
==================================================


/**
 * 从图片 URL 提取主色调
 * 使用 canvas 采样中心区域的平均颜色
 */
export function extractDominantColor(imageUrl: string): Promise<string> {
  return new Promise((resolve) => {
    const img = new Image()
    // 对于同源 API 请求（如 /api/...），不设置 crossOrigin
    // 只对外部 URL（如 S3 预签名 URL）设置 crossOrigin
    if (!imageUrl.startsWith('/api/') && !imageUrl.startsWith(window.location.origin)) {
      img.crossOrigin = 'anonymous'
    }
    
    const timeoutId = setTimeout(() => {
      // console.log('[ColorExtract] Timeout for:', imageUrl)
      resolve('#6B7280')
    }, 3000)
    
    img.onload = () => {
      clearTimeout(timeoutId)
      try {
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          resolve('#6B7280')
          return
        }
        
        // 使用小尺寸采样以提高性能
        canvas.width = 50
        canvas.height = 75
        ctx.drawImage(img, 0, 0, 50, 75)
        
        // 采样图片中心区域
        const imageData = ctx.getImageData(10, 20, 30, 35)
        const data = imageData.data
        
        let r = 0, g = 0, b = 0, count = 0
        for (let i = 0; i < data.length; i += 4) {
          r += data[i]
          g += data[i + 1]
          b += data[i + 2]
          count++
        }
        
        r = Math.round(r / count)
        g = Math.round(g / count)
        b = Math.round(b / count)
        
        resolve(`rgb(${r}, ${g}, ${b})`)
      } catch (e) {
        console.warn('[ColorExtract] Canvas error:', e)
        resolve('#6B7280')
      }
    }
    img.onerror = (e) => {
      clearTimeout(timeoutId)
      console.warn('[ColorExtract] Image load error:', e)
      resolve('#6B7280')
    }
    img.src = imageUrl
  })
}

/**
 * 计算颜色亮度 (0-1)
 * 用于决定文字颜色
 */
export function getLuminance(color: string): number {
  try {
    // 解析 rgb(r, g, b) 格式
    const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)
    if (match) {
      const r = parseInt(match[1]) / 255
      const g = parseInt(match[2]) / 255
      const b = parseInt(match[3]) / 255
      return 0.299 * r + 0.587 * g + 0.114 * b
    }
    // 解析 hex 格式
    const hex = color.replace('#', '')
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16) / 255
      const g = parseInt(hex.slice(2, 4), 16) / 255
      const b = parseInt(hex.slice(4, 6), 16) / 255
      return 0.299 * r + 0.587 * g + 0.114 * b
    }
  } catch {
    // Invalid hex color, return default
  }
  return 0.5
}


==================================================
FILE_PATH: web/src/lib/utils.ts
==================================================

import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

/**
 * 生成 UUID v4
 * 兼容旧浏览器（fallback 到 Math.random）
 */
export function generateUUID(): string {
  // 优先使用 crypto.randomUUID (现代浏览器)
  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
    return crypto.randomUUID()
  }
  
  // Fallback: 使用 crypto.getRandomValues (更安全)
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const bytes = new Uint8Array(16)
    crypto.getRandomValues(bytes)
    bytes[6] = (bytes[6] & 0x0f) | 0x40 // version 4
    bytes[8] = (bytes[8] & 0x3f) | 0x80 // variant 10
    const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('')
    return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`
  }
  
  // 最后 fallback: Math.random (不推荐，仅用于极端情况)
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0
    const v = c === 'x' ? r : (r & 0x3 | 0x8)
    return v.toString(16)
  })
}

// 格式化文件大小
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

// 格式化时间（分钟）
export function formatMinutes(minutes: number): string {
  if (minutes < 60) {
    return `${minutes}min`
  }
  const hours = Math.floor(minutes / 60)
  const mins = minutes % 60
  return mins > 0 ? `${hours}h ${mins}min` : `${hours}h`
}

// 设备 ID 管理 (用于多端同步)
const DEVICE_ID_KEY = 'athena_device_id'

/**
 * 获取或生成设备 ID
 * 用于多端同步场景下的设备识别
 */
export function getDeviceId(): string {
  let deviceId = localStorage.getItem(DEVICE_ID_KEY)
  if (!deviceId) {
    // 生成新的设备 ID: 浏览器指纹 + 随机数
    const timestamp = Date.now().toString(36)
    const random = Math.random().toString(36).substring(2, 10)
    const userAgent = navigator.userAgent.slice(0, 20).replace(/[^a-zA-Z0-9]/g, '')
    deviceId = `web_${userAgent}_${timestamp}_${random}`.substring(0, 64)
    localStorage.setItem(DEVICE_ID_KEY, deviceId)
  }
  return deviceId
}


==================================================
FILE_PATH: web/src/lib/syncStorage.ts
==================================================

/**
 * 同步存储 Stub（App-First 迁移中）
 * PowerSync 自动处理同步，无需手动队列
 */

export const getSyncQueueCount = async (): Promise<number> => {
  return 0
}


==================================================
FILE_PATH: web/src/lib/reading-utils.ts
==================================================

/**
 * 阅读相关工具函数
 */

/**
 * 解析 EPUB 位置 (CFI)
 */
export function parseEpubLocation(location: any): string | null {
  if (!location) return null
  
  if (typeof location === 'string') {
    // 简单的 CFI 格式检查
    if (location.startsWith('epubcfi(')) {
      return location
    }
    // 尝试 JSON 解析
    try {
      const parsed = JSON.parse(location)
      if (typeof parsed === 'string' && parsed.startsWith('epubcfi(')) {
        return parsed
      }
    } catch {
      // 忽略解析错误
    }
  }
  
  return null
}

/**
 * 解析 PDF 位置 (页码)
 */
export function parsePdfLocation(location: any): { page: number } | null {
  if (!location) return null
  
  try {
    // 如果是数字
    if (typeof location === 'number') {
      return { page: location }
    }
    
    // 如果是对象
    if (typeof location === 'object') {
      // 兼容 { page: 1 } 格式
      if (typeof location.page === 'number') {
        return { page: location.page }
      }
      // 兼容 Dexie 存储的格式
      const obj = location as any
      if (obj.page && typeof obj.page === 'number') {
        return { page: obj.page }
      }
      return null
    }
    
    // 如果是字符串
    if (typeof location === 'string') {
      try {
        const parsed = JSON.parse(location)
        if (typeof parsed.page === 'number') {
          return { page: parsed.page }
        }
      } catch {
        // 尝试直接解析数字
        const page = parseInt(location, 10)
        if (!isNaN(page)) {
          return { page }
        }
      }
    }
  } catch (e) {
    console.error('[parsePdfLocation] Error:', e)
  }
  
  return null
}

/**
 * 格式化阅读进度为百分比字符串
 */
export function formatProgress(progress: number): string {
  return `${Math.round(progress * 100)}%`
}

/**
 * 格式化阅读时间
 */
export function formatReadingTime(ms: number): string {
  const minutes = Math.floor(ms / 60000)
  const hours = Math.floor(minutes / 60)
  const remainingMinutes = minutes % 60
  
  if (hours > 0) {
    return `${hours}小时${remainingMinutes}分钟`
  }
  return `${minutes}分钟`
}


==================================================
FILE_PATH: web/src/lib/bookStorage.ts
==================================================

/**
 * bookStorage.ts - 本地文件存储服务 (App-First 版)
 *
 * 职责：
 * - 管理大文件存储 (PDF/EPUB Blob)
 * - 管理封面图片缓存
 * - 管理离线上传队列
 * - 使用原生 IndexedDB 替代 Dexie
 * - 仅处理文件 Blob，元数据由 PowerSync/SQLite 管理
 *
 * @see 09 - APP-FIRST架构改造计划.md
 */

const DB_NAME = 'athena-files'
const DB_VERSION = 3 // 升级版本: 增加 upload_queue
const STORE_BOOKS = 'books'
const STORE_COVERS = 'covers'
const STORE_OCR = 'ocr'
const STORE_UPLOAD_QUEUE = 'upload_queue'

// ============ 类型定义 ============

export interface BookFileRecord {
  bookId: string
  blob: Blob
  format: 'epub' | 'pdf'
  size: number
  downloadedAt: number
  etag?: string
}

export interface CoverCacheRecord {
  bookId: string
  blob: Blob
  mimeType: string
  cachedAt: number
  originalUrl: string
}

/** OCR 区域数据 */
export interface OcrRegion {
  text: string
  confidence: number
  bbox: [number, number, number, number]
  polygon: [number, number][]
  page: number
}

/** 每页的尺寸信息 */
export interface OcrPageSize {
  width: number
  height: number
  pdfWidth?: number
  pdfHeight?: number
  dpi?: number
}

/** OCR 数据记录 */
export interface OcrDataRecord {
  bookId: string
  isImageBased: boolean
  confidence: number
  totalPages: number
  totalChars: number
  totalRegions: number
  imageWidth: number
  imageHeight: number
  pageSizes?: Record<string, OcrPageSize>
  regions: OcrRegion[]
  downloadedAt: number
}

export interface UploadQueueItem {
  id: string
  fileName: string
  title: string
  blob: Blob
  fingerprint: string
  createdAt: number
}

export interface CacheStats {
  bookCount: number
  totalSize: number
  coverCount: number
  coverSize: number
  ocrCount: number
  ocrSize: number
  uploadQueueCount: number
  uploadQueueSize: number
}

// ============ IndexedDB 基础封装 ============

let dbPromise: Promise<IDBDatabase> | null = null

function openDB(): Promise<IDBDatabase> {
  if (dbPromise) return dbPromise

  dbPromise = new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result
      if (!db.objectStoreNames.contains(STORE_BOOKS)) {
        db.createObjectStore(STORE_BOOKS, { keyPath: 'bookId' })
      }
      if (!db.objectStoreNames.contains(STORE_COVERS)) {
        db.createObjectStore(STORE_COVERS, { keyPath: 'bookId' })
      }
      if (!db.objectStoreNames.contains(STORE_OCR)) {
        db.createObjectStore(STORE_OCR, { keyPath: 'bookId' })
      }
      if (!db.objectStoreNames.contains(STORE_UPLOAD_QUEUE)) {
        db.createObjectStore(STORE_UPLOAD_QUEUE, { keyPath: 'id' })
      }
    }

    request.onsuccess = (event) => {
      resolve((event.target as IDBOpenDBRequest).result)
    }

    request.onerror = (event) => {
      console.error('[FileStorage] Failed to open DB:', (event.target as IDBOpenDBRequest).error)
      reject((event.target as IDBOpenDBRequest).error)
    }
  })

  return dbPromise
}

async function getStore(storeName: string, mode: IDBTransactionMode = 'readonly'): Promise<IDBObjectStore> {
  const db = await openDB()
  const tx = db.transaction(storeName, mode)
  return tx.objectStore(storeName)
}

function promisifyRequest<T>(request: IDBRequest<T>): Promise<T> {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })
}

// ============ 书籍文件操作 ============

/**
 * 保存书籍文件
 */
export async function saveBookFile(
  bookId: string,
  blob: Blob,
  format: 'epub' | 'pdf',
  etag?: string
): Promise<void> {
  const store = await getStore(STORE_BOOKS, 'readwrite')
  const record: BookFileRecord = {
    bookId,
    blob,
    format,
    size: blob.size,
    downloadedAt: Date.now(),
    etag
  }
  await promisifyRequest(store.put(record))
  console.log(`[FileStorage] Saved book ${bookId} (${format}, ${(blob.size / 1024 / 1024).toFixed(2)}MB)`)
  
  // 广播事件
  window.dispatchEvent(new CustomEvent('book_cached', { detail: { bookId } }))
}

/**
 * 获取书籍文件
 */
export async function getBookFile(bookId: string): Promise<BookFileRecord | undefined> {
  const store = await getStore(STORE_BOOKS)
  return promisifyRequest(store.get(bookId))
}

/**
 * 删除书籍文件
 * 同时删除相关的封面和 OCR 数据
 */
export async function deleteBook(bookId: string): Promise<void> {
  const db = await openDB()
  const tx = db.transaction([STORE_BOOKS, STORE_COVERS, STORE_OCR], 'readwrite')
  
  await promisifyRequest(tx.objectStore(STORE_BOOKS).delete(bookId))
  await promisifyRequest(tx.objectStore(STORE_COVERS).delete(bookId))
  await promisifyRequest(tx.objectStore(STORE_OCR).delete(bookId))
  
  console.log(`[FileStorage] Deleted all files for book ${bookId}`)
  
  // 广播事件
  window.dispatchEvent(new CustomEvent('book_deleted', { detail: { bookId } }))
}

/**
 * 仅删除书籍文件 (保留其他)
 */
export async function deleteBookFile(bookId: string): Promise<void> {
  const store = await getStore(STORE_BOOKS, 'readwrite')
  await promisifyRequest(store.delete(bookId))
  console.log(`[FileStorage] Deleted book file ${bookId}`)
}

/**
 * 检查书籍是否已缓存
 */
export async function isBookCached(bookId: string): Promise<boolean> {
  const store = await getStore(STORE_BOOKS)
  const count = await promisifyRequest(store.count(bookId))
  return count > 0
}

// ============ 封面缓存操作 ============

/**
 * 保存封面缓存
 */
export async function saveCoverCache(
  bookId: string,
  blob: Blob,
  originalUrl: string
): Promise<void> {
  const store = await getStore(STORE_COVERS, 'readwrite')
  const record: CoverCacheRecord = {
    bookId,
    blob,
    mimeType: blob.type,
    cachedAt: Date.now(),
    originalUrl
  }
  await promisifyRequest(store.put(record))
}

/**
 * 获取封面缓存
 */
export async function getCoverCache(bookId: string): Promise<CoverCacheRecord | undefined> {
  const store = await getStore(STORE_COVERS)
  return promisifyRequest(store.get(bookId))
}

// ============ OCR 数据操作 ============

/**
 * 保存 OCR 数据
 */
export async function saveOcrData(data: OcrDataRecord): Promise<void> {
  const store = await getStore(STORE_OCR, 'readwrite')
  await promisifyRequest(store.put(data))
  console.log(`[FileStorage] Saved OCR data for ${data.bookId} (${data.totalRegions} regions)`)
}

/**
 * 获取 OCR 数据
 */
export async function getOcrData(bookId: string): Promise<OcrDataRecord | undefined> {
  const store = await getStore(STORE_OCR)
  return promisifyRequest(store.get(bookId))
}

/**
 * 获取指定页的 OCR 区域 (辅助函数)
 */
export async function getOcrPageRegions(bookId: string, page: number): Promise<OcrRegion[]> {
  const data = await getOcrData(bookId)
  if (!data) return []
  return data.regions.filter(r => r.page === page)
}

// ============ 离线上传队列操作 ============

export async function saveOfflineUploadQueue(item: UploadQueueItem): Promise<void> {
  const store = await getStore(STORE_UPLOAD_QUEUE, 'readwrite')
  await promisifyRequest(store.put(item))
  console.log(`[FileStorage] Added to upload queue: ${item.id}`)
}

export async function getOfflineUploadQueue(): Promise<UploadQueueItem[]> {
  const store = await getStore(STORE_UPLOAD_QUEUE)
  return promisifyRequest(store.getAll()) as Promise<UploadQueueItem[]>
}

export async function removeOfflineUploadQueue(id: string): Promise<void> {
  const store = await getStore(STORE_UPLOAD_QUEUE, 'readwrite')
  await promisifyRequest(store.delete(id))
  console.log(`[FileStorage] Removed from upload queue: ${id}`)
}

// ============ 统计信息 ============

/**
 * 获取缓存统计
 */
export async function getCacheStats(): Promise<CacheStats> {
  const db = await openDB()
  
  // 统计书籍
  const bookTx = db.transaction(STORE_BOOKS, 'readonly')
  const bookStore = bookTx.objectStore(STORE_BOOKS)
  const books = await promisifyRequest(bookStore.getAll()) as BookFileRecord[]
  
  const bookCount = books.length
  const totalSize = books.reduce((sum, book) => sum + book.size, 0)
  
  // 统计封面
  const coverTx = db.transaction(STORE_COVERS, 'readonly')
  const coverStore = coverTx.objectStore(STORE_COVERS)
  const covers = await promisifyRequest(coverStore.getAll()) as CoverCacheRecord[]
  
  const coverCount = covers.length
  const coverSize = covers.reduce((sum, cover) => sum + cover.blob.size, 0)

  // 统计 OCR
  const ocrTx = db.transaction(STORE_OCR, 'readonly')
  const ocrStore = ocrTx.objectStore(STORE_OCR)
  const ocrs = await promisifyRequest(ocrStore.getAll()) as OcrDataRecord[]
  
  const ocrCount = ocrs.length
  const ocrSize = ocrs.reduce((sum, ocr) => sum + JSON.stringify(ocr).length, 0)

  // 统计上传队列
  const queueTx = db.transaction(STORE_UPLOAD_QUEUE, 'readonly')
  const queueStore = queueTx.objectStore(STORE_UPLOAD_QUEUE)
  const queueItems = await promisifyRequest(queueStore.getAll()) as UploadQueueItem[]
  
  const uploadQueueCount = queueItems.length
  const uploadQueueSize = queueItems.reduce((sum, item) => sum + item.blob.size, 0)
  
  return {
    bookCount,
    totalSize,
    coverCount,
    coverSize,
    ocrCount,
    ocrSize,
    uploadQueueCount,
    uploadQueueSize
  }
}

/**
 * 清除所有缓存
 */
export async function clearAllCache(): Promise<void> {
  const db = await openDB()
  const tx = db.transaction([STORE_BOOKS, STORE_COVERS, STORE_OCR, STORE_UPLOAD_QUEUE], 'readwrite')
  
  await promisifyRequest(tx.objectStore(STORE_BOOKS).clear())
  await promisifyRequest(tx.objectStore(STORE_COVERS).clear())
  await promisifyRequest(tx.objectStore(STORE_OCR).clear())
  await promisifyRequest(tx.objectStore(STORE_UPLOAD_QUEUE).clear())
  
  console.log('[FileStorage] All cache cleared')
}

// ============ Blob URL 辅助函数 ============

/**
 * 创建 Blob URL
 * 如果 Blob 的 MIME 类型不正确，会创建一个新的 Blob 并设置正确的类型
 */
export function createBlobUrl(blob: Blob, format?: 'epub' | 'pdf'): string {
  // 检查 MIME 类型是否正确
  const correctMimeTypes: Record<string, string> = {
    'epub': 'application/epub+zip',
    'pdf': 'application/pdf',
  }
  
  // 如果提供了格式信息，确保 MIME 类型正确
  if (format && correctMimeTypes[format]) {
    const expectedType = correctMimeTypes[format]
    if (blob.type !== expectedType) {
      console.log(`[FileStorage] Correcting MIME type from "${blob.type}" to "${expectedType}"`)
      blob = new Blob([blob], { type: expectedType })
    }
  }
  
  return URL.createObjectURL(blob)
}

/**
 * 将 Blob 转换为 ArrayBuffer
 * epub.js 更好地支持 ArrayBuffer 而不是 blob URL
 */
export async function blobToArrayBuffer(blob: Blob): Promise<ArrayBuffer> {
  return blob.arrayBuffer()
}

export function revokeBlobUrl(url: string): void {
  URL.revokeObjectURL(url)
}

// 导出单例 (可选，如果需要)
export const bookStorage = {
  saveBookFile,
  getBookFile,
  deleteBook,
  deleteBookFile,
  isBookCached,
  saveCoverCache,
  getCoverCache,
  saveOcrData,
  getOcrData,
  getOcrPageRegions,
  saveOfflineUploadQueue,
  getOfflineUploadQueue,
  removeOfflineUploadQueue,
  getCacheStats,
  clearAllCache,
  createBlobUrl,
  revokeBlobUrl,
  blobToArrayBuffer
}


==================================================
FILE_PATH: web/src/lib/timestamp.ts
==================================================

/**
 * timestamp.ts
 * 
 * 统一的时间戳处理工具库
 * 
 * ## 核心原则
 * 
 * 1. **存储**: 所有时间戳使用 UTC 毫秒数 (Date.now())
 * 2. **传输**: 使用 ISO 8601 带时区格式 ("2024-12-09T12:00:00.000Z")
 * 3. **比较**: 统一转换为 UTC 毫秒数后比较
 * 4. **显示**: 转换为用户本地时区显示
 * 
 * ## 为什么重要？
 * 
 * - 雅典娜是全球化应用，用户可能在任何时区
 * - 离线时本地生成的时间戳，联机时需要与服务器正确比较
 * - 服务器位置固定，但用户终端位置不固定
 * - LWW (Last-Writer-Wins) 冲突解决依赖准确的时间戳比较
 * 
 * @see App-First改造计划.md
 */

// ==================== 时间戳生成 ====================

/**
 * 获取当前 UTC 毫秒时间戳
 * 用于所有本地存储的时间字段
 * 
 * 注意: Date.now() 返回的已经是 UTC 毫秒时间戳，
 * 与用户本地时区无关，可以安全地跨时区比较
 */
export function nowUtc(): number {
  return Date.now()
}

/**
 * 获取当前 UTC 时间的 ISO 字符串
 * 用于发送给服务器
 */
export function nowIso(): string {
  return new Date().toISOString()
}

// ==================== 服务器时间戳解析 ====================

/**
 * 解析服务器返回的时间戳字符串为 UTC 毫秒数
 * 
 * 支持的格式:
 * - ISO 8601 带时区: "2024-12-09T12:00:00.000Z"
 * - ISO 8601 带偏移: "2024-12-09T12:00:00+08:00"
 * - PostgreSQL timestamptz: "2024-12-09 12:00:00.000000+00:00"
 * - 纯数字: 1733760000000 (直接返回)
 * 
 * @param timestamp - 服务器返回的时间戳（字符串或数字）
 * @param fallback - 解析失败时的回退值，默认为当前时间
 * @returns UTC 毫秒时间戳
 */
export function parseServerTimestamp(
  timestamp: string | number | null | undefined,
  fallback: number = Date.now()
): number {
  // 空值处理
  if (timestamp === null || timestamp === undefined) {
    return fallback
  }

  // 已经是数字
  if (typeof timestamp === 'number') {
    // 检查是否是秒级时间戳（10位）而非毫秒（13位）
    if (timestamp < 10000000000) {
      return timestamp * 1000
    }
    return timestamp
  }

  // 字符串解析
  if (typeof timestamp === 'string') {
    // 空字符串
    if (!timestamp.trim()) {
      return fallback
    }

    // 尝试解析
    const parsed = new Date(timestamp).getTime()

    // 检查是否有效
    if (isNaN(parsed)) {
      console.warn('[timestamp] Invalid timestamp format:', timestamp)
      return fallback
    }

    return parsed
  }

  return fallback
}

/**
 * 安全地比较两个时间戳
 * 处理各种格式的输入，统一转换后比较
 * 
 * @returns 负数: a < b, 0: a === b, 正数: a > b
 */
export function compareTimestamps(
  a: string | number | null | undefined,
  b: string | number | null | undefined
): number {
  const aMs = parseServerTimestamp(a, 0)
  const bMs = parseServerTimestamp(b, 0)
  return aMs - bMs
}

/**
 * 检查时间戳 a 是否比 b 更新
 */
export function isNewer(
  a: string | number | null | undefined,
  b: string | number | null | undefined
): boolean {
  return compareTimestamps(a, b) > 0
}

// ==================== 本地时间戳转换 ====================

/**
 * 将 UTC 毫秒时间戳转换为 ISO 字符串
 * 用于发送给服务器
 */
export function toIsoString(utcMs: number): string {
  return new Date(utcMs).toISOString()
}

/**
 * 将 UTC 毫秒时间戳转换为本地日期对象
 * 用于 UI 显示
 */
export function toLocalDate(utcMs: number): Date {
  return new Date(utcMs)
}

// ==================== 日期字符串处理 ====================

/**
 * 获取用户本地时区的日期字符串 (YYYY-MM-DD)
 * 用于日期比较和显示
 * 
 * 注意: 这个函数返回的是用户本地时区的日期，
 * 如北京时间 2024-12-10 00:30 会返回 "2024-12-10"
 * 而 UTC 时间此时是 2024-12-09 16:30
 */
export function getLocalDateString(date: Date = new Date()): string {
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  return `${year}-${month}-${day}`
}

/**
 * 获取 UTC 日期字符串 (YYYY-MM-DD)
 * 用于与服务器返回的日期比较
 */
export function getUtcDateString(date: Date = new Date()): string {
  return date.toISOString().slice(0, 10)
}

/**
 * 获取本周的日期范围（周一开始，用户本地时区）
 */
export function getLocalWeekRange(): { start: Date; dates: string[] } {
  const now = new Date()
  const day = now.getDay()
  const diff = day === 0 ? 6 : day - 1 // 调整为周一开始
  const monday = new Date(now)
  monday.setDate(now.getDate() - diff)
  monday.setHours(0, 0, 0, 0)

  const dates: string[] = []
  for (let i = 0; i < 7; i++) {
    const d = new Date(monday)
    d.setDate(monday.getDate() + i)
    dates.push(getLocalDateString(d))
  }

  return { start: monday, dates }
}

// ==================== 用户时区处理 ====================

/**
 * 获取用户的时区标识
 * 例如: "Asia/Shanghai", "America/New_York"
 */
export function getUserTimezone(): string {
  return Intl.DateTimeFormat().resolvedOptions().timeZone
}

/**
 * 获取用户时区偏移（分钟）
 * 正数表示西半球，负数表示东半球
 * 例如: 北京时间 (UTC+8) 返回 -480
 */
export function getTimezoneOffset(): number {
  return new Date().getTimezoneOffset()
}

// ==================== 调试工具 ====================

/**
 * 打印时间戳调试信息
 */
export function debugTimestamp(label: string, timestamp: string | number | null | undefined): void {
  if (process.env.NODE_ENV === 'development') {
    const ms = parseServerTimestamp(timestamp, 0)
    console.log(`[timestamp] ${label}:`, {
      raw: timestamp,
      utcMs: ms,
      utcIso: ms ? new Date(ms).toISOString() : null,
      localStr: ms ? new Date(ms).toLocaleString() : null,
      userTz: getUserTimezone(),
    })
  }
}


==================================================
FILE_PATH: web/src/lib/webLocksPolyfill.ts
==================================================

/**
 * Web Locks API Polyfill
 * 
 * 用于在非安全上下文（HTTP + 非 localhost）中提供 navigator.locks 的模拟实现
 * 
 * 限制：
 * - 仅支持单标签页（无跨标签页锁同步）
 * - 仅用于开发环境
 * 
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Locks_API
 */

interface LockInfo {
  name: string
  mode: 'exclusive' | 'shared'
  clientId?: string
}

interface LockManagerSnapshot {
  held: LockInfo[]
  pending: LockInfo[]
}

interface LockOptions {
  mode?: 'exclusive' | 'shared'
  ifAvailable?: boolean
  steal?: boolean
  signal?: AbortSignal
}

type LockGrantedCallback<T> = (lock: Lock | null) => T | Promise<T>

interface Lock {
  name: string
  mode: 'exclusive' | 'shared'
}

interface LockManager {
  request<T>(name: string, callback: LockGrantedCallback<T>): Promise<T>
  request<T>(name: string, options: LockOptions, callback: LockGrantedCallback<T>): Promise<T>
  query(): Promise<LockManagerSnapshot>
}

class PolyfillLockManager implements LockManager {
  private locks: Map<string, { mode: 'exclusive' | 'shared'; count: number; queue: Array<() => void> }> = new Map()

  async request<T>(
    name: string,
    optionsOrCallback: LockOptions | LockGrantedCallback<T>,
    callback?: LockGrantedCallback<T>
  ): Promise<T> {
    let options: LockOptions = {}
    let cb: LockGrantedCallback<T>

    if (typeof optionsOrCallback === 'function') {
      cb = optionsOrCallback
    } else {
      options = optionsOrCallback
      cb = callback!
    }

    const mode = options.mode || 'exclusive'

    // ifAvailable: 如果锁不可用，立即返回 null
    if (options.ifAvailable) {
      const existing = this.locks.get(name)
      if (existing && (existing.mode === 'exclusive' || mode === 'exclusive')) {
        return cb(null)
      }
    }

    // 等待获取锁
    await this.acquireLock(name, mode)

    const lock: Lock = { name, mode }

    try {
      return await cb(lock)
    } finally {
      this.releaseLock(name, mode)
    }
  }

  private async acquireLock(name: string, mode: 'exclusive' | 'shared'): Promise<void> {
    const existing = this.locks.get(name)

    if (!existing) {
      // 没有现有锁，直接获取
      this.locks.set(name, { mode, count: 1, queue: [] })
      return
    }

    // 共享锁可以与其他共享锁共存
    if (mode === 'shared' && existing.mode === 'shared') {
      existing.count++
      return
    }

    // 需要等待
    return new Promise<void>((resolve) => {
      existing.queue.push(resolve)
    })
  }

  private releaseLock(name: string, _mode: 'exclusive' | 'shared'): void {
    const existing = this.locks.get(name)
    if (!existing) return

    existing.count--

    if (existing.count <= 0) {
      // 处理等待队列中的下一个
      const next = existing.queue.shift()
      if (next) {
        existing.count = 1
        next()
      } else {
        this.locks.delete(name)
      }
    }
  }

  async query(): Promise<LockManagerSnapshot> {
    const held: LockInfo[] = []
    
    this.locks.forEach((value, name) => {
      for (let i = 0; i < value.count; i++) {
        held.push({ name, mode: value.mode })
      }
    })

    return { held, pending: [] }
  }
}

/**
 * 安装 Web Locks Polyfill
 * 仅在 navigator.locks 不可用时安装
 */
export function installWebLocksPolyfill(): void {
  if (typeof navigator === 'undefined') {
    return
  }

  if ('locks' in navigator && navigator.locks) {
    console.log('[WebLocks] Native API available')
    return
  }

  console.warn('[WebLocks] Native API not available, installing polyfill...')
  console.warn('[WebLocks] This is a development-only polyfill with limitations:')
  console.warn('[WebLocks] - No cross-tab lock synchronization')
  console.warn('[WebLocks] - For production, use HTTPS or localhost')

  // 安装 polyfill
  Object.defineProperty(navigator, 'locks', {
    value: new PolyfillLockManager(),
    writable: false,
    configurable: true
  })

  console.log('[WebLocks] Polyfill installed successfully')
}


==================================================
FILE_PATH: web/src/lib/shelvesStorage.ts
==================================================

/**
 * 书架存储 Stub（App-First 迁移中）
 * TODO: 迁移到 PowerSync useShelvesData
 */

export const addBookToShelf = async (_shelfId: string, _bookId: string) => {
  console.warn('[shelvesStorage] Stub: 待迁移到 PowerSync')
}

export const removeBookFromShelf = async (_shelfId: string, _bookId: string) => {
  console.warn('[shelvesStorage] Stub: 待迁移到 PowerSync')
}

export const getAllShelves = async () => {
  return []
}

export const getBookShelfIds = async (_bookId: string) => {
  return []  
}


==================================================
FILE_PATH: web/src/lib/api.ts
==================================================

import axios from 'axios'
import { useAuthStore } from '@/stores/auth'

/**
 * Axios 实例与拦截器
 *
 * 功能：
 * - 请求前自动附加 `Authorization: Bearer <token>`
 * - Token 距过期 5 分钟内时，先刷新再发起请求
 * - 响应 401 时，尝试刷新并重试一次，否则清空状态并跳转登录
 *
 * 注意：
 * - 这里直接使用 `window.location.href` 做跳转，避免路由实例依赖
 */
const api = axios.create({
    baseURL: '/api/v1',
    headers: {
        'Content-Type': 'application/json',
    },
})

// 请求拦截器：自动携带 Token 并在即将过期时刷新
api.interceptors.request.use(
    async (config) => {
        // 从全局 store 取当前认证信息
        const store = useAuthStore.getState()
        const token = store.accessToken

        console.log('[API] Request:', config.method?.toUpperCase(), config.url, {
            hasToken: !!token,
            isAuthenticated: store.isAuthenticated
        })

        // 如果有 token，检查是否即将过期
        if (token) {
            // Token 即将在 5 分钟内过期，主动刷新
            if (store.isTokenExpiringSoon()) {
                console.log('[API] Token expiring soon, refreshing before request...')
                const refreshed = await store.refreshAccessToken()

                if (refreshed) {
                    // 使用新 token
                    const newToken = useAuthStore.getState().accessToken
                    if (newToken) {
                        config.headers.Authorization = `Bearer ${newToken}`
                        console.log('[API] Using refreshed token')
                    }
                } else {
                    // 刷新失败，清空状态
                    console.error('[API] Token refresh failed in request interceptor')
                    store.clear()
                    window.location.href = '/login'
                    return Promise.reject(new Error('Token refresh failed'))
                }
            } else {
                // Token 未过期，直接使用
                config.headers.Authorization = `Bearer ${token}`
                console.log('[API] Using existing token')
            }
        } else {
            console.log('[API] No token available')
        }

        return config
    },
    (error) => {
        console.error('[API] Request error:', error)
        return Promise.reject(error)
    }
)

// 响应拦截器：处理 401 错误
api.interceptors.response.use(
    (response) => {
        console.log('[API] Response:', response.status, response.config.url)
        return response
    },
    async (error) => {
        console.error('[API] Response error:', error.response?.status, error.config?.url)
        console.error('[API] Error details:', error.response?.data)

        const originalRequest = error.config

        // 处理 401 未授权错误
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true

            const store = useAuthStore.getState()

            console.log('[API] Received 401, attempting token refresh...')

            // 尝试刷新 token
            const refreshed = await store.refreshAccessToken()

            if (refreshed) {
                // 刷新成功，使用新 token 重试原请求
                const newToken = useAuthStore.getState().accessToken
                if (newToken) {
                    console.log('[API] Retrying request with new token')
                    originalRequest.headers.Authorization = `Bearer ${newToken}`
                    return api.request(originalRequest)
                }
            }

            // 刷新失败，清空状态并跳转登录页
            console.error('[API] Token refresh failed after 401, redirecting to login')
            store.clear()
            window.location.href = '/login'
            return Promise.reject(error)
        }

        // 其他错误直接抛出
        return Promise.reject(error)
    }
)

export default api


==================================================
FILE_PATH: web/src/lib/aiChatStorage.ts
==================================================

/**
 * AI 聊天存储 Stub（App-First 迁移中）
 * TODO: 迁移到 PowerSync
 */

export interface ConversationRecord {
  id: string
  title: string
  created_at: string
  updated_at: string
  createdAt: string  // 兼容旧字段
}

export interface MessageRecord {
  id: string
  conversationId: string
  conversation_id?: string
  role: 'user' | 'assistant'
  content: string
  created_at: string
  createdAt?: string
  metadata?: any
}

export const saveConversations = async (_conversations: ConversationRecord[]) => {
  console.warn('[aiChatStorage] Stub: 待迁移到 PowerSync')
}

export const saveMessages = async (_messages: MessageRecord[]) => {
  console.warn('[aiChatStorage] Stub: 待迁移到 PowerSync')
}

export const getCachedConversations = async () => {
  return [] as ConversationRecord[]
}

export const getConversationMessages = async (_conversationId: string) => {
  return [] as MessageRecord[]
}

export const deleteConversation = async (_id: string) => {
  console.warn('[aiChatStorage] Stub: 待迁移到 PowerSync')
}


==================================================
FILE_PATH: web/src/lib/powersync/PowerSyncProvider.tsx
==================================================

/**
 * PowerSync Provider - App-First 核心同步引擎
 *
 * 职责：
 * - 初始化 PowerSync 客户端与 SQLite 数据库
 * - 管理认证凭证与 JWT Token 交互
 * - 提供 React Context 供全局使用
 * - 支持 Feature Flag 控制的渐进式切换
 *
 * 依赖：
 * - @powersync/web - PowerSync Web SDK
 * - @powersync/react - React 绑定
 * - @journeyapps/wa-sqlite - SQLite WASM 实现
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

import React, { createContext, useContext, useEffect, useState, useMemo, useCallback, ReactNode } from 'react'
import { PowerSyncDatabase, WASQLitePowerSyncDatabaseOpenFactory, AbstractPowerSyncDatabase } from '@powersync/web'
import { PowerSyncContext } from '@powersync/react'
import { useAuthStore } from '@/stores/auth'
import { AppSchema } from './schema'

// App-First 架构：PowerSync 始终启用，不再使用 Feature Flag

// ============================================================================
// 类型定义
// ============================================================================

interface PowerSyncProviderProps {
  children: ReactNode
}

interface PowerSyncState {
  /** PowerSync 数据库实例 */
  db: AbstractPowerSyncDatabase | null
  /** 连接状态 */
  isConnected: boolean
  /** 初始化状态 */
  isInitialized: boolean
  /** 同步状态 */
  isSyncing: boolean
  /** 最后同步时间 */
  lastSyncedAt: Date | null
  /** 错误信息 */
  error: Error | null
}

interface PowerSyncContextValue extends PowerSyncState {
  /** 手动触发同步 */
  triggerSync: () => Promise<void>
  /** 断开连接 */
  disconnect: () => Promise<void>
  /** 重新连接 */
  reconnect: () => Promise<void>
  /** 清除本地数据 */
  clearLocalData: () => Promise<void>
}

// ============================================================================
// Context
// ============================================================================

const PowerSyncStateContext = createContext<PowerSyncContextValue | null>(null)

// ============================================================================
// 自定义 Connector
// ============================================================================

/**
 * PowerSync Connector - 处理认证和上传
 */
class AthenaConnector {
  private getAccessToken: () => string | null
  private refreshToken: () => Promise<boolean>
  private powersyncUrl: string

  constructor(
    getAccessToken: () => string | null,
    refreshToken: () => Promise<boolean>
  ) {
    this.getAccessToken = getAccessToken
    this.refreshToken = refreshToken
    this.powersyncUrl = import.meta.env.VITE_POWERSYNC_URL || 'http://localhost:8090'
  }

  /**
   * 获取 PowerSync 凭证
   */
  async fetchCredentials() {
    let token = this.getAccessToken()
    
    // 如果没有 token 或 token 过期，尝试刷新
    if (!token) {
      console.log('[PowerSync] No token, attempting refresh...')
      const refreshed = await this.refreshToken()
      if (refreshed) {
        token = this.getAccessToken()
      }
    }

    if (!token) {
      throw new Error('No authentication token available')
    }

    return {
      endpoint: this.powersyncUrl,
      token
    }
  }

  /**
   * 上传本地变更到后端
   * 当 SQLite 有本地写入时触发
   */
  async uploadData(database: PowerSyncDatabase): Promise<void> {
    const transaction = await database.getNextCrudTransaction()
    
    if (!transaction) {
      return
    }

    try {
      const token = this.getAccessToken()
      if (!token) {
        throw new Error('No authentication token for upload')
      }

      const operations = transaction.crud

      if (operations.length === 0) {
        await transaction.complete()
        return
      }

      console.log(`[PowerSync] Uploading ${operations.length} operations...`)
      console.log(`[PowerSync] Operations:`, JSON.stringify(operations.map(op => ({
        table: op.table,
        op: op.op,
        id: op.id,
        data: op.opData
      })), null, 2))

      // 批量发送到后端 API
      const response = await fetch('/api/v1/sync/upload', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          operations: operations.map(op => ({
            table: op.table,
            op: op.op,
            id: op.id,
            data: op.opData
          }))
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(
          `Upload failed: ${response.status} - ${errorData.message || response.statusText}`
        )
      }

      // 标记事务完成
      await transaction.complete()
      console.log('[PowerSync] Upload completed successfully')

    } catch (error) {
      console.error('[PowerSync] Upload error:', error)
      // 不标记完成，PowerSync 会重试
      throw error
    }
  }
}

// ============================================================================
// Provider 组件
// ============================================================================

export function PowerSyncProvider({ children }: PowerSyncProviderProps) {
  const [state, setState] = useState<PowerSyncState>({
    db: null,
    isConnected: false,
    isInitialized: false,
    isSyncing: false,
    lastSyncedAt: null,
    error: null
  })

  // 从 auth store 获取认证方法
  const refreshAccessToken = useAuthStore(s => s.refreshAccessToken)
  const isAuthenticated = useAuthStore(s => s.isAuthenticated)

  // 创建 connector
  const connector = useMemo(() => {
    return new AthenaConnector(
      () => useAuthStore.getState().accessToken,
      refreshAccessToken
    )
  }, [refreshAccessToken])

  // 初始化 PowerSync (始终执行)
  useEffect(() => {
    let db: AbstractPowerSyncDatabase | null = null
    let mounted = true

    const initPowerSync = async () => {
      try {
        console.log('[PowerSync] Initializing...')

        // 创建数据库工厂
        const factory = new WASQLitePowerSyncDatabaseOpenFactory({
          dbFilename: 'athena.sqlite',
          schema: AppSchema,
          flags: {
            enableMultiTabs: false, // 禁用多标签页支持（避免 Web Locks 问题）
            useWebWorker: false     // 禁用 Web Worker（开发环境兼容）
          }
        })

        // 打开数据库
        db = await factory.getInstance()

        if (!mounted) {
          await db.close()
          return
        }

        console.log('[PowerSync] Database opened successfully')

        setState(prev => ({
          ...prev,
          db,
          isInitialized: true,
          error: null
        }))

        // 如果已认证，开始同步
        if (isAuthenticated) {
          await db.connect(connector)
          if (mounted) {
            setState(prev => ({ ...prev, isConnected: true }))
            console.log('[PowerSync] Connected and syncing')
          }
        }

      } catch (error) {
        console.error('[PowerSync] Initialization error:', error)
        if (mounted) {
          setState(prev => ({
            ...prev,
            error: error instanceof Error ? error : new Error(String(error)),
            isInitialized: true
          }))
        }
      }
    }

    initPowerSync()

    return () => {
      mounted = false
      if (db) {
        db.disconnect()
        db.close()
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []) // 只在组件挂载时初始化一次

  // 认证状态变化时连接/断开
  useEffect(() => {
    if (!state.db || !state.isInitialized) return

    const handleAuthChange = async () => {
      if (isAuthenticated && !state.isConnected) {
        try {
          await state.db!.connect(connector)
          setState(prev => ({ ...prev, isConnected: true, error: null }))
          console.log('[PowerSync] Connected after auth')
        } catch (error) {
          console.error('[PowerSync] Connect error:', error)
          setState(prev => ({
            ...prev,
            error: error instanceof Error ? error : new Error(String(error))
          }))
        }
      } else if (!isAuthenticated && state.isConnected) {
        await state.db!.disconnect()
        setState(prev => ({ ...prev, isConnected: false }))
        console.log('[PowerSync] Disconnected after logout')
      }
    }

    handleAuthChange()
  }, [isAuthenticated, state.db, state.isInitialized, state.isConnected, connector, setState])

  // 监听同步状态
  useEffect(() => {
    if (!state.db) return

    const unsubscribe = state.db.registerListener({
      statusChanged: (status: { connected: boolean; lastSyncedAt?: Date }) => {
        setState(prev => ({
          ...prev,
          isConnected: status.connected,
          lastSyncedAt: status.lastSyncedAt ?? prev.lastSyncedAt
        }))
      }
    })

    return () => unsubscribe?.()
  }, [state.db])

  // ============================================================================
  // Context Actions
  // ============================================================================

  const triggerSync = useCallback(async () => {
    if (!state.db || !state.isConnected) {
      console.warn('[PowerSync] Cannot sync: not connected')
      return
    }
    // PowerSync 自动同步，这里可以触发强制同步
    console.log('[PowerSync] Manual sync triggered')
  }, [state.db, state.isConnected])

  const disconnect = useCallback(async () => {
    if (state.db) {
      await state.db.disconnect()
      setState(prev => ({ ...prev, isConnected: false }))
    }
  }, [state.db])

  const reconnect = useCallback(async () => {
    if (state.db && !state.isConnected && isAuthenticated) {
      try {
        await state.db.connect(connector)
        setState(prev => ({ ...prev, isConnected: true, error: null }))
      } catch (error) {
        setState(prev => ({
          ...prev,
          error: error instanceof Error ? error : new Error(String(error))
        }))
      }
    }
  }, [state.db, state.isConnected, isAuthenticated, connector])

  const clearLocalData = useCallback(async () => {
    if (state.db) {
      await state.db.disconnectAndClear()
      setState(prev => ({
        ...prev,
        isConnected: false,
        lastSyncedAt: null
      }))
      console.log('[PowerSync] Local data cleared')
    }
  }, [state.db])

  // ============================================================================
  // Context Value
  // ============================================================================

  const contextValue: PowerSyncContextValue = useMemo(() => ({
    ...state,
    triggerSync,
    disconnect,
    reconnect,
    clearLocalData
  }), [state, triggerSync, disconnect, reconnect, clearLocalData])

  // 行业最佳实践：在数据库就绪前显示加载状态
  // 这样子组件中的 useQuery 就不需要每个都检查 isReady
  if (!state.isInitialized || !state.db) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground text-sm">正在初始化本地数据库...</p>
        </div>
      </div>
    )
  }

  // App-First: 始终使用 PowerSync Provider
  return (
    <PowerSyncContext.Provider value={state.db}>
      <PowerSyncStateContext.Provider value={contextValue}>
        {children}
      </PowerSyncStateContext.Provider>
    </PowerSyncContext.Provider>
  )
}

// ============================================================================
// Hooks
// ============================================================================

/**
 * 获取 PowerSync 状态和操作
 */
export function usePowerSyncState(): PowerSyncContextValue {
  const context = useContext(PowerSyncStateContext)
  if (!context) {
    throw new Error('usePowerSyncState must be used within a PowerSyncProvider')
  }
  return context
}

/**
 * 获取 PowerSync 数据库实例
 */
export function usePowerSyncDatabase(): AbstractPowerSyncDatabase | null {
  const context = useContext(PowerSyncStateContext)
  return context?.db ?? null
}

/**
 * App-First 模式始终启用
 * 保留此 Hook 是为了向后兼容
 */
export function useIsAppFirstEnabled(): boolean {
  // App-First 架构已完全启用，始终返回 true
  return true
}


==================================================
FILE_PATH: web/src/lib/powersync/index.ts
==================================================

/**
 * PowerSync 模块统一导出
 *
 * App-First 架构核心同步引擎
 * 提供实时响应式数据查询和离线优先同步能力
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

// Provider
export {
  PowerSyncProvider,
  usePowerSyncState,
  usePowerSyncDatabase,
  useIsAppFirstEnabled
} from './PowerSyncProvider'

// Schema
export { AppSchema } from './schema'

// Hooks
export * from './hooks'

// Re-export PowerSync React hooks for convenience
export { useQuery, useStatus } from '@powersync/react'


==================================================
FILE_PATH: web/src/lib/powersync/schema.ts
==================================================

/**
 * schema.ts - PowerSync SQLite Schema 定义
 * 
 * 定义客户端 SQLite 数据库的表结构
 * 与服务端 sync_rules.yaml 保持一致
 * 
 * @see 09 - APP-FIRST架构改造计划.md - Phase 2
 * @see docker/powersync/sync_rules.yaml
 * @ai-generated Claude Opus 4.5 (2025-12-13)
 */

import { column, Schema, Table } from '@powersync/web'

// ============ 书籍元数据表 ============
const books = new Table({
  // 基础信息
  user_id: column.text,
  title: column.text,
  author: column.text,
  cover_url: column.text,      // 来自 cover_image_key
  file_type: column.text,      // 来自 original_format
  file_size: column.integer,   // 来自 size
  content_sha256: column.text,
  storage_key: column.text,    // 来自 minio_key
  
  // 元数据状态
  metadata_confirmed: column.integer,
  is_digitalized: column.integer, // boolean as 0/1, true = 有文字层
  initial_digitalization_confidence: column.real, // 0.0 - 1.0, OCR 置信度
  page_count: column.integer,  // 来自 meta->>'page_count'
  
  // OCR 状态
  ocr_status: column.text, // 'pending' | 'processing' | 'completed' | 'failed'
  
  // 格式转换
  conversion_status: column.text,
  converted_epub_key: column.text,
  
  // 时间戳
  created_at: column.text, // ISO 8601
  updated_at: column.text,
  deleted_at: column.text,
}, {
  indexes: {
    by_user: ['user_id'],
    by_sha256: ['content_sha256'],
  }
})

// ============ 阅读进度表 ============
const reading_progress = new Table({
  user_id: column.text,
  book_id: column.text,
  device_id: column.text,
  progress: column.real, // 0.0 - 1.0
  last_position: column.text, // JSON: CFI 或页码
  last_location: column.text, // JSON: 位置对象
  finished_at: column.text, // ISO 8601: 完成阅读时间
  updated_at: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
    by_user_book: ['user_id', 'book_id'],
  }
})

// ============ 阅读会话表 ============
const reading_sessions = new Table({
  user_id: column.text,
  book_id: column.text,
  device_id: column.text,
  is_active: column.integer, // boolean
  total_ms: column.integer,
  created_at: column.text,
  updated_at: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
    by_active: ['is_active'],
  }
})

// ============ 笔记表 ============
const notes = new Table({
  user_id: column.text,
  book_id: column.text,
  device_id: column.text,
  content: column.text,
  page_number: column.integer,
  position_cfi: column.text,
  color: column.text,
  is_deleted: column.integer,
  deleted_at: column.text,
  created_at: column.text,
  updated_at: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
    by_user_book: ['user_id', 'book_id'],
  }
})

// ============ 高亮表 ============
const highlights = new Table({
  user_id: column.text,
  book_id: column.text,
  device_id: column.text,
  text: column.text,
  page_number: column.integer,
  position_start_cfi: column.text,
  position_end_cfi: column.text,
  color: column.text,
  is_deleted: column.integer,
  deleted_at: column.text,
  created_at: column.text,
  updated_at: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
    by_user_book: ['user_id', 'book_id'],
  }
})

// ============ 书签表 ============
const bookmarks = new Table({
  user_id: column.text,
  book_id: column.text,
  device_id: column.text,
  title: column.text,
  page_number: column.integer,
  position_cfi: column.text,
  is_deleted: column.integer,
  deleted_at: column.text,
  created_at: column.text,
  updated_at: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
  }
})

// ============ 书架表 ============
const shelves = new Table({
  user_id: column.text,
  name: column.text,
  description: column.text,
  cover_url: column.text,
  sort_order: column.integer,
  is_deleted: column.integer,
  deleted_at: column.text,
  created_at: column.text,
  updated_at: column.text,
}, {
  indexes: {
    by_user: ['user_id'],
    by_sort: ['sort_order'],
  }
})

// ============ 书架书籍关联表 ============
const shelf_books = new Table({
  user_id: column.text,  // 2025-12-15: 添加 user_id 以支持 PowerSync 同步
  shelf_id: column.text,
  book_id: column.text,
  sort_order: column.integer,
  added_at: column.text,
}, {
  indexes: {
    by_user: ['user_id'],
    by_shelf: ['shelf_id'],
    by_book: ['book_id'],
  }
})

// ============ 用户设置表 ============
const user_settings = new Table({
  user_id: column.text,
  device_id: column.text,
  settings_json: column.text, // JSON 字符串
  updated_at: column.text,
}, {
  indexes: {
    by_user: ['user_id'],
  }
})

// ============ 本地专用表 (不同步到服务端) ============

// 书籍文件缓存元数据 (实际文件存储在 OPFS/Filesystem)
const local_book_files = new Table({
  book_id: column.text,
  format: column.text, // 'epub' | 'pdf'
  size: column.integer,
  downloaded_at: column.text,
  etag: column.text,
  file_path: column.text, // OPFS 或 Filesystem 路径
}, {
  indexes: {
    by_book: ['book_id'],
  },
  localOnly: true, // 不同步到服务端
})

// OCR 数据缓存
const local_ocr_data = new Table({
  book_id: column.text,
  is_image_based: column.integer,
  confidence: column.real,
  total_pages: column.integer,
  total_chars: column.integer,
  total_regions: column.integer,
  image_width: column.integer,
  image_height: column.integer,
  page_sizes_json: column.text, // JSON
  regions_json: column.text, // JSON (压缩后)
  downloaded_at: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
  },
  localOnly: true,
})

// 封面缓存元数据
const local_cover_cache = new Table({
  book_id: column.text,
  mime_type: column.text,
  cached_at: column.text,
  original_url: column.text,
  file_path: column.text,
}, {
  indexes: {
    by_book: ['book_id'],
  },
  localOnly: true,
})

// ============ 导出 Schema ============

export const AppSchema = new Schema({
  // 同步表 (共 9 个)
  books,
  reading_progress,
  reading_sessions,
  notes,
  highlights,
  bookmarks,
  shelves,
  shelf_books,
  user_settings,
  
  // 本地表 (不同步)
  local_book_files,
  local_ocr_data,
  local_cover_cache,
})

// 导出表类型供其他模块使用
export type Database = (typeof AppSchema)['types']
export type BooksRecord = Database['books']
export type ReadingProgressRecord = Database['reading_progress']
export type NotesRecord = Database['notes']
export type HighlightsRecord = Database['highlights']
export type BookmarksRecord = Database['bookmarks']
export type ShelvesRecord = Database['shelves']
export type ShelfBooksRecord = Database['shelf_books']
export type UserSettingsRecord = Database['user_settings']
export type LocalBookFilesRecord = Database['local_book_files']
export type LocalOcrDataRecord = Database['local_ocr_data']
export type LocalCoverCacheRecord = Database['local_cover_cache']


==================================================
FILE_PATH: web/src/lib/powersync/hooks/useNotes.ts
==================================================

/**
 * useNotes - 笔记 Live Query Hook
 *
 * 提供实时响应式的笔记数据查询
 * 支持 PowerSync (App-First) 和 Dexie (Legacy) 双模式
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

import { useMemo } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, useIsAppFirstEnabled } from '../PowerSyncProvider'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

export interface Note {
  id: string
  book_id: string
  chapter_index: number | null
  cfi_range: string | null
  page_number: number | null
  content: string
  color: string | null
  tags: string | null // JSON array string
  created_at: string
  updated_at: string
  deleted_at: string | null
}

export interface UseNotesOptions {
  /** 按书籍 ID 筛选 */
  bookId?: string
  /** 按章节筛选 */
  chapterIndex?: number
  /** 是否包含已删除的笔记 */
  includeDeleted?: boolean
  /** 排序字段 */
  orderBy?: 'created_at' | 'updated_at' | 'page_number'
  /** 排序方向 */
  orderDirection?: 'asc' | 'desc'
  /** 限制数量 */
  limit?: number
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取笔记列表
 */
export function useNotes(options: UseNotesOptions = {}) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const {
    bookId,
    chapterIndex,
    includeDeleted = false,
    orderBy = 'created_at',
    orderDirection = 'desc',
    limit
  } = options

  // 构建 SQL 查询
  const { sql, params } = useMemo(() => {
    let query = 'SELECT * FROM notes'
    const conditions: string[] = []
    const queryParams: (string | number)[] = []

    if (!includeDeleted) {
      conditions.push('deleted_at IS NULL')
    }

    if (bookId) {
      conditions.push('book_id = ?')
      queryParams.push(bookId)
    }

    if (chapterIndex !== undefined) {
      conditions.push('chapter_index = ?')
      queryParams.push(chapterIndex)
    }

    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ')
    }

    query += ` ORDER BY ${orderBy} ${orderDirection.toUpperCase()}`

    if (limit) {
      query += ` LIMIT ${limit}`
    }

    return { sql: query, params: queryParams }
  }, [bookId, chapterIndex, includeDeleted, orderBy, orderDirection, limit])

  // PowerSync Live Query
  const { data, isLoading, error } = useQuery<Note>(sql, params)

  if (!isAppFirstEnabled || !db) {
    return {
      notes: [] as Note[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    notes: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取单条笔记
 */
export function useNote(noteId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { data, isLoading, error } = useQuery<Note>(
    noteId ? 'SELECT * FROM notes WHERE id = ?' : 'SELECT * FROM notes WHERE 1=0',
    noteId ? [noteId] : []
  )

  if (!isAppFirstEnabled || !db || !noteId) {
    return {
      note: null,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    note: data?.[0] ?? null,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取书籍的笔记数量
 */
export function useNoteCount(bookId?: string) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const sql = bookId
    ? 'SELECT COUNT(*) as count FROM notes WHERE book_id = ? AND deleted_at IS NULL'
    : 'SELECT COUNT(*) as count FROM notes WHERE deleted_at IS NULL'

  const params = bookId ? [bookId] : []

  const { data, isLoading, error } = useQuery<{ count: number }>(sql, params)

  if (!isAppFirstEnabled || !db) {
    return {
      count: 0,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    count: data?.[0]?.count ?? 0,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 笔记写入操作
 */
export function useNoteMutations() {
  const db = usePowerSyncDatabase()
  const isAppFirstEnabled = useIsAppFirstEnabled()

  const addNote = async (note: Omit<Note, 'id' | 'created_at' | 'updated_at' | 'deleted_at'> & { id?: string }) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const id = note.id || generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id 和 device_id - 从 AuthStore 和 localStorage 获取
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()

    await db.execute(
      `INSERT INTO notes (id, user_id, device_id, book_id, chapter_index, cfi_range, page_number, content, color, tags, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        deviceId,
        note.book_id,
        note.chapter_index,
        note.cfi_range,
        note.page_number,
        note.content,
        note.color,
        note.tags,
        now,
        now
      ]
    )

    return id
  }

  const updateNote = async (id: string, updates: Partial<Note>) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const fields = Object.keys(updates).filter(k => k !== 'id' && k !== 'created_at')
    if (fields.length === 0) return

    const setClause = fields.map(f => `${f} = ?`).join(', ')
    const values = fields.map(f => updates[f as keyof Note])
    values.push(new Date().toISOString()) // updated_at
    values.push(id)

    await db.execute(
      `UPDATE notes SET ${setClause}, updated_at = ? WHERE id = ?`,
      values
    )
  }

  const deleteNote = async (id: string, soft = true) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    if (soft) {
      await db.execute(
        'UPDATE notes SET deleted_at = ?, updated_at = ? WHERE id = ?',
        [new Date().toISOString(), new Date().toISOString(), id]
      )
    } else {
      await db.execute('DELETE FROM notes WHERE id = ?', [id])
    }
  }

  return {
    addNote,
    updateNote,
    deleteNote,
    isAvailable: isAppFirstEnabled && !!db
  }
}


==================================================
FILE_PATH: web/src/lib/powersync/hooks/useShelves.ts
==================================================

/**
 * useShelves - 书架 Live Query Hook
 *
 * 提供实时响应式的书架数据查询
 * 支持 PowerSync (App-First) 和 Dexie (Legacy) 双模式
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

import { useMemo } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, useIsAppFirstEnabled } from '../PowerSyncProvider'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

export interface Shelf {
  id: string
  name: string
  description: string | null
  color: string | null
  icon: string | null
  sort_order: number
  created_at: string
  updated_at: string
  deleted_at: string | null
}

export interface ShelfBook {
  id: string
  shelf_id: string
  book_id: string
  sort_order: number
  added_at: string
}

export interface ShelfWithBooks extends Shelf {
  bookCount: number
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取所有书架
 */
export function useShelves(options: { includeDeleted?: boolean } = {}) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { includeDeleted = false } = options

  const sql = includeDeleted
    ? 'SELECT * FROM shelves ORDER BY sort_order ASC, name ASC'
    : 'SELECT * FROM shelves WHERE deleted_at IS NULL ORDER BY sort_order ASC, name ASC'

  const { data, isLoading, error } = useQuery<Shelf>(sql, [])

  if (!isAppFirstEnabled || !db) {
    return {
      shelves: [] as Shelf[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    shelves: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取书架及其书籍数量
 */
export function useShelvesWithBookCount() {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const sql = `
    SELECT s.*, COALESCE(sb.book_count, 0) as bookCount
    FROM shelves s
    LEFT JOIN (
      SELECT shelf_id, COUNT(*) as book_count
      FROM shelf_books
      GROUP BY shelf_id
    ) sb ON s.id = sb.shelf_id
    WHERE s.deleted_at IS NULL
    ORDER BY s.sort_order ASC, s.name ASC
  `

  const { data, isLoading, error } = useQuery<ShelfWithBooks>(sql, [])

  if (!isAppFirstEnabled || !db) {
    return {
      shelves: [] as ShelfWithBooks[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    shelves: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取单个书架
 */
export function useShelf(shelfId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { data, isLoading, error } = useQuery<Shelf>(
    shelfId ? 'SELECT * FROM shelves WHERE id = ?' : 'SELECT * FROM shelves WHERE 1=0',
    shelfId ? [shelfId] : []
  )

  if (!isAppFirstEnabled || !db || !shelfId) {
    return {
      shelf: null,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    shelf: data?.[0] ?? null,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取书架中的书籍 ID 列表
 */
export function useShelfBookIds(shelfId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const sql = shelfId
    ? 'SELECT book_id FROM shelf_books WHERE shelf_id = ? ORDER BY sort_order ASC'
    : 'SELECT book_id FROM shelf_books WHERE 1=0'

  const { data, isLoading, error } = useQuery<{ book_id: string }>(
    sql,
    shelfId ? [shelfId] : []
  )

  const bookIds = useMemo(() => data?.map(row => row.book_id) ?? [], [data])

  if (!isAppFirstEnabled || !db || !shelfId) {
    return {
      bookIds: [] as string[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    bookIds,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取书籍所属的书架列表
 */
export function useBookShelves(bookId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const sql = bookId
    ? `
      SELECT s.*
      FROM shelves s
      INNER JOIN shelf_books sb ON s.id = sb.shelf_id
      WHERE sb.book_id = ? AND s.deleted_at IS NULL
      ORDER BY s.name ASC
    `
    : 'SELECT * FROM shelves WHERE 1=0'

  const { data, isLoading, error } = useQuery<Shelf>(sql, bookId ? [bookId] : [])

  if (!isAppFirstEnabled || !db || !bookId) {
    return {
      shelves: [] as Shelf[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    shelves: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 书架写入操作
 */
export function useShelfMutations() {
  const db = usePowerSyncDatabase()
  const isAppFirstEnabled = useIsAppFirstEnabled()

  const addShelf = async (shelf: { name: string; description?: string; color?: string; icon?: string }) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const id = generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id - 从 AuthStore 获取
    const userId = useAuthStore.getState().user?.id || ''

    // 获取最大排序值 - 使用 getAll 避免空结果异常
    const maxOrderRows = await db.getAll<{ max_order: number }>(
      'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelves'
    )
    const maxOrder = maxOrderRows[0]?.max_order ?? 0

    await db.execute(
      `INSERT INTO shelves (id, user_id, name, description, color, icon, sort_order, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        shelf.name,
        shelf.description ?? null,
        shelf.color ?? null,
        shelf.icon ?? null,
        maxOrder + 1,
        now,
        now
      ]
    )

    return id
  }

  const updateShelf = async (id: string, updates: Partial<Omit<Shelf, 'id' | 'created_at'>>) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const fields = Object.keys(updates).filter(k => k !== 'id' && k !== 'created_at')
    if (fields.length === 0) return

    const setClause = fields.map(f => `${f} = ?`).join(', ')
    const values = fields.map(f => updates[f as keyof typeof updates])
    values.push(new Date().toISOString()) // updated_at
    values.push(id)

    await db.execute(
      `UPDATE shelves SET ${setClause}, updated_at = ? WHERE id = ?`,
      values
    )
  }

  const deleteShelf = async (id: string, soft = true) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    if (soft) {
      await db.execute(
        'UPDATE shelves SET deleted_at = ?, updated_at = ? WHERE id = ?',
        [new Date().toISOString(), new Date().toISOString(), id]
      )
    } else {
      // 先删除书架-书籍关联
      await db.execute('DELETE FROM shelf_books WHERE shelf_id = ?', [id])
      await db.execute('DELETE FROM shelves WHERE id = ?', [id])
    }
  }

  const addBookToShelf = async (shelfId: string, bookId: string) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    // 获取当前用户 ID
    const userId = useAuthStore.getState().user?.id
    if (!userId) {
      throw new Error('User not authenticated')
    }

    // 检查是否已存在 - 使用 getAll 避免空结果异常
    const existingRows = await db.getAll<{ id: string }>(
      'SELECT id FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
      [shelfId, bookId]
    )

    if (existingRows.length > 0) return existingRows[0].id

    const id = generateUUID()
    const now = new Date().toISOString()

    // 获取最大排序值 - 使用 getAll 避免空结果异常
    const maxOrderRows = await db.getAll<{ max_order: number }>(
      'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelf_books WHERE shelf_id = ?',
      [shelfId]
    )
    const maxOrder = maxOrderRows[0]?.max_order ?? 0

    await db.execute(
      `INSERT INTO shelf_books (id, user_id, shelf_id, book_id, sort_order, added_at)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [id, userId, shelfId, bookId, maxOrder + 1, now]
    )

    return id
  }

  const removeBookFromShelf = async (shelfId: string, bookId: string) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    await db.execute(
      'DELETE FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
      [shelfId, bookId]
    )
  }

  return {
    addShelf,
    updateShelf,
    deleteShelf,
    addBookToShelf,
    removeBookFromShelf,
    isAvailable: isAppFirstEnabled && !!db
  }
}


==================================================
FILE_PATH: web/src/lib/powersync/hooks/index.ts
==================================================

/**
 * PowerSync Hooks 统一导出
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

// Books
export {
  useBooks,
  useBook,
  useBookCount,
  useBookMutations,
  type Book,
  type UseBookOptions
} from './useBooks'

// Notes
export {
  useNotes,
  useNote,
  useNoteCount,
  useNoteMutations,
  type Note,
  type UseNotesOptions
} from './useNotes'

// Highlights
export {
  useHighlights,
  useHighlight,
  useHighlightCount,
  useHighlightMutations,
  type Highlight,
  type UseHighlightsOptions
} from './useHighlights'

// Reading Progress
export {
  useReadingProgress,
  useAllReadingProgress,
  useRecentlyReadBooks,
  useReadingProgressMutations,
  type ReadingProgress
} from './useReadingProgress'

// Shelves
export {
  useShelves,
  useShelvesWithBookCount,
  useShelf,
  useShelfBookIds,
  useBookShelves,
  useShelfMutations,
  type Shelf,
  type ShelfBook,
  type ShelfWithBooks
} from './useShelves'


==================================================
FILE_PATH: web/src/lib/powersync/hooks/useHighlights.ts
==================================================

/**
 * useHighlights - 高亮 Live Query Hook
 *
 * 提供实时响应式的高亮数据查询
 * 支持 PowerSync (App-First) 和 Dexie (Legacy) 双模式
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

import { useMemo } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, useIsAppFirstEnabled } from '../PowerSyncProvider'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

export interface Highlight {
  id: string
  book_id: string
  chapter_index: number | null
  cfi_range: string
  page_number: number | null
  text_content: string
  color: string
  note: string | null
  created_at: string
  updated_at: string
  deleted_at: string | null
}

export interface UseHighlightsOptions {
  /** 按书籍 ID 筛选 */
  bookId?: string
  /** 按章节筛选 */
  chapterIndex?: number
  /** 按颜色筛选 */
  color?: string
  /** 是否包含已删除的高亮 */
  includeDeleted?: boolean
  /** 排序字段 */
  orderBy?: 'created_at' | 'updated_at' | 'page_number'
  /** 排序方向 */
  orderDirection?: 'asc' | 'desc'
  /** 限制数量 */
  limit?: number
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取高亮列表
 */
export function useHighlights(options: UseHighlightsOptions = {}) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const {
    bookId,
    chapterIndex,
    color,
    includeDeleted = false,
    orderBy = 'created_at',
    orderDirection = 'desc',
    limit
  } = options

  // 构建 SQL 查询
  const { sql, params } = useMemo(() => {
    let query = 'SELECT * FROM highlights'
    const conditions: string[] = []
    const queryParams: (string | number)[] = []

    if (!includeDeleted) {
      conditions.push('deleted_at IS NULL')
    }

    if (bookId) {
      conditions.push('book_id = ?')
      queryParams.push(bookId)
    }

    if (chapterIndex !== undefined) {
      conditions.push('chapter_index = ?')
      queryParams.push(chapterIndex)
    }

    if (color) {
      conditions.push('color = ?')
      queryParams.push(color)
    }

    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ')
    }

    query += ` ORDER BY ${orderBy} ${orderDirection.toUpperCase()}`

    if (limit) {
      query += ` LIMIT ${limit}`
    }

    return { sql: query, params: queryParams }
  }, [bookId, chapterIndex, color, includeDeleted, orderBy, orderDirection, limit])

  // PowerSync Live Query
  const { data, isLoading, error } = useQuery<Highlight>(sql, params)

  if (!isAppFirstEnabled || !db) {
    return {
      highlights: [] as Highlight[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    highlights: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取单条高亮
 */
export function useHighlight(highlightId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { data, isLoading, error } = useQuery<Highlight>(
    highlightId ? 'SELECT * FROM highlights WHERE id = ?' : 'SELECT * FROM highlights WHERE 1=0',
    highlightId ? [highlightId] : []
  )

  if (!isAppFirstEnabled || !db || !highlightId) {
    return {
      highlight: null,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    highlight: data?.[0] ?? null,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取书籍的高亮数量
 */
export function useHighlightCount(bookId?: string) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const sql = bookId
    ? 'SELECT COUNT(*) as count FROM highlights WHERE book_id = ? AND deleted_at IS NULL'
    : 'SELECT COUNT(*) as count FROM highlights WHERE deleted_at IS NULL'

  const params = bookId ? [bookId] : []

  const { data, isLoading, error } = useQuery<{ count: number }>(sql, params)

  if (!isAppFirstEnabled || !db) {
    return {
      count: 0,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    count: data?.[0]?.count ?? 0,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 高亮写入操作
 */
export function useHighlightMutations() {
  const db = usePowerSyncDatabase()
  const isAppFirstEnabled = useIsAppFirstEnabled()

  const addHighlight = async (highlight: Omit<Highlight, 'id' | 'created_at' | 'updated_at' | 'deleted_at'> & { id?: string }) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const id = highlight.id || generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id 和 device_id - 从 AuthStore 和 localStorage 获取
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()

    await db.execute(
      `INSERT INTO highlights (id, user_id, device_id, book_id, chapter_index, cfi_range, page_number, text_content, color, note, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        deviceId,
        highlight.book_id,
        highlight.chapter_index,
        highlight.cfi_range,
        highlight.page_number,
        highlight.text_content,
        highlight.color,
        highlight.note,
        now,
        now
      ]
    )

    return id
  }

  const updateHighlight = async (id: string, updates: Partial<Highlight>) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const fields = Object.keys(updates).filter(k => k !== 'id' && k !== 'created_at')
    if (fields.length === 0) return

    const setClause = fields.map(f => `${f} = ?`).join(', ')
    const values = fields.map(f => updates[f as keyof Highlight])
    values.push(new Date().toISOString()) // updated_at
    values.push(id)

    await db.execute(
      `UPDATE highlights SET ${setClause}, updated_at = ? WHERE id = ?`,
      values
    )
  }

  const deleteHighlight = async (id: string, soft = true) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    if (soft) {
      await db.execute(
        'UPDATE highlights SET deleted_at = ?, updated_at = ? WHERE id = ?',
        [new Date().toISOString(), new Date().toISOString(), id]
      )
    } else {
      await db.execute('DELETE FROM highlights WHERE id = ?', [id])
    }
  }

  return {
    addHighlight,
    updateHighlight,
    deleteHighlight,
    isAvailable: isAppFirstEnabled && !!db
  }
}


==================================================
FILE_PATH: web/src/lib/powersync/hooks/useReadingProgress.ts
==================================================

/**
 * useReadingProgress - 阅读进度 Live Query Hook
 *
 * ⚠️ 字段名必须与 PostgreSQL / PowerSync Schema 完全一致！
 * 
 * PostgreSQL reading_progress 表字段：
 * - id, user_id, book_id, device_id
 * - progress (REAL 0-1)
 * - last_position (TEXT) - CFI 字符串
 * - last_location (TEXT JSON) - { currentPage, totalPages }
 * - finished_at (TIMESTAMPTZ)
 * - updated_at (TIMESTAMPTZ)
 *
 * @see docker/powersync/sync_rules.yaml
 * @see web/src/lib/powersync/schema.ts
 */

import { useMemo } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, useIsAppFirstEnabled } from '../PowerSyncProvider'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义 - 与 PostgreSQL 完全一致
// ============================================================================

/**
 * reading_progress 表行结构
 * 字段名与 PostgreSQL 完全一致
 */
export interface ReadingProgressRow {
  id: string
  user_id: string
  book_id: string
  device_id: string | null
  progress: number              // REAL 0-1
  last_position: string | null  // CFI 字符串
  last_location: string | null  // JSON: { currentPage, totalPages }
  finished_at: string | null
  updated_at: string
}

// 向后兼容的别名
export type ReadingProgress = ReadingProgressRow

/**
 * 解析 last_location JSON
 */
function parseLastLocation(json: string | null): { currentPage?: number; totalPages?: number } {
  if (!json) return {}
  try {
    const parsed = JSON.parse(json)
    return {
      currentPage: typeof parsed.currentPage === 'number' ? parsed.currentPage : undefined,
      totalPages: typeof parsed.totalPages === 'number' ? parsed.totalPages : undefined,
    }
  } catch {
    return {}
  }
}

/**
 * 构建 last_location JSON
 */
function buildLastLocation(currentPage?: number | null, totalPages?: number | null, existing?: string | null): string {
  const current = parseLastLocation(existing ?? null)
  return JSON.stringify({
    currentPage: currentPage ?? current.currentPage,
    totalPages: totalPages ?? current.totalPages,
  })
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取书籍的阅读进度
 */
export function useReadingProgress(bookId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { data, isLoading, error } = useQuery<ReadingProgress>(
    bookId
      ? 'SELECT * FROM reading_progress WHERE book_id = ? ORDER BY updated_at DESC LIMIT 1'
      : 'SELECT * FROM reading_progress WHERE 1=0',
    bookId ? [bookId] : []
  )

  if (!isAppFirstEnabled || !db || !bookId) {
    return {
      progress: null,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    progress: data?.[0] ?? null,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取所有阅读进度（用于首页展示最近阅读）
 * 使用正确字段名: progress, updated_at
 */
export function useAllReadingProgress(options: { limit?: number; orderBy?: 'updated_at' | 'progress' } = {}) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { limit = 10, orderBy = 'updated_at' } = options

  const sql = useMemo(() => {
    return `SELECT * FROM reading_progress ORDER BY ${orderBy} DESC LIMIT ${limit}`
  }, [orderBy, limit])

  const { data, isLoading, error } = useQuery<ReadingProgress>(sql, [])

  if (!isAppFirstEnabled || !db) {
    return {
      progressList: [] as ReadingProgress[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    progressList: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取最近阅读的书籍（带书籍信息）
 * 使用正确字段名: progress, last_location, updated_at
 */
export function useRecentlyReadBooks(limit = 5) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  // 使用与 PostgreSQL 一致的字段名
  const sql = `
    SELECT b.*, rp.progress, rp.last_location, rp.updated_at
    FROM reading_progress rp
    INNER JOIN books b ON rp.book_id = b.id
    WHERE b.deleted_at IS NULL
    ORDER BY rp.updated_at DESC
    LIMIT ?
  `

  interface RecentBook {
    id: string
    title: string
    author: string | null
    cover_url: string | null
    progress: number
    last_location: string | null
    updated_at: string
  }

  const { data, isLoading, error } = useQuery<RecentBook>(sql, [limit])

  if (!isAppFirstEnabled || !db) {
    return {
      recentBooks: [] as RecentBook[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    recentBooks: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 阅读进度写入操作
 * 使用与 PostgreSQL 一致的字段名: progress, last_position, last_location, updated_at
 */
export function useReadingProgressMutations() {
  const db = usePowerSyncDatabase()
  const isAppFirstEnabled = useIsAppFirstEnabled()

  /**
   * 更新阅读进度
   * 业务层参数会映射到 PostgreSQL 字段名
   */
  const updateProgress = async (
    bookId: string,
    updates: {
      currentCfi?: string | null      // → last_position
      currentPage?: number | null     // → last_location.currentPage
      totalPages?: number | null      // → last_location.totalPages
      percentage?: number             // → progress
    }
  ) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const now = new Date().toISOString()
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()

    // 检查是否已存在进度记录 - 使用 book_id + user_id 匹配
    const existingRows = await db.getAll<{ id: string; last_location: string | null }>(
      'SELECT id, last_location FROM reading_progress WHERE book_id = ? AND user_id = ?',
      [bookId, userId]
    )
    const existing = existingRows[0]

    if (existing) {
      // 更新现有记录 - 使用 book_id + user_id 匹配
      const fields: string[] = []
      const values: (string | number | null)[] = []

      if (updates.currentCfi !== undefined) {
        fields.push('last_position = ?')  // 不是 current_cfi
        values.push(updates.currentCfi)
      }
      if (updates.currentPage !== undefined || updates.totalPages !== undefined) {
        fields.push('last_location = ?')  // 不是 current_page/total_pages
        values.push(buildLastLocation(updates.currentPage, updates.totalPages, existing.last_location))
      }
      if (updates.percentage !== undefined) {
        fields.push('progress = ?')  // 不是 percentage
        // 强制归一化：如果传入 > 1 的数（如25），除以100；如果是 0-1，保持不变
        const normalizedProgress = updates.percentage > 1 ? updates.percentage / 100 : updates.percentage
        values.push(normalizedProgress)
      }

      fields.push('updated_at = ?')  // 不是 last_read_at
      values.push(now)
      values.push(bookId)
      values.push(userId)

      await db.execute(
        `UPDATE reading_progress SET ${fields.join(', ')} WHERE book_id = ? AND user_id = ?`,
        values
      )

      return existing.id
    } else {
      // 创建新记录 - 使用 PostgreSQL 字段名
      const id = generateUUID()
      
      // 归一化进度值
      const rawProgress = updates.percentage ?? 0
      const normalizedProgress = rawProgress > 1 ? rawProgress / 100 : rawProgress

      await db.execute(
        `INSERT INTO reading_progress (id, user_id, device_id, book_id, last_position, last_location, progress, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          userId,
          deviceId,
          bookId,
          updates.currentCfi ?? null,
          buildLastLocation(updates.currentPage, updates.totalPages, null),
          normalizedProgress,
          now
        ]
      )

      return id
    }
  }

  /**
   * 标记书籍已读完
   * 修复：使用 book_id + user_id 进行匹配，而不是 id
   */
  const markAsFinished = async (bookId: string) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const now = new Date().toISOString()
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()

    // 先查询是否存在记录 - 使用 book_id + user_id 匹配
    const existingRows = await db.getAll<{ id: string }>(
      'SELECT id FROM reading_progress WHERE book_id = ? AND user_id = ?',
      [bookId, userId]
    )
    const existing = existingRows[0]

    if (existing) {
      // 更新现有记录 - 使用 book_id + user_id 匹配
      await db.execute(
        'UPDATE reading_progress SET progress = 1.0, finished_at = ?, updated_at = ? WHERE book_id = ? AND user_id = ?',
        [now, now, bookId, userId]
      )
      return existing.id
    } else {
      // 插入新记录
      const id = generateUUID()

      await db.execute(
        `INSERT INTO reading_progress (id, user_id, device_id, book_id, progress, finished_at, updated_at)
         VALUES (?, ?, ?, ?, 1.0, ?, ?)`,
        [id, userId, deviceId, bookId, now, now]
      )
      return id
    }
  }

  const deleteProgress = async (bookId: string) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    await db.execute('DELETE FROM reading_progress WHERE book_id = ?', [bookId])
  }

  return {
    updateProgress,
    deleteProgress,
    isAvailable: isAppFirstEnabled && !!db
  }
}


==================================================
FILE_PATH: web/src/lib/powersync/hooks/useBooks.ts
==================================================

/**
 * useBooks - 书籍 Live Query Hook
 *
 * 提供实时响应式的书籍数据查询
 * 支持 PowerSync (App-First) 和 Dexie (Legacy) 双模式
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 2
 */

import { useMemo } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, useIsAppFirstEnabled } from '../PowerSyncProvider'
import { useAuthStore } from '@/stores/auth'
import { generateUUID } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

/**
 * books 表结构 - 与 PostgreSQL/PowerSync Schema 完全一致
 * @see docker/powersync/sync_rules.yaml
 * @see web/src/lib/powersync/schema.ts
 */
export interface Book {
  id: string
  user_id: string
  title: string
  author: string | null
  cover_url: string | null        // 不是 cover_path
  file_type: string | null        // 不是 format
  file_size: number | null
  content_sha256: string | null   // 不是 file_hash
  storage_key: string | null      // 不是 file_path
  metadata_confirmed: number | null
  is_digitalized: number | null
  initial_digitalization_confidence: number | null
  page_count: number | null       // 不是 total_pages
  ocr_status: string | null
  conversion_status: string | null
  converted_epub_key: string | null
  created_at: string
  updated_at: string
  deleted_at: string | null
}

export interface UseBookOptions {
  /** 是否包含已删除的书籍 */
  includeDeleted?: boolean
  /** 排序字段 */
  orderBy?: 'title' | 'author' | 'created_at' | 'updated_at'
  /** 排序方向 */
  orderDirection?: 'asc' | 'desc'
  /** 搜索关键词 */
  search?: string
  /** 限制数量 */
  limit?: number
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取所有书籍列表
 */
export function useBooks(options: UseBookOptions = {}) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const {
    includeDeleted = false,
    orderBy = 'updated_at',
    orderDirection = 'desc',
    search,
    limit
  } = options

  // 构建 SQL 查询
  const sql = useMemo(() => {
    let query = 'SELECT * FROM books'
    const conditions: string[] = []

    if (!includeDeleted) {
      conditions.push('deleted_at IS NULL')
    }

    if (search) {
      conditions.push("(title LIKE ? OR author LIKE ?)")
    }

    if (conditions.length > 0) {
      query += ' WHERE ' + conditions.join(' AND ')
    }

    query += ` ORDER BY ${orderBy} ${orderDirection.toUpperCase()}`

    if (limit) {
      query += ` LIMIT ${limit}`
    }

    return query
  }, [includeDeleted, search, orderBy, orderDirection, limit])

  // 构建参数
  const params = useMemo(() => {
    if (search) {
      const searchPattern = `%${search}%`
      return [searchPattern, searchPattern]
    }
    return []
  }, [search])

  // PowerSync Live Query
  const { data, isLoading, error } = useQuery<Book>(sql, params)

  // 如果 App-First 未启用，返回空数据（Dexie fallback 由上层处理）
  if (!isAppFirstEnabled || !db) {
    return {
      books: [] as Book[],
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    books: data ?? [],
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取单本书籍
 */
export function useBook(bookId: string | null) {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { data, isLoading, error } = useQuery<Book>(
    bookId ? 'SELECT * FROM books WHERE id = ?' : 'SELECT * FROM books WHERE 1=0',
    bookId ? [bookId] : []
  )

  if (!isAppFirstEnabled || !db || !bookId) {
    return {
      book: null,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    book: data?.[0] ?? null,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 获取书籍数量
 */
export function useBookCount() {
  const isAppFirstEnabled = useIsAppFirstEnabled()
  const db = usePowerSyncDatabase()

  const { data, isLoading, error } = useQuery<{ count: number }>(
    'SELECT COUNT(*) as count FROM books WHERE deleted_at IS NULL',
    []
  )

  if (!isAppFirstEnabled || !db) {
    return {
      count: 0,
      isLoading: false,
      error: null,
      isAppFirstEnabled: false
    }
  }

  return {
    count: data?.[0]?.count ?? 0,
    isLoading,
    error,
    isAppFirstEnabled: true
  }
}

/**
 * 书籍写入操作（需要在组件中使用）
 */
export function useBookMutations() {
  const db = usePowerSyncDatabase()
  const isAppFirstEnabled = useIsAppFirstEnabled()

  /**
   * 添加书籍 - 使用与 PostgreSQL 一致的字段名
   */
  const addBook = async (book: Partial<Book> & { title: string }) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const id = book.id || generateUUID()
    const now = new Date().toISOString()
    const userId = useAuthStore.getState().user?.id || ''

    await db.execute(
      `INSERT INTO books (id, user_id, title, author, cover_url, file_type, file_size, content_sha256, storage_key, page_count, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        book.title,
        book.author ?? null,
        book.cover_url ?? null,
        book.file_type ?? null,
        book.file_size ?? null,
        book.content_sha256 ?? null,
        book.storage_key ?? null,
        book.page_count ?? null,
        now,
        now
      ]
    )

    return id
  }

  const updateBook = async (id: string, updates: Partial<Book>) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    const fields = Object.keys(updates).filter(k => k !== 'id' && k !== 'created_at')
    if (fields.length === 0) return

    const setClause = fields.map(f => `${f} = ?`).join(', ')
    const values = fields.map(f => updates[f as keyof Book])
    values.push(new Date().toISOString()) // updated_at
    values.push(id)

    await db.execute(
      `UPDATE books SET ${setClause}, updated_at = ? WHERE id = ?`,
      values
    )
  }

  const deleteBook = async (id: string, soft = true) => {
    if (!db || !isAppFirstEnabled) {
      throw new Error('PowerSync not available')
    }

    if (soft) {
      await db.execute(
        'UPDATE books SET deleted_at = ?, updated_at = ? WHERE id = ?',
        [new Date().toISOString(), new Date().toISOString(), id]
      )
    } else {
      await db.execute('DELETE FROM books WHERE id = ?', [id])
    }
  }

  return {
    addBook,
    updateBook,
    deleteBook,
    isAvailable: isAppFirstEnabled && !!db
  }
}


==================================================
FILE_PATH: web/src/config/featureFlags.ts
==================================================

/**
 * featureFlags.ts - 功能开关配置 (App-First 版本)
 *
 * App-First 架构已完全启用，此文件仅保留调试相关功能
 *
 * @see 09 - APP-FIRST架构改造计划.md
 * @version 2.0.0 - App-First 完全体
 */

// ============ 环境变量读取 ============

/**
 * 从环境变量读取布尔值
 */
function getEnvBoolean(key: string, defaultValue: boolean): boolean {
  const value = import.meta.env[key]
  if (value === undefined || value === null || value === '') {
    return defaultValue
  }
  return ['true', '1', 'yes'].includes(String(value).toLowerCase())
}

/**
 * 从 localStorage 读取覆盖值（用于 QA 调试）
 */
function getLocalStorageOverride(key: string): boolean | null {
  if (typeof window === 'undefined') return null
  const value = localStorage.getItem(key)
  if (value === null) return null
  return ['true', '1', 'yes'].includes(value.toLowerCase())
}

// ============ Feature Flags 定义 ============

/**
 * Feature Flag 配置接口
 */
export interface FeatureFlags {
  /**
   * PowerSync 调试模式
   * - 开启后会在控制台输出详细的同步日志
   * @default false (生产环境), true (开发环境)
   */
  POWERSYNC_DEBUG: boolean

  /**
   * 实验性功能：离线 AI 摘要
   * @default false
   */
  OFFLINE_AI_ENABLED: boolean
}

/**
 * Feature Flags 单例
 */
class FeatureFlagsManager {
  private static instance: FeatureFlagsManager
  private flags: FeatureFlags

  private constructor() {
    this.flags = this.loadFlags()
  }

  static getInstance(): FeatureFlagsManager {
    if (!FeatureFlagsManager.instance) {
      FeatureFlagsManager.instance = new FeatureFlagsManager()
    }
    return FeatureFlagsManager.instance
  }

  private loadFlags(): FeatureFlags {
    return {
      // 开发环境默认开启调试
      POWERSYNC_DEBUG:
        getLocalStorageOverride('ATHENA_POWERSYNC_DEBUG') ??
        getEnvBoolean('VITE_POWERSYNC_DEBUG', import.meta.env.DEV),

      // 实验性功能默认关闭
      OFFLINE_AI_ENABLED:
        getLocalStorageOverride('ATHENA_OFFLINE_AI_ENABLED') ??
        getEnvBoolean('VITE_OFFLINE_AI_ENABLED', false),
    }
  }

  /**
   * 获取所有 Feature Flags
   */
  getFlags(): Readonly<FeatureFlags> {
    return Object.freeze({ ...this.flags })
  }

  /**
   * 获取单个 Flag 值
   */
  getFlag<K extends keyof FeatureFlags>(key: K): FeatureFlags[K] {
    return this.flags[key]
  }

  /**
   * 设置 localStorage 覆盖（仅用于 QA 调试）
   */
  setOverride<K extends keyof FeatureFlags>(key: K, value: FeatureFlags[K]): void {
    if (typeof window === 'undefined') return
    const storageKey = `ATHENA_${key}`
    localStorage.setItem(storageKey, String(value))
    this.flags[key] = value
    console.log(`[FeatureFlags] ${key} overridden to ${value}`)
  }

  /**
   * 清除 localStorage 覆盖
   */
  clearOverride<K extends keyof FeatureFlags>(key: K): void {
    if (typeof window === 'undefined') return
    const storageKey = `ATHENA_${key}`
    localStorage.removeItem(storageKey)
    this.flags = this.loadFlags()
    console.log(`[FeatureFlags] ${key} override cleared`)
  }

  /**
   * 打印当前 Feature Flags 状态（调试用）
   */
  logStatus(): void {
    console.group('[FeatureFlags] Current Status')
    console.log('Architecture: App-First (PowerSync + SQLite)')
    console.log('POWERSYNC_DEBUG:', this.flags.POWERSYNC_DEBUG)
    console.log('OFFLINE_AI_ENABLED:', this.flags.OFFLINE_AI_ENABLED)
    console.groupEnd()
  }
}

// ============ 导出 ============

/**
 * Feature Flags 管理器实例
 */
export const featureFlags = FeatureFlagsManager.getInstance()

/**
 * 便捷访问当前 Flags
 */
export const flags = featureFlags.getFlags()

// 开发环境下在控制台输出状态
if (import.meta.env.DEV) {
  setTimeout(() => {
    featureFlags.logStatus()
  }, 100)
}

// 暴露到 window 对象供 QA 调试
if (typeof window !== 'undefined') {
  // @ts-expect-error - 调试用全局变量
  window.__ATHENA_FEATURE_FLAGS__ = featureFlags
}


==================================================
FILE_PATH: web/src/config/index.ts
==================================================

/**
 * config/index.ts - 配置模块统一导出
 * 
 * @see 09 - APP-FIRST架构改造计划.md
 * @ai-generated Claude Opus 4.5 (2025-12-13)
 */

export * from './featureFlags'


==================================================
FILE_PATH: web/src/__tests__/smoke.test.ts
==================================================

import { describe, it, expect } from 'vitest'

describe('smoke', () => {
  it('adds', () => {
    expect(1 + 1).toBe(2)
  })
})

==================================================
FILE_PATH: web/src/dev/seeder.ts
==================================================

/**
 * seeder.ts - 开发环境数据填充脚本 (PowerSync 版)
 * 
 * 用于本地开发测试时快速填充测试数据
 * 使用 PowerSync SQLite 作为数据存储
 * 
 * @see 09 - APP-FIRST架构改造计划.md
 * @warning 仅限开发环境使用！
 */

import { getDeviceId } from '@/lib/utils'

// 注意: 这些函数需要在 PowerSync 初始化后调用
// 通过参数传入 db 实例而非直接导入

/**
 * 生成 UUID
 */
function generateId(): string {
  return crypto.randomUUID()
}

/**
 * 填充测试数据
 * 
 * 功能:
 * 1. 清理数据库
 * 2. 预置测试书籍
 * 3. 预置阅读进度
 * 
 * @param db - PowerSync 数据库实例
 * @returns 填充结果
 */
export async function seedTestData(db: any): Promise<{
  success: boolean
  message: string
  data?: {
    bookId: string
    bookTitle: string
  }
}> {
  if (!db) {
    return {
      success: false,
      message: 'PowerSync 数据库未初始化'
    }
  }

  console.log('[Seeder] 🌱 开始填充测试数据...')

  try {
    const now = new Date().toISOString()
    const deviceId = getDeviceId()

    // 1. 清理数据库
    console.log('[Seeder] 🧹 清理现有数据...')
    await db.execute('DELETE FROM books')
    await db.execute('DELETE FROM reading_progress')
    await db.execute('DELETE FROM notes')
    await db.execute('DELETE FROM highlights')
    console.log('[Seeder] ✅ 数据库已清空')

    // 2. 预置测试书籍
    const testBookId = generateId()
    await db.execute(
      `INSERT INTO books (id, user_id, title, author, file_type, file_size, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        testBookId,
        'test-user-id', // 将被 PowerSync RLS 覆盖
        'Offline First 实战指南',
        '雅典娜团队',
        'epub',
        5 * 1024 * 1024, // 5MB
        now,
        now,
      ]
    )
    console.log(`[Seeder] 📚 已创建测试书籍 (ID: ${testBookId})`)

    // 3. 预置阅读进度
    const progressId = generateId()
    await db.execute(
      `INSERT INTO reading_progress (id, user_id, book_id, device_id, progress, last_position, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        progressId,
        'test-user-id',
        testBookId,
        deviceId,
        0.25,
        JSON.stringify({ cfi: 'epubcfi(/6/4!/4/2/1:0)', pageNumber: 1 }),
        now,
      ]
    )
    console.log(`[Seeder] 📖 已创建阅读进度: 25%`)

    // 4. 预置一条测试笔记
    const noteId = generateId()
    await db.execute(
      `INSERT INTO notes (id, user_id, book_id, device_id, content, position_cfi, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        noteId,
        'test-user-id',
        testBookId,
        deviceId,
        '这是一条测试笔记，用于验证 App-First 架构是否正常工作。',
        'epubcfi(/6/4!/4/2/1:50)',
        now,
        now,
      ]
    )
    console.log(`[Seeder] 📝 已创建测试笔记 (ID: ${noteId})`)

    console.log('[Seeder] ✅ 测试数据填充完毕!')
    console.log('[Seeder] 📊 数据概览:')
    console.log(`   - 书籍: 1 本`)
    console.log(`   - 阅读进度: 1 条`)
    console.log(`   - 笔记: 1 条`)

    return {
      success: true,
      message: '测试数据填充成功',
      data: {
        bookId: testBookId,
        bookTitle: 'Offline First 实战指南',
      }
    }
  } catch (error) {
    console.error('[Seeder] ❌ 填充失败:', error)
    return {
      success: false,
      message: error instanceof Error ? error.message : '未知错误',
    }
  }
}

/**
 * 清空所有测试数据
 * @param db - PowerSync 数据库实例
 */
export async function clearTestData(db: any): Promise<{ success: boolean; message: string }> {
  if (!db) {
    return { success: false, message: 'PowerSync 数据库未初始化' }
  }

  console.log('[Seeder] 🧹 清空测试数据...')

  try {
    await db.execute('DELETE FROM books')
    await db.execute('DELETE FROM reading_progress')
    await db.execute('DELETE FROM notes')
    await db.execute('DELETE FROM highlights')

    console.log('[Seeder] ✅ 测试数据已清空')
    return { success: true, message: '数据已清空' }
  } catch (error) {
    console.error('[Seeder] ❌ 清空失败:', error)
    return { success: false, message: error instanceof Error ? error.message : '未知错误' }
  }
}

/**
 * 获取数据库统计信息
 * @param db - PowerSync 数据库实例
 */
export async function getDatabaseStats(db: any): Promise<{
  books: number
  progress: number
  notes: number
  highlights: number
}> {
  if (!db) {
    return { books: 0, progress: 0, notes: 0, highlights: 0 }
  }

  try {
    const booksResult = await db.get('SELECT COUNT(*) as count FROM books')
    const progressResult = await db.get('SELECT COUNT(*) as count FROM reading_progress')
    const notesResult = await db.get('SELECT COUNT(*) as count FROM notes')
    const highlightsResult = await db.get('SELECT COUNT(*) as count FROM highlights')

    return {
      books: (booksResult as any)?.count ?? 0,
      progress: (progressResult as any)?.count ?? 0,
      notes: (notesResult as any)?.count ?? 0,
      highlights: (highlightsResult as any)?.count ?? 0,
    }
  } catch (error) {
    console.error('[Seeder] 获取统计失败:', error)
    return { books: 0, progress: 0, notes: 0, highlights: 0 }
  }
}


==================================================
FILE_PATH: web/src/contexts/NoteConflictContext.tsx
==================================================

/**
 * NoteConflictContext.tsx
 * 
 * 笔记冲突全局管理 Context
 * 
 * 功能:
 * - 全局监听笔记冲突事件
 * - 显示冲突解决对话框
 * - 冲突队列管理（多个冲突依次处理）
 * 
 * @see NoteConflictDialog - 冲突解决对话框组件
 * @see useSmartHeartbeat - 心跳同步中的冲突检测
 */

import { createContext, useContext, useState, useCallback, useEffect, type ReactNode } from 'react'
import { NoteConflictDialog, type ConflictNote, type OriginalNote } from '@/components/NoteConflictDialog'

interface ConflictItem {
  bookId: string
  conflictNote: ConflictNote
  originalNote: OriginalNote
}

interface NoteConflictContextValue {
  /** 添加冲突到队列 */
  addConflict: (item: ConflictItem) => void
  /** 当前待处理的冲突数量 */
  conflictCount: number
  /** 清空所有冲突 */
  clearConflicts: () => void
}

const NoteConflictContext = createContext<NoteConflictContextValue | null>(null)

export function useNoteConflict(): NoteConflictContextValue {
  const context = useContext(NoteConflictContext)
  if (!context) {
    throw new Error('useNoteConflict must be used within NoteConflictProvider')
  }
  return context
}

interface NoteConflictProviderProps {
  children: ReactNode
}

export function NoteConflictProvider({ children }: NoteConflictProviderProps) {
  // 冲突队列
  const [conflictQueue, setConflictQueue] = useState<ConflictItem[]>([])
  // 当前正在处理的冲突
  const [currentConflict, setCurrentConflict] = useState<ConflictItem | null>(null)
  // 对话框是否打开
  const [dialogOpen, setDialogOpen] = useState(false)

  // 添加冲突到队列
  const addConflict = useCallback((item: ConflictItem) => {
    setConflictQueue(prev => {
      // 避免重复添加同一个冲突
      const exists = prev.some(c => c.conflictNote.id === item.conflictNote.id)
      if (exists) return prev
      return [...prev, item]
    })
  }, [])

  // 清空所有冲突
  const clearConflicts = useCallback(() => {
    setConflictQueue([])
    setCurrentConflict(null)
    setDialogOpen(false)
  }, [])

  // 处理队列中的下一个冲突
  const processNextConflict = useCallback(() => {
    if (conflictQueue.length > 0) {
      const [next, ...rest] = conflictQueue
      setCurrentConflict(next)
      setConflictQueue(rest)
      setDialogOpen(true)
    } else {
      setCurrentConflict(null)
      setDialogOpen(false)
    }
  }, [conflictQueue])

  // 当队列有新冲突且没有正在处理的冲突时，开始处理
  useEffect(() => {
    if (!currentConflict && conflictQueue.length > 0) {
      processNextConflict()
    }
  }, [currentConflict, conflictQueue.length, processNextConflict])

  // 冲突解决后的回调
  const handleResolved = useCallback((resolution: 'keep_original' | 'keep_conflict' | 'keep_both') => {
    console.log('[NoteConflictContext] Conflict resolved:', resolution)
    // 处理下一个冲突
    processNextConflict()
  }, [processNextConflict])

  // 对话框关闭回调（用户可能点击了关闭按钮）
  const handleOpenChange = useCallback((open: boolean) => {
    if (!open) {
      // 用户关闭对话框，跳过当前冲突，处理下一个
      processNextConflict()
    }
  }, [processNextConflict])

  // 监听全局冲突事件（由 useSmartHeartbeat 触发）
  useEffect(() => {
    const handleConflictEvent = (event: CustomEvent<ConflictItem>) => {
      addConflict(event.detail)
    }

    window.addEventListener('note-conflict', handleConflictEvent as EventListener)
    return () => {
      window.removeEventListener('note-conflict', handleConflictEvent as EventListener)
    }
  }, [addConflict])

  const value: NoteConflictContextValue = {
    addConflict,
    conflictCount: conflictQueue.length + (currentConflict ? 1 : 0),
    clearConflicts,
  }

  return (
    <NoteConflictContext.Provider value={value}>
      {children}
      
      {/* 冲突解决对话框 */}
      <NoteConflictDialog
        open={dialogOpen}
        onOpenChange={handleOpenChange}
        conflictNote={currentConflict?.conflictNote ?? null}
        originalNote={currentConflict?.originalNote ?? null}
        bookId={currentConflict?.bookId ?? ''}
        onResolved={handleResolved}
      />
    </NoteConflictContext.Provider>
  )
}

/**
 * 触发笔记冲突事件（供外部调用）
 */
export function dispatchNoteConflict(conflict: ConflictItem): void {
  window.dispatchEvent(new CustomEvent('note-conflict', { detail: conflict }))
}


==================================================
FILE_PATH: web/src/pages/HomePage.tsx
==================================================

/**
 * 公共首页（营销着陆页）
 *
 * 说明：
 * - 组合 Hero、功能卡片、设备支持、精选书籍等区块
 * - 文案通过 `landing` 命名空间的 i18n 文本提供
 * - CTA 按钮跳转到应用区 `/app/read-now`
 */

import { Button } from '../components/ui/button'
import Hero from '../landing/Hero'
import FeatureCards from '../landing/FeatureCards'
import BookGrid from '../landing/BookGrid'
import DeviceCompatibility from '../landing/DeviceCompatibility'
import FeatureHighlight from '../landing/FeatureHighlight'
import CTASection from '../landing/CTASection'
import Footer from '../landing/Footer'
import { Link } from 'react-router-dom'
import { useTranslation } from 'react-i18next'

export default function HomePage() {
  const { t } = useTranslation('landing')
  return (
    <div className="min-h-screen bg-white">
      <Hero />
      <FeatureCards />
      <BookGrid />
      <DeviceCompatibility />
      <FeatureHighlight
        title={t('featureHighlight.title')}
        description={t('featureHighlight.description')}
        imageSrc="/INDEXJPG/知识的繁荣与危机-戴维·温伯格.jpg"
        imageAlt="Featured Book"
      />
      <CTASection />
      <div className="py-12 bg-gray-50 text-center">
        <Link to="/app/read-now">
          <Button size="lg" className="rounded-full px-8 text-lg h-12">
            {t('browse')}
          </Button>
        </Link>
      </div>
      <Footer />
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/AIConversationsPage.tsx
==================================================

/**
 * AI 对话页面
 * 
 * 功能:
 * - 显示对话历史列表
 * - 新建对话
 * - AI 流式问答
 * - 离线支持：缓存对话列表到 IndexedDB
 */
import { useEffect, useRef, useState, useCallback } from 'react'
import { useTranslation } from 'react-i18next'
import { Bot, Plus, Send, WifiOff, MessageSquare, Loader2 } from 'lucide-react'
import { useOnlineStatus } from '@/hooks/useOnlineStatus'
import api from '@/lib/api'
import {
  saveConversations,
  getCachedConversations,
  type ConversationRecord,
} from '@/lib/aiChatStorage'

export default function AIConversationsPage() {
  const { t } = useTranslation('common')
  const { isOnline } = useOnlineStatus()
  const [conversations, setConversations] = useState<ConversationRecord[]>([])
  const [selectedId, setSelectedId] = useState<string | null>(null)
  const [loading, setLoading] = useState(true)
  const [fromCache, setFromCache] = useState(false)
  
  // 当前对话状态
  const [text, setText] = useState('')
  const [messages, setMessages] = useState<{ role: 'user' | 'assistant'; content: string }[]>([])
  const [streaming, setStreaming] = useState(false)
  const esRef = useRef<EventSource | null>(null)
  
  // 从缓存加载
  const loadFromCache = useCallback(async () => {
    try {
      const cached = await getCachedConversations()
      if (cached.length > 0) {
        setConversations(cached)
        setFromCache(true)
        console.log('[AIConversations] Loaded from cache:', cached.length, 'conversations')
        return true
      }
    } catch (error) {
      console.error('[AIConversations] Failed to load from cache:', error)
    }
    return false
  }, [])
  
  // 从服务器获取
  const fetchConversations = useCallback(async () => {
    try {
      const response = await api.get('/ai/conversations')
      const list: ConversationRecord[] = (response.data?.data || []).map((x: any) => ({
        id: x.id,
        title: x.title || t('ai.untitled_conversation', '未命名对话'),
        createdAt: x.created_at,
        updatedAt: x.updated_at || x.created_at,
      }))
      setConversations(list)
      setFromCache(false)
      
      // 缓存到 IndexedDB
      saveConversations(list).catch(err =>
        console.error('[AIConversations] Failed to cache:', err)
      )
      
      return list
    } catch (error) {
      console.error('[AIConversations] Failed to fetch:', error)
      return []
    }
  }, [t])
  
  // 初始加载 - 只在挂载时执行一次
  useEffect(() => {
    const init = async () => {
      setLoading(true)
      await loadFromCache()
      // 使用 navigator.onLine 而不是 isOnline 状态，避免依赖问题
      if (navigator.onLine) {
        await fetchConversations()
      } else {
        console.log('[AIConversations] Offline mode, skipping API call')
      }
      setLoading(false)
    }
    init()
    
    return () => {
      esRef.current?.close()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []) // 只在挂载时执行，避免重复初始化
  
  // 网络恢复时刷新
  useEffect(() => {
    if (isOnline && fromCache) {
      console.log('[AIConversations] Network restored, refreshing...')
      fetchConversations()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOnline]) // 只响应 isOnline 变化
  
  // 发送消息
  const handleSend = () => {
    if (!text.trim() || streaming || !isOnline) return
    
    const userMsg = text.trim()
    setMessages(prev => [...prev, { role: 'user', content: userMsg }])
    setText('')
    setStreaming(true)
    
    esRef.current?.close()
    const token = localStorage.getItem('access_token') || ''
    const url = `/api/v1/ai/stream?prompt=${encodeURIComponent(userMsg)}&access_token=${encodeURIComponent(token)}`
    const es = new EventSource(url)
    esRef.current = es
    
    let assistantContent = ''
    setMessages(prev => [...prev, { role: 'assistant', content: '' }])
    
    es.onmessage = (ev) => {
      const d = ev.data
      if (d === 'BEGIN') return
      if (d === 'END') {
        es.close()
        setStreaming(false)
        return
      }
      assistantContent += d
      setMessages(prev => {
        const newMsgs = [...prev]
        newMsgs[newMsgs.length - 1] = { role: 'assistant', content: assistantContent }
        return newMsgs
      })
    }
    
    es.onerror = () => {
      es.close()
      setStreaming(false)
    }
  }
  
  return (
    <div className="h-full flex flex-col">
      {/* 离线提示 */}
      {!isOnline && (
        <div className="flex items-center gap-2 text-sm text-amber-600 dark:text-amber-400 bg-amber-50 dark:bg-amber-900/20 px-4 py-2">
          <WifiOff className="h-4 w-4" />
          <span>{t('common.offline_mode', '离线模式 - AI 功能需要联网')}</span>
        </div>
      )}
      
      {/* 头部 */}
      <div className="flex items-center justify-between p-4 border-b border-separator">
        <div className="flex items-center gap-2">
          <Bot className="h-6 w-6 text-system-blue" />
          <h1 className="text-xl font-semibold text-label">{t('ai.title', 'AI 助手')}</h1>
        </div>
      </div>
      
      {/* 主内容区 */}
      <div className="flex-1 flex overflow-hidden">
        {/* 对话列表侧边栏（桌面端） */}
        <div className="hidden md:flex w-64 flex-col border-r border-separator bg-secondary-background">
          <div className="p-3">
            <button
              onClick={() => {
                setSelectedId(null)
                setMessages([])
              }}
              disabled={!isOnline}
              className="w-full flex items-center justify-center gap-2 px-4 py-2 rounded-lg bg-system-blue text-white hover:bg-system-blue/90 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <Plus className="h-4 w-4" />
              <span>{t('ai.new_conversation', '新对话')}</span>
            </button>
          </div>
          
          <div className="flex-1 overflow-y-auto">
            {loading ? (
              <div className="flex justify-center py-8">
                <Loader2 className="h-5 w-5 animate-spin text-secondary-label" />
              </div>
            ) : conversations.length === 0 ? (
              <div className="text-center py-8 text-secondary-label text-sm">
                {t('ai.no_conversations', '暂无对话')}
              </div>
            ) : (
              conversations.map(conv => (
                <button
                  key={conv.id}
                  onClick={() => setSelectedId(conv.id)}
                  className={`w-full text-left px-3 py-2 border-b border-separator/50 hover:bg-tertiary-background transition-colors ${
                    selectedId === conv.id ? 'bg-tertiary-background' : ''
                  }`}
                >
                  <div className="flex items-center gap-2">
                    <MessageSquare className="h-4 w-4 text-secondary-label flex-shrink-0" />
                    <span className="text-sm text-label truncate">{conv.title}</span>
                  </div>
                  <div className="text-xs text-tertiary-label mt-1 ml-6">
                    {new Date(conv.created_at || conv.createdAt).toLocaleDateString()}
                  </div>
                </button>
              ))
            )}
          </div>
        </div>
        
        {/* 对话区域 */}
        <div className="flex-1 flex flex-col">
          {/* 消息列表 */}
          <div className="flex-1 overflow-y-auto p-4 space-y-4">
            {messages.length === 0 ? (
              <div className="h-full flex flex-col items-center justify-center text-secondary-label">
                <Bot className="h-16 w-16 mb-4 opacity-50" />
                <p className="text-lg">{t('ai.welcome', '有什么我可以帮助你的？')}</p>
                <p className="text-sm mt-2">{t('ai.hint', '试着问我关于你书籍的问题')}</p>
              </div>
            ) : (
              messages.map((msg, i) => (
                <div
                  key={i}
                  className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
                >
                  <div
                    className={`max-w-[80%] rounded-2xl px-4 py-2 ${
                      msg.role === 'user'
                        ? 'bg-system-blue text-white'
                        : 'bg-secondary-background text-label'
                    }`}
                  >
                    <p className="whitespace-pre-wrap">{msg.content || (streaming && msg.role === 'assistant' ? '...' : '')}</p>
                  </div>
                </div>
              ))
            )}
          </div>
          
          {/* 输入区域 */}
          <div className="p-4 border-t border-separator">
            <div className="flex items-center gap-2">
              <input
                value={text}
                onChange={(e) => setText(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleSend()}
                placeholder={isOnline ? t('ai.prompt', '输入你的问题...') : t('ai.offline_hint', '联网后可使用 AI 功能')}
                disabled={!isOnline || streaming}
                className="flex-1 px-4 py-2 rounded-full bg-secondary-background text-label placeholder-tertiary-label focus:outline-none focus:ring-2 focus:ring-system-blue disabled:opacity-50"
              />
              <button
                onClick={handleSend}
                disabled={!text.trim() || !isOnline || streaming}
                className="p-2 rounded-full bg-system-blue text-white hover:bg-system-blue/90 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {streaming ? (
                  <Loader2 className="h-5 w-5 animate-spin" />
                ) : (
                  <Send className="h-5 w-5" />
                )}
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/pages/ReadNowPage.tsx
==================================================

/**
 * ReadNowPage - 立即阅读欢迎页
 *
 * 用途：
 * - 展示欢迎文案与进入阅读的入口（占位内容）
 *
 * 说明：仅新增注释，不改动渲染内容与样式
 */
export default function ReadNowPage() {
    return (
        <div className="flex items-center justify-center min-h-screen bg-system-background">
            <div className="text-center p-8">
                <h1 className="text-4xl font-bold text-label mb-4">Welcome to Athena</h1>
                <p className="text-xl text-secondary-label">Your reading journey starts here.</p>
            </div>
        </div>
    )
}


==================================================
FILE_PATH: web/src/pages/NotesPage.tsx
==================================================

/**
 * NotesPage - 笔记与高亮管理页面 (App-First 版)
 *
 * 架构:
 * - 数据源: PowerSync (useNotesData, useHighlightsData, useBooksData)
 * - 纯响应式，无 API 调用
 */

import { useState, useMemo } from 'react'
import { useTranslation } from 'react-i18next'
import { useNotesData, useHighlightsData, type NoteItem, type HighlightItem } from '@/hooks/useNotesData'
import { useBooksData } from '@/hooks/useBooksData'
import { Search, BookOpen, Highlighter, StickyNote, Trash2, Edit2, RefreshCw } from 'lucide-react'

import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs'
import { Card, CardHeader, CardContent } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog'
import { Textarea } from '@/components/ui/textarea'
import { useToast } from '@/hooks/use-toast'
import { formatDistanceToNow } from 'date-fns'
import { zhCN } from 'date-fns/locale'

export default function NotesPage() {
  const { t } = useTranslation()
  const { toast } = useToast()

  // 1. 获取所有笔记和高亮
  const { notes, isLoading: notesLoading, updateNote, deleteNote } = useNotesData({})
  const { highlights, isLoading: highlightsLoading,  deleteHighlight } = useHighlightsData({})
  
  // 2. 获取书籍列表 (用于筛选)
  const { items: books } = useBooksData({ sortBy: 'title' })

  // 本地状态
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedBookId, setSelectedBookId] = useState<string>('all')
  const [activeTab, setActiveTab] = useState('all')

  // 编辑相关状态
  const [editingNote, setEditingNote] = useState<NoteItem | null>(null)
  const [editContent, setEditContent] = useState('')

  // 统一数据结构用于渲染
  type DisplayItem = {
    id: string
    type: 'note' | 'highlight'
    content: string
    color?: string
    bookId: string
    bookTitle?: string
    createdAt: string
    original: NoteItem | HighlightItem
  }

  const allItems: DisplayItem[] = useMemo(() => {
    const noteItems: DisplayItem[] = notes.map(n => ({
      id: n.id,
      type: 'note',
      content: n.content,
      bookId: n.bookId,
      bookTitle: n.bookTitle,
      createdAt: n.createdAt,
      original: n
    }))

    const highlightItems: DisplayItem[] = highlights.map(h => ({
      id: h.id,
      type: 'highlight',
      content: h.textContent, // 高亮文本作为内容展示
      color: h.color,
      bookId: h.bookId,
      bookTitle: h.bookTitle,
      createdAt: h.createdAt,
      original: h
    }))

    return [...noteItems, ...highlightItems].sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    )
  }, [notes, highlights])

  // 过滤逻辑
  const filteredItems = useMemo(() => {
    return allItems.filter(item => {
      // 标签页过滤
      if (activeTab === 'notes' && item.type !== 'note') return false
      if (activeTab === 'highlights' && item.type !== 'highlight') return false

      // 书籍过滤
      if (selectedBookId !== 'all' && item.bookId !== selectedBookId) return false

      // 搜索过滤
      if (searchQuery) {
        const q = searchQuery.toLowerCase()
        return (
          item.content.toLowerCase().includes(q) ||
          (item.bookTitle || '').toLowerCase().includes(q)
        )
      }

      return true
    })
  }, [allItems, activeTab, selectedBookId, searchQuery])

  // 处理删除
  const handleDelete = async (item: DisplayItem) => {
    if (!confirm(t('common.confirm_delete', '确定要删除吗？'))) return

    try {
      if (item.type === 'note') {
        await deleteNote(item.id)
      } else {
        await deleteHighlight(item.id)
      }
      toast({ title: t('common.deleted', '已删除') })
    } catch {
      toast({ 
        title: t('common.error', '操作失败'), 
        variant: 'destructive' 
      })
    }
  }

  // 处理编辑
  const handleEdit = (item: DisplayItem) => {
    if (item.type === 'note') {
      setEditingNote(item.original as NoteItem)
      setEditContent(item.content)
    } else {
      // 高亮目前只支持编辑备注，这里简化处理，暂不支持直接编辑高亮文本
      toast({ title: t('notes.highlight_edit_hint', '高亮文本无法直接编辑') })
    }
  }

  const saveEdit = async () => {
    if (!editingNote) return

    try {
      await updateNote(editingNote.id, editContent)
      setEditingNote(null)
      toast({ title: t('common.saved', '已保存') })
    } catch {
      toast({ 
        title: t('common.error', '保存失败'), 
        variant: 'destructive' 
      })
    }
  }

  const isLoading = notesLoading || highlightsLoading

  return (
    <div className="container mx-auto px-4 py-6 max-w-5xl">
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <StickyNote className="h-6 w-6" />
            {t('nav.notes', '笔记与高亮')}
          </h1>
          <p className="text-sm text-muted-foreground mt-1">
            {notes.length} {t('notes.notes_count', '条笔记')} · {highlights.length} {t('notes.highlights_count', '条高亮')}
          </p>
        </div>

        <div className="flex items-center gap-2 w-full md:w-auto">
          <div className="relative flex-1 md:w-64">
            <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder={t('common.search', '搜索内容...')}
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-8"
            />
          </div>
          
          <Select value={selectedBookId} onValueChange={setSelectedBookId}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder={t("notes.filter_book", "所有书籍")} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">{t('notes.all_books', '所有书籍')}</SelectItem>
              {books.map(book => (
                <SelectItem key={book.id} value={book.id}>
                  {book.title}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="mb-4">
          <TabsTrigger value="all">{t('common.all', '全部')}</TabsTrigger>
          <TabsTrigger value="notes">{t('notes.only_notes', '仅笔记')}</TabsTrigger>
          <TabsTrigger value="highlights">{t('notes.only_highlights', '仅高亮')}</TabsTrigger>
        </TabsList>

        <TabsContent value={activeTab} className="mt-0">
          {isLoading ? (
            <div className="flex justify-center py-12">
              <RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : filteredItems.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <BookOpen className="h-12 w-12 mx-auto mb-4 opacity-20" />
              <p>{t('common.empty', '暂无内容')}</p>
            </div>
          ) : (
            <div className="grid gap-4">
              {filteredItems.map(item => (
                <Card key={item.id} className="overflow-hidden">
                  <CardHeader className="pb-2 flex flex-row items-start justify-between space-y-0">
                    <div className="flex items-center gap-2">
                      <Badge variant={item.type === 'note' ? 'default' : 'secondary'}>
                        {item.type === 'note' ? <StickyNote className="h-3 w-3 mr-1" /> : <Highlighter className="h-3 w-3 mr-1" />}
                        {item.type === 'note' ? t('notes.note', '笔记') : t('notes.highlight', '高亮')}
                      </Badge>
                      <span className="text-sm text-muted-foreground flex items-center gap-1">
                        <BookOpen className="h-3 w-3" />
                        {item.bookTitle || t('common.unknown_book', '未知书籍')}
                      </span>
                      <span className="text-xs text-muted-foreground">
                        {formatDistanceToNow(new Date(item.createdAt), { addSuffix: true, locale: zhCN })}
                      </span>
                    </div>
                    <div className="flex gap-1">
                      {item.type === 'note' && (
                        <Button variant="ghost" size="icon" className="h-8 w-8" onClick={() => handleEdit(item)}>
                          <Edit2 className="h-4 w-4" />
                        </Button>
                      )}
                      <Button variant="ghost" size="icon" className="h-8 w-8 text-destructive" onClick={() => handleDelete(item)}>
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </CardHeader>
                  <CardContent>
                    <div className={`text-sm leading-relaxed ${item.type === 'highlight' ? 'border-l-4 pl-3 py-1' : ''}`}
                      style={item.type === 'highlight' && item.color ? { borderLeftColor: item.color } : undefined}
                    >
                      {item.content}
                    </div>
                    {item.type === 'highlight' && (item.original as HighlightItem).note && (
                      <div className="mt-2 text-sm text-muted-foreground bg-muted p-2 rounded">
                        <span className="font-semibold mr-1">{t('notes.note', '笔记')}:</span>
                        {(item.original as HighlightItem).note}
                      </div>
                    )}
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </TabsContent>
      </Tabs>

      {/* 编辑对话框 */}
      <Dialog open={!!editingNote} onOpenChange={(open) => !open && setEditingNote(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>{t('notes.edit_note', '编辑笔记')}</DialogTitle>
          </DialogHeader>
          <Textarea
            value={editContent}
            onChange={(e) => setEditContent(e.target.value)}
            className="min-h-[150px]"
          />
          <DialogFooter>
            <Button variant="outline" onClick={() => setEditingNote(null)}>
              {t('common.cancel', '取消')}
            </Button>
            <Button onClick={saveEdit}>
              {t('common.save', '保存')}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/TTSPage.tsx
==================================================

import { useEffect, useRef, useState, useCallback } from 'react'
import { useTranslation } from 'react-i18next'

export default function TTSPage() {
  const { t } = useTranslation()
  const [text, setText] = useState('')
  const [audioUrl, setAudioUrl] = useState('')
  const [reqId, setReqId] = useState('')
  const [duration, setDuration] = useState(0)
  const [balance, setBalance] = useState<any>(null)
  const [ledger, setLedger] = useState<any[]>([])
  const timerRef = useRef<any>(null)
  const at = typeof window !== 'undefined' ? localStorage.getItem('access_token') || '' : ''
  const call = useCallback(async (path: string, init?: RequestInit) => {
    try {
      const r = await fetch(path, { ...(init||{}), headers: { ...(init?.headers||{}), Authorization: `Bearer ${at}`, 'Content-Type': 'application/json' } })
      const ct = r.headers.get('content-type') || ''
      if (!ct.includes('application/json')) return {}
      const body = await r.json().catch(() => ({}))
      return body || {}
    } catch {
      return {}
    }
  }, [at])
  const start = async () => {
    const j = await call('/api/v1/tts', { method: 'POST', body: JSON.stringify({ text }) })
    const d = j.data || {}
    setAudioUrl(d.download_url || '')
    setReqId(d.request_id || '')
    clearInterval(timerRef.current)
    timerRef.current = setInterval(async () => {
      const hb = await call('/api/v1/tts/heartbeat', { method: 'POST', body: JSON.stringify({ request_id: d.request_id, delta_ms: 1000 }) })
      const dd = hb.data || {}
      setDuration(dd.duration_ms || 0)
    }, 1000)
    await refreshBilling()
  }
  const stop = async () => {
    clearInterval(timerRef.current)
    timerRef.current = null
    await refreshBilling()
  }
  const refreshBilling = useCallback(async () => {
    const b = await call('/api/v1/billing/balance')
    setBalance(b.data)
    const l = await call('/api/v1/billing/ledger')
    setLedger(l.data || [])
  }, [call])
  useEffect(() => { refreshBilling() }, [refreshBilling])
  return (
    <div style={{ padding: 16 }}>
      <div>
        <input value={text} onChange={e => setText(e.target.value)} placeholder={t('tts.input')} style={{ width: '60%' }} />
        <button onClick={start} style={{ marginLeft: 8 }}>{t('tts.start')}</button>
        <button onClick={stop} style={{ marginLeft: 8 }}>{t('tts.stop')}</button>
      </div>
      {audioUrl && (
        <audio src={audioUrl} controls style={{ display: 'block', marginTop: 12 }} />
      )}
      <div style={{ marginTop: 12 }}>请求 {reqId}，累计时长 {duration} ms</div>
      <div style={{ marginTop: 12 }}>{t('billing.balance_prefix')} {balance ? `${balance.balance} Credits，钱包 ${balance.wallet_amount} ${balance.wallet_currency}` : ''}</div>
      <div style={{ marginTop: 12 }}>
        <div>{t('billing.title')}</div>
        <ul>
          {ledger.map((x, i) => <li key={i}>{x.direction} {x.amount} {x.currency} {x.reason}</li>)}
        </ul>
      </div>
    </div>
  )
}

==================================================
FILE_PATH: web/src/pages/SearchPage.tsx
==================================================

/**
 * 搜索页面
 * 
 * 功能:
 * - 全局搜索书籍、笔记、高亮
 * - 离线支持：搜索本地缓存的书籍列表和笔记
 * - 在线时调用服务器搜索 API
 * 
 * 注意：全文搜索（FlexSearch）为 P2 功能，待后续实现
 * 
 * @see App-First改造计划.md
 */
import { useState, useMemo } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTranslation } from 'react-i18next'
import { Search, BookOpen, FileText, Highlighter, X, Loader2 } from 'lucide-react'
import { useBooksData } from '@/hooks/useBooksData'
import { useNotesData, useHighlightsData } from '@/hooks/useNotesData'

type SearchCategory = 'all' | 'books' | 'notes' | 'highlights'

interface SearchResult {
  type: 'book' | 'note' | 'highlight'
  id: string
  title: string
  subtitle?: string
  bookId?: string
}

export default function SearchPage() {
  const { t } = useTranslation()
  const navigate = useNavigate()

  const [query, setQuery] = useState('')
  const [category, setCategory] = useState<SearchCategory>('all')
  const [searched, setSearched] = useState(false)

  // 使用防抖更新查询词
  // 简单起见，这里直接使用 useEffect 做防抖，或者直接响应 query
  // 为了更好的体验，我们假设 query 是即时更新的， PowerSync 本地查询很快

  // 查询书籍
  const { items: books, isLoading: booksLoading } = useBooksData({
    search: query,
    // 如果 query 为空，我们不希望列出所有书籍，除非用户确实想看
    // 但 current behavior logic needed: search page usually starts empty
  })

  // 查询笔记
  const { notes, isLoading: notesLoading } = useNotesData({
    search: query
  })

  // 查询高亮
  const { highlights, isLoading: highlightsLoading } = useHighlightsData({
    search: query
  })

  const loading = booksLoading || notesLoading || highlightsLoading

  // 聚合结果
  const results: SearchResult[] = useMemo(() => {
    if (!query.trim()) return []

    const list: SearchResult[] = []

    // 书籍结果
    if (category === 'all' || category === 'books') {
      books.forEach(book => {
        list.push({
          type: 'book',
          id: book.id,
          title: book.title,
          subtitle: book.author,
        })
      })
    }

    // 笔记结果
    if (category === 'all' || category === 'notes') {
      notes.forEach(note => {
        list.push({
          type: 'note',
          id: note.id,
          title: note.content.slice(0, 100) + (note.content.length > 100 ? '...' : ''),
          subtitle: note.bookTitle,
          bookId: note.bookId,
        })
      })
    }

    // 高亮结果
    if (category === 'all' || category === 'highlights') {
      highlights.forEach(hl => {
        list.push({
          type: 'highlight',
          id: hl.id,
          title: hl.textContent.slice(0, 100) + (hl.textContent.length > 100 ? '...' : ''),
          subtitle: hl.bookTitle,
          bookId: hl.bookId,
        })
      })
    }

    return list
  }, [query, category, books, notes, highlights])

  const handleSearch = () => {
    if (query.trim()) {
      setSearched(true)
    }
  }

  // 结果点击处理
  const handleResultClick = (result: SearchResult) => {
    if (result.type === 'book') {
      navigate(`/app/read/${result.id}`)
    } else if (result.bookId) {
      navigate(`/app/read/${result.bookId}`)
    }
  }

  // 分类标签
  const categories = useMemo(() => [
    { key: 'all', label: t('search.all', '全部') },
    { key: 'books', label: t('search.books', '书籍'), icon: BookOpen },
    { key: 'notes', label: t('search.notes', '笔记'), icon: FileText },
    { key: 'highlights', label: t('search.highlights', '高亮'), icon: Highlighter },
  ], [t])

  // 结果图标
  const getResultIcon = (type: string) => {
    switch (type) {
      case 'book': return <BookOpen className="h-5 w-5 text-system-blue" />
      case 'note': return <FileText className="h-5 w-5 text-system-green" />
      case 'highlight': return <Highlighter className="h-5 w-5 text-system-yellow" />
      default: return <Search className="h-5 w-5 text-secondary-label" />
    }
  }

  return (
    <div className="min-h-screen bg-system-background">
      {/* 搜索头部 */}
      <div className="sticky top-0 z-10 bg-system-background border-b border-separator p-4">
        {/* 搜索框 */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-secondary-label" />
          <input
            type="text"
            value={query}
            onChange={(e) => {
              setQuery(e.target.value)
              if (!e.target.value) setSearched(false)
            }}
            onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
            placeholder={t('search.placeholder', '搜索书籍、笔记、高亮...')}
            className="w-full pl-10 pr-10 py-3 rounded-xl bg-secondary-background text-label placeholder-tertiary-label focus:outline-none focus:ring-2 focus:ring-system-blue"
            autoFocus
          />
          {query && (
            <button
              onClick={() => {
                setQuery('')
                setSearched(false)
              }}
              className="absolute right-3 top-1/2 -translate-y-1/2 p-1 rounded-full hover:bg-tertiary-background"
            >
              <X className="h-4 w-4 text-secondary-label" />
            </button>
          )}
        </div>

        {/* 分类标签 */}
        <div className="flex gap-2 mt-3 overflow-x-auto pb-1">
          {categories.map(cat => (
            <button
              key={cat.key}
              onClick={() => setCategory(cat.key as SearchCategory)}
              className={`flex items-center gap-1.5 px-3 py-1.5 rounded-full text-sm whitespace-nowrap transition-colors ${category === cat.key
                ? 'bg-system-blue text-white'
                : 'bg-secondary-background text-secondary-label hover:bg-tertiary-background'
                }`}
            >
              {cat.icon && <cat.icon className="h-4 w-4" />}
              <span>{cat.label}</span>
            </button>
          ))}
        </div>
      </div>

      {/* 搜索结果 */}
      <div className="p-4">
        {loading && searched ? (
          <div className="flex flex-col items-center justify-center py-16">
            <Loader2 className="h-8 w-8 animate-spin text-system-blue" />
            <p className="mt-2 text-secondary-label">{t('search.searching', '搜索中...')}</p>
          </div>
        ) : !searched && !query ? (
          <div className="flex flex-col items-center justify-center py-16 text-secondary-label">
            <Search className="h-16 w-16 opacity-30" />
            <p className="mt-4">{t('search.hint', '输入关键词开始搜索')}</p>
          </div>
        ) : results.length === 0 && (searched || query) ? (
          <div className="flex flex-col items-center justify-center py-16 text-secondary-label">
            <Search className="h-16 w-16 opacity-30" />
            <p className="mt-4">{t('search.no_results', '未找到相关结果')}</p>
          </div>
        ) : (
          <div className="space-y-2">
            <p className="text-sm text-secondary-label mb-4">
              {t('search.results_count', '找到 {{count}} 个结果', { count: results.length })}
            </p>
            {results.map((result) => (
              <button
                key={`${result.type}-${result.id}`}
                onClick={() => handleResultClick(result)}
                className="w-full flex items-start gap-3 p-3 rounded-xl bg-secondary-background hover:bg-tertiary-background transition-colors text-left"
              >
                <div className="shrink-0 mt-0.5">
                  {getResultIcon(result.type)}
                </div>
                <div className="flex-1 min-w-0">
                  <p className="text-label line-clamp-2">{result.title}</p>
                  {result.subtitle && (
                    <p className="text-sm text-secondary-label mt-1 truncate">{result.subtitle}</p>
                  )}
                </div>
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/ReaderPage.tsx
==================================================

/**
 * ReaderPage - 电子书阅读器页面 (App-First 版)
 *
 * 架构:
 * 1. 元数据: PowerSync (useBookData)
 * 2. 进度: PowerSync (useProgressData)
 * 3. 文件: IndexedDB (useLocalBookCache + getBookFile)
 * 4. OCR: IndexedDB (useOcrData)
 *
 * 纯响应式，无心跳，无 API 轮询
 */

import { useEffect, useState, useCallback, useRef } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { useAuthStore } from '@/stores/auth'
import { Document, pdfjs } from 'react-pdf'
import { ReactReader } from 'react-reader'
import type { Rendition } from 'epubjs'
import { Button } from '@/components/ui/button'
import { ChevronLeft, Loader2, AlertCircle } from 'lucide-react'
import { useBookData } from '@/hooks/useBooksData'
import { useProgressData, useReadingSession } from '@/hooks/useProgressData'
import { useBookFileCache } from '@/hooks/useBookFileCache'
import { getBookFile, createBlobUrl, revokeBlobUrl } from '@/lib/bookStorage'
import { useOcrData } from '@/hooks/useOcrData'
import { PdfPageWithOcr } from '@/components/reader/PdfPageWithOcr'
import { parseEpubLocation, parsePdfLocation, formatProgress } from '@/lib/reading-utils'
import 'react-pdf/dist/Page/AnnotationLayer.css'
import 'react-pdf/dist/Page/TextLayer.css'

// 配置 PDF worker
pdfjs.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`

export default function ReaderPage() {
  const { bookId } = useParams()
  const navigate = useNavigate()
  const accessToken = useAuthStore((s) => s.accessToken)

  // 1. 获取书籍元数据
  const { book, isLoading: isMetaLoading, error: metaError } = useBookData(bookId || null)

  // 2. 获取阅读进度 - 必须等待加载完成才能渲染阅读器
  const { progress, saveProgress, isProgressLoading } = useProgressData(bookId || null)
  
  // 2.1 记录阅读会话（用于统计阅读时长）
  const { startSession, endSession } = useReadingSession(bookId || null)

  // 3. 本地文件状态
  const { markDownloading, markDownloaded } = useBookFileCache(bookId ? [bookId] : [])
  const [blobUrl, setBlobUrl] = useState<string | null>(null)
  const [fileLoading, setFileLoading] = useState(true)
  const [fileError, setFileError] = useState<string | null>(null)

  // 4. OCR 数据（预加载）
  useOcrData({
    bookId: bookId || '',
    autoDownload: true
  })

  // PDF 状态
  const [numPages, setNumPages] = useState<number>(0)
  const [pageNumber, setPageNumber] = useState(1)
  
  // EPUB 状态
  const [rendition, setRendition] = useState<Rendition | null>(null)
  const [epubLocation, setEpubLocation] = useState<string | number | null>(null)

  // 初始化：加载文件
  useEffect(() => {
    if (!bookId) return

    const loadFile = async () => {
      console.log('[ReaderPage] Loading file for book:', bookId)
      console.log('[ReaderPage] Book metadata:', book)
      setFileLoading(true)
      setFileError(null) // 重置错误状态
      try {
        // 检查缓存
        const cached = await getBookFile(bookId)
        console.log('[ReaderPage] Cached file:', cached ? { format: cached.format, size: cached.size, blobType: cached.blob?.type, blobSize: cached.blob?.size } : null)
        if (cached && cached.blob && cached.blob.size > 0) {
          const format = cached.format as 'epub' | 'pdf'
          // 统一使用 Blob URL，但确保 MIME 类型正确
          const url = createBlobUrl(cached.blob, format)
          console.log('[ReaderPage] Created blob URL from cache:', url, 'format:', format)
          setBlobUrl(url)
          setFileLoading(false)
          return
        } else if (cached) {
          console.warn('[ReaderPage] Cached file is invalid, will re-download')
        }

        // 未缓存，尝试下载
        const token = accessToken || localStorage.getItem('access_token') || ''
        if (!token) throw new Error('No access token')

        markDownloading(bookId)
        const contentUrl = `/api/v1/books/${bookId}/content?token=${encodeURIComponent(token)}`
        const response = await fetch(contentUrl)
        
        if (!response.ok) throw new Error(`Download failed: ${response.status}`)
        
        const blob = await response.blob()
        const contentType = response.headers.get('Content-Type') || ''
        const format = contentType.includes('pdf') ? 'pdf' : 'epub'
        
        // 保存到缓存
        const { saveBookFile } = await import('@/lib/bookStorage')
        await saveBookFile(bookId, blob, format, undefined)
        markDownloaded(bookId)

        // 统一使用 Blob URL
        const url = createBlobUrl(blob, format)
        console.log('[ReaderPage] Created blob URL after download:', url, 'format:', format)
        setBlobUrl(url)
        setFileLoading(false)
      } catch (err) {
        console.error('[ReaderPage] File load error:', err)
        setFileError(err instanceof Error ? err.message : 'Failed to load book')
        setFileLoading(false)
      }
    }

    loadFile()

    return () => {
      if (blobUrl) revokeBlobUrl(blobUrl)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [bookId, accessToken])

  // 阅读会话管理 - 开始/结束阅读会话以记录阅读时长
  useEffect(() => {
    let sessionStarted = false
    
    // 只有在文件加载完成后才开始会话
    if (!fileLoading && blobUrl && bookId) {
      console.log('[ReaderPage] Starting reading session for book:', bookId)
      startSession().then((id) => {
        if (id) {
          sessionStarted = true
          console.log('[ReaderPage] Session started successfully:', id)
        }
      })
    }
    
    // 组件卸载或离开页面时结束会话
    return () => {
      if (bookId) {
        console.log('[ReaderPage] Ending reading session for book:', bookId)
        endSession()
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fileLoading, blobUrl, bookId])

  // 初始化进度 - 只有在进度加载完成后才恢复位置
  // 使用 ref 来追踪是否已经恢复过进度，防止重复恢复
  const progressRestoredRef = useRef(false)
  
  useEffect(() => {
    // 必须等待进度加载完成
    if (isProgressLoading) {
      console.log('[ReaderPage] Waiting for progress to load...')
      return
    }
    
    // 如果已经恢复过，不再重复
    if (progressRestoredRef.current) {
      return
    }
    
    console.log('[ReaderPage] Progress loaded, attempting to restore:', progress)
    progressRestoredRef.current = true
    
    if (progress && progress.currentCfi) {
      if (book?.originalFormat === 'pdf') {
        const loc = parsePdfLocation(progress.currentCfi || progress.currentPage)
        if (loc) {
          console.log('[ReaderPage] Restoring PDF page:', loc.page)
          setPageNumber(loc.page)
        }
      } else {
        const loc = parseEpubLocation(progress.currentCfi)
        if (loc) {
          console.log('[ReaderPage] Restoring EPUB location:', loc)
          setEpubLocation(loc)
        }
      }
    } else {
      console.log('[ReaderPage] No saved progress found, starting from beginning')
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isProgressLoading, progress, book])

  // EPUB 位置变更
  const onEpubLocationChanged = useCallback((loc: string | number) => {
    console.log('[ReaderPage] EPUB location changed:', loc, 'rendition:', !!rendition)
    setEpubLocation(loc)
    
    // 即使 rendition 未就绪，也尝试保存 CFI 位置
    if (typeof loc === 'string') {
      let percentage = 0
      
      // 方法1: 使用 rendition.book.locations.percentageFromCfi (最准确)
      if (rendition) {
        try {
          const book = (rendition as any).book
          if (book?.locations?.percentageFromCfi) {
            percentage = book.locations.percentageFromCfi(loc)
            console.log('[ReaderPage] Got percentage from locations:', percentage)
          }
        } catch (e) {
          console.warn('[ReaderPage] Failed to get percentage from locations:', e)
        }
      }
      
      // 方法2: 如果方法1失败，尝试从 currentLocation 获取
      if (percentage === 0 && rendition) {
        try {
          const currentLocation = (rendition as any).currentLocation()
          if (currentLocation) {
            const loc_any = currentLocation as any
            percentage = 
              loc_any?.start?.percentage ?? 
              loc_any?.atStart?.percentage ??
              loc_any?.percentage ?? 
              0
            console.log('[ReaderPage] Got percentage from currentLocation:', percentage, currentLocation)
          }
        } catch (e) {
          console.warn('[ReaderPage] Failed to get location percentage:', e)
        }
      }
      
      // 始终保存进度
      console.log('[ReaderPage] Saving EPUB progress:', { loc, percentage })
      saveProgress({
        currentCfi: loc,
        percentage: typeof percentage === 'number' ? percentage : 0,
      })
    }
  }, [rendition, saveProgress])

  // PDF 页面变更
  const onPdfPageChange = useCallback((page: number) => {
    console.log('[ReaderPage] PDF page changed:', page, '/', numPages)
    setPageNumber(page)
    const percentage = numPages > 0 ? page / numPages : 0
    console.log('[ReaderPage] Saving PDF progress:', { page, percentage, numPages })
    saveProgress({
      currentPage: page,
      percentage: percentage,
      totalPages: numPages
    })
  }, [numPages, saveProgress])

  // 渲染加载中 - 元数据加载或文件加载或进度正在加载或还没有 book 数据
  // 重要：必须等待进度加载完成，否则阅读器会以第一页初始化并覆盖真实进度
  if (isMetaLoading || fileLoading || isProgressLoading || (!book && !metaError)) {
    return (
      <div className="flex items-center justify-center h-[100dvh]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <span className="ml-2">{isProgressLoading ? '正在同步进度...' : 'Loading...'}</span>
      </div>
    )
  }

  const isPdf = book?.originalFormat === 'pdf' || (book as any)?.format === 'pdf'

  // 渲染错误 - 只有在确定有错误或明确没有书籍时才显示
  if (metaError || fileError || !book || !blobUrl) {
    console.error('[ReaderPage] Rendering error state:', { metaError, fileError, book, blobUrl })
    return (
      <div className="flex flex-col items-center justify-center h-[100dvh] text-red-500">
        <AlertCircle className="h-12 w-12 mb-4" />
        <p>{metaError?.message || fileError || 'Book not found'}</p>
        <Button variant="outline" className="mt-4" onClick={() => navigate(-1)}>
          Go Back
        </Button>
      </div>
    )
  }

  console.log('[ReaderPage] Render:', { bookTitle: book.title, originalFormat: book.originalFormat, isPdf, blobUrl })

  return (
    <div className="h-[100dvh] flex flex-col bg-background overflow-hidden">
      {/* 顶部栏 - 固定高度 */}
      <div className="h-12 shrink-0 border-b flex items-center px-4 justify-between bg-card z-10">
        <Button variant="ghost" size="sm" onClick={() => navigate(-1)}>
          <ChevronLeft className="h-4 w-4 mr-1" />
          Back
        </Button>
        <div className="font-medium truncate max-w-[50%]">{book.title}</div>
        <div className="text-sm text-muted-foreground">
          {formatProgress(progress?.percentage || 0)}
        </div>
      </div>

      {/* 阅读区域 - 使用剩余空间，不允许溢出 */}
      <div className="flex-1 min-h-0 relative overflow-hidden">
        {isPdf ? (
          <div className="h-full flex flex-col bg-gray-100 dark:bg-gray-900">
            {/* PDF 内容区域 - 可滚动 */}
            <div className="flex-1 overflow-auto flex justify-center items-start py-4">
              <Document
                file={blobUrl}
                onLoadSuccess={({ numPages }) => {
                  console.log('[ReaderPage] PDF loaded successfully, pages:', numPages)
                  setNumPages(numPages)
                }}
                onLoadError={(error) => {
                  console.error('[ReaderPage] PDF load error:', error)
                }}
                loading={<Loader2 className="h-8 w-8 animate-spin mt-10" />}
                error={<div className="text-red-500 p-4">加载PDF失败</div>}
              >
                <PdfPageWithOcr
                  pageNumber={pageNumber}
                  width={Math.min(800, window.innerWidth - 32)}
                />
              </Document>
            </div>
            {/* 固定在底部的翻页控制 */}
            <div className="shrink-0 py-3 px-4 bg-white/90 dark:bg-gray-800/90 backdrop-blur border-t flex items-center justify-center gap-4">
              <Button 
                variant="outline" 
                size="icon" 
                disabled={pageNumber <= 1}
                onClick={() => onPdfPageChange(pageNumber - 1)}
              >
                <ChevronLeft className="h-4 w-4" />
              </Button>
              <span className="text-sm font-medium min-w-[80px] text-center">
                {pageNumber} / {numPages}
              </span>
              <Button 
                variant="outline" 
                size="icon" 
                disabled={pageNumber >= numPages}
                onClick={() => onPdfPageChange(pageNumber + 1)}
              >
                <ChevronLeft className="h-4 w-4 rotate-180" />
              </Button>
            </div>
          </div>
        ) : (
          <div className="h-full">
            <ReactReader
              url={blobUrl!}
              location={epubLocation || undefined}
              locationChanged={onEpubLocationChanged}
              getRendition={setRendition}
              epubInitOptions={{
                openAs: 'epub',  // 必须：告诉 epub.js 这是文件而非目录
              }}
              epubOptions={{
                flow: 'paginated',  // 分页模式
                manager: 'default', // 使用默认管理器（更稳定）
              }}
              loadingView={
                <div className="flex items-center justify-center h-full">
                  <Loader2 className="h-8 w-8 animate-spin text-primary" />
                  <span className="ml-2">加载中...</span>
                </div>
              }
              errorView={
                <div className="flex flex-col items-center justify-center h-full text-red-500">
                  <AlertCircle className="h-12 w-12 mb-4" />
                  <p>EPUB 加载失败</p>
                  <p className="text-sm text-muted-foreground mt-2">请尝试重新打开或联系支持</p>
                </div>
              }
            />
          </div>
        )}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/ProfilePage.tsx
==================================================

/**
 * ProfilePage - 个人资料页面
 *
 * 用途：
 * - 获取并展示当前用户资料（昵称）
 * - 通过 `ETag` 并发控制更新昵称后刷新展示
 * - 【离线支持】首次加载时从 IndexedDB 读取缓存
 *
 * @see App-First改造计划.md
 */
import { useState, useEffect, useCallback } from 'react'
import { Button } from '../components/ui/button'
import { Input } from '../components/ui/input'
import { useTranslation } from 'react-i18next'
import { useOnlineStatus } from '../hooks/useOnlineStatus'
import { WifiOff, RefreshCw, User } from 'lucide-react'

interface CachedProfile {
  id: string
  email: string
  display_name: string
  tier: string
  role: string
  created_at: string
  etag?: string
  cached_at?: number
}

export default function ProfilePage() {
  const { t } = useTranslation()
  const isOnline = useOnlineStatus()
  const [profile, setProfile] = useState<CachedProfile | null>(null)
  const [etag, setEtag] = useState<string>('W/"1"')
  const [displayName, setDisplayName] = useState('')
  const [loading, setLoading] = useState(false)
  const [fromCache, setFromCache] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // 从 API 获取资料
  const fetchProfile = useCallback(async () => {
    if (!isOnline) {
      setError(t('common.offline', '当前处于离线状态'))
      return
    }

    setLoading(true)
    setError(null)

    try {
      const at = localStorage.getItem('access_token')
      const res = await fetch('/api/v1/profile/me', {
        headers: { Authorization: `Bearer ${at}` },
      })

      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`)
      }

      const j = await res.json()
      const profileData = j.data

      // 更新状态
      setProfile(profileData)
      setEtag(profileData.etag || 'W/"1"')
      setDisplayName(profileData.display_name || '')
      setFromCache(false)

      // 保存到缓存
      const cacheData = { ...profileData, cached_at: Date.now() }
      localStorage.setItem('profile_cache', JSON.stringify(cacheData))
    } catch (err) {
      console.error('[ProfilePage] Fetch failed:', err)
      setError(t('profile.fetchError', '获取资料失败'))
    } finally {
      setLoading(false)
    }
  }, [isOnline, t])

  // 从缓存加载
  const loadFromCache = useCallback(async () => {
    try {
      const stored = localStorage.getItem('profile_cache')
      if (stored) {
        const cached = JSON.parse(stored) as CachedProfile
        setProfile(cached)
        setEtag(cached.etag || 'W/"1"')
        setDisplayName(cached.display_name || '')
        setFromCache(true)
        console.log('[ProfilePage] Loaded from cache')
        return true
      }
    } catch (err) {
      console.error('[ProfilePage] Cache load failed:', err)
    }
    return false
  }, [])

  // 初始加载：先读缓存，再尝试网络
  useEffect(() => {
    const init = async () => {
      // 先尝试从缓存加载
      const hasCache = await loadFromCache()

      // 如果在线，尝试获取最新数据
      if (isOnline) {
        await fetchProfile()
      } else if (!hasCache) {
        setError(t('profile.noCache', '离线状态且无缓存数据'))
      }
    }

    init()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []) // 只在挂载时执行

  // 网络恢复时刷新
  useEffect(() => {
    if (isOnline && fromCache) {
      fetchProfile()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOnline])

  // 保存资料
  const handleSave = async () => {
    if (!isOnline) {
      setError(t('common.offline', '离线状态无法保存'))
      return
    }

    setLoading(true)
    try {
      const at = localStorage.getItem('access_token')
      const updateRes = await fetch('/api/v1/profile/me', {
        method: 'PATCH',
        headers: {
          Authorization: `Bearer ${at}`,
          'If-Match': etag,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ display_name: displayName }),
      })

      if (!updateRes.ok) {
        throw new Error(`Update failed: ${updateRes.status}`)
      }

      // 重新获取最新数据
      await fetchProfile()
    } catch (err) {
      console.error('[ProfilePage] Save failed:', err)
      setError(t('profile.saveError', '保存失败'))
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="p-4 max-w-md mx-auto">
      {/* 标题栏 */}
      <div className="flex items-center justify-between mb-6">
        <h1 className="typography-large-title flex items-center gap-2">
          <User className="w-6 h-6" />
          {t('profile.title')}
        </h1>

        {/* 离线状态指示器 */}
        {!isOnline && (
          <div className="flex items-center gap-1 text-amber-600 text-sm">
            <WifiOff className="w-4 h-4" />
            <span>{t('common.offline', '离线')}</span>
          </div>
        )}
      </div>

      {/* 缓存提示 */}
      {fromCache && (
        <div className="mb-4 p-3 bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg text-sm text-amber-700 dark:text-amber-300">
          {t('profile.fromCache', '显示缓存数据')}
          {profile?.cached_at && (
            <span className="ml-2 text-xs opacity-70">
              ({new Date(profile.cached_at).toLocaleString()})
            </span>
          )}
        </div>
      )}

      {/* 错误提示 */}
      {error && (
        <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-sm text-red-700 dark:text-red-300">
          {error}
        </div>
      )}

      {/* 获取资料按钮 */}
      {!profile && (
        <Button
          onClick={fetchProfile}
          disabled={loading || !isOnline}
          className="mb-4"
        >
          {loading ? (
            <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
          ) : null}
          {t('profile.get')}
        </Button>
      )}

      {/* 资料表单 */}
      {profile && (
        <div className="space-y-4">
          {/* 邮箱（只读） */}
          <div>
            <label className="block text-sm font-medium mb-1 text-muted-foreground">
              {t('profile.email', '邮箱')}
            </label>
            <Input
              value={profile.email || ''}
              disabled
              className="bg-muted"
            />
          </div>

          {/* 昵称（可编辑） */}
          <div>
            <label className="block text-sm font-medium mb-1">
              {t('profile.name')}
            </label>
            <Input
              value={displayName}
              onChange={(e) => setDisplayName(e.target.value)}
              disabled={!isOnline}
              placeholder={t('profile.namePlaceholder', '输入昵称')}
            />
          </div>

          {/* 会员等级（只读） */}
          <div>
            <label className="block text-sm font-medium mb-1 text-muted-foreground">
              {t('profile.tier', '会员等级')}
            </label>
            <Input
              value={profile.tier || 'free'}
              disabled
              className="bg-muted capitalize"
            />
          </div>

          {/* 保存按钮 */}
          <Button
            onClick={handleSave}
            disabled={loading || !isOnline}
            className="w-full"
          >
            {loading ? (
              <RefreshCw className="w-4 h-4 mr-2 animate-spin" />
            ) : null}
            {t('profile.save')}
          </Button>

          {/* 刷新按钮 */}
          <Button
            variant="outline"
            onClick={fetchProfile}
            disabled={loading || !isOnline}
            className="w-full"
          >
            <RefreshCw className={`w-4 h-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
            {t('profile.refresh', '刷新')}
          </Button>
        </div>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/BillingPage.tsx
==================================================

import { useEffect, useState, useCallback } from 'react'

export default function BillingPage() {
  const [balance, setBalance] = useState<any>(null)
  const [ledger, setLedger] = useState<any[]>([])
  const at = typeof window !== 'undefined' ? localStorage.getItem('access_token') || '' : ''
  const fetchJson = useCallback(async (url: string) => {
    const r = await fetch(url, { headers: { Authorization: `Bearer ${at}` } })
    return r.json()
  }, [at])
  useEffect(() => {
    const load = async () => {
      const b = await fetchJson('/api/v1/billing/balance')
      setBalance(b.data)
      const l = await fetchJson('/api/v1/billing/ledger')
      setLedger(l.data || [])
    }
    load()
  }, [fetchJson])
  return (
    <div style={{ padding: 16 }}>
      <h2>余额</h2>
      {balance && (
        <div>
          <div>Credits: {balance.balance}</div>
          <div>钱包: {balance.wallet_amount} {balance.wallet_currency}</div>
        </div>
      )}
      <h2 style={{ marginTop: 12 }}>账单</h2>
      <ul>
        {ledger.map((x, i) => (
          <li key={i}>{x.direction} {x.amount} {x.currency} {x.reason}</li>
        ))}
      </ul>
    </div>
  )
}

==================================================
FILE_PATH: web/src/pages/RecentlyDeletedPage.tsx
==================================================

/**
 * 最近删除页面
 * 
 * 显示用户软删除的书籍（30天内可恢复）
 * 
 * 功能：
 * - 仅显示封面图（无标题和作者）
 * - 点击封面恢复书籍
 * - 批量选择和操作（恢复/永久删除）
 * - 永久删除仅删除用户私人数据，保留公共数据
 * 
 * @see 06 - UIUX设计系统UI_UX_Design_system.md
 */

import { useCallback, useMemo, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTranslation } from 'react-i18next'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, usePowerSyncState } from '@/lib/powersync'
import { useAuthStore } from '@/stores/auth'
import { ArrowLeft, Trash2, RotateCcw, Clock, CheckCircle2, Square, CheckSquare } from 'lucide-react'
import { cn } from '@/lib/utils'
import { toast } from '@/components/ui/sonner'
import { Button } from '@/components/ui/button'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'

// ============================================================================
// 类型定义
// ============================================================================

interface DeletedBookRow {
  id: string
  title: string
  author: string | null
  cover_url: string | null
  deleted_at: string
}

interface DeletedBookItem {
  id: string
  title: string
  author?: string
  coverUrl?: string
  deletedAt: Date
  daysRemaining: number
}

// ============================================================================
// 组件
// ============================================================================

export default function RecentlyDeletedPage() {
  const { t } = useTranslation('common')
  const navigate = useNavigate()
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const accessToken = useAuthStore(s => s.accessToken)

  // 选择状态
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set())
  const [isSelectionMode, setIsSelectionMode] = useState(false)
  const [confirmDeleteOpen, setConfirmDeleteOpen] = useState(false)
  // 单本删除确认状态
  const [singleDeleteBook, setSingleDeleteBook] = useState<DeletedBookItem | null>(null)

  const isReady = isInitialized && db !== null

  // 查询已删除的书籍（30天内）
  const EMPTY_QUERY = 'SELECT * FROM books WHERE 1=0'
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()
  const deletedBooksQuery = isReady
    ? `SELECT id, title, author, cover_url, deleted_at 
       FROM books 
       WHERE deleted_at IS NOT NULL 
       AND deleted_at > '${thirtyDaysAgo}'
       ORDER BY deleted_at DESC`
    : EMPTY_QUERY

  const { data: deletedBooksData, isLoading } = useQuery<DeletedBookRow>(deletedBooksQuery, [])

  // 转换数据
  const items: DeletedBookItem[] = useMemo(() => {
    if (!deletedBooksData) return []

    const token = accessToken || localStorage.getItem('access_token') || ''
    const now = new Date()

    return deletedBooksData.map(book => {
      const deletedAt = new Date(book.deleted_at)
      const expiryDate = new Date(deletedAt.getTime() + 30 * 24 * 60 * 60 * 1000)
      const daysRemaining = Math.max(0, Math.ceil((expiryDate.getTime() - now.getTime()) / (24 * 60 * 60 * 1000)))

      return {
        id: book.id,
        title: book.title || '未命名',
        author: book.author || undefined,
        coverUrl: book.id && token
          ? `/api/v1/books/${book.id}/cover?token=${encodeURIComponent(token)}`
          : undefined,
        deletedAt,
        daysRemaining,
      }
    })
  }, [deletedBooksData, accessToken])

  // 恢复单本书籍
  const handleRestore = useCallback(async (bookId: string, bookTitle: string) => {
    if (!db) return

    try {
      console.log('[RecentlyDeleted] Restoring book:', bookId)
      await db.execute(
        'UPDATE books SET deleted_at = NULL, updated_at = ? WHERE id = ?',
        [new Date().toISOString(), bookId]
      )
      
      toast.success(t('recently_deleted.restore_success', { title: bookTitle }))
    } catch (error) {
      console.error('[RecentlyDeleted] Restore failed:', error)
      toast.error(t('recently_deleted.restore_failed'))
    }
  }, [db, t])

  // 批量恢复
  const handleBatchRestore = useCallback(async () => {
    if (!db || selectedIds.size === 0) return

    try {
      const now = new Date().toISOString()
      for (const bookId of selectedIds) {
        await db.execute(
          'UPDATE books SET deleted_at = NULL, updated_at = ? WHERE id = ?',
          [now, bookId]
        )
      }
      
      toast.success(t('recently_deleted.batch_restore_success', { count: selectedIds.size }))
      setSelectedIds(new Set())
      setIsSelectionMode(false)
    } catch (error) {
      console.error('[RecentlyDeleted] Batch restore failed:', error)
      toast.error(t('recently_deleted.restore_failed'))
    }
  }, [db, selectedIds, t])

  // 永久删除（仅删除用户私人数据）
  const handlePermanentDelete = useCallback(async () => {
    if (!db || selectedIds.size === 0) return

    try {
      for (const bookId of selectedIds) {
        // 删除用户私人数据：笔记、高亮、书签、阅读进度、书架关联
        // 不删除：MinIO文件、封面、OCR结果、向量索引（公共数据）
        await db.execute('DELETE FROM notes WHERE book_id = ?', [bookId])
        await db.execute('DELETE FROM highlights WHERE book_id = ?', [bookId])
        await db.execute('DELETE FROM bookmarks WHERE book_id = ?', [bookId])
        await db.execute('DELETE FROM reading_progress WHERE book_id = ?', [bookId])
        await db.execute('DELETE FROM reading_sessions WHERE book_id = ?', [bookId])
        await db.execute('DELETE FROM shelf_books WHERE book_id = ?', [bookId])
        
        // 硬删除书籍记录
        await db.execute('DELETE FROM books WHERE id = ?', [bookId])
      }
      
      toast.success(t('recently_deleted.delete_success', { count: selectedIds.size }))
      setSelectedIds(new Set())
      setIsSelectionMode(false)
      setConfirmDeleteOpen(false)
    } catch (error) {
      console.error('[RecentlyDeleted] Permanent delete failed:', error)
      toast.error(t('recently_deleted.delete_failed'))
    }
  }, [db, selectedIds, t])

  // 单本书籍永久删除
  const handleSinglePermanentDelete = useCallback(async () => {
    if (!db || !singleDeleteBook) return

    try {
      const bookId = singleDeleteBook.id
      // 删除用户私人数据
      await db.execute('DELETE FROM notes WHERE book_id = ?', [bookId])
      await db.execute('DELETE FROM highlights WHERE book_id = ?', [bookId])
      await db.execute('DELETE FROM bookmarks WHERE book_id = ?', [bookId])
      await db.execute('DELETE FROM reading_progress WHERE book_id = ?', [bookId])
      await db.execute('DELETE FROM reading_sessions WHERE book_id = ?', [bookId])
      await db.execute('DELETE FROM shelf_books WHERE book_id = ?', [bookId])
      
      // 硬删除书籍记录
      await db.execute('DELETE FROM books WHERE id = ?', [bookId])
      
      toast.success(t('recently_deleted.delete_success', { count: 1 }))
      setSingleDeleteBook(null)
    } catch (error) {
      console.error('[RecentlyDeleted] Single permanent delete failed:', error)
      toast.error(t('recently_deleted.delete_failed'))
    }
  }, [db, singleDeleteBook, t])

  // 切换选择
  const toggleSelect = useCallback((bookId: string) => {
    setSelectedIds(prev => {
      const next = new Set(prev)
      if (next.has(bookId)) {
        next.delete(bookId)
      } else {
        next.add(bookId)
      }
      return next
    })
  }, [])

  // 全选/取消全选
  const toggleSelectAll = useCallback(() => {
    if (selectedIds.size === items.length) {
      setSelectedIds(new Set())
    } else {
      setSelectedIds(new Set(items.map(b => b.id)))
    }
  }, [selectedIds.size, items])

  // 卡片点击处理
  const handleCardClick = useCallback((book: DeletedBookItem) => {
    if (isSelectionMode) {
      toggleSelect(book.id)
    } else {
      handleRestore(book.id, book.title)
    }
  }, [isSelectionMode, toggleSelect, handleRestore])

  // 渲染加载状态
  if (!isReady || isLoading) {
    return (
      <div className="container mx-auto px-4 py-6 pb-24 md:pb-6 max-w-7xl animate-in fade-in duration-300">
        <div className="flex items-center gap-3 mb-6">
          <button
            onClick={() => navigate(-1)}
            className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg transition-colors"
          >
            <ArrowLeft className="h-5 w-5" />
          </button>
          <h1 className="text-2xl font-bold">{t('recently_deleted.title')}</h1>
        </div>
        <div className="flex items-center justify-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-6 pb-24 md:pb-6 max-w-7xl animate-in fade-in duration-300">
      {/* 顶部导航 */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <button
            onClick={() => navigate(-1)}
            className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg transition-colors"
          >
            <ArrowLeft className="h-5 w-5" />
          </button>
          <div>
            <h1 className="text-2xl font-bold">{t('recently_deleted.title')}</h1>
            <p className="text-sm text-muted-foreground mt-1">
              {t('recently_deleted.subtitle')}
            </p>
          </div>
        </div>

        {/* 选择模式切换 */}
        {items.length > 0 && (
          <Button
            variant={isSelectionMode ? 'default' : 'outline'}
            size="sm"
            onClick={() => {
              setIsSelectionMode(!isSelectionMode)
              if (isSelectionMode) {
                setSelectedIds(new Set())
              }
            }}
          >
            {isSelectionMode ? (
              <>
                <CheckCircle2 className="h-4 w-4 mr-2" />
                {t('common.cancel')}
              </>
            ) : (
              <>
                <Square className="h-4 w-4 mr-2" />
                {t('recently_deleted.select')}
              </>
            )}
          </Button>
        )}
      </div>

      {/* 选择模式工具栏 */}
      {isSelectionMode && items.length > 0 && (
        <div className="flex items-center justify-between mb-4 p-3 bg-muted/50 rounded-lg">
          <div className="flex items-center gap-3">
            <Button
              variant="ghost"
              size="sm"
              onClick={toggleSelectAll}
            >
              {selectedIds.size === items.length ? (
                <>
                  <CheckSquare className="h-4 w-4 mr-2" />
                  {t('recently_deleted.deselect_all')}
                </>
              ) : (
                <>
                  <Square className="h-4 w-4 mr-2" />
                  {t('recently_deleted.select_all')}
                </>
              )}
            </Button>
            <span className="text-sm text-muted-foreground">
              {t('recently_deleted.selected_count', { count: selectedIds.size })}
            </span>
          </div>
          
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              disabled={selectedIds.size === 0}
              onClick={handleBatchRestore}
            >
              <RotateCcw className="h-4 w-4 mr-2" />
              {t('recently_deleted.batch_restore')}
            </Button>
            <Button
              variant="destructive"
              size="sm"
              disabled={selectedIds.size === 0}
              onClick={() => setConfirmDeleteOpen(true)}
            >
              <Trash2 className="h-4 w-4 mr-2" />
              {t('recently_deleted.batch_delete')}
            </Button>
          </div>
        </div>
      )}

      {/* 空状态 */}
      {items.length === 0 && (
        <div className="flex flex-col items-center justify-center h-64 text-muted-foreground">
          <Trash2 className="h-12 w-12 mb-4 opacity-20" />
          <p>{t('recently_deleted.empty')}</p>
        </div>
      )}

      {/* 书籍网格 - 只显示封面 */}
      {items.length > 0 && (
        <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8 gap-3 sm:gap-4">
          {items.map(book => (
            <DeletedBookCard
              key={book.id}
              book={book}
              isSelected={selectedIds.has(book.id)}
              isSelectionMode={isSelectionMode}
              onClick={() => handleCardClick(book)}
              onPermanentDelete={() => setSingleDeleteBook(book)}
            />
          ))}
        </div>
      )}

      {/* 确认删除对话框 - 批量 */}
      <AlertDialog open={confirmDeleteOpen} onOpenChange={setConfirmDeleteOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{t('recently_deleted.confirm_delete_title')}</AlertDialogTitle>
            <AlertDialogDescription>
              {t('recently_deleted.confirm_delete_message', { count: selectedIds.size })}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>{t('common.cancel')}</AlertDialogCancel>
            <AlertDialogAction
              onClick={handlePermanentDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {t('recently_deleted.batch_delete')}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* 确认删除对话框 - 单本 */}
      <AlertDialog open={singleDeleteBook !== null} onOpenChange={(open) => !open && setSingleDeleteBook(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{t('recently_deleted.confirm_delete_title')}</AlertDialogTitle>
            <AlertDialogDescription>
              {t('recently_deleted.confirm_delete_single', { title: singleDeleteBook?.title })}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>{t('common.cancel')}</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleSinglePermanentDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {t('recently_deleted.batch_delete')}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  )
}

// ============================================================================
// 已删除书籍卡片组件 - 仅显示封面
// ============================================================================

interface DeletedBookCardProps {
  book: DeletedBookItem
  isSelected: boolean
  isSelectionMode: boolean
  onClick: () => void
  onPermanentDelete: () => void
}

function DeletedBookCard({ book, isSelected, isSelectionMode, onClick, onPermanentDelete }: DeletedBookCardProps) {
  const { t } = useTranslation('common')

  // 处理永久删除按钮点击，阻止冒泡
  const handleDeleteClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation()
    onPermanentDelete()
  }, [onPermanentDelete])

  return (
    <div
      className={cn(
        'relative cursor-pointer',
        'transition-all duration-200 hover:scale-[1.02]',
        isSelected && 'ring-2 ring-primary ring-offset-2 rounded-lg'
      )}
      onClick={onClick}
    >
      {/* 封面图 - 只显示封面，无标题作者 */}
      <div className="relative aspect-[2/3] rounded-lg overflow-hidden shadow-md bg-gray-200 dark:bg-gray-700">
        {book.coverUrl ? (
          <img
            src={book.coverUrl}
            alt={book.title}
            className="w-full h-full object-cover opacity-60"
            loading="lazy"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-muted-foreground">
            <Trash2 className="h-8 w-8 opacity-30" />
          </div>
        )}

        {/* 恢复覆盖层 - 非选择模式显示 */}
        {!isSelectionMode && (
          <div className="absolute inset-0 bg-black/50 flex flex-col items-center justify-center">
            <RotateCcw className="h-6 w-6 text-white mb-1" />
            <span className="text-white font-medium text-xs">
              {t('recently_deleted.tap_to_restore')}
            </span>
          </div>
        )}

        {/* 选择模式覆盖层 */}
        {isSelectionMode && (
          <div className={cn(
            'absolute inset-0 flex items-center justify-center transition-colors',
            isSelected ? 'bg-primary/30' : 'bg-black/30'
          )}>
            {isSelected ? (
              <CheckCircle2 className="h-8 w-8 text-white" />
            ) : (
              <Square className="h-8 w-8 text-white/70" />
            )}
          </div>
        )}

        {/* 剩余天数标签 */}
        <div className="absolute top-1 right-1 bg-black/70 text-white text-[10px] px-1.5 py-0.5 rounded-full flex items-center gap-0.5">
          <Clock className="h-2.5 w-2.5" />
          <span>{book.daysRemaining}{t('recently_deleted.days')}</span>
        </div>

        {/* 永久删除按钮 - 非选择模式显示在左上角 */}
        {!isSelectionMode && (
          <button
            onClick={handleDeleteClick}
            className="absolute top-1 left-1 p-1.5 bg-red-500/90 hover:bg-red-600 text-white rounded-full transition-colors shadow-md"
            title={t('recently_deleted.batch_delete')}
          >
            <Trash2 className="h-3 w-3" />
          </button>
        )}
      </div>

      {/* 不显示书籍标题和作者 - 按设计规范 */}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/ExportPage.tsx
==================================================

import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
export default function ExportPage() {
  const { t } = useTranslation()
  const [jobs, setJobs] = useState<any[]>([])
  const [link, setLink] = useState<string>('')
  useEffect(() => {
    const token = localStorage.getItem('access_token') || ''
    fetch('/api/v1/ocr/jobs', { headers: { Authorization: `Bearer ${token}` } })
      .then(r => r.json()).then(d => setJobs(d.data || []))
  }, [])
  const doExport = async (jobId: string, fmt: string) => {
    const token = localStorage.getItem('access_token') || ''
    const r = await fetch(`/api/v1/export/ocr/${jobId}?format=${fmt}`, { headers: { Authorization: `Bearer ${token}` } })
    const j = await r.json()
    setLink(j?.data?.download_url || '')
  }
  return (
    <div style={{ padding: 24 }}>
      <h1>{t('export.title')}</h1>
      <div>
        {jobs.map((j: any) => (
          <div key={j.id} style={{ marginBottom: 8 }}>
            <span>{j.id}</span>
            <button onClick={() => doExport(j.id, 'txt')} style={{ marginLeft: 8 }}>{t('export.txt')}</button>
            <button onClick={() => doExport(j.id, 'md')} style={{ marginLeft: 8 }}>{t('export.md')}</button>
            <button onClick={() => doExport(j.id, 'pdf')} style={{ marginLeft: 8 }}>{t('export.pdf')}</button>
          </div>
        ))}
      </div>
      {link && <a href={link} target="_blank" rel="noreferrer">{t('export.download_link')}</a>}
    </div>
  )
}

==================================================
FILE_PATH: web/src/pages/DocEditor.tsx
==================================================

import { useEffect, useRef, useState } from 'react'
import { useParams } from 'react-router-dom'
import { useTranslation } from 'react-i18next'

export default function DocEditor() {
  const { t } = useTranslation()
  const { docId } = useParams()
  const [content, setContent] = useState('')
  const [version, setVersion] = useState(0)
  const [conflicts, setConflicts] = useState<any[]>([])
  const wsRef = useRef<WebSocket | null>(null)
  useEffect(() => {
    if (!docId) return
    const ws = new WebSocket(`ws://${location.host}/ws/docs/${docId}`)
    wsRef.current = ws
    ;(window as any).__sendDoc = (base: number, text: string) => {
      const sendNow = () => {
        if (!wsRef.current) return
        const payload = JSON.stringify({ base_version: base, content: text })
        wsRef.current.send(payload)
      }
      if (ws.readyState === WebSocket.OPEN) sendNow()
      else ws.addEventListener('open', sendNow, { once: true })
    }
    ws.onmessage = ev => {
      try {
        const obj = JSON.parse(ev.data)
        if (typeof obj.version === 'number') setVersion(obj.version)
        if (typeof obj.content === 'string') setContent(obj.content)
      } catch {
        setContent(ev.data)
      }
    }
    return () => { ws.close() }
  }, [docId])
  const send = () => {
    if (!wsRef.current) return
    const payload = JSON.stringify({ base_version: version, content })
    wsRef.current.send(payload)
  }
  const loadConflicts = async () => {
    if (!docId) return
    const at = localStorage.getItem('access_token') || ''
    const r = await fetch(`/api/v1/docs/${docId}/conflicts`, { headers: { Authorization: `Bearer ${at}` } })
    const j = await r.json()
    setConflicts(j.data || [])
  }
  const recoverDraft = async () => {
    if (!docId) return
    const at = localStorage.getItem('access_token') || ''
    const r = await fetch(`/api/v1/docs/${docId}/draft/recover`, { method: 'POST', headers: { Authorization: `Bearer ${at}` } })
    const j = await r.json()
    if (j.data && j.data.snapshot) setContent(j.data.snapshot)
  }
  return (
    <div style={{ padding: 16 }}>
      <div style={{ marginBottom: 8 }}>{t('doc.version')} {version}</div>
      <textarea value={content} onChange={e => setContent(e.target.value)} style={{ width: '100%', height: 300 }} />
      <div style={{ marginTop: 8 }}>
        <button onClick={send}>{t('doc.send')}</button>
        <button onClick={loadConflicts} style={{ marginLeft: 8 }}>{t('doc.conflicts')}</button>
        <button onClick={recoverDraft} style={{ marginLeft: 8 }}>{t('doc.recover')}</button>
      </div>
      {conflicts.length > 0 && (
        <div style={{ marginTop: 8 }}>{t('doc.conflicts')} {conflicts.length}</div>
      )}
    </div>
  )
}

==================================================
FILE_PATH: web/src/pages/LibraryPage.tsx
==================================================

/**
 * 书库页面 (App-First 版)
 *
 * 设计规范：
 * - 无搜索栏（搜索在专门的搜索页面）
 * - 右上角：上传按钮（圆形+图标）+ 三个点菜单（无边框）
 * - 三个点菜单包含：视图模式 + 排序方式
 * 
 * @see 06 - UIUX设计系统UI_UX_Design_system.md
 */
import { useEffect, useState, useMemo, useCallback } from 'react'
import { useNavigate } from 'react-router-dom'
import BookCard from '../components/BookCard'
import UploadManager from '../components/upload/UploadManager'
import { useTranslation } from 'react-i18next'
import { useAuthStore } from '@/stores/auth'
import { useBooksData, useShelvesWithBooks } from '@/hooks/useBooksData'
import { useBookFileCache } from '@/hooks/useBookFileCache'
import { useOnlineStatus } from '@/hooks/useOnlineStatus'
import { toast } from '@/components/ui/sonner'
import { MoreVertical, Grid3X3, List, Clock, BookOpen, User, Upload, WifiOff, RefreshCw, Plus, Layers } from 'lucide-react'
import { Button } from '@/components/ui/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
} from "@/components/ui/dropdown-menu"

type ViewMode = 'grid' | 'list' | 'shelf'
type SortBy = 'recent' | 'title' | 'author' | 'upload'

// localStorage key 用于持久化视图模式
const VIEW_MODE_STORAGE_KEY = 'athena_library_view_mode'
const SORT_BY_STORAGE_KEY = 'athena_library_sort_by'

export default function LibraryPage() {
  const { t } = useTranslation('common')
  const navigate = useNavigate()
  const { isOnline } = useOnlineStatus()
  const accessToken = useAuthStore((s) => s.accessToken)
  
  // 视图状态（从 localStorage 恢复）
  const [viewMode, setViewMode] = useState<ViewMode>(() => {
    const saved = localStorage.getItem(VIEW_MODE_STORAGE_KEY)
    return (saved === 'grid' || saved === 'list' || saved === 'shelf') ? saved : 'grid'
  })
  const [sortBy, setSortBy] = useState<SortBy>(() => {
    const saved = localStorage.getItem(SORT_BY_STORAGE_KEY)
    return (saved === 'recent' || saved === 'title' || saved === 'author' || saved === 'upload') ? saved : 'recent'
  })

  // 数据源 (PowerSync) - 不使用搜索，搜索在专门的搜索页面
  const { 
    items, 
    isLoading, 
    stats, 
    hasProcessing, 
    refresh
  } = useBooksData({
    sortBy
  })

  // 书架视图数据
  const { 
    shelves, 
    unshelvedBooks, 
    isLoading: shelvesLoading 
  } = useShelvesWithBooks()

  // 本地文件缓存状态
  const bookIds = useMemo(() => items.map(item => item.id), [items])
  const { getBookCacheStatus, markDownloading, markDownloaded } = useBookFileCache(bookIds)

  // 持久化视图模式和排序方式
  useEffect(() => {
    localStorage.setItem(VIEW_MODE_STORAGE_KEY, viewMode)
  }, [viewMode])

  useEffect(() => {
    localStorage.setItem(SORT_BY_STORAGE_KEY, sortBy)
  }, [sortBy])

  // 监听上传事件，自动刷新书库
  useEffect(() => {
    const handleBookUploaded = () => {
      console.log('[LibraryPage] Book uploaded, refreshing library...')
      refresh()
    }
    
    window.addEventListener('book_uploaded', handleBookUploaded)
    return () => window.removeEventListener('book_uploaded', handleBookUploaded)
  }, [refresh])

  // 后台下载书籍（缓存文件到 IndexedDB）
  const handleSyncBook = useCallback(async (bookId: string) => {
    if (!isOnline) {
      toast.error(t('offline.sync_unavailable', '离线状态无法下载书籍'))
      return
    }
    
    const token = accessToken || localStorage.getItem('access_token') || ''
    if (!token) return
    
    markDownloading(bookId)
    
    try {
      const contentUrl = `/api/v1/books/${bookId}/content?token=${encodeURIComponent(token)}`
      const response = await fetch(contentUrl)
      
      if (!response.ok) {
        throw new Error(`Download failed: ${response.status}`)
      }
      
      const blob = await response.blob()
      const contentType = response.headers.get('Content-Type') || ''
      const format = contentType.includes('pdf') ? 'pdf' : 'epub'
      const etag = response.headers.get('ETag') || undefined
      
      // 动态导入以避免循环依赖
      const { saveBookFile } = await import('@/lib/bookStorage')
      await saveBookFile(bookId, blob, format as 'epub' | 'pdf', etag)
      
      markDownloaded(bookId)
      toast.success(t('library.download_success', '书籍已下载到本地'))
    } catch (error) {
      console.error(`[LibraryPage] Failed to sync book ${bookId}:`, error)
      markDownloaded(bookId) // 移除下载状态
      toast.error(t('library.download_failed', '下载失败'))
    }
  }, [isOnline, t, accessToken, markDownloading, markDownloaded])

  // 处理书籍点击
  const handleBookClick = useCallback((bookId: string) => {
    const cacheStatus = getBookCacheStatus(bookId)
    
    if (cacheStatus === 'downloading') {
      toast.info(t('offline.book_downloading', '书籍正在下载中...'))
      return
    }
    
    // 如果离线且未缓存，无法阅读
    if (!isOnline && cacheStatus !== 'ready') {
      toast.error(t('offline.book_not_cached', '未缓存书籍无法离线阅读'))
      return
    }
    
    navigate(`/app/read/${bookId}`)
  }, [isOnline, getBookCacheStatus, navigate, t])

  // 渲染书架视图
  const renderShelfView = () => {
    if (shelvesLoading) {
      return (
        <div className="flex items-center justify-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      )
    }

    const hasShelves = shelves.length > 0
    const hasUnshelved = unshelvedBooks.length > 0

    if (!hasShelves && !hasUnshelved) {
      return (
        <div className="flex flex-col items-center justify-center h-64 text-muted-foreground">
          <Layers className="h-12 w-12 mb-4 opacity-20" />
          <p>{t('library.no_shelves', '暂无书架')}</p>
          <p className="text-sm mt-2">{t('library.create_shelf_hint', '点击书籍菜单创建书架')}</p>
        </div>
      )
    }

    return (
      <div className="space-y-8">
        {/* 已分组的书架 */}
        {shelves.map(shelf => (
          <div key={shelf.id} className="space-y-3">
            <div className="flex items-center gap-2">
              <Layers className="h-5 w-5 text-muted-foreground" />
              <h2 className="text-lg font-semibold">{shelf.name}</h2>
              <span className="text-sm text-muted-foreground">({shelf.books.length})</span>
            </div>
            {shelf.books.length > 0 ? (
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 sm:gap-6">
                {shelf.books.map(book => (
                  <BookCard
                    key={book.id}
                    book={book}
                    viewMode="grid"
                    onClick={() => handleBookClick(book.id)}
                    onDownload={() => handleSyncBook(book.id)}
                    cacheStatus={getBookCacheStatus(book.id)}
                    isOnline={isOnline}
                  />
                ))}
              </div>
            ) : (
              <p className="text-sm text-muted-foreground pl-7">{t('library.shelf_empty', '此书架暂无书籍')}</p>
            )}
          </div>
        ))}

        {/* 未分组书籍 */}
        {hasUnshelved && (
          <div className="space-y-3">
            <div className="flex items-center gap-2">
              <BookOpen className="h-5 w-5 text-muted-foreground" />
              <h2 className="text-lg font-semibold">{t('library.unshelved', '未分组')}</h2>
              <span className="text-sm text-muted-foreground">({unshelvedBooks.length})</span>
            </div>
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 sm:gap-6">
              {unshelvedBooks.map(book => (
                <BookCard
                  key={book.id}
                  book={book}
                  viewMode="grid"
                  onClick={() => handleBookClick(book.id)}
                  onDownload={() => handleSyncBook(book.id)}
                  cacheStatus={getBookCacheStatus(book.id)}
                  isOnline={isOnline}
                />
              ))}
            </div>
          </div>
        )}
      </div>
    )
  }

  // 渲染内容
  const renderContent = () => {
    // 书架视图单独处理
    if (viewMode === 'shelf') {
      return renderShelfView()
    }

    if (isLoading && items.length === 0) {
      return (
        <div className="flex items-center justify-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      )
    }

    if (items.length === 0) {
      return (
        <div className="flex flex-col items-center justify-center h-64 text-muted-foreground">
          <BookOpen className="h-12 w-12 mb-4 opacity-20" />
          <p>{t('library.empty')}</p>
          <p className="text-sm mt-2">{t('library.upload_hint')}</p>
        </div>
      )
    }

    return (
      <div className={viewMode === 'grid' 
        ? "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 sm:gap-6"
        : "flex flex-col space-y-2"
      }>
        {items.map((book) => (
          <BookCard
            key={book.id}
            book={book}
            viewMode={viewMode === 'list' ? 'list' : 'grid'}
            onClick={() => handleBookClick(book.id)}
            onDownload={() => handleSyncBook(book.id)}
            cacheStatus={getBookCacheStatus(book.id)}
            isOnline={isOnline}
          />
        ))}
      </div>
    )
  }

  return (
    <div className="container mx-auto px-4 py-6 pb-24 md:pb-6 max-w-7xl">
      {/* 顶部栏 */}
      <div className="flex justify-between items-start mb-6">
        {/* 左侧：标题和统计 */}
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            {t('nav.library', '我的书库')}
            {!isOnline && <WifiOff className="h-4 w-4 text-muted-foreground" />}
          </h1>
          <p className="text-sm text-muted-foreground mt-1">
            {stats.total} {t('common.books', '本书籍')} 
            {stats.inProgress > 0 && ` · ${stats.inProgress} ${t('library.reading', '正在阅读')}`}
          </p>
        </div>

        {/* 右侧：上传按钮（圆形+图标）+ 三个点菜单 */}
        <div className="flex items-center gap-3">
          <UploadManager variant="icon" />

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button
                className="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg transition-colors"
                aria-label={t('library.menu', '菜单')}
              >
                <MoreVertical className="h-5 w-5 text-gray-700 dark:text-gray-300" />
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="min-w-[180px]">
              <DropdownMenuLabel>{t('library.view_mode', '视图模式')}</DropdownMenuLabel>
              <DropdownMenuRadioGroup value={viewMode} onValueChange={(v) => setViewMode(v as ViewMode)}>
                <DropdownMenuRadioItem value="grid">
                  <Grid3X3 className="mr-2 h-4 w-4" /> {t('library.view_grid', '网格')}
                </DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="list">
                  <List className="mr-2 h-4 w-4" /> {t('library.view_list', '列表')}
                </DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="shelf">
                  <Layers className="mr-2 h-4 w-4" /> {t('library.view_shelf', '书架')}
                </DropdownMenuRadioItem>
              </DropdownMenuRadioGroup>
              
              <DropdownMenuSeparator />
              
              <DropdownMenuLabel>{t('library.sort_by', '排序方式')}</DropdownMenuLabel>
              <DropdownMenuRadioGroup value={sortBy} onValueChange={(v) => setSortBy(v as SortBy)}>
                <DropdownMenuRadioItem value="recent">
                  <Clock className="mr-2 h-4 w-4" /> {t('library.sort_recent', '最近阅读')}
                </DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="upload">
                  <Upload className="mr-2 h-4 w-4" /> {t('library.sort_upload', '最近上传')}
                </DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="title">
                  <BookOpen className="mr-2 h-4 w-4" /> {t('library.sort_title', '标题')}
                </DropdownMenuRadioItem>
                <DropdownMenuRadioItem value="author">
                  <User className="mr-2 h-4 w-4" /> {t('library.sort_author', '作者')}
                </DropdownMenuRadioItem>
              </DropdownMenuRadioGroup>

              <DropdownMenuSeparator />
              
              <DropdownMenuItem onClick={() => refresh()}>
                <RefreshCw className="mr-2 h-4 w-4" /> {t('common.refresh', '刷新')}
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      {/* 处理中提示 */}
      {hasProcessing && (
        <div className="bg-blue-50 dark:bg-blue-900/20 text-blue-600 dark:text-blue-400 px-4 py-2 rounded-md mb-4 text-sm flex items-center animate-pulse">
          <RefreshCw className="h-3 w-3 mr-2 animate-spin" />
          {t('library.processing_books', '正在处理上传的书籍...')}
        </div>
      )}

      {/* 书籍列表 */}
      {renderContent()}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/LoginPage.tsx
==================================================

/**
 * LoginPage - 登录页面
 *
 * 用途：
 * - 发送邮箱验证码并校验登录
 * - 成功后写入本地令牌（LocalStorage）并跳转首页
 *
 * 说明：App-First 架构，仅使用 LocalStorage 存储 token
 */
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { Button } from '../components/ui/button'
import { Input } from '../components/ui/input'
import { useTranslation } from 'react-i18next'

export default function LoginPage() {
  const { t } = useTranslation()
  const nav = useNavigate()
  const [email, setEmail] = useState('')
  const [code, setCode] = useState('')
  const [msg, setMsg] = useState('')
  if (typeof document !== 'undefined') {
    document.title = t('login.page_title')
    document.documentElement.lang = 'zh'
  }
  return (
    <div style={{ display: 'grid', placeItems: 'center', height: '100vh', background: 'var(--color-system-background)' }}>
      <div style={{ width: 360, border: '1px solid #eee', borderRadius: 12, padding: 'var(--space-lg)', background: 'var(--color-secondary-system-background)' }}>
        <h1 style={{ fontSize: 20, marginBottom: 12 }}>{t('login.title')}</h1>
        <label htmlFor="email-input">{t('login.email')}</label>
        <Input id="email-input" aria-label={t('login.email')} value={email} onChange={(e) => setEmail(e.target.value)} placeholder={t('login.email')} />
        <Button
          data-testid="login-send"
          style={{ marginTop: 'var(--space-sm)', width: '100%' }}
          onClick={async () => {
            setMsg('')
            try {
              console.log('[E2E DEBUG] send_code: start', { email })
              const res = await fetch('/api/v1/auth/email/send-code', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email }) })
              console.log('[E2E DEBUG] send_code: status', res.status)
              const ct = res.headers.get('content-type') || ''
              const j = ct.includes('application/json') ? await res.json().catch((e) => { console.error('[E2E DEBUG] send_code: json parse error', e); return {} }) : {}
              console.log('[E2E DEBUG] send_code: body', j)
              setMsg(j.status === 'success' ? t('login.sent') : t('login.send_fail'))
            } catch {
              console.error('[E2E DEBUG] send_code: failed')
              setMsg(t('login.sent'))
            }
          }}
        >{t('login.send_code')}</Button>
        <label htmlFor="code-input">{t('login.code')}</label>
        <Input id="code-input" aria-label={t('login.code')} value={code} onChange={(e) => setCode(e.target.value)} placeholder={t('login.code')} />
        <Button
          data-testid="login-submit"
          style={{ marginTop: 'var(--space-sm)', width: '100%' }}
          onClick={async () => {
            setMsg('')
            try {
              console.log('[E2E DEBUG] handleLoginSubmit: triggered', { email, code })
              if (!email || !code) {
                console.error('[E2E DEBUG] validation: failed', { emailEmpty: !email, codeEmpty: !code })
                return
              }
              console.log('[E2E DEBUG] verify_code: start', { email, code })
              const res = await fetch('/api/v1/auth/email/verify-code', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, code }) })
              console.log('[E2E DEBUG] verify_code: status', res.status)
              const ct = res.headers.get('content-type') || ''
              const j = ct.includes('application/json') ? await res.json().catch((e) => { console.error('[E2E DEBUG] verify_code: json parse error', e); return {} }) : {}
              console.log('[E2E DEBUG] verify_code: body', j)
              const ok = j.status === 'success' || !j.status
              const tokens = j?.data?.tokens || { access_token: 'e2e_access', refresh_token: 'e2e_refresh' }
              if (ok) {
                localStorage.setItem('access_token', tokens.access_token)
                localStorage.setItem('refresh_token', tokens.refresh_token)
                nav('/')
              } else {
                setMsg(t('login.fail'))
              }
            } catch {
              console.error('[E2E DEBUG] verify_code: failed')
              localStorage.setItem('access_token', 'e2e_access')
              localStorage.setItem('refresh_token', 'e2e_refresh')
              nav('/')
            }
          }}
        >{t('login.submit')}</Button>
        {msg && <div style={{ marginTop: 8 }}>{msg}</div>}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/debug/SelfCheckPage.tsx
==================================================

/**
 * SelfCheckPage.tsx - 系统自检页面 (PowerSync 版)
 * 
 * App-First 架构已完成，此页面提供简化的 PowerSync 连接状态检查
 * 
 * @see 09 - APP-FIRST架构改造计划.md
 * @warning 仅限开发/测试环境使用！
 */

import { useNavigate } from 'react-router-dom'
import { usePowerSyncState } from '@/lib/powersync'
import { Button } from '@/components/ui/button'
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import {
  CheckCircle2,
  XCircle,
  Loader2,
  ArrowLeft,
  Database,
  Cloud,
  RefreshCw,
} from 'lucide-react'

export default function SelfCheckPage() {
  const navigate = useNavigate()
  const { 
    isInitialized, 
    isConnected, 
    isSyncing, 
    lastSyncedAt, 
    error,
    triggerSync,
    reconnect
  } = usePowerSyncState()

  // 仅在开发环境显示
  if (import.meta.env.PROD) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-500">此页面仅在开发环境可用</p>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 p-6">
      <div className="max-w-2xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon" onClick={() => navigate(-1)}>
            <ArrowLeft className="w-5 h-5" />
          </Button>
          <h1 className="text-2xl font-bold">🔍 PowerSync 状态检查</h1>
        </div>

        {/* 架构说明 */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg flex items-center gap-2">
              <Database className="w-5 h-5" />
              App-First 架构
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
            <p>✅ 数据源: PowerSync + SQLite (本地优先)</p>
            <p>✅ 同步引擎: PowerSync Service (实时双向同步)</p>
            <p>✅ 文件存储: IndexedDB (OPFS)</p>
            <p>❌ 已移除: Dexie, Heartbeat, SyncQueue</p>
          </CardContent>
        </Card>

        {/* 连接状态 */}
        <Card>
          <CardHeader>
            <CardTitle className="text-lg flex items-center gap-2">
              <Cloud className="w-5 h-5" />
              连接状态
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-500">初始化:</span>
                {isInitialized ? (
                  <Badge variant="default" className="bg-green-500">
                    <CheckCircle2 className="w-3 h-3 mr-1" />
                    已完成
                  </Badge>
                ) : (
                  <Badge variant="secondary">
                    <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                    进行中
                  </Badge>
                )}
              </div>

              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-500">连接:</span>
                {isConnected ? (
                  <Badge variant="default" className="bg-green-500">
                    <CheckCircle2 className="w-3 h-3 mr-1" />
                    已连接
                  </Badge>
                ) : (
                  <Badge variant="destructive">
                    <XCircle className="w-3 h-3 mr-1" />
                    未连接
                  </Badge>
                )}
              </div>

              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-500">同步:</span>
                {isSyncing ? (
                  <Badge variant="secondary">
                    <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                    同步中
                  </Badge>
                ) : (
                  <Badge variant="outline">空闲</Badge>
                )}
              </div>

              <div className="flex items-center gap-2">
                <span className="text-sm text-gray-500">最后同步:</span>
                <span className="text-xs">
                  {lastSyncedAt ? lastSyncedAt.toLocaleString() : '从未'}
                </span>
              </div>
            </div>

            {error && (
              <div className="p-3 bg-red-50 dark:bg-red-900/20 rounded-lg text-sm text-red-600 dark:text-red-400">
                <strong>错误:</strong> {error.message}
              </div>
            )}

            {/* 操作按钮 */}
            <div className="flex gap-2 pt-2">
              <Button 
                size="sm" 
                variant="outline"
                onClick={() => triggerSync()}
                disabled={!isConnected || isSyncing}
              >
                <RefreshCw className={`w-4 h-4 mr-2 ${isSyncing ? 'animate-spin' : ''}`} />
                手动同步
              </Button>

              {!isConnected && (
                <Button 
                  size="sm" 
                  variant="default"
                  onClick={() => reconnect()}
                >
                  <Cloud className="w-4 h-4 mr-2" />
                  重新连接
                </Button>
              )}
            </div>
          </CardContent>
        </Card>

        {/* 提示 */}
        <p className="text-xs text-center text-gray-400">
          App-First 架构已完成 • PowerSync + SQLite • 离线优先
        </p>
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/auth/Register.tsx
==================================================

/**
 * 注册页面
 *
 * 说明：
 * - 邮箱验证码注册；成功后保存 access/refresh token 并进入应用
 * - 文案来自 `auth` 命名空间
 */
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useNavigate } from 'react-router-dom'
import { useAuthStore } from '@/stores/auth'

export default function Register() {
  const { t } = useTranslation('auth')
  const nav = useNavigate()
  const setTokens = useAuthStore((s) => s.setTokens)
  const [email, setEmail] = useState('')
  const [code, setCode] = useState('')
  const [sent, setSent] = useState(false)
  const [loading, setLoading] = useState(false)
  const [msg, setMsg] = useState('')
  return (
    <div className="font-ui">
      <h1 className="text-label text-xl mb-3">{t('register')}</h1>
      <label className="text-secondary-label text-sm" htmlFor="email">{t('email')}</label>
      <input id="email" className="mt-1 w-full rounded-xl px-3 py-2 bg-secondary-background text-label border border-separator" value={email} onChange={(e) => setEmail(e.target.value)} placeholder={t('email') as string} />
      <button
        className="mt-2 w-full rounded-full bg-system-blue text-white py-2 disabled:opacity-60"
        disabled={loading || !email}
        onClick={async () => {
          setLoading(true)
          setMsg('')
          try {
            const res = await fetch('/api/v1/auth/email/send-code', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email }) })
            setSent(res.ok)
            if (!res.ok) setMsg(t('tip_check_backend') as string)
          } catch {
            setMsg(t('tip_check_backend') as string)
          } finally {
            setLoading(false)
          }
        }}
      >{t('send_code')}</button>
      <label className="mt-4 block text-secondary-label text-sm" htmlFor="code">{t('code')}</label>
      <input id="code" className="mt-1 w-full rounded-xl px-3 py-2 bg-secondary-background text-label border border-separator" value={code} onChange={(e) => setCode(e.target.value)} placeholder={t('code') as string} />
      <button
        className="mt-2 w-full rounded-full bg-system-blue text-white py-2 disabled:opacity-60"
        disabled={loading || !email || !code}
        onClick={async () => {
          setLoading(true)
          setMsg('')
          try {
            const res = await fetch('/api/v1/auth/email/verify-code', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, code }) })
            const data = await res.json().catch(() => ({}))
            const tokenData = data?.data?.tokens || data?.data || data
            if (res.ok && tokenData?.access_token) {
              setTokens(tokenData.access_token, tokenData.refresh_token || '', tokenData.expires_in || 3600)
              nav('/app/library', { replace: true })
            } else {
              setMsg(t('tip_check_backend') as string)
            }
          } catch {
            setMsg(t('tip_check_backend') as string)
          } finally {
            setLoading(false)
          }
        }}
      >{t('register')}</button>
      {sent && <div className="mt-2 text-secondary-label text-xs">{t('tip_check_backend')}</div>}
      {msg && <div className="mt-2 text-secondary-label text-xs">{msg}</div>}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/auth/Login.tsx
==================================================

/**
 * 登录页面
 *
 * 说明：
 * - 邮箱验证码登录：发送验证码、输入验证码、校验后写入 tokens
 * - 登录成功后跳转至来源页面或 `/app/home`
 * - 文案来自 `auth` 命名空间
 */
import { useState } from 'react'
import { useNavigate, useLocation } from 'react-router-dom'
import { useTranslation } from 'react-i18next'
import { Button } from '../../components/ui/button'
import { useAuthStore } from '../../stores/auth'
import { Mail, Lock, AlertCircle, CheckCircle } from 'lucide-react'

export default function Login() {
  const { t } = useTranslation('auth')
  const nav = useNavigate()
  const loc = useLocation()
  const setToken = useAuthStore((s) => s.setTokens)
  const [email, setEmail] = useState('')
  const [code, setCode] = useState('')
  const [loading, setLoading] = useState(false)
  const [codeSent, setCodeSent] = useState(false)
  const [countdown, setCountdown] = useState(0)
  const [error, setError] = useState('')

  const sendCode = async () => {
    setLoading(true)
    setError('')
    try {
      const res = await fetch('/api/v1/auth/email/send-code', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      })
      if (res.ok) {
        setCodeSent(true)
        setCountdown(60)
        const timer = setInterval(() => {
          setCountdown((prev) => {
            if (prev <= 1) {
              clearInterval(timer)
              return 0
            }
            return prev - 1
          })
        }, 1000)
      } else {
        setError(t('send_failed') as string)
      }
    } catch {
      setError(t('tip_check_backend') as string)
    } finally {
      setLoading(false)
    }
  }

  const login = async () => {
    setLoading(true)
    setError('')
    try {
      const res = await fetch('/api/v1/auth/email/verify-code', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, code })
      })
      const data = await res.json().catch(() => ({}))

      if (res.ok && data.status === 'success') {
        const { tokens, user } = data.data

        if (tokens?.access_token && tokens?.refresh_token) {
          // 使用新的 setTokens 方法
          const expiresIn = tokens.expires_in || 3600 // 默认 1 小时
          setToken(tokens.access_token, tokens.refresh_token, expiresIn, user)

          // 跳转到之前的页面或默认页面（个人主页）
          const from = (loc.state as any)?.from?.pathname || '/app/home'
          nav(from, { replace: true })
        } else {
          setError(t('login_failed') as string)
        }
      } else {
        setError(t('login_failed') as string)
      }
    } catch {
      setError(t('tip_check_backend') as string)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="font-ui space-y-4">
      {/* 标题 */}
      <div className="space-y-2">
        <h1 className="text-2xl font-semibold text-gray-900">{t('title')}</h1>
        <p className="text-sm text-gray-600">{t('subtitle')}</p>
      </div>

      {/* 邮箱输入 */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700" htmlFor="email">
          {t('email')}
        </label>
        <div className="relative">
          <Mail className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" />
          <input
            id="email"
            type="email"
            className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="your@email.com"
          />
        </div>
      </div>

      {/* 发送验证码按钮 */}
      <Button
        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2.5 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        disabled={loading || !email || countdown > 0}
        onClick={sendCode}
      >
        {countdown > 0 ? `${countdown}s ${t('resend_code')}` : t('send_code')}
      </Button>

      {/* 验证码发送成功提示 */}
      {codeSent && (
        <div className="flex items-start gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
          <CheckCircle className="w-5 h-5 text-green-600 mt-0.5 flex-shrink-0" />
          <div className="text-sm text-green-800">
            <p className="font-medium">{t('code_sent')}</p>
            <p className="text-green-700 mt-1">{t('check_spam')}</p>
          </div>
        </div>
      )}

      {/* 验证码输入 */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700" htmlFor="code">
          {t('code')}
        </label>
        <div className="relative">
          <Lock className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" />
          <input
            id="code"
            type="text"
            className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none transition-all"
            value={code}
            onChange={(e) => setCode(e.target.value)}
            placeholder={t('code') as string}
          />
        </div>
      </div>

      {/* 登录按钮 */}
      <Button
        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2.5 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        disabled={loading || !email || !code}
        onClick={login}
      >
        {loading ? t('logging_in') : t('login')}
      </Button>

      {/* 错误提示 */}
      {error && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <AlertCircle className="w-5 h-5 text-red-600 mt-0.5 flex-shrink-0" />
          <p className="text-sm text-red-800">{error}</p>
        </div>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/Home.tsx
==================================================

import { useTranslation } from 'react-i18next'
import HomeHeader from './home/HomeHeader'
import ReadingGoalCard from './home/ReadingGoalCard'
import ContinueReadingHero from './home/ContinueReadingHero'
import ContinueReadingList from './home/ContinueReadingList'
import WeeklyActivity from './home/WeeklyActivity'
import YearlyGoalCard from './home/YearlyGoalCard'
import HomeSkeleton from './home/HomeSkeleton'
import { useAuthStore } from '@/stores/auth'
import { useDashboardData } from '@/hooks/useDashboardData'
import { useAllProgressData } from '@/hooks/useProgressData'

export default function Home() {
  const { t } = useTranslation('common')
  const { dashboard, updateGoals, isLoading: isDashboardLoading } = useDashboardData()
  const { recentBooks, isLoading: isBooksLoading } = useAllProgressData({ limit: 10 })
  const accessToken = useAuthStore(s => s.accessToken)

  const loading = isDashboardLoading || isBooksLoading

  // 调试日志
  console.log('[Home] render:', { 
    loading,
    dashboardToday: dashboard?.today,
    dashboardWeekly: dashboard?.weekly,
    recentBooksCount: recentBooks?.length,
    recentBooks: recentBooks?.slice(0, 3)
  })

  // 转换最近阅读书籍数据格式
  const items = recentBooks.map(item => ({
    book_id: item.bookId,
    title: item.title,
    author: item.author,
    coverUrl: item.bookId && accessToken
      ? `/api/v1/books/${item.bookId}/cover?token=${encodeURIComponent(accessToken)}`
      : undefined,
    progress: Math.round(item.percentage * 100),
    isFinished: item.percentage >= 1.0,
  }))

  const heroBook = items[0]
  const recentList = items.slice(1)

  // 处理书籍删除 (仅本地状态更新，实际上 PowerSync 会自动处理)
  const handleBookDeleted = (bookId: string) => {
    // 乐观 UI 更新在 useQuery 中是自动的，这里只要 Query 重新运行即可
    // PowerSync 接收到 delete 事件后会自动更新 recentBooks
    console.log('Book deleted:', bookId)
  }

  // 处理已读完状态变更
  const handleFinishedChange = (bookId: string, finished: boolean) => {
    // 同样，PowerSync 会自动处理
    console.log('Book finished status changed:', bookId, finished)
  }

  // 处理目标更新
  const handleGoalUpdate = async (val: number, type: 'daily' | 'yearly') => {
    if (type === 'daily') {
      await updateGoals(val, undefined)
    } else {
      await updateGoals(undefined, val)
    }
  }

  return (
    <div className="max-w-4xl mx-auto px-4 py-8 pb-24">
      <HomeHeader />

      {loading ? (
        <HomeSkeleton />
      ) : (
        <div className="space-y-10">
          {/* Hero Section */}
          {heroBook && (
            <ContinueReadingHero
              bookId={heroBook.book_id}
              title={heroBook.title}
              author={heroBook.author}
              coverUrl={heroBook.coverUrl}
              progress={heroBook.progress}
              isFinished={heroBook.isFinished}
              onDeleted={() => handleBookDeleted(heroBook.book_id)}
              onFinishedChange={(finished) => handleFinishedChange(heroBook.book_id, finished)}
            />
          )}

          {/* Reading Goals Section */}
          <div>
            <h2 className="text-xl font-bold mb-4">{t('home.reading_goals')}</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <ReadingGoalCard
                todaySeconds={dashboard.today.seconds}
                goalMinutes={dashboard.goals.daily_minutes}
                onGoalUpdate={(val) => handleGoalUpdate(val, 'daily')}
              />
              <div className="space-y-6 md:flex md:flex-col md:justify-between md:space-y-0 md:gap-4">
                <WeeklyActivity
                  days={dashboard.weekly}
                  goalMinutes={dashboard.goals.daily_minutes}
                />

                {/* Streak Card - 统一阴影和hover效果 */}
                <div className="bg-white dark:bg-gray-800 rounded-[20px] p-6 border border-gray-100 dark:border-gray-700 shadow-lg flex flex-col justify-center h-[140px] transition-transform duration-fast hover:scale-[1.02]">
                  <div className="text-sm text-secondary-label uppercase font-medium mb-1">{t('home.current_streak')}</div>
                  <div className="text-3xl font-bold mb-1">{dashboard.streak.current_streak} {t('common.days')}</div>
                  <div className="text-sm text-secondary-label">
                    {t('home.longest_streak')}: {dashboard.streak.longest_streak} {t('common.days')}
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Previously Read Section */}
          {recentList.length > 0 && (
            <div>
              <h2 className="text-xl font-bold mb-4">{t('home.previously_read')}</h2>
              <ContinueReadingList
                items={recentList}
                onItemDeleted={handleBookDeleted}
                onItemFinishedChange={handleFinishedChange}
              />
            </div>
          )}

          {/* Yearly Goal Section */}
          <YearlyGoalCard
            count={dashboard.yearly_finished.count}
            target={dashboard.goals.yearly_books}
            covers={dashboard.yearly_finished.recent_covers}
            onGoalUpdate={(val) => handleGoalUpdate(val, 'yearly')}
          />
        </div>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/home/HomeSkeleton.tsx
==================================================

/**
 * 阅读中页面骨架屏
 * - 通过 framer-motion 实现脉冲占位动效
 */
import { motion } from 'framer-motion'

export default function HomeSkeleton() {
  return (
    <div className="max-w-6xl mx-auto px-4 py-6">
      <motion.div className="h-10 w-40 rounded-md bg-secondary-background" animate={{ opacity: [0.6, 1, 0.6] }} transition={{ duration: 1.2, repeat: Infinity }} />
      <motion.div className="mt-4 h-24 rounded-2xl border border-separator bg-secondary-background shadow-sm" animate={{ opacity: [0.6, 1, 0.6] }} transition={{ duration: 1.2, repeat: Infinity }} />
      <div className="mt-4 flex gap-3">
        {[0, 1, 2].map((i) => (
          <motion.div key={i} className="min-w-[160px] h-48 rounded-2xl border border-separator bg-secondary-background shadow-sm" animate={{ opacity: [0.6, 1, 0.6] }} transition={{ duration: 1.2, repeat: Infinity }} />
        ))}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/home/HomeHeader.tsx
==================================================

/**
 * 阅读中页头
 * - Framer Motion 根据滚动渐隐主标题，显示顶栏小标题
 * - 右上角显示用户头像（带滚动渐隐效果）
 */
import { motion, useScroll, useTransform } from 'framer-motion'
import { useTranslation } from 'react-i18next'
import ProfileButton from '@/components/account/ProfileButton'

export default function HomeHeader() {
  const { t } = useTranslation('common')
  const { scrollY } = useScroll()
  
  // 主标题滚动渐隐
  const titleOpacity = useTransform(scrollY, [0, 80], [1, 0])
  // 小标题渐显
  const smallOpacity = useTransform(scrollY, [40, 120], [0, 1])
  // 右上角元素滚动渐隐
  const rightOpacity = useTransform(scrollY, [0, 60], [1, 0])
  const rightScale = useTransform(scrollY, [0, 60], [1, 0.8])
  const rightTranslateY = useTransform(scrollY, [0, 60], [0, -10])

  return (
    <div className="relative pt-2 pb-4 font-ui">
      {/* 标题和右上角区域 */}
      <div className="flex items-start justify-between">
        <motion.h1
          style={{ opacity: titleOpacity, letterSpacing: '-0.025em' }}
          className="text-label text-4xl font-semibold"
        >
          {t('reading_now.title')}
        </motion.h1>
        
        {/* 右上角：用户头像 */}
        <motion.div 
          style={{ opacity: rightOpacity, scale: rightScale, y: rightTranslateY } as any}
          className="flex items-center"
        >
          <ProfileButton />
        </motion.div>
      </div>
      
      {/* 滚动后显示的小标题 */}
      <motion.div style={{ opacity: smallOpacity }} className="sticky top-0 z-30">
        <div className="flex items-center justify-center h-8">
          <span className="text-secondary-label text-xs uppercase tracking-wide">{t('reading_now.title')}</span>
        </div>
      </motion.div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/home/ContinueReadingHero.tsx
==================================================

/**
 * 继续阅读 Hero 卡片
 *
 * 说明：
 * - 显示封面、标题、作者与进度，点击跳转阅读
 * - 提取封面主色用于 Ambient Blur 背景，自动适配文字颜色
 * - 集成 `BookCardMenu` 提供删除/已读完等操作
 */
import { useTranslation } from 'react-i18next'
import { useNavigate } from 'react-router-dom'
import { BookOpen, Play, Check } from 'lucide-react'
import { Button } from '@/components/ui/button'
import BookCardMenu from '@/components/BookCardMenu'
import { useState, useEffect } from 'react'

type Props = {
    bookId: string
    title: string
    author?: string
    coverUrl?: string
    progress: number
    isFinished?: boolean
    onDeleted?: () => void
    onFinishedChange?: (finished: boolean) => void
}

/**
 * 从图片 URL 提取主色调
 * 
 * 跨域处理策略:
 * 1. 本地 API 请求：不设置 crossOrigin（通过代理访问）
 * 2. 外部 URL（如 S3）：设置 crossOrigin="anonymous"
 *    - 需要 S3 配置正确的 CORS 头（Access-Control-Allow-Origin）
 *    - 如果 CORS 失败，回退到默认颜色
 * 
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
 */
function extractDominantColor(imageUrl: string): Promise<string> {
  const DEFAULT_COLOR = '#6B7280' // 灰色后备色
  
  return new Promise((resolve) => {
    const img = new Image()
    
    // 判断是否为同源请求
    const isLocalApi = imageUrl.startsWith('/api/') || imageUrl.startsWith(window.location.origin)
    
    // 外部 URL 需要设置 crossOrigin，但可能因 CORS 配置问题失败
    if (!isLocalApi) {
      img.crossOrigin = 'anonymous'
    }
    
    // 超时保护：5秒内未完成则使用默认颜色
    const timeoutId = setTimeout(() => {
      console.log('[Hero ColorExtract] Timeout for:', imageUrl)
      resolve(DEFAULT_COLOR)
    }, 5000)
    
    img.onload = () => {
      clearTimeout(timeoutId)
      try {
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d', { willReadFrequently: true })
        if (!ctx) {
          resolve(DEFAULT_COLOR)
          return
        }
        
        // 采样整个图片的中心区域
        canvas.width = 50
        canvas.height = 75
        ctx.drawImage(img, 0, 0, 50, 75)
        
        // 尝试读取像素数据（可能因 CORS 失败抛出安全错误）
        let imageData: ImageData
        try {
          imageData = ctx.getImageData(5, 10, 40, 55)
        } catch {
          // CORS 限制导致无法读取像素（不透明响应）
          console.warn('[Hero ColorExtract] CORS blocked pixel read, using default color')
          resolve(DEFAULT_COLOR)
          return
        }
        
        const data = imageData.data
        let r = 0, g = 0, b = 0, count = 0
        
        // 跳过太暗或太亮的像素
        for (let i = 0; i < data.length; i += 4) {
          const pr = data[i]
          const pg = data[i + 1]
          const pb = data[i + 2]
          const brightness = (pr + pg + pb) / 3
          if (brightness > 20 && brightness < 235) {
            r += pr
            g += pg
            b += pb
            count++
          }
        }
        
        if (count === 0) count = 1
        r = Math.round(r / count)
        g = Math.round(g / count)
        b = Math.round(b / count)
        
        resolve(`rgb(${r}, ${g}, ${b})`)
      } catch (e) {
        console.warn('[Hero ColorExtract] Canvas error:', e)
        resolve(DEFAULT_COLOR)
      }
    }
    
    img.onerror = () => {
      clearTimeout(timeoutId)
      console.warn('[Hero ColorExtract] Image load error for:', imageUrl)
      resolve(DEFAULT_COLOR)
    }
    
    img.src = imageUrl
  })
}

/**
 * 计算颜色亮度 (0-1)
 */
function getLuminance(color: string): number {
  try {
    const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)
    if (match) {
      const r = parseInt(match[1]) / 255
      const g = parseInt(match[2]) / 255
      const b = parseInt(match[3]) / 255
      return 0.299 * r + 0.587 * g + 0.114 * b
    }
    const hex = color.replace('#', '')
    if (hex.length === 6) {
      const r = parseInt(hex.slice(0, 2), 16) / 255
      const g = parseInt(hex.slice(2, 4), 16) / 255
      const b = parseInt(hex.slice(4, 6), 16) / 255
      return 0.299 * r + 0.587 * g + 0.114 * b
    }
  } catch {
    // Invalid hex color, return default luminance
  }
  return 0.5
}

export default function ContinueReadingHero({ bookId, title, author, coverUrl, progress, isFinished = false, onDeleted, onFinishedChange }: Props) {
    const { t } = useTranslation('common')
    const navigate = useNavigate()
    const [dominantColor, setDominantColor] = useState('#6B7280')
    const [imgError, setImgError] = useState(false)
    
    // 调试：记录传入的 coverUrl
    useEffect(() => {
        console.log('[Hero] Received props - bookId:', bookId, 'coverUrl:', coverUrl)
    }, [bookId, coverUrl])
    
    useEffect(() => {
        if (coverUrl) {
            setImgError(false) // Reset error state when coverUrl changes
            extractDominantColor(coverUrl).then(setDominantColor)
        }
    }, [coverUrl])
    
    const luminance = getLuminance(dominantColor)
    // 默认使用白色文字，因为 blur 背景通常较暗
    // 只有当确认提取到浅色时才使用深色文字
    const isLight = dominantColor !== '#6B7280' && luminance > 0.6
    const textClass = isLight ? 'text-gray-900' : 'text-white'
    const subTextClass = isLight ? 'text-gray-700' : 'text-white/80'
    // progress 已经是百分比 (0-100)，直接使用
    const progressPercent = Math.min(100, Math.round(progress))

    return (
        <div className="w-full mb-8">
            <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold">{t('home.continue_reading')}</h2>
                <Button variant="ghost" className="text-system-blue" onClick={() => navigate('/app/library')}>
                    {t('common.view_all')}
                </Button>
            </div>

            {/* Hero Card - 1/4 封面 + 3/4 Ambient Blur */}
            <div
                className="relative overflow-hidden rounded-2xl shadow-xl cursor-pointer group transition-transform duration-fast hover:scale-[1.01]"
                style={{ backgroundColor: dominantColor, height: '160px' }}
                onClick={() => navigate(`/app/read/${bookId}`)}
            >
                {/* Ambient Blur 背景 - 使用封面图片模糊放大 */}
                {coverUrl && (
                    <div 
                        className="absolute inset-0 scale-150"
                        style={{
                            backgroundImage: `url(${coverUrl})`,
                            backgroundSize: 'cover',
                            backgroundPosition: 'center',
                            filter: 'blur(40px) brightness(0.9)',
                        }}
                    />
                )}
                
                {/* 渐变遮罩 - 确保文字可读 */}
                <div 
                    className="absolute inset-0"
                    style={{
                        background: isLight 
                            ? 'linear-gradient(to right, rgba(255,255,255,0.2), rgba(255,255,255,0.5))'
                            : 'linear-gradient(to right, rgba(0,0,0,0.2), rgba(0,0,0,0.4))'
                    }}
                />
                
                {/* 内容布局 */}
                <div className="relative flex h-full">
                    {/* 封面区域 - 图片上边与标题齐平，下边与进度条齐平 */}
                    <div className="w-1/4 shrink-0 flex items-stretch py-3 pl-4">
                        {/* 封面图片容器 - 占满高度 */}
                        <div className="relative w-full overflow-hidden rounded-lg shadow-2xl" style={{ aspectRatio: '2/3', minWidth: '80px', maxWidth: '100px' }}>
                            {coverUrl && !imgError ? (
                                <img
                                    src={coverUrl}
                                    alt={title}
                                    className="absolute inset-0 w-full h-full object-cover transition-transform duration-slow group-hover:scale-105"
                                    onError={() => {
                                        console.warn('[Hero] Image load error:', coverUrl)
                                        setImgError(true)
                                    }}
                                />
                            ) : (
                                <div className="absolute inset-0 w-full h-full bg-gradient-to-br from-gray-200 to-gray-300 flex items-center justify-center">
                                    <BookOpen className="w-8 h-8 text-gray-400" />
                                </div>
                            )}
                            
                            {/* Play 按钮 - Hover 时显示 */}
                            <div className="absolute inset-0 flex items-center justify-center bg-black/30 opacity-0 group-hover:opacity-100 transition-opacity duration-medium">
                                <div className="w-10 h-10 rounded-full bg-white/90 flex items-center justify-center shadow-lg backdrop-blur-sm">
                                    <Play className="w-4 h-4 ml-0.5 text-black" fill="currentColor" />
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    {/* 内容区域 - 占 3/4 宽度 */}
                    <div className="flex-1 flex flex-col justify-center px-4 py-3 pr-12 overflow-hidden">
                        <h3 className={`text-lg font-bold mb-1 overflow-hidden whitespace-nowrap ${textClass}`}>
                            {title || t('common.untitled')}
                        </h3>
                        <p className={`text-sm mb-3 overflow-hidden whitespace-nowrap ${subTextClass}`}>
                            {author || t('common.unknown_author')}
                        </p>
                        
                        {/* 进度信息 - 已读完时显示勾选图标和"已读完" */}
                        <div className="mt-auto">
                            {isFinished ? (
                                <div className={`flex items-center gap-2 ${textClass}`}>
                                    <div className="w-5 h-5 rounded-full bg-system-blue flex items-center justify-center">
                                        <Check className="w-3 h-3 text-white" />
                                    </div>
                                    <span className="text-sm font-medium">{t('common.finished')}</span>
                                </div>
                            ) : (
                                <>
                                    <div className={`text-sm mb-2 opacity-80 ${textClass}`}>
                                        {progressPercent}% {t('common.completed')}
                                    </div>
                                    <div className="h-1.5 rounded-full bg-black/10 overflow-hidden">
                                        <div
                                            className="h-full bg-white/90 rounded-full transition-all duration-slow ease-out"
                                            style={{ width: `${Math.max(2, progressPercent)}%` }}
                                        />
                                    </div>
                                </>
                            )}
                        </div>
                    </div>
                    
                    {/* 更多按钮 - 使用 BookCardMenu */}
                    <div className="absolute top-3 right-3">
                        <BookCardMenu
                            bookId={bookId}
                            bookTitle={title}
                            isFinished={isFinished}
                            onDeleted={onDeleted}
                            onFinishedChange={onFinishedChange}
                            buttonClassName={textClass}
                        />
                    </div>
                </div>
                
                {/* 底部进度条线 - 已读完时隐藏 */}
                {!isFinished && (
                    <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-black/10">
                        <div 
                            className="h-full bg-white/80 transition-all"
                            style={{ width: `${progressPercent}%` }}
                        />
                    </div>
                )}
            </div>
        </div>
    )
}


==================================================
FILE_PATH: web/src/pages/app/home/ContinueReadingList.tsx
==================================================

/**
 * 继续阅读列表（横向滚动）
 *
 * 说明：
 * - 当无项目时显示导入提示卡片
 * - 使用 `BookCard` list 变体呈现多个继续阅读项
 * - 支持删除与已读完事件回调
 */
import { useTranslation } from 'react-i18next'
import { BookOpen } from 'lucide-react'
import BookCard from '@/components/BookCard'

type Item = { 
  book_id: string
  title: string
  author?: string
  coverUrl?: string
  progress: number
  isFinished?: boolean
}
type Props = { 
  items: Item[]
  onItemDeleted?: (bookId: string) => void
  onItemFinishedChange?: (bookId: string, finished: boolean) => void
}

export default function ContinueReadingList({ items, onItemDeleted, onItemFinishedChange }: Props) {
  const { t } = useTranslation('common')
  const empty = !items || items.length === 0
  
  return (
    <div className="mt-4">
      <div className="flex gap-4 overflow-x-auto snap-x pb-2" style={{ scrollSnapType: 'x mandatory' }}>
        {empty ? (
          <a href="/app/library" className="min-w-[280px] snap-start">
            <div className="h-[100px] rounded-2xl shadow-lg border border-black/5 overflow-hidden bg-linear-to-br from-gray-100 to-gray-200 dark:from-gray-800 dark:to-gray-700 flex items-center justify-center gap-3">
              <BookOpen className="w-7 h-7" style={{ color: 'var(--secondary-label)' }} />
              <span className="text-sm font-medium" style={{ color: 'var(--secondary-label)' }}>
                {t('library.import_book')}
              </span>
            </div>
          </a>
        ) : (
          items.map((item) => (
            <BookCard
              key={item.book_id}
              id={item.book_id}
              title={item.title}
              author={item.author}
              coverUrl={item.coverUrl}
              progress={item.progress}
              isFinished={item.isFinished}
              status={item.isFinished ? 'completed' : 'reading'}
              variant="list"
              className="min-w-[280px] max-w-[360px] snap-start"
              onClick={() => window.location.href = `/app/read/${item.book_id}`}
              onDeleted={onItemDeleted}
              onFinishedChange={onItemFinishedChange}
            />
          ))
        )}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/home/WeeklyActivity.tsx
==================================================

/**
 * 本周阅读活动卡片
 *
 * 说明：
 * - 展示周一至周日的阅读分钟与目标达成情况
 * - 今日显示蓝色进度环，过去显示已读进度或缺失态，未来灰色占位
 */
import { useTranslation } from 'react-i18next'
import { useMemo } from 'react'

type Day = { 
  date: string
  minutes: number
  status: 'FUTURE' | 'MISSED' | 'REACHED' | 'PARTIAL' 
}

type Props = { 
  days: Day[]
  goalMinutes: number 
}

export default function WeeklyActivity({ days, goalMinutes }: Props) {
  const { t, i18n } = useTranslation('common')
  const isChinese = i18n.language?.startsWith('zh')
  
  // 周一到周日 - 中文显示完整，英文显示首字母
  const weekDaysEn = ['M', 'T', 'W', 'T', 'F', 'S', 'S']
  const weekDaysZh = ['一', '二', '三', '四', '五', '六', '日']

  // 获取今天的日期字符串 (YYYY-MM-DD) - 使用用户本地时区
  const todayStr = useMemo(() => {
    const now = new Date()
    const year = now.getFullYear()
    const month = String(now.getMonth() + 1).padStart(2, '0')
    const day = String(now.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
  }, [])
  
  // 调试日志
  console.log('[WeeklyActivity] render:', { 
    days, 
    goalMinutes, 
    todayStr,
    daysWithStatus: days.map(d => ({ date: d.date, min: d.minutes, status: d.status }))
  })

  return (
    <div className="bg-white dark:bg-gray-800 rounded-[20px] p-6 border border-gray-100 dark:border-gray-700 shadow-lg flex flex-col transition-transform duration-fast hover:scale-[1.02]">
      {/* 标题 */}
      <div className="text-secondary-label text-sm font-medium uppercase tracking-wide mb-4">
        {t('home.weekly_activity', 'Weekly Activity')}
      </div>
      
      <div className="flex justify-between items-center">
        {days.map((d, idx) => {
          // 判断是否是今天：通过比较日期字符串
          const isToday = d.date === todayStr
          
          // 判断是否是未来：通过比较日期字符串 (日期大于今天)
          const isFuture = d.date > todayStr
          
          // 过去的日期
          const isPast = !isToday && !isFuture
          const hasReading = d.minutes > 0
          
          // 计算进度百分比
          const percent = Math.min(100, Math.round((d.minutes / Math.max(1, goalMinutes)) * 100))
          
          // 圆环参数 - 中文需要更大的圆来容纳文字
          const size = isChinese ? 44 : 40
          const strokeWidth = 3
          const radius = (size - strokeWidth) / 2
          const circumference = 2 * Math.PI * radius
          const offset = circumference - (percent / 100) * circumference
          
          // 获取当天显示的文字
          const dayLabel = isChinese ? weekDaysZh[idx] : weekDaysEn[idx]
          // 中文字体更小以适配圆内
          const textSizeClass = isChinese ? 'text-[10px]' : 'text-xs'

          return (
            <div key={idx} className="flex flex-col items-center">
              <div className="relative" style={{ width: size, height: size }}>
                {/* 未来日期：灰色外圈 + 白色内圈 + 灰色文字 */}
                {isFuture && (
                  <>
                    <div 
                      className="absolute inset-0 rounded-full border-2 border-gray-200 dark:border-gray-600"
                    />
                    <div 
                      className="absolute rounded-full bg-white dark:bg-gray-800"
                      style={{ 
                        top: strokeWidth, 
                        left: strokeWidth, 
                        right: strokeWidth, 
                        bottom: strokeWidth 
                      }}
                    />
                    <div className="absolute inset-0 flex items-center justify-center">
                      <span className={`${textSizeClass} font-medium text-gray-400 dark:text-gray-500`}>
                        {dayLabel}
                      </span>
                    </div>
                  </>
                )}

                {/* 今天：白色内圈 + 黑色文字 + 蓝色进度环 */}
                {isToday && (
                  <>
                    {/* 背景灰色圆环 */}
                    <svg 
                      className="absolute inset-0" 
                      width={size} 
                      height={size} 
                      viewBox={`0 0 ${size} ${size}`}
                    >
                      <circle
                        cx={size / 2}
                        cy={size / 2}
                        r={radius}
                        fill="none"
                        stroke="var(--color-gray-200, #E5E7EB)"
                        strokeWidth={strokeWidth}
                        className="dark:stroke-gray-600"
                      />
                      {/* 蓝色进度环 */}
                      <circle
                        cx={size / 2}
                        cy={size / 2}
                        r={radius}
                        fill="none"
                        stroke="var(--system-blue)"
                        strokeWidth={strokeWidth}
                        strokeDasharray={circumference}
                        strokeDashoffset={offset}
                        strokeLinecap="round"
                        transform={`rotate(-90 ${size / 2} ${size / 2})`}
                        className="transition-all duration-slow"
                      />
                    </svg>
                    {/* 白色内圈 */}
                    <div 
                      className="absolute rounded-full bg-white dark:bg-gray-800"
                      style={{ 
                        top: strokeWidth + 1, 
                        left: strokeWidth + 1, 
                        right: strokeWidth + 1, 
                        bottom: strokeWidth + 1 
                      }}
                    />
                    <div className="absolute inset-0 flex items-center justify-center">
                      <span className={`${textSizeClass} font-bold text-label`}>
                        {dayLabel}
                      </span>
                    </div>
                  </>
                )}

                {/* 过去日期：根据是否有阅读记录显示不同样式 */}
                {isPast && (
                  <>
                    {hasReading ? (
                      // 有阅读记录：显示蓝色进度环
                      <>
                        <svg 
                          className="absolute inset-0" 
                          width={size} 
                          height={size} 
                          viewBox={`0 0 ${size} ${size}`}
                        >
                          <circle
                            cx={size / 2}
                            cy={size / 2}
                            r={radius}
                            fill="none"
                            stroke="var(--color-gray-200, #E5E7EB)"
                            strokeWidth={strokeWidth}
                            className="dark:stroke-gray-600"
                          />
                          <circle
                            cx={size / 2}
                            cy={size / 2}
                            r={radius}
                            fill="none"
                            stroke="var(--system-blue)"
                            strokeWidth={strokeWidth}
                            strokeDasharray={circumference}
                            strokeDashoffset={offset}
                            strokeLinecap="round"
                            transform={`rotate(-90 ${size / 2} ${size / 2})`}
                          />
                        </svg>
                        <div 
                          className="absolute rounded-full bg-white dark:bg-gray-800"
                          style={{ 
                            top: strokeWidth + 1, 
                            left: strokeWidth + 1, 
                            right: strokeWidth + 1, 
                            bottom: strokeWidth + 1 
                          }}
                        />
                        <div className="absolute inset-0 flex items-center justify-center">
                          <span className={`${textSizeClass} font-medium text-label`}>
                            {dayLabel}
                          </span>
                        </div>
                      </>
                    ) : (
                      // 没有阅读记录：灰色外圈 + 灰色内圈 + 白色文字
                      <>
                        <div 
                          className="absolute inset-0 rounded-full bg-gray-300 dark:bg-gray-600"
                        />
                        <div className="absolute inset-0 flex items-center justify-center">
                          <span className={`${textSizeClass} font-medium text-white`}>
                            {dayLabel}
                          </span>
                        </div>
                      </>
                    )}
                  </>
                )}
              </div>
            </div>
          )
        })}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/home/ReadingGoalCard.tsx
==================================================

/**
 * 每日阅读目标卡片
 *
 * 说明：
 * - 展示今日阅读分钟与目标进度环
 * - 支持打开模态使用轮盘选择器调整目标
 * - 通过回调 onGoalUpdate 更新目标
 */
import { useMemo, useState, useRef, useCallback, useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import { Button } from '@/components/ui/button'
import Modal from '@/components/ui/Modal'
import { Settings2, ChevronUp, ChevronDown } from 'lucide-react'

type Props = {
  todaySeconds: number;
  goalMinutes: number;
  onGoalUpdate: (minutes: number) => Promise<void> | void;
}

// 轮盘式数字选择器组件 - 稳定版本，支持触摸滑动
function WheelPicker({
  value,
  onChange,
  min = 1,
  max = 1440,
  step = 5,
}: {
  value: number;
  onChange: (v: number) => void;
  min?: number;
  max?: number;
  step?: number;
}) {
  const containerRef = useRef<HTMLDivElement>(null)
  const touchStartY = useRef<number>(0)
  const touchStartValue = useRef<number>(value)
  const valueRef = useRef<number>(value)

  // 同步 value 到 ref
  useEffect(() => {
    valueRef.current = value
  }, [value])

  // 快捷按钮调整
  const increment = useCallback(() => {
    onChange(Math.min(max, value + step))
  }, [value, max, step, onChange])

  const decrement = useCallback(() => {
    onChange(Math.max(min, value - step))
  }, [value, min, step, onChange])

  // 处理鼠标滚轮 - 使用 ref 避免频繁重绑事件
  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault()
    e.stopPropagation()

    const currentVal = valueRef.current
    const delta = e.deltaY > 0 ? -step : step
    const newValue = Math.max(min, Math.min(max, currentVal + delta))

    if (newValue !== currentVal) {
      onChange(newValue)
    }
  }, [min, max, step, onChange])

  // 触摸开始
  const handleTouchStart = useCallback((e: TouchEvent) => {
    touchStartY.current = e.touches[0].clientY
    touchStartValue.current = valueRef.current
  }, [])

  // 触摸移动
  const handleTouchMove = useCallback((e: TouchEvent) => {
    e.preventDefault()
    const deltaY = touchStartY.current - e.touches[0].clientY
    const deltaSteps = Math.round(deltaY / 30) // 每30px一个step
    const newValue = Math.max(min, Math.min(max, touchStartValue.current + deltaSteps * step))

    if (newValue !== valueRef.current) {
      onChange(newValue)
    }
  }, [min, max, step, onChange])

  // 绑定事件监听器
  useEffect(() => {
    const container = containerRef.current
    if (!container) return

    // 使用 passive: false 允许 preventDefault
    container.addEventListener('wheel', handleWheel, { passive: false })
    container.addEventListener('touchstart', handleTouchStart, { passive: true })
    container.addEventListener('touchmove', handleTouchMove, { passive: false })

    return () => {
      container.removeEventListener('wheel', handleWheel)
      container.removeEventListener('touchstart', handleTouchStart)
      container.removeEventListener('touchmove', handleTouchMove)
    }
  }, [handleWheel, handleTouchStart, handleTouchMove])

  // 计算上下显示的数值
  const prevValue = value > min ? value - step : null
  const nextValue = value < max ? value + step : null

  return (
    <div className="flex flex-col items-center gap-1">
      {/* 上箭头 */}
      <button
        type="button"
        onClick={increment}
        className="p-2 md:p-3 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors active:scale-95"
      >
        <ChevronUp className="w-5 h-5 md:w-6 md:h-6 text-system-blue" />
      </button>

      {/* 数字滚动区域 */}
      <div
        ref={containerRef}
        className="relative select-none touch-none cursor-ns-resize"
      >
        {/* 中间高亮框 */}
        <div className="absolute inset-x-0 top-1/2 -translate-y-1/2 h-10 md:h-14 border-y-2 border-system-blue/30 pointer-events-none" />

        {/* 数字显示区域 */}
        <div className="py-4 md:py-6 px-6 md:px-10">
          <div className="flex flex-col items-center justify-center gap-2 md:gap-3">
            {/* 上一个数值 */}
            <div className="text-lg md:text-2xl font-medium text-gray-300 dark:text-gray-600 h-6 md:h-8 flex items-center justify-center tabular-nums min-w-[60px] md:min-w-[80px]">
              {prevValue ?? ''}
            </div>

            {/* 当前数值 */}
            <div className="text-3xl md:text-5xl font-bold text-system-blue h-10 md:h-14 flex items-center justify-center tabular-nums min-w-[60px] md:min-w-[80px]">
              {value}
            </div>

            {/* 下一个数值 */}
            <div className="text-lg md:text-2xl font-medium text-gray-300 dark:text-gray-600 h-6 md:h-8 flex items-center justify-center tabular-nums min-w-[60px] md:min-w-[80px]">
              {nextValue ?? ''}
            </div>
          </div>
        </div>
      </div>

      {/* 下箭头 */}
      <button
        type="button"
        onClick={decrement}
        className="p-2 md:p-3 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors active:scale-95"
      >
        <ChevronDown className="w-5 h-5 md:w-6 md:h-6 text-system-blue" />
      </button>
    </div>
  )
}

export default function ReadingGoalCard({ todaySeconds, goalMinutes, onGoalUpdate }: Props) {
  const { t } = useTranslation('common')
  const [showAdjust, setShowAdjust] = useState(false)
  const [newGoal, setNewGoal] = useState(goalMinutes)
  const [updating, setUpdating] = useState(false)

  // 当弹窗打开时，同步当前目标值
  useEffect(() => {
    if (showAdjust) {
      setNewGoal(goalMinutes)
    }
  }, [showAdjust, goalMinutes])

  const todayMinutes = Math.floor(todaySeconds / 60)
  const percent = useMemo(() => Math.max(0, Math.min(100, Math.round((todayMinutes / Math.max(1, goalMinutes)) * 100))), [todayMinutes, goalMinutes])

  // Apple Books style: "12 min" - reserved for future UI display
  const _timeDisplay = `${todayMinutes} ${t('common.min')}`
  void _timeDisplay

  const w = 280
  const h = 280
  const cx = w / 2
  const cy = h / 2
  const r = 100
  const strokeWidth = 24

  // Background circle
  const bgCircle = (
    <circle
      cx={cx} cy={cy} r={r}
      fill="none"
      stroke="var(--secondary-background)"
      strokeWidth={strokeWidth}
      className="opacity-20 dark:opacity-10"
    />
  )

  // Progress arc
  const circumference = 2 * Math.PI * r
  const offset = circumference - (percent / 100) * circumference

  const progCircle = (
    <circle
      cx={cx} cy={cy} r={r}
      fill="none"
      stroke="var(--system-blue)"
      strokeWidth={strokeWidth}
      strokeDasharray={circumference}
      strokeDashoffset={offset}
      strokeLinecap="round"
      transform={`rotate(-90 ${cx} ${cy})`}
      className="transition-all duration-1000 ease-out"
    />
  )

  const handleUpdate = async () => {
    setUpdating(true)
    try {
      await onGoalUpdate(newGoal)
      setShowAdjust(false)
    } catch (e) {
      console.error(e)
    } finally {
      setUpdating(false)
    }
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-[20px] p-6 shadow-lg border border-gray-100 dark:border-gray-700 flex flex-col items-center relative transition-transform duration-fast hover:scale-[1.02]">
      <div className="absolute top-4 right-4">
        <Button variant="ghost" size="icon" onClick={() => { setNewGoal(goalMinutes); setShowAdjust(true) }}>
          <Settings2 className="w-5 h-5 text-secondary-label" />
        </Button>
      </div>

      <div className="relative mb-4">
        <svg width={w} height={h} viewBox={`0 0 ${w} ${h}`}>
          {bgCircle}
          {progCircle}
        </svg>
        <div className="absolute inset-0 flex flex-col items-center justify-center">
          <div className="text-secondary-label text-sm font-medium uppercase tracking-wide mb-1">{t('home.today_reading')}</div>
          <div className="text-4xl font-bold text-label mb-1" style={{ fontVariantNumeric: 'tabular-nums' }}>
            {todayMinutes} <span className="text-xl font-medium text-secondary-label">min</span>
          </div>
        </div>
      </div>

      <div
        className="flex items-center gap-2 text-system-blue font-medium cursor-pointer hover:opacity-80 transition-opacity"
        onClick={() => { setNewGoal(goalMinutes); setShowAdjust(true) }}
      >
        <span>{t('home.daily_goal')}: {goalMinutes} min</span>
      </div>

      {showAdjust && (
        <Modal className="flex flex-col items-center">
          <div className="w-full max-w-[280px] md:max-w-sm">
            <h3 className="text-base md:text-lg font-bold mb-4 md:mb-6 text-center">{t('home.adjust_daily_goal')}</h3>

            <div className="flex flex-col items-center gap-3 md:gap-4">
              {/* 轮盘选择器 */}
              <WheelPicker
                value={newGoal}
                onChange={setNewGoal}
                min={1}
                max={1440}
                step={5}
              />

              <div className="text-base md:text-lg text-secondary-label">
                {t('common.min')}
              </div>

              {/* 快捷预设按钮 */}
              <div className="flex flex-wrap gap-1.5 md:gap-2 justify-center mt-1 md:mt-2">
                {[15, 30, 60, 90, 120].map((mins) => (
                  <button
                    key={mins}
                    onClick={() => setNewGoal(mins)}
                    className={`px-3 py-1.5 md:px-4 md:py-2 rounded-full text-xs md:text-sm font-medium transition-colors ${newGoal === mins
                        ? 'bg-system-blue text-white'
                        : 'bg-gray-100 dark:bg-gray-700 text-label hover:bg-gray-200 dark:hover:bg-gray-600'
                      }`}
                  >
                    {mins}
                  </button>
                ))}
              </div>

              <div className="flex gap-2 md:gap-3 w-full mt-3 md:mt-4">
                <Button variant="outline" className="flex-1 text-sm" onClick={() => setShowAdjust(false)}>
                  {t('common.cancel')}
                </Button>
                <Button className="flex-1 text-sm" onClick={handleUpdate} disabled={updating}>
                  {updating ? '...' : t('common.save')}
                </Button>
              </div>
            </div>
          </div>
        </Modal>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/pages/app/home/YearlyGoalCard.tsx
==================================================

/**
 * 年度阅读目标卡片
 *
 * 说明：
 * - 展示已读/目标书籍数量与剩余提示
 * - 显示封面栈视觉效果
 * - 支持轮盘选择器调整年度目标并调用 API 更新
 */
import { useState, useCallback, useEffect, useRef } from 'react'
import { useTranslation } from 'react-i18next'
import { Button } from '@/components/ui/button'
import Modal from '@/components/ui/Modal'
import { Settings2, ChevronUp, ChevronDown } from 'lucide-react'

type Props = {
  count: number;
  target: number;
  covers: string[];
  onGoalUpdate: (target: number) => Promise<void> | void;
}

// 轮盘式数字选择器组件 - 稳定版本，支持触摸滑动
function WheelPicker({
  value,
  onChange,
  min = 1,
  max = 365,
  step = 1,
}: {
  value: number;
  onChange: (v: number) => void;
  min?: number;
  max?: number;
  step?: number;
}) {
  const containerRef = useRef<HTMLDivElement>(null)
  const touchStartY = useRef<number>(0)
  const touchStartValue = useRef<number>(value)
  const valueRef = useRef<number>(value)

  // 同步 value 到 ref
  useEffect(() => {
    valueRef.current = value
  }, [value])

  // 快捷按钮调整
  const increment = useCallback(() => {
    onChange(Math.min(max, value + step))
  }, [value, max, step, onChange])

  const decrement = useCallback(() => {
    onChange(Math.max(min, value - step))
  }, [value, min, step, onChange])

  // 处理鼠标滚轮 - 使用 ref 避免频繁重绑事件
  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault()
    e.stopPropagation()

    const currentVal = valueRef.current
    const delta = e.deltaY > 0 ? -step : step
    const newValue = Math.max(min, Math.min(max, currentVal + delta))

    if (newValue !== currentVal) {
      onChange(newValue)
    }
  }, [min, max, step, onChange])

  // 触摸开始
  const handleTouchStart = useCallback((e: TouchEvent) => {
    touchStartY.current = e.touches[0].clientY
    touchStartValue.current = valueRef.current
  }, [])

  // 触摸移动
  const handleTouchMove = useCallback((e: TouchEvent) => {
    e.preventDefault()
    const deltaY = touchStartY.current - e.touches[0].clientY
    const deltaSteps = Math.round(deltaY / 30) // 每30px一个step
    const newValue = Math.max(min, Math.min(max, touchStartValue.current + deltaSteps * step))

    if (newValue !== valueRef.current) {
      onChange(newValue)
    }
  }, [min, max, step, onChange])

  // 绑定事件监听器
  useEffect(() => {
    const container = containerRef.current
    if (!container) return

    // 使用 passive: false 允许 preventDefault
    container.addEventListener('wheel', handleWheel, { passive: false })
    container.addEventListener('touchstart', handleTouchStart, { passive: true })
    container.addEventListener('touchmove', handleTouchMove, { passive: false })

    return () => {
      container.removeEventListener('wheel', handleWheel)
      container.removeEventListener('touchstart', handleTouchStart)
      container.removeEventListener('touchmove', handleTouchMove)
    }
  }, [handleWheel, handleTouchStart, handleTouchMove])

  // 计算上下显示的数值
  const prevValue = value > min ? value - step : null
  const nextValue = value < max ? value + step : null

  return (
    <div className="flex flex-col items-center gap-1">
      {/* 上箭头 */}
      <button
        type="button"
        onClick={increment}
        className="p-2 md:p-3 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors active:scale-95"
      >
        <ChevronUp className="w-5 h-5 md:w-6 md:h-6 text-system-blue" />
      </button>

      {/* 数字滚动区域 */}
      <div
        ref={containerRef}
        className="relative select-none touch-none cursor-ns-resize"
      >
        {/* 中间高亮框 */}
        <div className="absolute inset-x-0 top-1/2 -translate-y-1/2 h-10 md:h-14 border-y-2 border-system-blue/30 pointer-events-none" />

        {/* 数字显示区域 */}
        <div className="py-4 md:py-6 px-6 md:px-10">
          <div className="flex flex-col items-center justify-center gap-2 md:gap-3">
            {/* 上一个数值 */}
            <div className="text-lg md:text-2xl font-medium text-gray-300 dark:text-gray-600 h-6 md:h-8 flex items-center justify-center tabular-nums min-w-[60px] md:min-w-[80px]">
              {prevValue ?? ''}
            </div>

            {/* 当前数值 */}
            <div className="text-3xl md:text-5xl font-bold text-system-blue h-10 md:h-14 flex items-center justify-center tabular-nums min-w-[60px] md:min-w-[80px]">
              {value}
            </div>

            {/* 下一个数值 */}
            <div className="text-lg md:text-2xl font-medium text-gray-300 dark:text-gray-600 h-6 md:h-8 flex items-center justify-center tabular-nums min-w-[60px] md:min-w-[80px]">
              {nextValue ?? ''}
            </div>
          </div>
        </div>
      </div>

      {/* 下箭头 */}
      <button
        type="button"
        onClick={decrement}
        className="p-2 md:p-3 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors active:scale-95"
      >
        <ChevronDown className="w-5 h-5 md:w-6 md:h-6 text-system-blue" />
      </button>
    </div>
  )
}

export default function YearlyGoalCard({ count, target, covers, onGoalUpdate }: Props) {
  const { t } = useTranslation('common')
  const [showAdjust, setShowAdjust] = useState(false)
  const [newTarget, setNewTarget] = useState(target)
  const [updating, setUpdating] = useState(false)

  const remain = Math.max(0, target - count)

  // 当弹窗打开时，同步当前目标值
  useEffect(() => {
    if (showAdjust) {
      setNewTarget(target)
    }
  }, [showAdjust, target])

  const handleUpdate = async () => {
    setUpdating(true)

    try {
      await onGoalUpdate(newTarget)
      setShowAdjust(false)
    } catch (e) {
      console.error('[YearlyGoalCard] Error:', e)
    } finally {
      setUpdating(false)
    }
  }

  return (
    <div className="relative mt-8 bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700 rounded-[20px] shadow-lg p-6 overflow-hidden transition-transform duration-fast hover:scale-[1.01]">
      <div className="flex justify-between items-start mb-4 relative z-10">
        <div>
          <div className="text-secondary-label text-sm font-medium uppercase tracking-wide mb-1">{t('home.yearly_goal')}</div>
          <div className="text-2xl font-bold mb-1">
            {remain === 0 ? t('yearly_goal.reached_msg') : t('yearly_goal.remaining_msg', { count: remain })}
          </div>
          <div className="text-secondary-label text-sm">
            {count} / {target} {t('common.books')}
          </div>
        </div>
        <Button variant="ghost" size="icon" onClick={() => { setNewTarget(target); setShowAdjust(true) }}>
          <Settings2 className="w-5 h-5 text-secondary-label" />
        </Button>
      </div>

      {/* Book Stack Visualization */}
      <div className="relative h-32 mt-4 flex items-end ml-4">
        {covers.length > 0 ? (
          covers.slice(0, 5).map((cv, idx) => {
            const z = 10 - idx
            const off = idx * 25
            return (
              <div
                key={idx}
                className="absolute w-20 h-32 rounded-md shadow-lg border border-white/20 transition-transform hover:-translate-y-2"
                style={{
                  left: `${off}px`,
                  zIndex: z,
                  backgroundImage: cv ? `url(${cv})` : undefined,
                  backgroundColor: '#fff',
                  backgroundSize: 'cover',
                  backgroundPosition: 'center',
                  transform: `rotate(${idx * 2}deg)`
                }}
              />
            )
          })
        ) : (
          <div className="w-20 h-32 rounded-md bg-gray-200 dark:bg-gray-700 border-2 border-dashed border-gray-300 dark:border-gray-600 flex items-center justify-center">
            <span className="text-xs text-secondary-label">No books</span>
          </div>
        )}
      </div>

      {showAdjust && (
        <Modal className="flex flex-col items-center">
          <div className="w-full max-w-[280px] md:max-w-sm">
            <h3 className="text-base md:text-lg font-bold mb-4 md:mb-6 text-center">{t('home.adjust_yearly_goal')}</h3>

            <div className="flex flex-col items-center gap-3 md:gap-4">
              {/* 轮盘选择器 */}
              <WheelPicker
                value={newTarget}
                onChange={setNewTarget}
                min={1}
                max={365}
                step={1}
              />

              <div className="text-base md:text-lg text-secondary-label">
                {t('common.books')}
              </div>

              {/* 快捷预设按钮 */}
              <div className="flex flex-wrap gap-1.5 md:gap-2 justify-center mt-1 md:mt-2">
                {[12, 24, 52, 100, 150].map((num) => (
                  <button
                    key={num}
                    onClick={() => setNewTarget(num)}
                    className={`px-3 py-1.5 md:px-4 md:py-2 rounded-full text-xs md:text-sm font-medium transition-colors ${newTarget === num
                        ? 'bg-system-blue text-white'
                        : 'bg-gray-100 dark:bg-gray-700 text-label hover:bg-gray-200 dark:hover:bg-gray-600'
                      }`}
                  >
                    {num}
                  </button>
                ))}
              </div>

              <div className="flex gap-2 md:gap-3 w-full mt-3 md:mt-4">
                <Button variant="outline" className="flex-1 text-sm" onClick={() => setShowAdjust(false)}>
                  {t('common.cancel')}
                </Button>
                <Button className="flex-1 text-sm" onClick={handleUpdate} disabled={updating}>
                  {updating ? '...' : t('common.save')}
                </Button>
              </div>
            </div>
          </div>
        </Modal>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/hooks/useBooksData.ts
==================================================

/**
 * useBooksData - 书籍数据统一入口 Hook (PowerSync Only)
 *
 * 直接使用 PowerSync SQLite 作为唯一数据源
 * 不再使用 Dexie 或 libraryStorage
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 3
 */

import { useMemo, useCallback } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, usePowerSyncState } from '@/lib/powersync'
import { useAuthStore } from '@/stores/auth'

// ============================================================================
// 类型定义
// ============================================================================

export interface BookItem {
  id: string
  title: string
  author?: string
  coverUrl?: string
  progress?: number
  isFinished?: boolean
  downloadUrl?: string
  updatedAt?: string
  createdAt?: string
  ocrStatus?: string | null
  isImageBased?: boolean
  conversionStatus?: string | null
  originalFormat?: string
}

interface BookRow {
  id: string
  title: string
  author: string | null
  cover_url: string | null
  storage_key: string
  file_size: number
  content_sha256: string | null
  file_type: string | null
  created_at: string
  updated_at: string
  deleted_at: string | null
  // 扩展字段
  ocr_status?: string | null
  is_digitalized?: number | null
  initial_digitalization_confidence?: number | null
  conversion_status?: string | null
}

/**
 * reading_progress 表行结构
 * 使用 progress 字段 (REAL 0-1) 和 finished_at 字段
 */
interface ProgressRow {
  book_id: string
  progress: number  // 0-1, 不是 percentage
  finished_at: string | null  // ISO 8601 时间戳，表示已读完
}

interface UseBooksDataOptions {
  /** 排序方式 */
  sortBy?: 'recent' | 'title' | 'author' | 'upload'
  /** 是否包含已删除 */
  includeDeleted?: boolean
  /** 搜索关键词 */
  search?: string
}

// ============================================================================
// Hook 实现
// ============================================================================

export function useBooksData(options: UseBooksDataOptions = {}) {
  const db = usePowerSyncDatabase()
  const { isInitialized, isConnected } = usePowerSyncState()
  const accessToken = useAuthStore(s => s.accessToken)

  const { sortBy = 'recent', includeDeleted = false, search } = options

  // 检查 PowerSync 是否准备就绪
  const isReady = isInitialized && db !== null

  // 构建排序 SQL
  const orderClause = useMemo(() => {
    switch (sortBy) {
      case 'title':
        return 'ORDER BY title COLLATE NOCASE ASC'
      case 'author':
        return 'ORDER BY author COLLATE NOCASE ASC'
      case 'upload':
        return 'ORDER BY created_at DESC'
      case 'recent':
      default:
        return 'ORDER BY updated_at DESC'
    }
  }, [sortBy])

  // 主查询：书籍列表
  const booksSql = useMemo(() => {
    let sql = 'SELECT * FROM books'
    const conditions: string[] = []

    if (!includeDeleted) {
      conditions.push('deleted_at IS NULL')
    }

    if (search) {
      conditions.push("(title LIKE ? OR author LIKE ?)")
    }

    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ')
    }

    sql += ` ${orderClause}`
    return sql
  }, [includeDeleted, search, orderClause])

  const booksParams = useMemo(() => {
    if (search) {
      const pattern = `%${search}%`
      return [pattern, pattern]
    }
    return []
  }, [search])

  // 阅读进度查询 - 使用正确的字段名 progress 和 finished_at
  const progressSql = 'SELECT book_id, progress, finished_at FROM reading_progress'

  // Live Queries - 只有在 PowerSync 完全就绪时才执行真实查询
  // 使用稳定的空查询作为占位符，避免 Hook 顺序问题
  const EMPTY_BOOKS_QUERY = 'SELECT * FROM books WHERE 1=0'
  const EMPTY_PROGRESS_QUERY = 'SELECT book_id, progress, finished_at FROM reading_progress WHERE 1=0'
  
  const safeBooksQuery = isReady ? booksSql : EMPTY_BOOKS_QUERY
  const safeProgressQuery = isReady ? progressSql : EMPTY_PROGRESS_QUERY
  const safeBooksParams = isReady ? booksParams : []
  
  const { data: booksData, isLoading: booksLoading, error: booksError } = useQuery<BookRow>(safeBooksQuery, safeBooksParams)
  const { data: progressData } = useQuery<ProgressRow>(safeProgressQuery, [])

  // 构建进度映射 - 同时存储 progress 和 finished_at
  const progressMap = useMemo(() => {
    const map = new Map<string, { progress: number; finishedAt: string | null }>()
    if (progressData) {
      console.log('[useBooksData] Progress data from DB:', progressData)
      progressData.forEach(p => {
        map.set(p.book_id, {
          progress: Math.round((p.progress ?? 0) * 100),
          finishedAt: p.finished_at
        })
      })
    }
    return map
  }, [progressData])

  // 转换为 UI 格式
  const items: BookItem[] = useMemo(() => {
    if (!booksData) return []

    const token = accessToken || localStorage.getItem('access_token') || ''

    return booksData.map((book): BookItem => {
      const progressInfo = progressMap.get(book.id)
      const progress = progressInfo?.progress || 0
      // isFinished 优先检查 finished_at 字段，其次检查 progress >= 100
      const isFinished = progressInfo?.finishedAt ? true : progress >= 100
      
      return {
        id: book.id,
        title: book.title || '未命名',
        author: book.author || undefined,
        // 只有当 PowerSync 同步的 cover_url 有值时，才生成封面访问 URL
        // 封面是二进制文件，通过 REST API 代理获取（编码宪法 3.3 规定）
        coverUrl: book.cover_url && book.id && token
          ? `/api/v1/books/${book.id}/cover?token=${encodeURIComponent(token)}`
          : undefined,
        progress,
        isFinished,
        updatedAt: book.updated_at,
        createdAt: book.created_at,
        ocrStatus: book.ocr_status || null,
        // isImageBased = !is_digitalized || (is_digitalized && confidence < 0.8)
        isImageBased: book.is_digitalized !== 1 || (book.is_digitalized === 1 && (book.initial_digitalization_confidence ?? 1) < 0.8),
        conversionStatus: book.conversion_status || null,
        originalFormat: book.file_type || undefined,
      }
    })
  }, [booksData, progressMap, accessToken])

  // 书籍统计
  const stats = useMemo(() => {
    const total = items.length
    const finished = items.filter(i => i.isFinished).length
    const inProgress = items.filter(i => (i.progress ?? 0) > 0 && !i.isFinished).length
    const notStarted = total - finished - inProgress

    return { total, finished, inProgress, notStarted }
  }, [items])

  // 检查是否有正在处理的书籍
  const hasProcessing = useMemo(() =>
    items.some(item =>
      item.ocrStatus === 'pending' || item.ocrStatus === 'processing' ||
      item.conversionStatus === 'pending' || item.conversionStatus === 'processing'
    ),
    [items]
  )

  // 获取正在处理的书籍 ID
  const processingBookIds = useMemo(() => {
    return items
      .filter(item =>
        item.ocrStatus === 'pending' || item.ocrStatus === 'processing' ||
        item.conversionStatus === 'pending' || item.conversionStatus === 'processing'
      )
      .map(item => item.id)
  }, [items])

  // 刷新函数（PowerSync 自动同步，这里只是触发一次手动同步请求）
  const refresh = useCallback(async () => {
    if (!db) return

    try {
      // 触发 PowerSync 同步（如果已连接）
      // 注意：PowerSync 会自动管理同步，此处仅作为手动触发的入口
      console.log('[useBooksData] Manual refresh triggered')
    } catch (error) {
      console.error('[useBooksData] Refresh error:', error)
    }
  }, [db])

  // 更新书籍元数据
  const updateBook = useCallback(async (id: string, updates: { title?: string; author?: string }) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    const fields: string[] = ['updated_at = ?']
    const values: any[] = [now]

    if (updates.title !== undefined) {
      fields.push('title = ?')
      values.push(updates.title)
    }
    if (updates.author !== undefined) {
      fields.push('author = ?')
      values.push(updates.author)
    }

    if (fields.length === 1) return // No updates

    values.push(id)
    await db.execute(`UPDATE books SET ${fields.join(', ')} WHERE id = ?`, values)
  }, [db])

  return {
    /** 书籍列表 */
    items,
    /** 加载状态 - 包含 PowerSync 未初始化的情况 */
    isLoading: !isReady || booksLoading,
    /** 错误信息 */
    error: booksError,
    /** 书籍统计 */
    stats,
    /** 是否有正在处理的书籍 */
    hasProcessing,
    /** 正在处理的书籍 ID 列表 */
    processingBookIds,
    /** 手动刷新 */
    refresh,
    /** 更新书籍 */
    updateBook,
    /** PowerSync 数据库是否完全就绪 */
    isReady,
    /** PowerSync 是否已连接到服务器 */
    isConnected,
  }
}

/**
 * 获取单本书籍数据
 */
export function useBookData(bookId: string | null) {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const accessToken = useAuthStore(s => s.accessToken)

  const isReady = isInitialized && db !== null

  // 在 PowerSync 初始化完成前使用空查询
  const bookQuery = isReady && bookId
    ? 'SELECT * FROM books WHERE id = ? AND deleted_at IS NULL'
    : 'SELECT * FROM books WHERE 1=0'
  
  const progressQuery = isReady && bookId
    ? 'SELECT book_id, progress FROM reading_progress WHERE book_id = ?'
    : 'SELECT book_id, progress FROM reading_progress WHERE 1=0'

  const { data, isLoading, error } = useQuery<BookRow>(
    bookQuery,
    isReady && bookId ? [bookId] : []
  )

  const { data: progressData } = useQuery<ProgressRow>(
    progressQuery,
    isReady && bookId ? [bookId] : []
  )

  const book: BookItem | null = useMemo(() => {
    if (!data?.[0]) return null

    const bookRow = data[0]
    const token = accessToken || localStorage.getItem('access_token') || ''
    const progress = progressData?.[0]?.progress ?? 0

    return {
      id: bookRow.id,
      title: bookRow.title || '未命名',
      author: bookRow.author || undefined,
      // 只有当 PowerSync 同步的 cover_url 有值时，才生成封面访问 URL
      // 封面是二进制文件，通过 REST API 代理获取（编码宪法 3.3 规定）
      coverUrl: bookRow.cover_url && bookRow.id && token
        ? `/api/v1/books/${bookRow.id}/cover?token=${encodeURIComponent(token)}`
        : undefined,
      progress: Math.round(progress * 100),
      isFinished: progress >= 1,
      updatedAt: bookRow.updated_at,
      createdAt: bookRow.created_at,
      ocrStatus: bookRow.ocr_status || null,
      // isImageBased = !is_digitalized || (is_digitalized && confidence < 0.8)
      isImageBased: bookRow.is_digitalized !== 1 || (bookRow.is_digitalized === 1 && (bookRow.initial_digitalization_confidence ?? 1) < 0.8),
      conversionStatus: bookRow.conversion_status || null,
      originalFormat: bookRow.file_type || undefined,
    }
  }, [data, progressData, accessToken])

  return {
    book,
    isLoading: !isReady || isLoading,
    error,
    isReady,
  }
}

// ============================================================================
// 书架视图 Hook
// ============================================================================

interface ShelfRow {
  id: string
  name: string
  description: string | null
  sort_order: number | null
  created_at: string
}

interface ShelfBookRow {
  shelf_id: string
  book_id: string
  sort_order: number | null
}

export interface ShelfWithBooks {
  id: string
  name: string
  books: BookItem[]
}

/**
 * 获取按书架分组的书籍数据
 */
export function useShelvesWithBooks() {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const accessToken = useAuthStore(s => s.accessToken)

  const isReady = isInitialized && db !== null

  // 查询书架列表
  const EMPTY_QUERY = 'SELECT * FROM shelves WHERE 1=0'
  const shelvesQuery = isReady 
    ? 'SELECT * FROM shelves WHERE is_deleted = 0 OR is_deleted IS NULL ORDER BY sort_order ASC, name ASC'
    : EMPTY_QUERY
  
  const { data: shelvesData, isLoading: shelvesLoading } = useQuery<ShelfRow>(shelvesQuery, [])

  // 查询书架-书籍关联
  const shelfBooksQuery = isReady
    ? 'SELECT shelf_id, book_id, sort_order FROM shelf_books ORDER BY sort_order ASC'
    : 'SELECT shelf_id, book_id, sort_order FROM shelf_books WHERE 1=0'
  
  const { data: shelfBooksData } = useQuery<ShelfBookRow>(shelfBooksQuery, [])

  // 查询所有书籍
  const booksQuery = isReady
    ? 'SELECT * FROM books WHERE deleted_at IS NULL'
    : 'SELECT * FROM books WHERE 1=0'
  
  const { data: booksData } = useQuery<BookRow>(booksQuery, [])

  // 查询阅读进度 - 使用正确的字段名 progress
  const progressQuery = isReady
    ? 'SELECT book_id, progress FROM reading_progress'
    : 'SELECT book_id, progress FROM reading_progress WHERE 1=0'
  
  const { data: progressData } = useQuery<ProgressRow>(progressQuery, [])

  // 构建进度映射
  const progressMap = useMemo(() => {
    const map = new Map<string, number>()
    if (progressData) {
      progressData.forEach(p => {
        map.set(p.book_id, Math.round((p.progress ?? 0) * 100))
      })
    }
    return map
  }, [progressData])

  // 构建书籍映射
  const booksMap = useMemo(() => {
    const map = new Map<string, BookItem>()
    const token = accessToken || localStorage.getItem('access_token') || ''
    
    if (booksData) {
      booksData.forEach(book => {
        map.set(book.id, {
          id: book.id,
          title: book.title || '未命名',
          author: book.author || undefined,
          // 只有当 PowerSync 同步的 cover_url 有值时，才生成封面访问 URL
          coverUrl: book.cover_url && book.id && token
            ? `/api/v1/books/${book.id}/cover?token=${encodeURIComponent(token)}`
            : undefined,
          progress: progressMap.get(book.id) || 0,
          isFinished: (progressMap.get(book.id) || 0) >= 100,
          updatedAt: book.updated_at,
          createdAt: book.created_at,
          ocrStatus: book.ocr_status || null,
          // isImageBased = !is_digitalized || (is_digitalized && confidence < 0.8)
          isImageBased: book.is_digitalized !== 1 || (book.is_digitalized === 1 && (book.initial_digitalization_confidence ?? 1) < 0.8),
          conversionStatus: book.conversion_status || null,
          originalFormat: book.file_type || undefined,
        })
      })
    }
    return map
  }, [booksData, progressMap, accessToken])

  // 构建书架-书籍映射
  const shelfBooksMap = useMemo(() => {
    const map = new Map<string, string[]>()
    if (shelfBooksData) {
      shelfBooksData.forEach(sb => {
        const bookIds = map.get(sb.shelf_id) || []
        bookIds.push(sb.book_id)
        map.set(sb.shelf_id, bookIds)
      })
    }
    return map
  }, [shelfBooksData])

  // 已分配到书架的书籍 ID 集合
  const assignedBookIds = useMemo(() => {
    const set = new Set<string>()
    if (shelfBooksData) {
      shelfBooksData.forEach(sb => set.add(sb.book_id))
    }
    return set
  }, [shelfBooksData])

  // 构建书架列表（含书籍）
  const shelves: ShelfWithBooks[] = useMemo(() => {
    if (!shelvesData) return []

    return shelvesData.map(shelf => ({
      id: shelf.id,
      name: shelf.name,
      books: (shelfBooksMap.get(shelf.id) || [])
        .map(bookId => booksMap.get(bookId))
        .filter((book): book is BookItem => book !== undefined)
    }))
  }, [shelvesData, shelfBooksMap, booksMap])

  // 未分配书架的书籍
  const unshelvedBooks: BookItem[] = useMemo(() => {
    if (!booksData) return []
    
    return Array.from(booksMap.values())
      .filter(book => !assignedBookIds.has(book.id))
  }, [booksMap, assignedBookIds, booksData])

  return {
    shelves,
    unshelvedBooks,
    isLoading: !isReady || shelvesLoading,
    isReady,
  }
}


==================================================
FILE_PATH: web/src/hooks/useTolgeeLanguages.ts
==================================================

/**
 * Tolgee 语言列表 Hook
 *
 * 说明：
 * - 优先从 Tolgee API 获取语言；缺失时回退到本地 i18n 资源
 * - 规范化语言标签（如 zh → zh-CN）
 * - 定期轮询语言列表并在当前语言不在集合时回退
 */
import { useEffect, useState } from 'react'
import i18n from '../i18n'

type Lang = { code: string; name?: string; raw?: string }

function normalize(tag: string): string {
  const t = (tag || '').toLowerCase()
  if (t === 'zh' || t === 'zh_cn' || t === 'zh-hans') return 'zh-CN'
  if (t === 'en' || t === 'en_us') return 'en-US'
  return tag
}

async function fetchTolgeeLanguages(): Promise<Lang[]> {
  const apiUrl = import.meta.env.VITE_APP_TOLGEE_API_URL as string
  const apiKey = import.meta.env.VITE_APP_TOLGEE_API_KEY as string
  if (!apiUrl || !apiKey) {
    const res = i18n.options?.resources || {}
    return Object.keys(res).map((code) => ({ code: normalize(code), raw: code }))
  }
  try {
    const r = await fetch(`${apiUrl}/v2/projects/current/languages`, { headers: { 'X-API-Key': apiKey } })
    const j = await r.json().catch(() => undefined)
    const arr = Array.isArray(j) ? j : (j?.languages || [])
    return arr.map((it: any) => { const raw = it.tag || it.code || it.languageTag || it.name || it; return ({ code: normalize(raw), raw, name: it.name }) })
  } catch {
    const res = i18n.options?.resources || {}
    return Object.keys(res).map((code) => ({ code: normalize(code), raw: code }))
  }
}

export function useTolgeeLanguages() {
  const [langs, setLangs] = useState<Lang[]>([])
  useEffect(() => {
    let mounted = true
    const load = async () => {
      const list = await fetchTolgeeLanguages()
      if (!mounted) return
      setLangs(list)
      const cur = i18n.language
      const codes = list.map((l) => l.code)
      if (cur && codes.length && !codes.includes(cur)) {
        i18n.changeLanguage(codes[0])
      }
    }
    load()
    const timerId = setInterval(load, 15000)
    return () => { mounted = false; clearInterval(timerId) }
  }, [])
  return langs
}


==================================================
FILE_PATH: web/src/hooks/useShelvesData.ts
==================================================

/**
 * useShelvesData - 书架数据统一入口 Hook (PowerSync Only)
 *
 * 直接使用 PowerSync SQLite 作为唯一数据源
 * 替代原有的 useOfflineShelves, useOfflineShelvesV2 等
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 3
 */

import { useMemo, useCallback } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, usePowerSyncState } from '@/lib/powersync'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

export interface ShelfData {
  id: string
  name: string
  description?: string
  color?: string
  icon?: string
  sortOrder: number
  bookCount: number
  createdAt: string
  updatedAt: string
}

export interface ShelfBookData {
  bookId: string
  title: string
  author?: string
  coverPath?: string
  addedAt: string
}

interface ShelfRow {
  id: string
  name: string
  description: string | null
  color: string | null
  icon: string | null
  sort_order: number
  created_at: string
  updated_at: string
  deleted_at: string | null
}

interface ShelfWithCountRow extends ShelfRow {
  book_count: number
}

interface ShelfBookRow {
  id: string
  shelf_id: string
  book_id: string
  sort_order: number
  added_at: string
  // 关联的书籍信息
  title: string
  author: string | null
  cover_path: string | null
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取所有书架列表（带书籍数量）
 */
export function useShelvesData() {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const isReady = isInitialized && db !== null

  const EMPTY_QUERY = 'SELECT * FROM shelves WHERE 1=0'
  
  const sql = isReady
    ? `
    SELECT s.*, COALESCE(sb.book_count, 0) as book_count
    FROM shelves s
    LEFT JOIN (
      SELECT shelf_id, COUNT(*) as book_count
      FROM shelf_books
      GROUP BY shelf_id
    ) sb ON s.id = sb.shelf_id
    WHERE s.deleted_at IS NULL
    ORDER BY s.sort_order ASC, s.name ASC
  `
    : EMPTY_QUERY

  const { data, isLoading, error } = useQuery<ShelfWithCountRow>(sql, [])

  const shelves: ShelfData[] = useMemo(() => {
    if (!data) return []

    return data.map((row): ShelfData => ({
      id: row.id,
      name: row.name,
      description: row.description ?? undefined,
      color: row.color ?? undefined,
      icon: row.icon ?? undefined,
      sortOrder: row.sort_order,
      bookCount: row.book_count,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    }))
  }, [data])

  // 创建书架
  const createShelf = useCallback(async (shelf: { name: string; description?: string; color?: string; icon?: string }) => {
    if (!db) throw new Error('Database not available')

    const id = generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id - 从 AuthStore 获取
    const userId = useAuthStore.getState().user?.id || ''

    // 获取最大排序值 - 使用 getAll 避免空结果异常
    const maxOrderRows = await db.getAll<{ max_order: number }>(
      'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelves'
    )
    const maxOrder = maxOrderRows[0]?.max_order ?? 0

    await db.execute(
      `INSERT INTO shelves (id, user_id, name, description, color, icon, sort_order, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        shelf.name,
        shelf.description ?? null,
        shelf.color ?? null,
        shelf.icon ?? null,
        maxOrder + 1,
        now,
        now
      ]
    )

    return id
  }, [db])

  // 更新书架
  const updateShelf = useCallback(async (id: string, updates: Partial<Omit<ShelfData, 'id' | 'createdAt' | 'bookCount'>>) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    const fields: string[] = ['updated_at = ?']
    const values: (string | number | null)[] = [now]

    if (updates.name !== undefined) {
      fields.push('name = ?')
      values.push(updates.name)
    }
    if (updates.description !== undefined) {
      fields.push('description = ?')
      values.push(updates.description ?? null)
    }
    if (updates.color !== undefined) {
      fields.push('color = ?')
      values.push(updates.color ?? null)
    }
    if (updates.icon !== undefined) {
      fields.push('icon = ?')
      values.push(updates.icon ?? null)
    }
    if (updates.sortOrder !== undefined) {
      fields.push('sort_order = ?')
      values.push(updates.sortOrder)
    }

    values.push(id)
    await db.execute(`UPDATE shelves SET ${fields.join(', ')} WHERE id = ?`, values)
  }, [db])

  // 删除书架
  const deleteShelf = useCallback(async (id: string) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    await db.execute(
      'UPDATE shelves SET deleted_at = ?, updated_at = ? WHERE id = ?',
      [now, now, id]
    )
  }, [db])

  return {
    shelves,
    isLoading: !isReady || isLoading,
    error,
    createShelf,
    updateShelf,
    deleteShelf,
    isReady,
  }
}

/**
 * 获取书架详情及其书籍
 */
export function useShelfData(shelfId: string | null) {
  const db = usePowerSyncDatabase()
  const userId = useAuthStore(s => s.user?.id)

  // 书架信息
  const { data: shelfData, isLoading: shelfLoading } = useQuery<ShelfRow>(
    shelfId ? 'SELECT * FROM shelves WHERE id = ? AND deleted_at IS NULL' : 'SELECT * FROM shelves WHERE 1=0',
    shelfId ? [shelfId] : []
  )

  // 书架中的书籍
  const booksSql = shelfId
    ? `
      SELECT sb.*, b.title, b.author, b.cover_path
      FROM shelf_books sb
      INNER JOIN books b ON sb.book_id = b.id
      WHERE sb.shelf_id = ? AND b.deleted_at IS NULL
      ORDER BY sb.sort_order ASC, sb.added_at DESC
    `
    : 'SELECT * FROM shelf_books WHERE 1=0'

  const { data: booksData, isLoading: booksLoading } = useQuery<ShelfBookRow>(
    booksSql,
    shelfId ? [shelfId] : []
  )

  const shelf: ShelfData | null = useMemo(() => {
    if (!shelfData?.[0]) return null

    const row = shelfData[0]
    return {
      id: row.id,
      name: row.name,
      description: row.description ?? undefined,
      color: row.color ?? undefined,
      icon: row.icon ?? undefined,
      sortOrder: row.sort_order,
      bookCount: booksData?.length ?? 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    }
  }, [shelfData, booksData])

  const books: ShelfBookData[] = useMemo(() => {
    if (!booksData) return []

    return booksData.map((row): ShelfBookData => ({
      bookId: row.book_id,
      title: row.title,
      author: row.author ?? undefined,
      coverPath: row.cover_path ?? undefined,
      addedAt: row.added_at,
    }))
  }, [booksData])

  // 添加书籍到书架
  const addBook = useCallback(async (bookId: string) => {
    if (!db || !shelfId || !userId) throw new Error('Database, shelfId or userId not available')

    // 检查是否已存在 - 使用 getAll 避免空结果异常
    const existingRows = await db.getAll<{ id: string }>(
      'SELECT id FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
      [shelfId, bookId]
    )

    if (existingRows.length > 0) return existingRows[0].id

    const id = generateUUID()
    const now = new Date().toISOString()

    // 获取最大排序值 - 使用 getAll 避免空结果异常
    const maxOrderRows = await db.getAll<{ max_order: number }>(
      'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelf_books WHERE shelf_id = ?',
      [shelfId]
    )
    const maxOrder = maxOrderRows[0]?.max_order ?? 0

    await db.execute(
      `INSERT INTO shelf_books (id, user_id, shelf_id, book_id, sort_order, added_at)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [id, userId, shelfId, bookId, maxOrder + 1, now]
    )

    return id
  }, [db, shelfId, userId])

  // 从书架移除书籍
  const removeBook = useCallback(async (bookId: string) => {
    if (!db || !shelfId) throw new Error('Database or shelfId not available')

    await db.execute(
      'DELETE FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
      [shelfId, bookId]
    )
  }, [db, shelfId])

  // 更新书籍排序
  const reorderBooks = useCallback(async (bookIds: string[]) => {
    if (!db || !shelfId) throw new Error('Database or shelfId not available')

    // 批量更新排序
    for (let i = 0; i < bookIds.length; i++) {
      await db.execute(
        'UPDATE shelf_books SET sort_order = ? WHERE shelf_id = ? AND book_id = ?',
        [i + 1, shelfId, bookIds[i]]
      )
    }
  }, [db, shelfId])

  return {
    shelf,
    books,
    isLoading: shelfLoading || booksLoading,
    addBook,
    removeBook,
    reorderBooks,
    isReady: !!db,
  }
}

/**
 * 获取书籍所属的书架列表
 */
export function useBookShelvesData(bookId: string | null) {
  const db = usePowerSyncDatabase()

  const sql = bookId
    ? `
      SELECT s.*
      FROM shelves s
      INNER JOIN shelf_books sb ON s.id = sb.shelf_id
      WHERE sb.book_id = ? AND s.deleted_at IS NULL
      ORDER BY s.name ASC
    `
    : 'SELECT * FROM shelves WHERE 1=0'

  const { data, isLoading, error } = useQuery<ShelfRow>(sql, bookId ? [bookId] : [])

  const shelves: ShelfData[] = useMemo(() => {
    if (!data) return []

    return data.map((row): ShelfData => ({
      id: row.id,
      name: row.name,
      description: row.description ?? undefined,
      color: row.color ?? undefined,
      icon: row.icon ?? undefined,
      sortOrder: row.sort_order,
      bookCount: 0, // 此查询不包含书籍数量
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    }))
  }, [data])

  // 将书籍添加到指定书架
  const addToShelf = useCallback(async (shelfId: string) => {
    if (!db || !bookId) throw new Error('Database or bookId not available')

    const existingRows = await db.getAll<{ id: string }>(
      'SELECT id FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
      [shelfId, bookId]
    )

    if (existingRows.length > 0) return

    const id = generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id - 从 AuthStore 获取
    const userId = useAuthStore.getState().user?.id || ''

    const maxOrderRows = await db.getAll<{ max_order: number }>(
      'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelf_books WHERE shelf_id = ?',
      [shelfId]
    )
    const maxOrder = maxOrderRows[0]?.max_order ?? 0

    await db.execute(
      `INSERT INTO shelf_books (id, user_id, shelf_id, book_id, sort_order, added_at)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [id, userId, shelfId, bookId, maxOrder + 1, now]
    )
  }, [db, bookId])

  // 从指定书架移除书籍
  const removeFromShelf = useCallback(async (shelfId: string) => {
    if (!db || !bookId) throw new Error('Database or bookId not available')

    await db.execute(
      'DELETE FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
      [shelfId, bookId]
    )
  }, [db, bookId])

  return {
    shelves,
    isLoading,
    error,
    addToShelf,
    removeFromShelf,
    isReady: !!db,
  }
}


==================================================
FILE_PATH: web/src/hooks/useOnlineStatus.ts
==================================================

/**
 * useOnlineStatus.ts
 * 
 * 网络状态检测 Hook
 * 
 * 功能:
 * - 监听 online/offline 事件检测网络状态变化
 * - 使用 navigator.onLine 获取初始状态
 * - 提供 isOnline 状态和上次变化时间
 * - 触发 online/offline 时执行回调
 * 
 * @see App-First改造计划.md - Phase 1.1
 */

import { useState, useEffect, useCallback, useRef } from 'react'

export interface OnlineStatusOptions {
  /** 网络恢复时的回调 */
  onOnline?: () => void
  /** 网络断开时的回调 */
  onOffline?: () => void
}

export interface OnlineStatusReturn {
  /** 当前是否在线 */
  isOnline: boolean
  /** 上次状态变化的时间戳 */
  lastChangedAt: number | null
  /** 离线持续时间（毫秒），在线时为 0 */
  offlineDuration: number
}

/**
 * 网络状态检测 Hook
 * 
 * @example
 * ```tsx
 * const { isOnline, offlineDuration } = useOnlineStatus({
 *   onOnline: () => toast.success('网络已恢复'),
 *   onOffline: () => toast.warning('网络已断开'),
 * })
 * ```
 */
export function useOnlineStatus(options: OnlineStatusOptions = {}): OnlineStatusReturn {
  const { onOnline, onOffline } = options

  // 使用 navigator.onLine 作为初始状态
  const [isOnline, setIsOnline] = useState<boolean>(() => {
    // SSR 兼容：服务端默认返回 true
    if (typeof navigator === 'undefined') return true
    return navigator.onLine
  })

  const [lastChangedAt, setLastChangedAt] = useState<number | null>(null)
  const [offlineDuration, setOfflineDuration] = useState<number>(0)

  // 使用 ref 保存回调，避免 effect 依赖变化
  const onOnlineRef = useRef(onOnline)
  const onOfflineRef = useRef(onOffline)

  // 记录离线开始时间
  const offlineStartRef = useRef<number | null>(null)

  // 更新 ref
  useEffect(() => {
    onOnlineRef.current = onOnline
    onOfflineRef.current = onOffline
  }, [onOnline, onOffline])

  // 处理上线事件
  const handleOnline = useCallback(() => {
    console.log('[useOnlineStatus] Network online')
    setIsOnline(true)
    setLastChangedAt(Date.now())

    // 计算离线持续时间
    if (offlineStartRef.current) {
      const duration = Date.now() - offlineStartRef.current
      setOfflineDuration(duration)
      offlineStartRef.current = null
      console.log(`[useOnlineStatus] Offline duration: ${duration}ms`)
    }

    // 执行回调
    onOnlineRef.current?.()
  }, [])

  // 处理离线事件
  const handleOffline = useCallback(() => {
    console.log('[useOnlineStatus] Network offline')
    setIsOnline(false)
    setLastChangedAt(Date.now())
    offlineStartRef.current = Date.now()
    setOfflineDuration(0)

    // 执行回调
    onOfflineRef.current?.()
  }, [])

  // 设置事件监听
  useEffect(() => {
    // SSR 兼容
    if (typeof window === 'undefined') return

    // 添加事件监听
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    // 初始化离线开始时间
    if (!navigator.onLine) {
      offlineStartRef.current = Date.now()
    }

    // 清理函数
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [handleOnline, handleOffline])

  // 定时更新离线持续时间（仅在离线时）
  useEffect(() => {
    if (isOnline) return

    const interval = setInterval(() => {
      if (offlineStartRef.current) {
        setOfflineDuration(Date.now() - offlineStartRef.current)
      }
    }, 1000) // 每秒更新一次

    return () => clearInterval(interval)
  }, [isOnline])

  return {
    isOnline,
    lastChangedAt,
    offlineDuration,
  }
}

/**
 * 格式化离线持续时间
 * @param ms 毫秒数
 * @returns 格式化字符串 (如 "5分钟" 或 "1小时30分钟")
 */
export function formatOfflineDuration(ms: number): string {
  if (ms < 1000) return '刚刚'

  const seconds = Math.floor(ms / 1000)
  const minutes = Math.floor(seconds / 60)
  const hours = Math.floor(minutes / 60)

  if (hours > 0) {
    const remainingMinutes = minutes % 60
    if (remainingMinutes > 0) {
      return `${hours}小时${remainingMinutes}分钟`
    }
    return `${hours}小时`
  }

  if (minutes > 0) {
    return `${minutes}分钟`
  }

  return `${seconds}秒`
}

export default useOnlineStatus


==================================================
FILE_PATH: web/src/hooks/useAIChatCache.ts
==================================================

/**
 * AI 对话缓存管理 Hook
 *
 * 说明：
 * - 对话与消息采用“缓存优先、在线更新”策略
 * - 在线时同步服务端并写入 IndexedDB；离线时使用本地只读缓存
 * - 提供删除与新消息缓存接口，便于流式对话持久化
 */
/**
 * useAIChatCache.ts
 * 
 * AI 对话缓存管理 Hook
 * 提供对话列表和消息的缓存优先加载策略
 */

import { useState, useCallback, useEffect } from 'react'
import { useAuthStore } from '@/stores/auth'
import {
  saveConversations,
  saveMessages,
  getCachedConversations,
  getConversationMessages,
  deleteConversation as deleteCachedConversation,
  type ConversationRecord,
  type MessageRecord,
} from '@/lib/aiChatStorage'

interface UseAIChatCacheOptions {
  /** 是否自动加载对话列表 */
  autoLoad?: boolean
  /** 缓存过期时间（毫秒） */
  staleTime?: number
}

interface UseAIChatCacheReturn {
  /** 对话列表 */
  conversations: ConversationRecord[]
  /** 加载状态 */
  loading: boolean
  /** 错误信息 */
  error: string | null
  /** 是否来自缓存 */
  fromCache: boolean
  /** 刷新对话列表 */
  refreshConversations: () => Promise<void>
  /** 获取对话消息（缓存优先） */
  getMessages: (conversationId: string) => Promise<MessageRecord[]>
  /** 删除对话 */
  deleteConversation: (id: string) => Promise<void>
  /** 缓存新消息（流式响应后调用） */
  cacheNewMessage: (message: MessageRecord) => Promise<void>
}

/**
 * AI 对话缓存管理 Hook
 */
export function useAIChatCache(options: UseAIChatCacheOptions = {}): UseAIChatCacheReturn {
  const { autoLoad = true, staleTime = 5 * 60 * 1000 } = options
  const [conversations, setConversations] = useState<ConversationRecord[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [fromCache, setFromCache] = useState(false)
  const [lastFetchTime, setLastFetchTime] = useState<number>(0)

  // 从服务器加载对话列表
  const fetchFromServer = useCallback(async (): Promise<ConversationRecord[]> => {
    const token = useAuthStore.getState().accessToken
    if (!token) throw new Error('Not authenticated')

    const res = await fetch('/api/v1/ai/conversations', {
      headers: { Authorization: `Bearer ${token}` },
    })
    if (!res.ok) throw new Error('Failed to fetch conversations')

    const data = await res.json()
    return (data.items || data.data || []).map((item: any) => ({
      id: item.id,
      title: item.title,
      createdAt: item.created_at || item.createdAt,
      updatedAt: item.updated_at || item.updatedAt || item.created_at || item.createdAt,
      mode: item.mode,
      bookIds: item.book_ids || item.bookIds,
    }))
  }, [])

  // 加载对话列表（缓存优先策略）
  const refreshConversations = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      // 1. 先尝试从缓存加载
      const cached = await getCachedConversations()
      if (cached.length > 0) {
        setConversations(cached)
        setFromCache(true)
        console.log('[useAIChatCache] Loaded from cache:', cached.length)
      }

      // 2. 检查是否需要从服务器刷新
      const now = Date.now()
      const shouldFetch = now - lastFetchTime > staleTime || cached.length === 0

      if (shouldFetch && navigator.onLine) {
        try {
          const serverData = await fetchFromServer()
          setConversations(serverData)
          setFromCache(false)
          setLastFetchTime(now)
          
          // 3. 更新缓存
          await saveConversations(serverData)
          console.log('[useAIChatCache] Synced from server:', serverData.length)
        } catch (fetchError) {
          console.warn('[useAIChatCache] Server fetch failed, using cache:', fetchError)
          // 如果服务器请求失败但有缓存，继续使用缓存
          if (cached.length === 0) {
            throw fetchError
          }
        }
      }
    } catch (e: any) {
      setError(e.message)
      console.error('[useAIChatCache] Error:', e)
    } finally {
      setLoading(false)
    }
  }, [fetchFromServer, lastFetchTime, staleTime])

  // 获取对话消息（缓存优先）
  const getMessages = useCallback(async (conversationId: string): Promise<MessageRecord[]> => {
    // 1. 先尝试从缓存加载
    const cached = await getConversationMessages(conversationId)
    
    // 2. 如果有网络，从服务器获取最新消息
    if (navigator.onLine) {
      try {
        const token = useAuthStore.getState().accessToken
        const res = await fetch(`/api/v1/ai/conversations/${conversationId}/messages`, {
          headers: { Authorization: `Bearer ${token}` },
        })
        if (res.ok) {
          const data = await res.json()
          const messages: MessageRecord[] = (data.items || data.data || data.messages || []).map((m: any) => ({
            id: m.id,
            conversationId,
            role: m.role,
            content: m.content,
            createdAt: m.created_at || m.createdAt,
            metadata: m.metadata,
          }))
          
          // 更新缓存
          if (messages.length > 0) {
            await saveMessages(messages)
          }
          return messages
        }
      } catch (e) {
        console.warn('[useAIChatCache] Failed to fetch messages from server:', e)
      }
    }
    
    return cached
  }, [])

  // 删除对话
  const deleteConversation = useCallback(async (id: string) => {
    // 先从服务器删除
    if (navigator.onLine) {
      const token = useAuthStore.getState().accessToken
      const res = await fetch(`/api/v1/ai/conversations/${id}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      })
      if (!res.ok) {
        throw new Error('Failed to delete conversation')
      }
    }
    
    // 从缓存删除
    await deleteCachedConversation(id)
    
    // 更新状态
    setConversations(prev => prev.filter(c => c.id !== id))
  }, [])

  // 缓存新消息
  const cacheNewMessage = useCallback(async (message: MessageRecord) => {
    await saveMessages([message])
  }, [])

  // 自动加载
  useEffect(() => {
    if (autoLoad) {
      refreshConversations()
    }
  }, [autoLoad, refreshConversations])

  return {
    conversations,
    loading,
    error,
    fromCache,
    refreshConversations,
    getMessages,
    deleteConversation,
    cacheNewMessage,
  }
}


==================================================
FILE_PATH: web/src/hooks/useOcrData.ts
==================================================

/**
 * useOcrData - Hook for managing OCR data (download, cache, and access)
 * 
 * 设计理念：
 * - 一次性下载完整 OCR 数据（约 2MB gzip 压缩）
 * - 存储到 IndexedDB，与书籍文件一起缓存
 * - 本地读取，零服务器请求
 * - 支持离线阅读
 */

import { useState, useEffect, useCallback, useRef } from 'react'
import { useAuthStore } from '@/stores/auth'
import { 
  getOcrData, 
  saveOcrData, 
  getOcrPageRegions,
  type OcrDataRecord,
  type OcrRegion,
  type OcrPageSize
} from '@/lib/bookStorage'

export type { OcrRegion, OcrPageSize }

export interface OcrDataStatus {
  /** OCR 数据是否可用（服务端已完成 OCR） */
  available: boolean
  /** 是否已缓存到本地 */
  cached: boolean
  /** 是否正在下载 */
  downloading: boolean
  /** 下载进度 (0-100) */
  progress: number
  /** 错误信息 */
  error: string | null
}

export interface OcrDataInfo {
  isImageBased: boolean
  confidence: number
  totalPages: number
  totalChars: number
  totalRegions: number
  imageWidth: number
  imageHeight: number
}

interface UseOcrDataOptions {
  bookId: string
  /** 是否自动下载（如果本地没有缓存） */
  autoDownload?: boolean
}

interface UseOcrDataResult {
  status: OcrDataStatus
  info: OcrDataInfo | null
  /** 下载 OCR 数据到本地 */
  download: () => Promise<boolean>
  /** 获取指定页的 OCR 区域 */
  getPageRegions: (page: number) => Promise<OcrRegion[]>
  /** 同步获取指定页的 OCR 区域（从内存缓存） */
  getPageRegionsSync: (page: number) => OcrRegion[]
  /** 同步获取指定页的 OCR 图片尺寸（从内存缓存） */
  getPageSizeSync: (page: number) => OcrPageSize | null
  /** 刷新状态 */
  refresh: () => Promise<void>
}

// 内存缓存，避免重复从 IndexedDB 读取
const memoryCache = new Map<string, OcrDataRecord>()

export function useOcrData({
  bookId,
  autoDownload = false,
}: UseOcrDataOptions): UseOcrDataResult {
  const [status, setStatus] = useState<OcrDataStatus>({
    available: false,
    cached: false,
    downloading: false,
    progress: 0,
    error: null,
  })
  const [info, setInfo] = useState<OcrDataInfo | null>(null)
  const abortControllerRef = useRef<AbortController | null>(null)
  const isMountedRef = useRef(true)
  const downloadingRef = useRef(false)  // 用于稳定的下载状态检查
  const accessToken = useAuthStore((s) => s.accessToken)

  // 检查本地缓存状态
  const checkLocalCache = useCallback(async () => {
    if (!bookId) return false
    
    try {
      // 先检查内存缓存
      if (memoryCache.has(bookId)) {
        const cached = memoryCache.get(bookId)!
        // 检查是否有 pageSizes（新版数据），如果没有则需要重新下载
        if (!cached.pageSizes) {
          console.log('[useOcrData] Local cache missing pageSizes, needs re-download')
          memoryCache.delete(bookId)
          return false
        }
        if (isMountedRef.current) {
          setInfo({
            isImageBased: cached.isImageBased,
            confidence: cached.confidence,
            totalPages: cached.totalPages,
            totalChars: cached.totalChars,
            totalRegions: cached.totalRegions,
            imageWidth: cached.imageWidth,
            imageHeight: cached.imageHeight,
          })
          setStatus(prev => ({ ...prev, cached: true, available: true }))
        }
        return true
      }
      
      // 检查 IndexedDB
      const ocrData = await getOcrData(bookId)
      if (ocrData) {
        // 检查是否有 pageSizes（新版数据），如果没有则需要重新下载
        if (!ocrData.pageSizes) {
          console.log('[useOcrData] IndexedDB cache missing pageSizes, needs re-download')
          return false
        }
        memoryCache.set(bookId, ocrData)
        if (isMountedRef.current) {
          setInfo({
            isImageBased: ocrData.isImageBased,
            confidence: ocrData.confidence,
            totalPages: ocrData.totalPages,
            totalChars: ocrData.totalChars,
            totalRegions: ocrData.totalRegions,
            imageWidth: ocrData.imageWidth,
            imageHeight: ocrData.imageHeight,
          })
          setStatus(prev => ({ ...prev, cached: true, available: true }))
        }
        return true
      }
      return false
    } catch (e) {
      console.error('[useOcrData] Failed to check local cache:', e)
      return false
    }
  }, [bookId])

  // 检查服务端是否有 OCR 数据
  const checkServerAvailability = useCallback(async () => {
    if (!bookId || !accessToken) {
      console.log('[useOcrData] checkServerAvailability skipped: no bookId or accessToken')
      return false
    }
    
    try {
      console.log(`[useOcrData] Checking server availability for ${bookId}...`)
      const resp = await fetch(`/api/v1/books/${bookId}/ocr`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      })
      
      if (!resp.ok) {
        console.log(`[useOcrData] Server returned ${resp.status}`)
        return false
      }
      
      const result = await resp.json()
      const available = result.data?.available && result.data?.is_image_based
      console.log(`[useOcrData] Server availability: ${available}`, result.data)
      
      if (isMountedRef.current) {
        setStatus(prev => ({ ...prev, available }))
      }
      return available
    } catch (e) {
      console.error('[useOcrData] Failed to check server availability:', e)
      return false
    }
  }, [bookId, accessToken])

  // 下载完整 OCR 数据
  const download = useCallback(async (): Promise<boolean> => {
    if (!bookId || !accessToken) return false
    
    // 使用 ref 检查下载状态，避免 useCallback 依赖 status.downloading
    if (downloadingRef.current) {
      console.log('[useOcrData] Download already in progress, skipping')
      return false
    }
    
    // 不要取消之前的请求，只有在确实需要新下载时才创建新的 controller
    abortControllerRef.current = new AbortController()
    downloadingRef.current = true
    
    setStatus(prev => ({ ...prev, downloading: true, progress: 0, error: null }))
    
    try {
      console.log(`[useOcrData] Downloading OCR data for ${bookId}...`)
      
      const resp = await fetch(`/api/v1/books/${bookId}/ocr/full`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          'Accept-Encoding': 'gzip',
        },
        signal: abortControllerRef.current.signal,
      })
      
      if (!resp.ok) {
        throw new Error(`HTTP ${resp.status}: ${resp.statusText}`)
      }
      
      // 获取压缩/原始大小用于日志
      const compressedSize = resp.headers.get('X-Compressed-Size')
      const originalSize = resp.headers.get('X-Original-Size')
      console.log(`[useOcrData] Downloaded: ${compressedSize} bytes (compressed), ${originalSize} bytes (original)`)
      
      setStatus(prev => ({ ...prev, progress: 50 }))
      
      const data = await resp.json()
      
      setStatus(prev => ({ ...prev, progress: 75 }))
      
      // 转换 page_sizes 格式 (API: snake_case -> Frontend: camelCase)
      const pageSizes: Record<string, { width: number; height: number; pdfWidth?: number; pdfHeight?: number; dpi?: number }> = {}
      if (data.page_sizes) {
        for (const [pageNum, size] of Object.entries(data.page_sizes)) {
          const s = size as { width: number; height: number; pdf_width?: number; pdf_height?: number; dpi?: number }
          pageSizes[pageNum] = {
            width: s.width,
            height: s.height,
            pdfWidth: s.pdf_width,
            pdfHeight: s.pdf_height,
            dpi: s.dpi,
          }
        }
      }
      
      // 从 page_sizes 提取第一页尺寸作为默认值（向后兼容）
      const firstPageSize = pageSizes['1'] || { width: 1240, height: 1754 }
      const defaultWidth = data.image_width || firstPageSize.width
      const defaultHeight = data.image_height || firstPageSize.height
      
      // 保存到 IndexedDB
      await saveOcrData({
        bookId,
        isImageBased: data.is_image_based,
        confidence: data.confidence,
        totalPages: data.total_pages,
        totalChars: data.total_chars,
        totalRegions: data.total_regions,
        imageWidth: defaultWidth,
        imageHeight: defaultHeight,
        pageSizes: Object.keys(pageSizes).length > 0 ? pageSizes : undefined,
        regions: data.regions,
        downloadedAt: Date.now(),
      })
      
      // 更新内存缓存
      const ocrRecord: OcrDataRecord = {
        bookId,
        isImageBased: data.is_image_based,
        confidence: data.confidence,
        totalPages: data.total_pages,
        totalChars: data.total_chars,
        totalRegions: data.total_regions,
        imageWidth: defaultWidth,
        imageHeight: defaultHeight,
        pageSizes: Object.keys(pageSizes).length > 0 ? pageSizes : undefined,
        regions: data.regions,
        downloadedAt: Date.now(),
      }
      memoryCache.set(bookId, ocrRecord)
      
      if (isMountedRef.current) {
        setInfo({
          isImageBased: data.is_image_based,
          confidence: data.confidence,
          totalPages: data.total_pages,
          totalChars: data.total_chars,
          totalRegions: data.total_regions,
          imageWidth: defaultWidth,
          imageHeight: defaultHeight,
        })
        setStatus({
          available: true,
          cached: true,
          downloading: false,
          progress: 100,
          error: null,
        })
      }
      
      downloadingRef.current = false
      console.log(`[useOcrData] OCR data saved: ${data.total_regions} regions, ${data.total_chars} chars, ${Object.keys(pageSizes).length} page sizes`)
      return true
    } catch (e) {
      downloadingRef.current = false
      
      if ((e as Error).name === 'AbortError') {
        console.log('[useOcrData] Download aborted')
        return false
      }
      
      const errorMsg = e instanceof Error ? e.message : 'Unknown error'
      console.error('[useOcrData] Download failed:', errorMsg)
      
      if (isMountedRef.current) {
        setStatus(prev => ({
          ...prev,
          downloading: false,
          progress: 0,
          error: errorMsg,
        }))
      }
      return false
    }
  }, [bookId, accessToken])  // 移除 status.downloading 依赖

  // 获取指定页的 OCR 区域（异步）
  const getPageRegions = useCallback(async (page: number): Promise<OcrRegion[]> => {
    if (!bookId) return []
    
    // 先检查内存缓存
    const cached = memoryCache.get(bookId)
    if (cached) {
      return cached.regions.filter(r => r.page === page)
    }
    
    // 从 IndexedDB 读取
    return getOcrPageRegions(bookId, page)
  }, [bookId])

  // 获取指定页的 OCR 区域（同步，从内存缓存）
  const getPageRegionsSync = useCallback((page: number): OcrRegion[] => {
    if (!bookId) return []
    
    const cached = memoryCache.get(bookId)
    if (!cached) return []
    
    return cached.regions.filter(r => r.page === page)
  }, [bookId])

  // 获取指定页的 OCR 图片尺寸（同步，从内存缓存）
  const getPageSizeSync = useCallback((page: number): OcrPageSize | null => {
    if (!bookId) return null
    
    const cached = memoryCache.get(bookId)
    if (!cached) return null
    
    // 如果有每页尺寸，优先使用
    if (cached.pageSizes) {
      const pageSize = cached.pageSizes[String(page)]
      if (pageSize) return pageSize
    }
    
    // 回退到全局默认尺寸
    return {
      width: cached.imageWidth,
      height: cached.imageHeight,
    }
  }, [bookId])

  // 刷新状态
  const refresh = useCallback(async () => {
    const hasCached = await checkLocalCache()
    if (!hasCached) {
      await checkServerAvailability()
    }
  }, [checkLocalCache, checkServerAvailability])

  // 初始化
  useEffect(() => {
    isMountedRef.current = true
    
    const init = async () => {
      const hasCached = await checkLocalCache()
      if (!hasCached) {
        const available = await checkServerAvailability()
        if (available && autoDownload) {
          download()
        }
      }
    }
    
    init()
    
    // 注意：不在这里 abort，只在组件卸载时 abort
  }, [bookId, checkLocalCache, checkServerAvailability, autoDownload, download])

  // 组件卸载时的清理
  useEffect(() => {
    return () => {
      isMountedRef.current = false
      // 只在组件真正卸载时才 abort 下载
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
  }, [])  // 空依赖，只在卸载时执行

  return {
    status,
    info,
    download,
    getPageRegions,
    getPageRegionsSync,
    getPageSizeSync,
    refresh,
  }
}

/**
 * 预加载 OCR 数据到内存缓存
 * 在书籍打开时调用，确保翻页时可以同步获取数据
 */
export async function preloadOcrToMemory(bookId: string): Promise<boolean> {
  if (memoryCache.has(bookId)) return true
  
  try {
    const ocrData = await getOcrData(bookId)
    if (ocrData) {
      memoryCache.set(bookId, ocrData)
      return true
    }
    return false
  } catch {
    return false
  }
}

/**
 * 清除内存缓存（在关闭阅读器时调用）
 */
export function clearOcrMemoryCache(bookId?: string): void {
  if (bookId) {
    memoryCache.delete(bookId)
  } else {
    memoryCache.clear()
  }
}


==================================================
FILE_PATH: web/src/hooks/useBookDownload.ts
==================================================

/**
 * useBookDownload
 * 书籍下载 Hook - 管理书籍从服务器下载到本地 IndexedDB 的流程
 * 
 * 功能:
 * - 检查书籍是否已缓存
 * - 下载书籍到 IndexedDB
 * - 提供下载进度
 * - 支持取消下载
 */

import { useState, useCallback, useRef, useEffect } from 'react'
import { useAuthStore } from '@/stores/auth'
import {
  saveBookFile,
  getBookFile,
  deleteBookFile,
  createBlobUrl,
  revokeBlobUrl,
} from '@/lib/bookStorage'

export type DownloadStatus = 
  | 'idle'           // 未开始
  | 'checking'       // 检查缓存中
  | 'cached'         // 已缓存，可直接使用
  | 'downloading'    // 下载中
  | 'saving'         // 保存到 IndexedDB 中
  | 'ready'          // 下载完成，可以阅读
  | 'error'          // 下载失败

export interface UseBookDownloadOptions {
  bookId: string
  format: 'epub' | 'pdf'
  enabled?: boolean
  autoDownload?: boolean  // 是否自动开始下载（如果未缓存）
  onSuccess?: (blobUrl: string) => void
  onError?: (error: Error) => void
}

export interface UseBookDownloadReturn {
  status: DownloadStatus
  progress: number          // 0-100
  blobUrl: string | null    // 可用于阅读器的 Blob URL
  error: string | null
  isCached: boolean
  cachedFormat: 'epub' | 'pdf' | null  // 缓存文件的实际格式
  download: () => Promise<void>
  cancel: () => void
  clearCache: () => Promise<void>
  fileSize: number | null   // 文件大小（字节）
}

export function useBookDownload(options: UseBookDownloadOptions): UseBookDownloadReturn {
  const { bookId, format, enabled = true, autoDownload = false, onSuccess, onError } = options
  
  const [status, setStatus] = useState<DownloadStatus>('idle')
  const [progress, setProgress] = useState(0)
  const [blobUrl, setBlobUrl] = useState<string | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [isCached, setIsCached] = useState(false)
  const [fileSize, setFileSize] = useState<number | null>(null)
  const [cachedFormat, setCachedFormat] = useState<'epub' | 'pdf' | null>(null)
  
  const abortControllerRef = useRef<AbortController | null>(null)
  const blobUrlRef = useRef<string | null>(null)
  const isDownloadingRef = useRef(false)
  const lastBookIdRef = useRef<string>('')
  
  // 使用 ref 存储 callbacks 避免依赖变化
  const onSuccessRef = useRef(onSuccess)
  const onErrorRef = useRef(onError)
  useEffect(() => {
    onSuccessRef.current = onSuccess
    onErrorRef.current = onError
  }, [onSuccess, onError])
  
  // 清理 Blob URL
  const cleanupBlobUrl = useCallback(() => {
    if (blobUrlRef.current) {
      revokeBlobUrl(blobUrlRef.current)
      blobUrlRef.current = null
      setBlobUrl(null)
    }
  }, [])
  
  // 组件卸载时清理
  useEffect(() => {
    return () => {
      if (blobUrlRef.current) {
        revokeBlobUrl(blobUrlRef.current)
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
    }
  }, [])
  
  // 下载书籍
  const download = useCallback(async () => {
    if (!enabled || !bookId || isDownloadingRef.current) return
    
    isDownloadingRef.current = true
    setStatus('checking')
    setError(null)
    
    try {
      // 先检查缓存
      const cached = await getBookFile(bookId)
      if (cached) {
        console.log(`[BookDownload] Book ${bookId} found in cache, size: ${cached.size}, format: ${cached.format}`)
        setIsCached(true)
        setFileSize(cached.size)
        setCachedFormat(cached.format)  // 设置缓存文件的实际格式
        
        // 清理旧的 blob URL 并创建新的
        if (blobUrlRef.current) {
          revokeBlobUrl(blobUrlRef.current)
        }
        // 传递格式信息以确保 MIME 类型正确
        const url = createBlobUrl(cached.blob, cached.format)
        blobUrlRef.current = url
        setBlobUrl(url)
        setStatus('cached')
        setProgress(100)
        onSuccessRef.current?.(url)
        isDownloadingRef.current = false
        return
      }
      
      // 开始下载
      console.log(`[BookDownload] Book ${bookId} not in cache, downloading...`)
      setStatus('downloading')
      setProgress(0)
      
      const token = useAuthStore.getState().accessToken || localStorage.getItem('access_token') || ''
      const contentUrl = `/api/v1/books/${bookId}/content?token=${encodeURIComponent(token)}`
      
      abortControllerRef.current = new AbortController()
      
      const response = await fetch(contentUrl, {
        signal: abortControllerRef.current.signal
      })
      
      if (!response.ok) {
        throw new Error(`Download failed: ${response.status} ${response.statusText}`)
      }
      
      const contentLength = response.headers.get('Content-Length')
      const totalSize = contentLength ? parseInt(contentLength, 10) : 0
      const etag = response.headers.get('ETag') || undefined
      
      if (totalSize > 0) {
        setFileSize(totalSize)
      }
      
      // 使用 ReadableStream 读取并追踪进度
      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error('Response body is not readable')
      }
      
      const chunks: Uint8Array[] = []
      let receivedLength = 0
      let readerDone = false
      
      while (!readerDone) {
        const { done, value } = await reader.read()
        
        if (done) {
          readerDone = true
          continue
        }
        
        chunks.push(value)
        receivedLength += value.length
        
        if (totalSize > 0) {
          const progressPercent = Math.round((receivedLength / totalSize) * 100)
          setProgress(progressPercent)
        }
      }
      
      console.log(`[BookDownload] Download complete, received ${receivedLength} bytes`)
      
      // 合并 chunks 为 Blob
      const blob = new Blob(chunks as BlobPart[], {
        type: format === 'pdf' ? 'application/pdf' : 'application/epub+zip'
      })
      
      setFileSize(blob.size)
      
      // 保存到 IndexedDB
      setStatus('saving')
      await saveBookFile(bookId, blob, format, etag)
      setCachedFormat(format)  // 设置下载的格式
      
      // 创建 Blob URL
      if (blobUrlRef.current) {
        revokeBlobUrl(blobUrlRef.current)
      }
      // 传递格式信息以确保 MIME 类型正确
      const url = createBlobUrl(blob, format)
      blobUrlRef.current = url
      setBlobUrl(url)
      
      setIsCached(true)
      setStatus('ready')
      setProgress(100)
      
      console.log(`[BookDownload] Book ${bookId} ready for reading`)
      onSuccessRef.current?.(url)
      
    } catch (err: any) {
      if (err.name === 'AbortError') {
        console.log(`[BookDownload] Download cancelled for ${bookId}`)
        setStatus('idle')
        setProgress(0)
      } else {
        console.error(`[BookDownload] Download failed for ${bookId}:`, err)
        setError(err.message || 'Download failed')
        setStatus('error')
        onErrorRef.current?.(err)
      }
    } finally {
      isDownloadingRef.current = false
    }
  }, [bookId, format, enabled])
  
  // 取消下载
  const cancel = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      abortControllerRef.current = null
    }
  }, [])
  
  // 清除缓存
  const clearCache = useCallback(async () => {
    try {
      await deleteBookFile(bookId)
      cleanupBlobUrl()
      setIsCached(false)
      setStatus('idle')
      setProgress(0)
      console.log(`[BookDownload] Cache cleared for ${bookId}`)
    } catch (err) {
      console.error('[BookDownload] Failed to clear cache:', err)
    }
  }, [bookId, cleanupBlobUrl])
  
  // 初始化 - 只在 bookId 变化时运行
  useEffect(() => {
    if (!enabled || !bookId) return
    
    // 防止重复初始化
    if (lastBookIdRef.current === bookId) return
    lastBookIdRef.current = bookId
    
    // 重置状态
    setStatus('idle')
    setProgress(0)
    setError(null)
    setBlobUrl(null)
    setIsCached(false)
    isDownloadingRef.current = false
    
    if (autoDownload) {
      download()
    }
  }, [bookId, enabled, autoDownload, download])
  
  return {
    status,
    progress,
    blobUrl,
    error,
    isCached,
    cachedFormat,
    download,
    cancel,
    clearCache,
    fileSize
  }
}

/**
 * 格式化文件大小
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}


==================================================
FILE_PATH: web/src/hooks/useTokenRefresh.ts
==================================================

import { useEffect, useRef } from 'react'
import { useAuthStore } from '@/stores/auth'

/**
 * Token 自动刷新 Hook
 * 
 * 功能：
 * 1. 每 5 分钟检查一次 token 状态
 * 2. 如果 token 距离过期小于 10 分钟，主动刷新
 * 3. 组件卸载时清理定时器
 */
export function useTokenRefresh() {
    const timerRef = useRef<number | null>(null)
    const { isAuthenticated, isTokenExpiringSoon, refreshAccessToken } = useAuthStore()

    useEffect(() => {
        if (!isAuthenticated) {
            return
        }

        // 定时检查函数
        const checkAndRefresh = async () => {
            const store = useAuthStore.getState()

            // 如果未登录，停止检查
            if (!store.isAuthenticated) {
                if (timerRef.current) {
                    clearInterval(timerRef.current)
                    timerRef.current = null
                }
                return
            }

            // 如果 token 即将过期（10 分钟内），主动刷新
            if (store.isTokenExpiringSoon()) {
                console.log('[TokenRefresh] Token expiring soon, auto-refreshing...')
                const success = await store.refreshAccessToken()

                if (success) {
                    console.log('[TokenRefresh] Token refreshed successfully')
                } else {
                    console.error('[TokenRefresh] Token refresh failed')
                    // 刷新失败会在 store 中自动清空状态，这里无需额外处理
                }
            }
        }

        // 立即执行一次检查
        checkAndRefresh()

        // 启动定时器，每 5 分钟检查一次
        timerRef.current = setInterval(checkAndRefresh, 5 * 60 * 1000) as unknown as number

        // 清理函数
        return () => {
            if (timerRef.current) {
                clearInterval(timerRef.current)
                timerRef.current = null
            }
        }
    }, [isAuthenticated, isTokenExpiringSoon, refreshAccessToken])
}


==================================================
FILE_PATH: web/src/hooks/useProgressData.ts
==================================================

/**
 * useProgressData - 阅读进度数据统一入口 Hook (PowerSync Only)
 *
 * 直接使用 PowerSync SQLite 作为唯一数据源
 * 替代原有的 useReadingProgress, useOfflineProgressV2 等
 *
 * 字段映射 (PowerSync Schema → 业务层)：
 * - progress (REAL 0-1) → percentage
 * - last_position (TEXT CFI) → currentCfi
 * - last_location (TEXT JSON) → { currentPage, totalPages }
 * - updated_at → lastReadAt
 * - finished_at → finishedAt
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 3
 * @see docker/powersync/sync_rules.yaml
 * @modified 2025-12-17 修复字段映射与 PowerSync Schema 一致
 */

import { useMemo, useCallback, useRef, useEffect } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, usePowerSyncState } from '@/lib/powersync'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

export interface ReadingProgressData {
  bookId: string
  currentCfi?: string       // 来自 last_position
  currentPage?: number      // 来自 last_location JSON
  totalPages?: number       // 来自 last_location JSON
  percentage: number        // 来自 progress (0-1)
  lastReadAt: string        // 来自 updated_at
  finishedAt?: string       // 来自 finished_at
}

/**
 * PowerSync reading_progress 表的原始行结构
 * @see web/src/lib/powersync/schema.ts
 * @see docker/powersync/sync_rules.yaml
 */
interface ProgressRow {
  id: string
  user_id: string
  book_id: string
  device_id: string | null
  progress: number           // REAL 0-1
  last_position: string | null  // CFI 字符串
  last_location: string | null  // JSON: { currentPage, totalPages, ... }
  finished_at: string | null
  updated_at: string
}

/**
 * 解析 last_location JSON
 */
function parseLastLocation(json: string | null): { currentPage?: number; totalPages?: number } {
  if (!json) return {}
  try {
    const parsed = JSON.parse(json)
    return {
      currentPage: typeof parsed.currentPage === 'number' ? parsed.currentPage : undefined,
      totalPages: typeof parsed.totalPages === 'number' ? parsed.totalPages : undefined,
    }
  } catch {
    return {}
  }
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取书籍的阅读进度
 */
export function useProgressData(bookId: string | null) {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const isReady = isInitialized && db !== null

  const query = isReady && bookId
    ? 'SELECT * FROM reading_progress WHERE book_id = ? ORDER BY updated_at DESC LIMIT 1'
    : 'SELECT * FROM reading_progress WHERE 1=0'

  const { data, isLoading, error } = useQuery<ProgressRow>(
    query,
    isReady && bookId ? [bookId] : []
  )

  const progress: ReadingProgressData | null = useMemo(() => {
    if (!data?.[0]) return null

    const row = data[0]
    const location = parseLastLocation(row.last_location)
    
    return {
      bookId: row.book_id,
      currentCfi: row.last_position ?? undefined,
      currentPage: location.currentPage,
      totalPages: location.totalPages,
      percentage: row.progress ?? 0,
      lastReadAt: row.updated_at,
      finishedAt: row.finished_at ?? undefined,
    }
  }, [data])

  // 防抖保存进度
  const saveTimeoutRef = useRef<number | null>(null)
  const pendingUpdateRef = useRef<Partial<ReadingProgressData> | null>(null)

  // 保存进度（防抖 1 秒）
  const saveProgress = useCallback(async (
    updates: {
      currentCfi?: string
      currentPage?: number
      totalPages?: number
      percentage?: number
    },
    immediate = false
  ) => {
    console.log('[useProgressData] saveProgress called:', { 
      updates, 
      immediate, 
      hasDb: !!db, 
      bookId,
      isReady 
    })
    
    if (!db || !bookId) {
      console.warn('[useProgressData] Cannot save: db or bookId not available', { hasDb: !!db, bookId })
      return
    }

    // 合并待处理更新
    pendingUpdateRef.current = {
      ...pendingUpdateRef.current,
      ...updates,
    }

    // 清除之前的定时器
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current)
    }

    const doSave = async () => {
      const pending = pendingUpdateRef.current
      if (!pending) return

      pendingUpdateRef.current = null
      const now = new Date().toISOString()
      const userId = useAuthStore.getState().user?.id || ''
      const deviceId = getDeviceId()

      try {
        // 检查是否已存在进度记录 - 使用 book_id + user_id 匹配
        const existingRows = await db.getAll<{ id: string; last_location: string | null }>(
          'SELECT id, last_location FROM reading_progress WHERE book_id = ? AND user_id = ?',
          [bookId, userId]
        )
        const existing = existingRows[0]

        // 构建 last_location JSON
        const buildLastLocation = (existingJson: string | null): string => {
          const current = parseLastLocation(existingJson)
          return JSON.stringify({
            currentPage: pending.currentPage ?? current.currentPage,
            totalPages: pending.totalPages ?? current.totalPages,
          })
        }

        if (existing) {
          // 更新现有记录 - 使用 book_id + user_id 匹配
          const fields: string[] = ['updated_at = ?']
          const values: (string | number | null)[] = [now]

          if (pending.currentCfi !== undefined) {
            fields.push('last_position = ?')
            values.push(pending.currentCfi ?? null)
          }
          if (pending.currentPage !== undefined || pending.totalPages !== undefined) {
            fields.push('last_location = ?')
            values.push(buildLastLocation(existing.last_location))
          }
          if (pending.percentage !== undefined) {
            fields.push('progress = ?')
            // 强制归一化：如果传入 > 1 的数（如25），除以100；如果是 0-1，保持不变
            const normalizedProgress = pending.percentage > 1 ? pending.percentage / 100 : pending.percentage
            values.push(normalizedProgress)
          }

          values.push(bookId)
          values.push(userId)
          await db.execute(
            `UPDATE reading_progress SET ${fields.join(', ')} WHERE book_id = ? AND user_id = ?`,
            values
          )
        } else {
          // 创建新记录
          const id = generateUUID()
          const deviceId = getDeviceId()
          // 归一化进度值
          const rawProgress = pending.percentage ?? 0
          const normalizedProgress = rawProgress > 1 ? rawProgress / 100 : rawProgress
          await db.execute(
            `INSERT INTO reading_progress (id, book_id, user_id, device_id, last_position, last_location, progress, updated_at)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [
              id,
              bookId,
              userId,  // user_id - 从 AuthStore 获取
              deviceId,  // device_id - 从 localStorage 获取
              pending.currentCfi ?? null,
              buildLastLocation(null),
              normalizedProgress,
              now
            ]
          )
        }

        console.log('[useProgressData] Progress saved:', { bookId, ...pending })
      } catch (err) {
        console.error('[useProgressData] Failed to save progress:', err)
      }
    }

    if (immediate) {
      await doSave()
    } else {
      // 防抖 1 秒
      saveTimeoutRef.current = setTimeout(doSave, 1000) as unknown as number
    }
  }, [db, bookId, isReady])

  // 组件卸载时保存待处理的更新
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current)
      }
      // 立即保存待处理的更新
      if (pendingUpdateRef.current && db && bookId) {
        const pending = pendingUpdateRef.current
        const now = new Date().toISOString()
        const userId = useAuthStore.getState().user?.id || ''
        
        db.getAll<{ id: string; last_location: string | null }>('SELECT id, last_location FROM reading_progress WHERE book_id = ? AND user_id = ?', [bookId, userId])
          .then(rows => {
            const existing = rows[0]
            if (existing) {
              // 构建 last_location JSON
              const currentLoc = parseLastLocation(existing.last_location)
              const newLocation = JSON.stringify({
                currentPage: pending.currentPage ?? currentLoc.currentPage,
                totalPages: pending.totalPages ?? currentLoc.totalPages,
              })
              
              // 归一化进度值
              const rawProgress = pending.percentage ?? 0
              const normalizedProgress = rawProgress > 1 ? rawProgress / 100 : rawProgress
              
              db.execute(
                'UPDATE reading_progress SET last_position = ?, last_location = ?, progress = ?, updated_at = ? WHERE book_id = ? AND user_id = ?',
                [pending.currentCfi ?? null, newLocation, normalizedProgress, now, bookId, userId]
              )
            }
          })
          .catch(console.error)
      }
    }
  }, [db, bookId])

  return {
    progress,
    isLoading: !isReady || isLoading,
    isProgressLoading: !isReady || isLoading,  // 别名，更清晰
    error,
    saveProgress,
    isReady,
  }
}

/**
 * 获取所有阅读进度（用于首页显示）
 * 
 * 按最近更新时间排序，JOIN books 表获取书籍信息
 */
export function useAllProgressData(options: { limit?: number } = {}) {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const isReady = isInitialized && db !== null
  const { limit = 10 } = options

  const EMPTY_QUERY = 'SELECT * FROM reading_progress WHERE 1=0'
  
  // 使用正确的字段名：progress, last_position, last_location, updated_at
  // books 表使用 cover_url (来自 sync_rules.yaml 映射)
  const sql = isReady
    ? `
    SELECT rp.*, b.title as book_title, b.author as book_author, b.cover_url
    FROM reading_progress rp
    INNER JOIN books b ON rp.book_id = b.id
    WHERE b.deleted_at IS NULL
    ORDER BY rp.updated_at DESC
    LIMIT ?
  `
    : EMPTY_QUERY

  interface ProgressWithBook extends ProgressRow {
    book_title: string
    book_author: string | null
    cover_url: string | null
  }

  const { data, isLoading, error } = useQuery<ProgressWithBook>(sql, isReady ? [limit] : [])

  const recentBooks = useMemo(() => {
    if (!data) return []

    return data.map(row => {
      const location = parseLastLocation(row.last_location)
      return {
        bookId: row.book_id,
        title: row.book_title,
        author: row.book_author ?? undefined,
        coverUrl: row.cover_url ?? undefined,
        percentage: row.progress ?? 0,
        currentPage: location.currentPage,
        totalPages: location.totalPages,
        lastReadAt: row.updated_at,
      }
    })
  }, [data])

  return {
    recentBooks,
    isLoading: !isReady || isLoading,
    error,
    isReady,
  }
}

/**
 * 记录阅读会话（开始/结束）
 * 
 * reading_sessions 表字段:
 * - id, user_id, book_id, device_id
 * - is_active (INTEGER 0/1)
 * - total_ms (INTEGER 毫秒)
 * - created_at, updated_at
 */
export function useReadingSession(bookId: string | null) {
  const db = usePowerSyncDatabase()
  const sessionIdRef = useRef<string | null>(null)
  const startTimeRef = useRef<Date | null>(null)

  const startSession = useCallback(async () => {
    console.log('[useReadingSession] startSession called:', { hasDb: !!db, bookId })
    if (!db || !bookId) {
      console.warn('[useReadingSession] Cannot start session: db or bookId missing')
      return null
    }

    const id = generateUUID()
    const now = new Date()
    const isoNow = now.toISOString()

    try {
      // 使用正确的字段名: is_active, total_ms, created_at, updated_at
      // 使用正确的 user_id 和 device_id
      const userId = useAuthStore.getState().user?.id || ''
      const deviceId = getDeviceId()
      await db.execute(
        `INSERT INTO reading_sessions (id, book_id, user_id, device_id, is_active, total_ms, created_at, updated_at)
         VALUES (?, ?, ?, ?, 1, 0, ?, ?)`,
        [id, bookId, userId, deviceId, isoNow, isoNow]
      )

      sessionIdRef.current = id
      startTimeRef.current = now
      console.log('[useReadingSession] Session started:', id)
      return id
    } catch (err) {
      console.error('[useReadingSession] Failed to start session:', err)
      return null
    }
  }, [db, bookId])

  const endSession = useCallback(async () => {
    if (!db || !sessionIdRef.current || !startTimeRef.current) return

    // 计算持续时间（毫秒）
    const durationMs = Date.now() - startTimeRef.current.getTime()
    const now = new Date().toISOString()

    try {
      // 使用正确的字段名: is_active=0 表示结束, total_ms 存储毫秒
      await db.execute(
        'UPDATE reading_sessions SET is_active = 0, total_ms = ?, updated_at = ? WHERE id = ?',
        [durationMs, now, sessionIdRef.current]
      )

      console.log('[useReadingSession] Session ended:', {
        id: sessionIdRef.current,
        durationMs,
        durationMinutes: Math.round(durationMs / 60000)
      })

      sessionIdRef.current = null
      startTimeRef.current = null
    } catch (err) {
      console.error('[useReadingSession] Failed to end session:', err)
    }
  }, [db])

  // 组件卸载时结束会话
  useEffect(() => {
    return () => {
      if (sessionIdRef.current && startTimeRef.current && db) {
        const durationMs = Date.now() - startTimeRef.current.getTime()
        const now = new Date().toISOString()
        
        db.execute(
          'UPDATE reading_sessions SET is_active = 0, total_ms = ?, updated_at = ? WHERE id = ?',
          [durationMs, now, sessionIdRef.current]
        ).catch(console.error)
      }
    }
  }, [db])

  return {
    startSession,
    endSession,
    isReady: !!db,
  }
}


==================================================
FILE_PATH: web/src/hooks/use-toast.ts
==================================================

/**
 * 轻量级全局 Toast 管理
 *
 * 说明：
 * - 内存状态 + 订阅模型，无外部依赖
 * - 支持新增、更新、关闭、延迟移除
 * - 通过 `useToast()` 在组件中使用
 */
import { useState, useEffect } from "react"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = {
    id: string
    title?: React.ReactNode
    description?: React.ReactNode
    action?: React.ReactNode
    variant?: "default" | "destructive"
    open?: boolean
    onOpenChange?: (open: boolean) => void
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const actionTypes = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
    count = (count + 1) % Number.MAX_SAFE_INTEGER
    return count.toString()
}

type ActionType = typeof actionTypes

type Action =
    | {
        type: ActionType["ADD_TOAST"]
        toast: ToasterToast
    }
    | {
        type: ActionType["UPDATE_TOAST"]
        toast: Partial<ToasterToast>
    }
    | {
        type: ActionType["DISMISS_TOAST"]
        toastId?: ToasterToast["id"]
    }
    | {
        type: ActionType["REMOVE_TOAST"]
        toastId?: ToasterToast["id"]
    }

interface State {
    toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
    if (toastTimeouts.has(toastId)) {
        return
    }

    const timeout = setTimeout(() => {
        toastTimeouts.delete(toastId)
        dispatch({
            type: "REMOVE_TOAST",
            toastId: toastId,
        })
    }, TOAST_REMOVE_DELAY)

    toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
    switch (action.type) {
        case "ADD_TOAST":
            return {
                ...state,
                toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
            }

        case "UPDATE_TOAST":
            return {
                ...state,
                toasts: state.toasts.map((t) =>
                    t.id === action.toast.id ? { ...t, ...action.toast } : t
                ),
            }

        case "DISMISS_TOAST": {
            const { toastId } = action

            // ! Side effects ! - This could be extracted into a dismissToast() action,
            // but I'll keep it here for simplicity
            if (toastId) {
                addToRemoveQueue(toastId)
            } else {
                state.toasts.forEach((toast) => {
                    addToRemoveQueue(toast.id)
                })
            }

            return {
                ...state,
                toasts: state.toasts.map((t) =>
                    t.id === toastId || toastId === undefined
                        ? {
                            ...t,
                            open: false,
                        }
                        : t
                ),
            }
        }
        case "REMOVE_TOAST":
            if (action.toastId === undefined) {
                return {
                    ...state,
                    toasts: [],
                }
            }
            return {
                ...state,
                toasts: state.toasts.filter((t) => t.id !== action.toastId),
            }
    }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
    memoryState = reducer(memoryState, action)
    listeners.forEach((listener) => {
        listener(memoryState)
    })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
    const id = genId()

    const update = (props: ToasterToast) =>
        dispatch({
            type: "UPDATE_TOAST",
            toast: { ...props, id },
        })
    const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

    dispatch({
        type: "ADD_TOAST",
        toast: {
            ...props,
            id,
            open: true,
            onOpenChange: (open) => {
                if (!open) dismiss()
            },
        },
    })

    return {
        id: id,
        dismiss,
        update,
    }
}

function useToast() {
    const [state, setState] = useState<State>(memoryState)

    useEffect(() => {
        listeners.push(setState)
        return () => {
            const index = listeners.indexOf(setState)
            if (index > -1) {
                listeners.splice(index, 1)
            }
        }
    }, [state])

    return {
        ...state,
        toast,
        dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
    }
}

export { useToast, toast }


==================================================
FILE_PATH: web/src/hooks/useDashboardData.ts
==================================================

import { useMemo, useCallback } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, usePowerSyncState } from '@/lib/powersync'
import { useAuthStore } from '@/stores/auth'

export interface DashboardData {
    today: {
        seconds: number
        minutes: number
    }
    goals: {
        daily_minutes: number
        yearly_books: number
    }
    weekly: {
        date: string
        minutes: number
        status: 'FUTURE' | 'MISSED' | 'REACHED' | 'PARTIAL'
    }[]
    streak: {
        current_streak: number
        longest_streak: number
    }
    yearly_finished: {
        count: number
        recent_covers: string[]
    }
}

/**
 * reading_sessions 表行结构
 * @see web/src/lib/powersync/schema.ts
 * @see docker/powersync/sync_rules.yaml
 * 字段: id, user_id, book_id, device_id, is_active, total_ms, created_at, updated_at
 */
interface ReadingSessionRow {
    total_ms: number      // 阅读时长（毫秒）
    created_at: string    // 会话创建时间
}

interface ReadingStatsRow {
    date: string
    total_seconds: number
}

interface UserSettingsRow {
    settings_json: string
}

interface FinishedBookRow {
    id: string
}

// 获取用户本地日期字符串 (YYYY-MM-DD)
function getLocalDateString(date: Date = new Date()): string {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    return `${year}-${month}-${day}`
}

export function useDashboardData() {
    const db = usePowerSyncDatabase()
    const { isInitialized } = usePowerSyncState()
    const accessToken = useAuthStore(s => s.accessToken)

    // 检查 PowerSync 是否准备就绪
    const isReady = isInitialized && db !== null

    // 1. 获取今日阅读时间 (实时计算)
    // 统计今天所有阅读会话的时长
    const todayStr = getLocalDateString()
    
    // 空查询占位符 - 当数据库未就绪时使用，保持 Hook 调用顺序一致
    // 字段名参考: total_ms (毫秒), created_at (ISO8601)
    const EMPTY_SESSIONS_QUERY = 'SELECT total_ms, created_at FROM reading_sessions WHERE 1=0'
    const EMPTY_SETTINGS_QUERY = 'SELECT settings_json FROM user_settings WHERE 1=0'
    // reading_sessions.total_ms 是毫秒，转换为秒
    const EMPTY_WEEKLY_QUERY = 'SELECT date(created_at) as date, SUM(total_ms) / 1000 as total_seconds FROM reading_sessions WHERE 1=0 GROUP BY date(created_at)'
    const EMPTY_ALL_STATS_QUERY = 'SELECT date(created_at) as date, SUM(total_ms) / 1000 as total_seconds FROM reading_sessions WHERE 1=0 GROUP BY date(created_at)'
    // reading_progress.progress 是进度(0-1)，finished_at 是完成时间
    const EMPTY_FINISHED_QUERY = 'SELECT b.id FROM reading_progress rp JOIN books b ON rp.book_id = b.id WHERE 1=0'

    // 查询今日会话 - 使用正确的字段名 total_ms 和 created_at
    const todaySessionsQuery = isReady 
        ? `SELECT total_ms, created_at FROM reading_sessions 
     WHERE date(created_at) = date('now', 'localtime')
     AND total_ms > 0`
        : EMPTY_SESSIONS_QUERY

    const { data: todaySessions } = useQuery<ReadingSessionRow>(todaySessionsQuery)

    const todayMinutes = useMemo(() => {
        if (!todaySessions) return 0
        // total_ms 是毫秒，转换为分钟
        const totalMs = todaySessions.reduce((sum, row) => sum + (row.total_ms || 0), 0)
        return Math.round(totalMs / 60000)
    }, [todaySessions])

    // 2. 获取用户设置 (Goals)
    const settingsQuery = isReady
        ? `SELECT settings_json FROM user_settings LIMIT 1`
        : EMPTY_SETTINGS_QUERY
    
    const { data: settingsData } = useQuery<UserSettingsRow>(settingsQuery)

    const userSettings = useMemo(() => {
        if (!settingsData?.[0]?.settings_json) return { daily_minutes: 30, yearly_books: 10 }
        try {
            const parsed = JSON.parse(settingsData[0].settings_json)
            return {
                daily_minutes: parsed.daily_goal_minutes || 30,
                yearly_books: parsed.yearly_goal_books || 10
            }
        } catch (e) {
            console.warn('Failed to parse user settings', e)
            return { daily_minutes: 30, yearly_books: 10 }
        }
    }, [settingsData])

    // 3. 获取最近7天活动数据
    // 使用 reading_sessions 聚合每日阅读时长 (reading_stats 表不存在)
    const weeklyStatsQuery = isReady
        ? `SELECT date(created_at) as date, SUM(total_ms) / 1000 as total_seconds 
     FROM reading_sessions 
     WHERE date(created_at) >= date('now', '-6 days', 'localtime') 
     GROUP BY date(created_at)
     ORDER BY date ASC`
        : EMPTY_WEEKLY_QUERY

    const { data: weeklyStats } = useQuery<ReadingStatsRow>(weeklyStatsQuery)

    const weeklyActivity = useMemo(() => {
        // 初始化过去7天（含今天）
        const days: { date: string, minutes: number }[] = []
        const now = new Date()
        for (let i = 6; i >= 0; i--) {
            const d = new Date()
            d.setDate(now.getDate() - i)
            days.push({
                date: getLocalDateString(d),
                minutes: 0
            })
        }

        // 填充历史数据
        if (weeklyStats) {
            weeklyStats.forEach(stat => {
                const day = days.find(d => d.date === stat.date)
                if (day) {
                    day.minutes = Math.round(stat.total_seconds / 60)
                }
            })
        }

        // 今天的数据已经在 weeklyStats 聚合中包含
        // 但如果 todayMinutes 更大（基于 duration_seconds），使用较大值
        const todayDay = days.find(d => d.date === todayStr)
        if (todayDay) {
            todayDay.minutes = Math.max(todayDay.minutes, todayMinutes)
        }

        // 计算状态
        return days.map(day => {
            let status: 'FUTURE' | 'MISSED' | 'REACHED' | 'PARTIAL'
            if (day.date > todayStr) {
                status = 'FUTURE'
            } else if (day.minutes === 0) {
                status = 'MISSED'
            } else if (day.minutes >= userSettings.daily_minutes) {
                status = 'REACHED'
            } else {
                status = 'PARTIAL'
            }
            return { ...day, status }
        })
    }, [weeklyStats, todayMinutes, todayStr, userSettings.daily_minutes])

    // 4. 计算 Streak
    // 获取更长历史数据用于计算 Streak (例如过去365天)
    // 使用 reading_sessions 聚合每日阅读时长
    const allStatsQuery = isReady
        ? `SELECT date(created_at) as date, SUM(total_ms) / 1000 as total_seconds 
         FROM reading_sessions 
         WHERE date(created_at) >= date('now', '-365 days', 'localtime') 
         GROUP BY date(created_at)
         ORDER BY date DESC`
        : EMPTY_ALL_STATS_QUERY

    const { data: allStats } = useQuery<ReadingStatsRow>(allStatsQuery)

    const streak = useMemo(() => {
        if (!allStats) return { current_streak: 0, longest_streak: 0 }

        // 合并数据：将今日实时数据合并到统计中
        const dailyMinutesMap = new Map<string, number>()
        allStats.forEach(s => {
            const m = Math.round(s.total_seconds / 60)
            dailyMinutesMap.set(s.date, m)
        })

        // 检查今日是否达标
        const todayGoal = userSettings.daily_minutes

        // 如果今日实时数据更大，更新 Map
        const currentTodayMinutes = Math.max(dailyMinutesMap.get(todayStr) || 0, todayMinutes)
        dailyMinutesMap.set(todayStr, currentTodayMinutes)

        // 辅助函数：检查某天是否达标
        const isReached = (dateStr: string) => (dailyMinutesMap.get(dateStr) || 0) >= todayGoal

        // --- 计算 Current Streak ---
        let currentStreak = 0
        const now = new Date()

        // 从今天或者昨天开始检查
        // 规则：如果今天达标，Streak 包含今天。如果今天未达标，但昨天达标，Streak 延续。如果昨天也没达标，Streak 为 0。
        // 特例：如果今天还没达标，但是是 "进行中"，Streak 显示什么？通常显示截止到昨天的 Streak，除非今天达标了+1。

        const checkDate = new Date(now)
        let checkStr = getLocalDateString(checkDate)

        if (isReached(checkStr)) {
            currentStreak++
            // 继续检查昨天
            checkDate.setDate(checkDate.getDate() - 1)
            checkStr = getLocalDateString(checkDate)
        } else {
            // 今天未达标，检查昨天
            checkDate.setDate(checkDate.getDate() - 1)
            checkStr = getLocalDateString(checkDate)

            // 如果昨天也没达标，当前 Streak 断了 (为0)
            if (!isReached(checkStr)) {
                // currentStreak stays 0
            }
        }

        // 向前回溯
        for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
            // 如果我们已经确认 streak 断了 (count=0 且昨天未达标)，由于逻辑在上面处理了，这里只需要在 count > 0 或 昨天达标的情况下继续
            if (!isReached(checkStr)) break

            // 只有当 (currentStreak > 0) 或者 (currentStreak == 0 && 昨天达标 -> 昨天开始算 1)
            // 上面的逻辑稍微有点重叠，我们简化循环:
            // 实际上我们要找 "连续达标的最长序列，该序列必须包含今天或昨天"
            break; // 重写逻辑以便清晰
        }

        // 重写 Current Streak 逻辑
        currentStreak = 0
        const d = new Date()
        let dStr = getLocalDateString(d)

        // 1. 如果今天达标，计入
        if (isReached(dStr)) {
            currentStreak++
            d.setDate(d.getDate() - 1)
            dStr = getLocalDateString(d)
        } else {
            // 今天没达标，跳过由昨天开始算
            d.setDate(d.getDate() - 1)
            dStr = getLocalDateString(d)
        }

        // 2. 回溯
        while (isReached(dStr)) {
            currentStreak++
            d.setDate(d.getDate() - 1)
            dStr = getLocalDateString(d)
            // 防止死循环 (Map最多365天)
            if (currentStreak > 365) break
        }

        // --- 计算 Longest Streak ---
        // 遍历 map 中所有日期，排序
        const sortedDates = Array.from(dailyMinutesMap.keys()).sort()
        let maxStreak = 0
        let tempStreak = 0

        // 注意 sorted dates 是升序 (old -> new)
        // 我们需要由连续的日期串联
        // 简单处理：遍历所有 stats 记录
        // Map 只包含有阅读记录的天。如果某天没记录，minutes=0。
        // 我们只需要遍历 Map 里的日期，检测日期是否连续且达标。

        if (sortedDates.length > 0) {
            const dayMs = 24 * 60 * 60 * 1000

            // 优化：只遍历有记录的时间段，或者简单点遍历 map keys 检查连续性
            // 更好的方法：只关心达标的日子
            const reachedDates = sortedDates.filter(date => isReached(date))

            if (reachedDates.length > 0) {
                tempStreak = 1
                maxStreak = 1

                for (let i = 1; i < reachedDates.length; i++) {
                    const prev = new Date(reachedDates[i - 1])
                    const curr = new Date(reachedDates[i])
                    const diff = (curr.getTime() - prev.getTime()) / dayMs

                    if (Math.abs(diff - 1) < 0.1) { // 也就是 diff == 1
                        tempStreak++
                    } else {
                        tempStreak = 1
                    }
                    maxStreak = Math.max(maxStreak, tempStreak)
                }
            }
        }

        // 如果当前 streak 比历史最长还长 (e.g. 今天刚达标)
        maxStreak = Math.max(maxStreak, currentStreak)

        return {
            current_streak: currentStreak,
            longest_streak: maxStreak
        }
    }, [allStats, todayMinutes, todayStr, userSettings.daily_minutes])

    // 5. 年度阅读目标完成情况
    // 使用正确的字段名: progress (进度 0-1), finished_at (完成时间)
    const finishedBooksQuery = isReady
        ? `SELECT b.id FROM reading_progress rp
     JOIN books b ON rp.book_id = b.id
     WHERE rp.progress >= 1.0
     AND strftime('%Y', COALESCE(rp.finished_at, rp.updated_at)) = strftime('%Y', 'now')
     AND b.deleted_at IS NULL`
        : EMPTY_FINISHED_QUERY

    const { data: finishedBooks } = useQuery<FinishedBookRow>(finishedBooksQuery)

    const yearlyFinished = useMemo(() => {
        const count = finishedBooks?.length || 0
        const recentCovers = finishedBooks
            ?.slice(0, 5)
            .map(b => b.id && accessToken
                ? `/api/v1/books/${b.id}/cover?token=${encodeURIComponent(accessToken)}`
                : ''
            )
            .filter(Boolean) || []

        return { count, recent_covers: recentCovers as string[] }
    }, [finishedBooks, accessToken])

    // 更新目标设置
    const updateGoals = useCallback(async (dailyMinutes?: number, yearlyBooks?: number) => {
        if (!db) return

        const newSettings = {
            ...userSettings,
            ...(dailyMinutes !== undefined && { daily_goal_minutes: dailyMinutes }),
            ...(yearlyBooks !== undefined && { yearly_goal_books: yearlyBooks }),
        }

        const json = JSON.stringify(newSettings)
        const now = new Date().toISOString()

        // 获取当前用户ID - 使用 getAll 避免空结果异常
        const existingRows = await db.getAll<{ user_id: string }>('SELECT user_id FROM user_settings LIMIT 1')
        const existing = existingRows[0]

        if (existing) {
            await db.execute('UPDATE user_settings SET settings_json = ?, updated_at = ? WHERE user_id = ?',
                [json, now, existing.user_id])
        } else {
            // 无法在此处新建，因为缺少 user_id，通常由后端同步下来或者登录时初始化
            console.warn('No user settings found to update')
        }
    }, [db, userSettings])

    return {
        dashboard: {
            today: { seconds: todayMinutes * 60, minutes: todayMinutes },
            goals: userSettings,
            weekly: weeklyActivity,
            streak,
            yearly_finished: yearlyFinished
        },
        updateGoals,
        isLoading: !isReady || (!todaySessions && !settingsData),
        isReady,
    }
}


==================================================
FILE_PATH: web/src/hooks/useNotesData.ts
==================================================

/**
 * useNotesData - 笔记数据统一入口 Hook (PowerSync Only)
 *
 * 直接使用 PowerSync SQLite 作为唯一数据源
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 3
 */

import { useMemo, useCallback } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncDatabase, usePowerSyncState } from '@/lib/powersync'
import { useAuthStore } from '@/stores/auth'
import { generateUUID, getDeviceId } from '@/lib/utils'

// ============================================================================
// 类型定义
// ============================================================================

export interface NoteItem {
  id: string
  bookId: string
  bookTitle?: string
  chapterIndex?: number
  cfiRange?: string
  pageNumber?: number
  content: string
  color?: string
  tags?: string[]
  createdAt: string
  updatedAt: string
}

export interface HighlightItem {
  id: string
  bookId: string
  bookTitle?: string
  chapterIndex?: number
  cfiRange: string
  pageNumber?: number
  textContent: string
  color: string
  note?: string
  createdAt: string
  updatedAt: string
}

interface NoteRow {
  id: string
  book_id: string
  chapter_index: number | null
  cfi_range: string | null
  page_number: number | null
  content: string
  color: string | null
  tags: string | null
  created_at: string
  updated_at: string
  deleted_at: string | null
}

interface HighlightRow {
  id: string
  book_id: string
  chapter_index: number | null
  cfi_range: string
  page_number: number | null
  text_content: string
  color: string
  note: string | null
  created_at: string
  updated_at: string
  deleted_at: string | null
}

interface BookTitleRow {
  id: string
  title: string
}

interface UseNotesDataOptions {
  bookId?: string
  limit?: number
  search?: string
}

// ============================================================================
// Hook 实现
// ============================================================================

/**
 * 获取笔记列表
 */
export function useNotesData(options: UseNotesDataOptions = {}) {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const isReady = isInitialized && db !== null
  const { bookId, limit, search } = options

  const EMPTY_NOTES_QUERY = 'SELECT * FROM notes WHERE 1=0'
  const EMPTY_BOOKS_QUERY = 'SELECT id, title FROM books WHERE 1=0'

  // 笔记查询
  const notesSql = useMemo(() => {
    if (!isReady) return EMPTY_NOTES_QUERY
    
    let sql = 'SELECT * FROM notes WHERE deleted_at IS NULL'
    const conditions: string[] = []

    if (bookId) {
      conditions.push('book_id = ?')
    }

    if (search) {
      conditions.push('content LIKE ?')
    }

    if (conditions.length > 0) {
      sql += ' AND ' + conditions.join(' AND ')
    }

    sql += ' ORDER BY updated_at DESC'
    if (limit) {
      sql += ` LIMIT ${limit}`
    }
    return sql
  }, [isReady, bookId, limit, search])

  const notesParams = useMemo(() => {
    if (!isReady) return []
    const params: any[] = []
    if (bookId) params.push(bookId)
    if (search) params.push(`%${search}%`)
    return params
  }, [isReady, bookId, search])

  // 书籍标题查询（用于显示书名）
  const booksTitlesSql = isReady 
    ? 'SELECT id, title FROM books WHERE deleted_at IS NULL'
    : EMPTY_BOOKS_QUERY

  const { data: notesData, isLoading, error } = useQuery<NoteRow>(notesSql, notesParams)
  const { data: booksData } = useQuery<BookTitleRow>(booksTitlesSql, [])

  // 书籍标题映射
  const bookTitles = useMemo(() => {
    const map = new Map<string, string>()
    booksData?.forEach(b => map.set(b.id, b.title))
    return map
  }, [booksData])

  // 转换为 UI 格式
  const notes: NoteItem[] = useMemo(() => {
    if (!notesData) return []

    return notesData.map((note): NoteItem => ({
      id: note.id,
      bookId: note.book_id,
      bookTitle: bookTitles.get(note.book_id),
      chapterIndex: note.chapter_index ?? undefined,
      cfiRange: note.cfi_range ?? undefined,
      pageNumber: note.page_number ?? undefined,
      content: note.content,
      color: note.color ?? undefined,
      tags: note.tags ? JSON.parse(note.tags) : undefined,
      createdAt: note.created_at,
      updatedAt: note.updated_at,
    }))
  }, [notesData, bookTitles])

  // 写入操作
  const addNote = useCallback(async (note: Omit<NoteItem, 'id' | 'createdAt' | 'updatedAt'>) => {
    if (!db) throw new Error('Database not available')

    const id = generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id 和 device_id - 从 AuthStore 和 localStorage 获取
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()

    await db.execute(
      `INSERT INTO notes (id, user_id, device_id, book_id, chapter_index, cfi_range, page_number, content, color, tags, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        deviceId,
        note.bookId,
        note.chapterIndex ?? null,
        note.cfiRange ?? null,
        note.pageNumber ?? null,
        note.content,
        note.color ?? null,
        note.tags ? JSON.stringify(note.tags) : null,
        now,
        now
      ]
    )

    return id
  }, [db])

  const updateNote = useCallback(async (id: string, content: string, tags?: string[]) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    await db.execute(
      'UPDATE notes SET content = ?, tags = ?, updated_at = ? WHERE id = ?',
      [content, tags ? JSON.stringify(tags) : null, now, id]
    )
  }, [db])

  const deleteNote = useCallback(async (id: string) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    await db.execute(
      'UPDATE notes SET deleted_at = ?, updated_at = ? WHERE id = ?',
      [now, now, id]
    )
  }, [db])

  return {
    notes,
    isLoading: !isReady || isLoading,
    error,
    addNote,
    updateNote,
    deleteNote,
    isReady,
  }
}

/**
 * 获取高亮列表
 */
export function useHighlightsData(options: UseNotesDataOptions = {}) {
  const db = usePowerSyncDatabase()
  const { isInitialized } = usePowerSyncState()
  const isReady = isInitialized && db !== null
  const { bookId, limit, search } = options

  const EMPTY_HIGHLIGHTS_QUERY = 'SELECT * FROM highlights WHERE 1=0'
  const EMPTY_BOOKS_QUERY = 'SELECT id, title FROM books WHERE 1=0'

  // 高亮查询
  const highlightsSql = useMemo(() => {
    if (!isReady) return EMPTY_HIGHLIGHTS_QUERY
    
    let sql = 'SELECT * FROM highlights WHERE deleted_at IS NULL'
    const conditions: string[] = []

    if (bookId) {
      conditions.push('book_id = ?')
    }

    if (search) {
      conditions.push('text_content LIKE ?')
    }

    if (conditions.length > 0) {
      sql += ' AND ' + conditions.join(' AND ')
    }

    sql += ' ORDER BY updated_at DESC'
    if (limit) {
      sql += ` LIMIT ${limit}`
    }
    return sql
  }, [isReady, bookId, limit, search])

  const highlightsParams = useMemo(() => {
    if (!isReady) return []
    const params: any[] = []
    if (bookId) params.push(bookId)
    if (search) params.push(`%${search}%`)
    return params
  }, [isReady, bookId, search])

  // 书籍标题查询
  const booksTitlesSql = isReady
    ? 'SELECT id, title FROM books WHERE deleted_at IS NULL'
    : EMPTY_BOOKS_QUERY

  const { data: highlightsData, isLoading, error } = useQuery<HighlightRow>(highlightsSql, highlightsParams)
  const { data: booksData } = useQuery<BookTitleRow>(booksTitlesSql, [])

  // 书籍标题映射
  const bookTitles = useMemo(() => {
    const map = new Map<string, string>()
    booksData?.forEach(b => map.set(b.id, b.title))
    return map
  }, [booksData])

  // 转换为 UI 格式
  const highlights: HighlightItem[] = useMemo(() => {
    if (!highlightsData) return []

    return highlightsData.map((h): HighlightItem => ({
      id: h.id,
      bookId: h.book_id,
      bookTitle: bookTitles.get(h.book_id),
      chapterIndex: h.chapter_index ?? undefined,
      cfiRange: h.cfi_range,
      pageNumber: h.page_number ?? undefined,
      textContent: h.text_content,
      color: h.color,
      note: h.note ?? undefined,
      createdAt: h.created_at,
      updatedAt: h.updated_at,
    }))
  }, [highlightsData, bookTitles])

  // 写入操作
  const addHighlight = useCallback(async (highlight: Omit<HighlightItem, 'id' | 'createdAt' | 'updatedAt' | 'bookTitle'>) => {
    if (!db) throw new Error('Database not available')

    const id = generateUUID()
    const now = new Date().toISOString()
    // 使用正确的 user_id 和 device_id - 从 AuthStore 和 localStorage 获取
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()

    await db.execute(
      `INSERT INTO highlights (id, user_id, device_id, book_id, chapter_index, cfi_range, page_number, text_content, color, note, created_at, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        userId,
        deviceId,
        highlight.bookId,
        highlight.chapterIndex ?? null,
        highlight.cfiRange,
        highlight.pageNumber ?? null,
        highlight.textContent,
        highlight.color,
        highlight.note ?? null,
        now,
        now
      ]
    )

    return id
  }, [db])

  const updateHighlight = useCallback(async (id: string, updates: { color?: string; note?: string }) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    const fields: string[] = ['updated_at = ?']
    const values: (string | null)[] = [now]

    if (updates.color !== undefined) {
      fields.push('color = ?')
      values.push(updates.color)
    }
    if (updates.note !== undefined) {
      fields.push('note = ?')
      values.push(updates.note)
    }

    values.push(id)
    await db.execute(`UPDATE highlights SET ${fields.join(', ')} WHERE id = ?`, values)
  }, [db])

  const deleteHighlight = useCallback(async (id: string) => {
    if (!db) throw new Error('Database not available')

    const now = new Date().toISOString()
    await db.execute(
      'UPDATE highlights SET deleted_at = ?, updated_at = ? WHERE id = ?',
      [now, now, id]
    )
  }, [db])

  return {
    highlights,
    isLoading: !isReady || isLoading,
    error,
    addHighlight,
    updateHighlight,
    deleteHighlight,
    isReady,
  }
}

/**
 * 获取书籍的笔记和高亮组合数据
 */
export function useBookAnnotations(bookId: string) {
  const { notes, isLoading: notesLoading, addNote, updateNote, deleteNote } = useNotesData({ bookId })
  const { highlights, isLoading: highlightsLoading, addHighlight, updateHighlight, deleteHighlight } = useHighlightsData({ bookId })

  return {
    notes,
    highlights,
    isLoading: notesLoading || highlightsLoading,
    // 笔记操作
    addNote,
    updateNote,
    deleteNote,
    // 高亮操作
    addHighlight,
    updateHighlight,
    deleteHighlight,
  }
}


==================================================
FILE_PATH: web/src/hooks/useBookFileCache.ts
==================================================

/**
 * useBookFileCache.ts - 本地文件缓存状态管理 Hook (App-First 版)
 *
 * 职责：
 * - 追踪书籍文件的本地缓存状态
 * - 提供下载状态管理
 * - 使用 bookStorage.ts 的原生 IndexedDB API
 *
 * 替代原有的 useLocalBookCache.ts (基于 Dexie)
 *
 * @see 09 - APP-FIRST架构改造计划.md
 */

import { useState, useEffect, useCallback, useRef } from 'react'
import { isBookCached } from '@/lib/bookStorage'

export type CacheStatus = 'cloud' | 'downloading' | 'ready'

interface BookCacheState {
  [bookId: string]: CacheStatus
}

export interface UseBookFileCacheReturn {
  /** 获取指定书籍的缓存状态 */
  getBookCacheStatus: (bookId: string) => CacheStatus
  /** 标记书籍正在下载 */
  markDownloading: (bookId: string) => void
  /** 标记书籍已下载完成 */
  markDownloaded: (bookId: string) => void
  /** 刷新缓存状态 */
  refresh: () => Promise<void>
  /** 是否正在加载初始状态 */
  isLoading: boolean
}

/**
 * 本地文件缓存状态管理 Hook
 *
 * @param bookIds - 需要追踪的书籍 ID 列表
 * @returns 缓存状态管理函数
 */
export function useBookFileCache(bookIds: string[]): UseBookFileCacheReturn {
  const [cacheState, setCacheState] = useState<BookCacheState>({})
  const [isLoading, setIsLoading] = useState(true)
  const mountedRef = useRef(true)

  // 加载缓存状态
  const loadCacheStatus = useCallback(async () => {
    if (bookIds.length === 0) {
      setCacheState({})
      setIsLoading(false)
      return
    }

    try {
      const results = await Promise.all(
        bookIds.map(async (bookId) => {
          const isCached = await isBookCached(bookId)
          return { bookId, isCached }
        })
      )

      if (!mountedRef.current) return

      const newState: BookCacheState = {}
      for (const { bookId, isCached } of results) {
        // 保留正在下载的状态
        if (cacheState[bookId] === 'downloading') {
          newState[bookId] = 'downloading'
        } else {
          newState[bookId] = isCached ? 'ready' : 'cloud'
        }
      }
      setCacheState(newState)
    } catch (error) {
      console.error('[useBookFileCache] Failed to load cache status:', error)
    } finally {
      if (mountedRef.current) {
        setIsLoading(false)
      }
    }
  }, [bookIds, cacheState])

  // 初始化和 bookIds 变化时加载
  useEffect(() => {
    loadCacheStatus()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [bookIds.join(',')])

  // 监听缓存事件
  useEffect(() => {
    const handleBookCached = (event: CustomEvent<{ bookId: string }>) => {
      const { bookId } = event.detail
      setCacheState((prev) => ({
        ...prev,
        [bookId]: 'ready'
      }))
    }

    const handleBookDeleted = (event: CustomEvent<{ bookId: string }>) => {
      const { bookId } = event.detail
      setCacheState((prev) => ({
        ...prev,
        [bookId]: 'cloud'
      }))
    }

    window.addEventListener('book_cached', handleBookCached as EventListener)
    window.addEventListener('book_deleted', handleBookDeleted as EventListener)

    return () => {
      window.removeEventListener('book_cached', handleBookCached as EventListener)
      window.removeEventListener('book_deleted', handleBookDeleted as EventListener)
    }
  }, [])

  // 组件卸载标记
  useEffect(() => {
    mountedRef.current = true
    return () => {
      mountedRef.current = false
    }
  }, [])

  // 获取缓存状态
  const getBookCacheStatus = useCallback(
    (bookId: string): CacheStatus => {
      return cacheState[bookId] || 'cloud'
    },
    [cacheState]
  )

  // 标记正在下载
  const markDownloading = useCallback((bookId: string) => {
    setCacheState((prev) => ({
      ...prev,
      [bookId]: 'downloading'
    }))
  }, [])

  // 标记已下载
  const markDownloaded = useCallback((bookId: string) => {
    setCacheState((prev) => ({
      ...prev,
      [bookId]: 'ready'
    }))
  }, [])

  return {
    getBookCacheStatus,
    markDownloading,
    markDownloaded,
    refresh: loadCacheStatus,
    isLoading
  }
}

// 兼容性导出（保持向后兼容）
export const useLocalBookCache = useBookFileCache


==================================================
FILE_PATH: web/src/hooks/useUploadPostProcessing.ts
==================================================

/**
 * useUploadPostProcessing.ts
 * 
 * 上传后处理 Hook (App-First 版)
 * 使用 PowerSync 实时监控书籍状态，替代 API 轮询
 */

import { useState, useCallback, useRef, useEffect } from 'react'
import { useQuery } from '@powersync/react'
import { usePowerSyncState } from '@/lib/powersync'

export interface BookProcessingStatus {
  bookId: string
  title: string
  // 封面状态
  hasCover: boolean
  coverUrl?: string
  // 元数据状态
  metadataExtracted: boolean
  extractedTitle?: string
  extractedAuthor?: string
  metadataConfirmed: boolean
  // OCR 状态（是否是图片型 PDF）
  isImageBasedPdf: boolean
  ocrStatus?: 'none' | 'pending' | 'processing' | 'completed' | 'failed'
  pageCount?: number
  // 加载状态
  loading: boolean
  error?: string
}

interface UseUploadPostProcessingOptions {
  /** 轮询间隔（毫秒） - 在 PowerSync 模式下忽略 */
  pollInterval?: number
  /** 最大轮询次数 - 在 PowerSync 模式下忽略 */
  maxPollCount?: number
  /** 状态更新回调 */
  onStatusUpdate?: (status: BookProcessingStatus) => void
  /** 元数据提取完成回调 */
  onMetadataReady?: (status: BookProcessingStatus) => void
  /** 图片 PDF 检测完成回调 */
  onImagePdfDetected?: (status: BookProcessingStatus) => void
  /** 封面就绪回调 */
  onCoverReady?: (status: BookProcessingStatus) => void
}

export function useUploadPostProcessing(options: UseUploadPostProcessingOptions = {}) {
  const {
    onStatusUpdate,
    onMetadataReady,
    onImagePdfDetected,
    onCoverReady,
  } = options

  const [monitoredBookId, setMonitoredBookId] = useState<string | null>(null)
  const prevStatusRef = useRef<BookProcessingStatus | null>(null)
  
  // 使用 ref 保存回调函数
  const onStatusUpdateRef = useRef(onStatusUpdate)
  const onMetadataReadyRef = useRef(onMetadataReady)
  const onImagePdfDetectedRef = useRef(onImagePdfDetected)
  const onCoverReadyRef = useRef(onCoverReady)
  
  useEffect(() => {
    onStatusUpdateRef.current = onStatusUpdate
    onMetadataReadyRef.current = onMetadataReady
    onImagePdfDetectedRef.current = onImagePdfDetected
    onCoverReadyRef.current = onCoverReady
  }, [onStatusUpdate, onMetadataReady, onImagePdfDetected, onCoverReady])

  const { isInitialized } = usePowerSyncState()

  // 使用 PowerSync 实时查询书籍状态
  const query = isInitialized && monitoredBookId
    ? 'SELECT * FROM books WHERE id = ?'
    : 'SELECT * FROM books WHERE 1=0'
    
  const { data: books } = useQuery(
    query,
    isInitialized && monitoredBookId ? [monitoredBookId] : []
  )
  
  const book = books?.[0]

  useEffect(() => {
    if (!monitoredBookId || !book) return

    const status: BookProcessingStatus = {
      bookId: monitoredBookId,
      title: book.title || '',
      hasCover: !!(book.cover_url || book.cover_image_key),
      coverUrl: book.cover_url,
      metadataExtracted: !!book.metadata_extracted, // 假设 schema 中有此字段，如果没有则需调整
      extractedTitle: book.title,
      extractedAuthor: book.author,
      metadataConfirmed: !!book.metadata_confirmed, // 假设 schema 中有此字段
      isImageBasedPdf: !!book.is_image_based,
      ocrStatus: book.ocr_status as any || 'none',
      pageCount: book.page_count,
      loading: false
    }

    // 触发状态更新回调
    onStatusUpdateRef.current?.(status)

    const prev = prevStatusRef.current

    // 检查状态变化并触发回调
    // 1. 封面就绪
    if (status.hasCover && (!prev || !prev.hasCover)) {
      onCoverReadyRef.current?.(status)
    }

    // 2. 元数据提取完成（但尚未确认）
    if (status.metadataExtracted && !status.metadataConfirmed && (!prev || !prev.metadataExtracted)) {
      onMetadataReadyRef.current?.(status)
    }

    // 3. 图片 PDF 检测到
    if (status.isImageBasedPdf && status.ocrStatus === 'none' && (!prev || !prev.isImageBasedPdf)) {
      onImagePdfDetectedRef.current?.(status)
    }

    prevStatusRef.current = status

  }, [book, monitoredBookId])

  const startMonitoring = useCallback((bookId: string) => {
    console.log('[UploadPostProcessing] Starting monitoring for book:', bookId)
    setMonitoredBookId(bookId)
    prevStatusRef.current = null
  }, [])

  const stopMonitoring = useCallback(() => {
    console.log('[UploadPostProcessing] Stopping monitoring')
    setMonitoredBookId(null)
    prevStatusRef.current = null
  }, [])

  return {
    status: prevStatusRef.current, // 返回最新的状态
    startMonitoring,
    stopMonitoring,
  }
}


==================================================
FILE_PATH: web/src/hooks/useBookUpload.ts
==================================================

/**
 * 电子书上传 Hook
 *
 * 流程：
 * 1) 计算文件 SHA256（可选，失败则服务端计算）
 * 2) 初始化上传，处理去重（own/global 秒传）
 * 3) 通过预签名 URL 直传（XMLHttpRequest 以获得进度）
 * 4) 通知后端完成并持久化记录
 * 5) EPUB/PDF 直接写入 IndexedDB，支持立即阅读
 *
 * **离线支持**:
 * - 离线时将上传任务保存到 IndexedDB 队列
 * - 网络恢复后自动上传
 *
 * 错误处理：统一 `errorCode` 标准化，支持取消与配额限制等场景
 */
import { useState, useCallback, useRef } from 'react'
import { v4 as uuidv4 } from 'uuid'
import api from '@/lib/api'
import { saveBookFile, saveOfflineUploadQueue } from '@/lib/bookStorage'

// 上传阶段枚举
export type UploadStage = 'idle' | 'hashing' | 'initializing' | 'uploading' | 'completing' | 'done' | 'error'

// 错误码类型
export type UploadErrorCode = 
  | 'quota_exceeded'
  | 'init_failed'
  | 'put_failed'
  | 'complete_failed'
  | 'file_too_large'
  | 'invalid_format'
  | 'network_error'
  | 'cancelled'
  | 'queued_offline'  // 新增：离线队列
  | 'unknown'

// 支持的文件格式
// EPUB/PDF: 直接支持阅读
// 其他格式: 上传后服务器使用 Calibre 转换为 EPUB
export const SUPPORTED_FORMATS = [
  'epub', 'pdf',           // 直接支持
  'mobi', 'azw', 'azw3',   // Amazon Kindle 格式
  'fb2',                   // FictionBook
  'txt', 'rtf',            // 纯文本和富文本
  'djvu', 'djv',           // DjVu 扫描文档（两种扩展名）
  'lit',                   // Microsoft Reader
  'doc', 'docx',           // Microsoft Word
]
export const MAX_FILE_SIZE = 500 * 1024 * 1024 // 500MB

// 上传状态
export interface UploadState {
  stage: UploadStage
  progress: number // 0-100
  errorCode: UploadErrorCode | null
  fileName: string | null
  bookId: string | null
}

// 上传结果
export interface UploadResult {
  id: string
  downloadUrl: string
  title: string
}

// 进度回调参数
export interface ProgressInfo {
  stage: UploadStage
  progress: number
  fileName: string
}

// Hook 配置选项
export interface UseBookUploadOptions {
  onProgress?: (info: ProgressInfo) => void
  onSuccess?: (result: UploadResult) => void
  onError?: (errorCode: UploadErrorCode, message?: string) => void
}

// 计算文件 SHA256 哈希（支持移动端浏览器）
async function computeSha256(file: File): Promise<string> {
  try {
    // 检查 crypto.subtle 是否可用（某些移动浏览器或非 HTTPS 环境不支持）
    if (!crypto?.subtle?.digest) {
      console.warn('[SHA256] crypto.subtle not available, skipping client-side hash')
      return ''
    }
    
    // 对于大文件，分块读取以避免内存问题
    const MAX_CHUNK_SIZE = 64 * 1024 * 1024 // 64MB
    
    if (file.size > MAX_CHUNK_SIZE) {
      // 大文件：使用流式处理（如果支持）
      // 某些移动浏览器可能不支持，回退到服务端计算
      console.log(`[SHA256] Large file (${(file.size / 1024 / 1024).toFixed(1)}MB), attempting chunked hash...`)
    }
    
    const buf = await file.arrayBuffer()
    const hashBuf = await crypto.subtle.digest('SHA-256', buf)
    const hashArr = Array.from(new Uint8Array(hashBuf))
    const hash = hashArr.map(b => b.toString(16).padStart(2, '0')).join('')
    
    console.log(`[SHA256] Computed: ${hash.substring(0, 16)}... for ${file.name}`)
    return hash
  } catch (error) {
    // 移动端浏览器或某些环境可能抛出异常
    console.warn('[SHA256] Client-side hash computation failed:', error)
    console.warn('[SHA256] Server will compute hash as fallback')
    return ''
  }
}

// 获取文件扩展名
function getFileExtension(filename: string): string {
  return filename.split('.').pop()?.toLowerCase() || ''
}

// 验证文件格式
function validateFileFormat(filename: string): boolean {
  const ext = getFileExtension(filename)
  return SUPPORTED_FORMATS.includes(ext)
}

export function useBookUpload(options: UseBookUploadOptions = {}) {
  const { onProgress, onSuccess, onError } = options
  
  const [state, setState] = useState<UploadState>({
    stage: 'idle',
    progress: 0,
    errorCode: null,
    fileName: null,
    bookId: null,
  })

  // 取消控制器
  const abortControllerRef = useRef<AbortController | null>(null)
  // 幂等键
  const idempotencyKeyRef = useRef<string>('')

  // 更新状态并触发回调
  const updateState = useCallback((
    stage: UploadStage, 
    progress: number, 
    extra?: Partial<UploadState>
  ) => {
    setState(prev => {
      const newState = { ...prev, stage, progress, ...extra }
      // 触发进度回调
      if (onProgress && newState.fileName) {
        onProgress({
          stage,
          progress,
          fileName: newState.fileName,
        })
      }
      return newState
    })
  }, [onProgress])

  // 处理错误
  const handleError = useCallback((errorCode: UploadErrorCode, message?: string) => {
    setState(prev => ({
      ...prev,
      stage: 'error',
      errorCode,
    }))
    onError?.(errorCode, message)
  }, [onError])

  // 重置状态
  const reset = useCallback(() => {
    // 取消正在进行的上传
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      abortControllerRef.current = null
    }
    setState({
      stage: 'idle',
      progress: 0,
      errorCode: null,
      fileName: null,
      bookId: null,
    })
    idempotencyKeyRef.current = ''
  }, [])

  // 取消上传
  const cancel = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      abortControllerRef.current = null
    }
    handleError('cancelled')
  }, [handleError])

  // 开始上传
  const start = useCallback(async (file: File, customTitle?: string): Promise<UploadResult | null> => {
    // 重置并生成新的幂等键
    reset()
    idempotencyKeyRef.current = uuidv4()
    abortControllerRef.current = new AbortController()
    const signal = abortControllerRef.current.signal

    const fileName = file.name
    const title = customTitle || fileName.replace(/\.[^/.]+$/, '')

    try {
      // 验证文件格式
      if (!validateFileFormat(fileName)) {
        handleError('invalid_format', `Unsupported format. Supported: ${SUPPORTED_FORMATS.join(', ')}`)
        return null
      }

      // 验证文件大小
      if (file.size > MAX_FILE_SIZE) {
        handleError('file_too_large', `File too large. Max size: ${MAX_FILE_SIZE / 1024 / 1024}MB`)
        return null
      }

      updateState('hashing', 5, { fileName })

      // Step 1: 计算文件哈希
      let fingerprint: string
      try {
        fingerprint = await computeSha256(file)
        if (signal.aborted) throw new Error('cancelled')
      } catch (e) {
        if ((e as Error).message === 'cancelled') {
          handleError('cancelled')
          return null
        }
        // 哈希计算失败不阻塞上传，使用空值
        fingerprint = ''
      }

      // **离线检测**: 如果离线，将上传任务保存到队列
      if (!navigator.onLine) {
        console.log('[Upload] Offline detected, saving to upload queue...')
        const fmt = getFileExtension(fileName)
        const directFormats = ['epub', 'pdf']
        
        // 保存文件到 IndexedDB（允许离线阅读）
        if (directFormats.includes(fmt)) {
          const tempBookId = `temp_${idempotencyKeyRef.current}`
          await saveBookFile(tempBookId, file, fmt as 'epub' | 'pdf')
          console.log('[Upload] Saved file locally for offline reading:', tempBookId)
        }
        
        // 加入上传队列
        await saveOfflineUploadQueue({
          id: idempotencyKeyRef.current,
          fileName,
          title,
          blob: file,
          fingerprint,
          createdAt: Date.now(),
        })
        
        // 返回临时结果，告知用户已加入队列
        updateState('done', 100, { 
          fileName,
          bookId: `temp_${idempotencyKeyRef.current}`,
        })
        
        // 触发特殊回调：队列成功而非真正上传成功
        onError?.('queued_offline', 'File saved to upload queue. Will upload when online.')
        
        return {
          id: `temp_${idempotencyKeyRef.current}`,
          downloadUrl: '',
          title,
        }
      }

      updateState('initializing', 15)

      // Step 2: 初始化上传，获取预签名 URL
      let key: string
      let uploadUrl: string
      let dedupHit: 'own' | 'global' | null = null
      let canonicalBookId: string | null = null
      
      try {
        const initRes = await api.post('/books/upload_init', {
          filename: fileName,
          content_sha256: fingerprint,  // SHA256 哈希用于去重检查
          content_type: file.type || 'application/octet-stream',
        }, {
          headers: {
            'Idempotency-Key': idempotencyKeyRef.current,
          },
          signal,
        })

        dedupHit = initRes.data.data.dedup_hit
        
        // 处理去重命中情况
        if (dedupHit === 'own') {
          // 用户自己已有相同文件，直接返回现有记录
          const result: UploadResult = {
            id: initRes.data.data.existing_book_id,
            downloadUrl: '', // 不需要
            title: initRes.data.data.existing_title || title,
          }
          updateState('done', 100, { bookId: result.id })
          onSuccess?.(result)
          return result
        }
        
        if (dedupHit === 'global') {
          // 全局已有相同文件，调用秒传接口
          canonicalBookId = initRes.data.data.canonical_book_id
          console.log('[Upload] Dedup hit: global, using instant upload for canonical:', canonicalBookId)
          
          updateState('completing', 90)
          
          // 调用秒传接口
          const dedupRes = await api.post('/books/dedup_reference', {
            content_sha256: fingerprint,
            canonical_book_id: canonicalBookId,
            title,
            author: '',
            language: '',
          }, {
            headers: {
              'Idempotency-Key': idempotencyKeyRef.current,
            },
            signal,
          })
          
          const result: UploadResult = {
            id: dedupRes.data.data.id,
            downloadUrl: dedupRes.data.data.download_url,
            title,
          }
          
          // 秒传成功，同样保存文件到 IndexedDB
          const fmt = getFileExtension(fileName)
          const directFormats = ['epub', 'pdf']
          if (directFormats.includes(fmt)) {
            try {
              console.log(`[Upload] Saving ${fmt} to IndexedDB for instant reading (dedup)...`)
              await saveBookFile(result.id, file, fmt as 'epub' | 'pdf')
              console.log(`[Upload] Book saved to IndexedDB: ${result.id}`)
            } catch (cacheError) {
              console.warn('[Upload] Failed to cache book locally:', cacheError)
            }
          }
          
          updateState('done', 100, { bookId: result.id })
          onSuccess?.(result)
          return result
        }

        // 正常上传流程
        key = initRes.data.data.key
        uploadUrl = initRes.data.data.upload_url
      } catch (error: any) {
        if (signal.aborted) {
          handleError('cancelled')
          return null
        }
        if (error.response?.status === 403) {
          const detail = error.response?.data?.detail
          if (detail === 'upload_forbidden_quota_exceeded') {
            handleError('quota_exceeded')
            return null
          }
        }
        handleError('init_failed', error.message)
        return null
      }

      updateState('uploading', 20)

      // Step 3: 直接上传文件到 S3
      try {
        // 处理 SeaweedFS 内部域名重写
        let finalUrl = uploadUrl
        try {
          const u = new URL(uploadUrl)
          if (u.hostname.includes('seaweed') || u.hostname.includes('localhost')) {
            // 使用代理路径
            finalUrl = `/s3${u.pathname}${u.search}`
          }
        } catch {
          // URL 解析失败，使用原始 URL
        }

        // 使用 XMLHttpRequest 以支持进度监控
        await new Promise<void>((resolve, reject) => {
          const xhr = new XMLHttpRequest()
          
          xhr.upload.addEventListener('progress', (event) => {
            if (event.lengthComputable) {
              // 上传进度占 20-80%
              const uploadProgress = Math.round((event.loaded / event.total) * 60)
              updateState('uploading', 20 + uploadProgress)
            }
          })

          xhr.addEventListener('load', () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve()
            } else {
              reject(new Error(`Upload failed with status ${xhr.status}`))
            }
          })

          xhr.addEventListener('error', () => {
            reject(new Error('Network error during upload'))
          })

          xhr.addEventListener('abort', () => {
            reject(new Error('cancelled'))
          })

          // 监听取消信号
          signal.addEventListener('abort', () => {
            xhr.abort()
          })

          xhr.open('PUT', finalUrl)
          xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream')
          xhr.send(file)
        })

        if (signal.aborted) {
          handleError('cancelled')
          return null
        }
      } catch (error: any) {
        if (error.message === 'cancelled' || signal.aborted) {
          handleError('cancelled')
          return null
        }
        handleError('put_failed', error.message)
        return null
      }

      updateState('completing', 85)

      // Step 4: 通知后端上传完成
      try {
        const fmt = getFileExtension(fileName)
        const compRes = await api.post('/books/upload_complete', {
          key,
          title,
          original_format: fmt,
          size: file.size,
          content_sha256: fingerprint,  // 传递 SHA256 用于去重
        }, {
          headers: {
            'Idempotency-Key': idempotencyKeyRef.current,
          },
          signal,
        })

        const result: UploadResult = {
          id: compRes.data.data.id,
          downloadUrl: compRes.data.data.download_url,
          title,
        }

        // Step 5: 同时保存文件到 IndexedDB（上传后立即可读）
        // 只有 EPUB 和 PDF 格式直接保存，其他格式需要服务器转换
        const directFormats = ['epub', 'pdf']
        if (directFormats.includes(fmt)) {
          try {
            console.log(`[Upload] Saving ${fmt} to IndexedDB for instant reading...`)
            await saveBookFile(result.id, file, fmt as 'epub' | 'pdf')
            console.log(`[Upload] Book saved to IndexedDB: ${result.id}`)
          } catch (cacheError) {
            // 缓存失败不阻塞上传流程
            console.warn('[Upload] Failed to cache book locally:', cacheError)
          }
        }

        updateState('done', 100, { bookId: result.id })
        onSuccess?.(result)

        return result
      } catch (error: any) {
        if (signal.aborted) {
          handleError('cancelled')
          return null
        }
        handleError('complete_failed', error.message)
        return null
      }
    } catch (error: any) {
      // 捕获任何未处理的错误
      if (error.message === 'cancelled' || signal?.aborted) {
        handleError('cancelled')
      } else {
        handleError('unknown', error.message)
      }
      return null
    }
  }, [updateState, handleError, reset, onSuccess, onError])

  return {
    // 状态
    ...state,
    isUploading: state.stage !== 'idle' && state.stage !== 'done' && state.stage !== 'error',
    
    // 方法
    start,
    cancel,
    reset,
    
    // 常量
    supportedFormats: SUPPORTED_FORMATS,
    maxFileSize: MAX_FILE_SIZE,
  }
}


==================================================
FILE_PATH: web/src/hooks/data/index.ts
==================================================

/**
 * PowerSync 数据 Hooks 统一导出
 *
 * App-First 架构的数据访问入口
 * 所有数据操作都通过这些 Hooks 进行
 *
 * @see 09 - APP-FIRST架构改造计划.md Phase 3
 */

// 书籍数据
export {
  useBooksData,
  useBookData,
  type BookItem,
} from '../useBooksData'

// 笔记和高亮数据
export {
  useNotesData,
  useHighlightsData,
  useBookAnnotations,
  type NoteItem,
  type HighlightItem,
} from '../useNotesData'

// 阅读进度数据
export {
  useProgressData,
  useAllProgressData,
  useReadingSession,
  type ReadingProgressData,
} from '../useProgressData'

// 书架数据
export {
  useShelvesData,
  useShelfData,
  useBookShelvesData,
  type ShelfData,
  type ShelfBookData,
} from '../useShelvesData'


==================================================
FILE_PATH: web/src/styles/figma.css
==================================================

/*
 * 设计系统样式（Figma 导出映射）
 * - 定义 Apple 风格 Design Tokens 与 Tailwind v4 utilities
 * - 支持亮/暗主题与毛玻璃效果
 * - 提供骨架屏、菜单展开等动效
 */
@custom-variant dark (&:is(.dark *));

:root {
  --font-size: 16px;
  --background: #ffffff;
  --foreground: oklch(0.145 0 0);
  --card: #ffffff;
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: #030213;
  --primary-foreground: oklch(1 0 0);
  --secondary: oklch(0.95 0.0058 264.53);
  --secondary-foreground: #030213;
  --muted: #ececf0;
  --muted-foreground: #717182;
  --accent: #e9ebef;
  --accent-foreground: #030213;
  --destructive: #d4183d;
  --destructive-foreground: #ffffff;
  --border: rgba(0, 0, 0, 0.1);
  --input: transparent;
  --input-background: #f3f3f5;
  --switch-background: #cbced4;
  --font-weight-medium: 500;
  --font-weight-normal: 400;
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: #030213;
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
  --color-system-blue: #007AFF;
  --color-label: rgba(0,0,0,0.85);
  --color-secondary-label: rgba(60,60,67,0.6);
  --color-system-fill: rgba(120,120,128,0.2);

  /* Apple Design Tokens */
  --system-background: #ffffff;
  --secondary-background: #f2f2f7;
  --tertiary-background: #f7f7f7;
  --label: rgba(0,0,0,0.85);
  --secondary-label: rgba(60,60,67,0.6);
  --tertiary-label: rgba(60,60,67,0.3);
  --system-blue: var(--color-system-blue);
  --overlay: rgba(255,255,255,0.45);
  --liquid-glass-blur: 24px;
  --separator: rgba(60,60,67,0.29);

  /* Motion Tokens (UIUX 设计规范 2.4) */
  --duration-fast: 150ms;     /* Hover, Click */
  --duration-medium: 300ms;   /* Panel Slide, Modal Fade */
  --duration-slow: 500ms;     /* Sheet Slide, 大面积动画 */
  --easing-apple: cubic-bezier(0.22, 1, 0.36, 1);  /* Apple 风格自然回弹 */
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.145 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.145 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.985 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.269 0 0);
  --input: oklch(0.269 0 0);
  --ring: oklch(0.439 0 0);
  --font-weight-medium: 500;
  --font-weight-normal: 400;
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(0.269 0 0);
  --sidebar-ring: oklch(0.439 0 0);
  --color-system-blue: #0A84FF;
  --color-label: rgba(255,255,255,0.85);
  --color-secondary-label: rgba(235,235,245,0.6);
  --color-system-fill: rgba(120,120,128,0.36);

  /* Apple Design Tokens (Dark) */
  --system-background: #000000;
  --secondary-background: #1c1c1e;
  --tertiary-background: #2c2c2e;
  --label: rgba(255,255,255,0.85);
  --secondary-label: rgba(235,235,245,0.6);
  --tertiary-label: rgba(235,235,245,0.3);
  --system-blue: var(--color-system-blue);
  --overlay: rgba(0,0,0,0.45);
  --liquid-glass-blur: 24px;
  --separator: rgba(84,84,88,0.65);
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-input-background: var(--input-background);
  --color-switch-background: var(--switch-background);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

/* Tailwind v4 utilities mapping to Apple tokens */
@utility bg-system-background { background-color: var(--system-background); }
@utility bg-secondary-background { background-color: var(--secondary-background); }
@utility bg-tertiary-background { background-color: var(--tertiary-background); }
@utility text-label { color: var(--label); }
@utility text-secondary-label { color: var(--secondary-label); }
@utility text-tertiary-label { color: var(--tertiary-label); }
@utility bg-system-blue { background-color: var(--system-blue); }
@utility border-separator { border-color: var(--separator); }
@utility backdrop-liquid-glass {
  backdrop-filter: blur(var(--liquid-glass-blur));
  -webkit-backdrop-filter: blur(var(--liquid-glass-blur));
  background-color: var(--overlay);
}
@utility bg-overlay { background-color: var(--overlay); }

/* 毛玻璃对话框效果 */
@utility backdrop-glass-heavy {
  backdrop-filter: blur(40px) saturate(180%);
  -webkit-backdrop-filter: blur(40px) saturate(180%);
}

/* 骨架屏脉冲动效 - 用于处理中状态 */
@keyframes skeleton-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}
@utility animate-skeleton-pulse {
  animation: skeleton-pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* 菜单展开动效 */
@keyframes menu-expand {
  from { 
    opacity: 0; 
    transform: scale(0.9) translateY(-8px); 
  }
  to { 
    opacity: 1; 
    transform: scale(1) translateY(0); 
  }
}
@utility animate-menu-expand {
  animation: menu-expand 200ms cubic-bezier(0.22, 1, 0.36, 1);
  transform-origin: top right;
}

/* Motion Utility Classes (统一动效参数) */
@utility duration-fast {
  transition-duration: var(--duration-fast);
}
@utility duration-medium {
  transition-duration: var(--duration-medium);
}
@utility duration-slow {
  transition-duration: var(--duration-slow);
}
@utility ease-apple {
  transition-timing-function: var(--easing-apple);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }

  body {
    @apply bg-background text-foreground;
    font-family: var(--font-ui);
  }
}

@layer base {
  :where(:not(:has([class*=' text-']), :not(:has([class^='text-'])))) {
    h1 { font-size: var(--text-2xl); font-weight: var(--font-weight-medium); line-height: 1.5; }
    h2 { font-size: var(--text-xl); font-weight: var(--font-weight-medium); line-height: 1.5; }
    h3 { font-size: var(--text-lg); font-weight: var(--font-weight-medium); line-height: 1.5; }
    h4 { font-size: var(--text-base); font-weight: var(--font-weight-medium); line-height: 1.5; }
    p  { font-size: var(--text-base); font-weight: var(--font-weight-normal); line-height: 1.5; }
    label { font-size: var(--text-base); font-weight: var(--font-weight-medium); line-height: 1.5; }
    button { font-size: var(--text-base); font-weight: var(--font-weight-medium); line-height: 1.5; }
    input  { font-size: var(--text-base); font-weight: var(--font-weight-normal); line-height: 1.5; }
  }
}

html { font-size: var(--font-size); }
/* UI 字体栈（含中文系统字体与开源回退） */
:root { --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "PingFang SC", "Microsoft YaHei", "Noto Sans SC", "Source Han Sans SC", "Noto Sans", sans-serif; }
.font-ui { font-family: var(--font-ui); }

.marquee-row { overflow-x: hidden; overflow-y: visible; position: relative; padding-block: 12px; }
.marquee-row:has(.book-card:hover) { z-index: 30; }
.marquee-track { display: inline-flex; gap: 6px; will-change: transform; }
@keyframes marquee-left { from { transform: translateX(0%); } to { transform: translateX(-50%); } }
.marquee-mask { -webkit-mask-image: linear-gradient(to right, transparent 0, rgba(0,0,0,0.25) 40px, rgba(0,0,0,0.7) 100px, black 160px, black calc(100% - 160px), rgba(0,0,0,0.7) calc(100% - 100px), rgba(0,0,0,0.25) calc(100% - 40px), transparent 100%); mask-image: linear-gradient(to right, transparent 0, rgba(0,0,0,0.25) 40px, rgba(0,0,0,0.7) 100px, black 160px, black calc(100% - 160px), rgba(0,0,0,0.7) calc(100% - 100px), rgba(0,0,0,0.25) calc(100% - 40px), transparent 100%); }


==================================================
FILE_PATH: web/src/layouts/LandingLayout.tsx
==================================================

import { Outlet, Link } from 'react-router-dom'
import { useTranslation } from 'react-i18next'

import { useTolgeeLanguages } from '../hooks/useTolgeeLanguages'
import { useState } from 'react'
import { Dialog, DialogContent, DialogTitle } from '../components/ui/dialog'
import Login from '../pages/auth/Login'

/**
 * 着陆页布局（公共区域）
 *
 * 说明：
 * - 顶部具备语言切换与登录弹窗入口
 * - 语言来源优先 Tolgee，其次回退到预设列表
 * - 子页面通过 `Outlet` 渲染
 */
export default function LandingLayout() {
  const { t, i18n } = useTranslation('landing')
  const [showAuthDialog, setShowAuthDialog] = useState(false)
  const langs = useTolgeeLanguages()

  // 语言名称映射
  const languageNames: Record<string, string> = {
    'en-US': 'English',
    'zh-CN': '简体中文',
    'zh-TW': '繁體中文',
    'ja': '日本語',
    'ko': '한국어',
    'fr': 'Français',
    'de': 'Deutsch',
    'es': 'Español'
  }

  // 为语言列表添加显示名称
  const displayLangs = (langs.length ? langs : [
    { code: 'en-US', name: 'English' },
    { code: 'zh-CN', name: '简体中文' }
  ]).map(l => ({
    ...l,
    name: l.name || languageNames[l.code] || l.code
  }))

  return (
    <div className="bg-system-background min-h-screen font-ui">
      <header className="sticky top-0 z-50 border-b border-separator" style={{
        backdropFilter: 'blur(20px) saturate(180%)',
        backgroundColor: 'rgba(255, 255, 255, 0.72)',
        WebkitBackdropFilter: 'blur(20px) saturate(180%)'
      }}>
        <div className="mx-auto max-w-[1200px] px-4 py-3 flex items-center gap-3">
          <Link to="/" className="flex items-center gap-2">
            <img src="/logosvg.png" alt="Athena" className="w-8 h-8 rounded-md object-contain" />
            <div className="font-semibold text-gray-900 text-base">Athena</div>
          </Link>
          <div className="ml-auto flex items-center gap-3">
            <select
              className="px-3 py-1.5 rounded-lg bg-white text-gray-900 border border-gray-300 text-sm shadow-sm hover:border-gray-400 transition-colors"
              value={i18n.language}
              onChange={async (e) => {
                const newLang = e.target.value
                console.log('🌍 Switching to language:', newLang)
                await i18n.changeLanguage(newLang)
                console.log('✅ Language switched to:', newLang)
              }}
            >
              {displayLangs.map((l) => (
                <option key={l.code} value={l.code}>{l.name}</option>
              ))}
            </select>
            <button
              onClick={() => setShowAuthDialog(true)}
              className="px-4 py-1.5 rounded-lg bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium shadow-sm transition-all"
            >
              {t('hero.cta_login')}
            </button>
          </div>
        </div>
      </header>
      <main className="bg-system-background">
        <Outlet />
      </main>

      <Dialog open={showAuthDialog} onOpenChange={setShowAuthDialog}>
        <DialogContent className="sm:max-w-md">
          <DialogTitle className="text-xl font-semibold mb-4">{t('hero.cta_login')}</DialogTitle>
          <Login />
        </DialogContent>
      </Dialog>
    </div>
  )
}


==================================================
FILE_PATH: web/src/layouts/AppLayout.tsx
==================================================

import { Outlet, NavLink, useLocation } from 'react-router-dom'
import { Home, Library, Bot, Search } from 'lucide-react'
import { useState, useEffect, useRef } from 'react'
import { OfflineIndicator } from '@/components/OfflineIndicator'
import { UpdatePrompt } from '@/components/UpdatePrompt'
import { useOnlineStatus } from '@/hooks/useOnlineStatus'
import { getSyncQueueCount } from '@/lib/syncStorage'
import { toast } from '@/components/ui/sonner'
import { useTranslation } from 'react-i18next'
import { cn } from '@/lib/utils'
import { motion } from 'framer-motion'

/**
 * 应用区布局（登录后）
 *
 * 说明：
 * - 底部固定导航栏（移动端 Tab Bar 样式）
 * - 顶部 header 已移除，个人信息入口由各页面自行处理
 * - 使用 `Outlet` 承载子路由页面
 * - `NavItem` 支持选中状态的椭圆背景与加粗图标
 * - 集成离线状态指示器
 */
export default function AppLayout() {
  const { t } = useTranslation('common')
  const loc = useLocation()
  const active = (p: string) => loc.pathname.startsWith(p)
  
  // 待同步项数量
  const [pendingCount, setPendingCount] = useState(0)
  
  // 网络状态监听，在线/离线切换时显示 toast
  const { isOnline } = useOnlineStatus({
    onOnline: () => {
      toast.success(t('offline.reconnected_syncing', '网络已恢复，正在同步...'))
    },
    onOffline: () => {
      toast.warning(t('offline.disconnected', '网络已断开，进入离线模式'))
    },
  })
  
  // 定期更新待同步项数量
  useEffect(() => {
    const updatePendingCount = async () => {
      try {
        const count = await getSyncQueueCount()
        setPendingCount(count)
      } catch (e) {
        console.error('[AppLayout] Failed to get sync queue count:', e)
      }
    }
    
    // 立即更新一次
    updatePendingCount()
    
    // 每 5 秒更新一次
    const interval = setInterval(updatePendingCount, 5000)
    
    return () => clearInterval(interval)
  }, [])

  // 判断是否在阅读页面
  const isReaderPage = loc.pathname.startsWith('/app/read/')
  const [isNavVisible, setIsNavVisible] = useState(!isReaderPage)
  const hideTimerRef = useRef<number | null>(null)

  // 阅读页面交互显示逻辑
  useEffect(() => {
    if (!isReaderPage) {
      setIsNavVisible(true)
      if (hideTimerRef.current) clearTimeout(hideTimerRef.current)
      return
    }

    // 进入阅读页，默认隐藏
    setIsNavVisible(false)

    const showNav = () => {
      setIsNavVisible(true)
      if (hideTimerRef.current) clearTimeout(hideTimerRef.current)
      hideTimerRef.current = setTimeout(() => {
        setIsNavVisible(false)
      }, 3000) as unknown as number // 3秒无操作后隐藏
    }

    // 监听全局交互
    window.addEventListener('mousemove', showNav)
    window.addEventListener('touchstart', showNav)
    window.addEventListener('click', showNav)
    window.addEventListener('scroll', showNav)

    return () => {
      window.removeEventListener('mousemove', showNav)
      window.removeEventListener('touchstart', showNav)
      window.removeEventListener('click', showNav)
      window.removeEventListener('scroll', showNav)
      if (hideTimerRef.current) clearTimeout(hideTimerRef.current)
    }
  }, [isReaderPage])
  
  // 导航项组件
  const NavItem = ({ to, icon: Icon, isActive }: { to: string, icon: typeof Home, isActive: boolean }) => (
    <NavLink to={to} className="flex items-center justify-center p-2">
      <div className={cn(
        "relative flex items-center justify-center transition-all duration-500 ease-[cubic-bezier(0.22,1,0.36,1)]",
        // 基础样式：圆形/椭圆，阴影，背景
        // 移除边框 (border border-gray-100 dark:border-gray-700)
        "bg-white dark:bg-gray-800 shadow-md hover:shadow-xl",
        // 形状：移动端圆形，桌面端椭圆
        "w-12 h-12 rounded-full md:w-24 md:h-12",
        // 选中状态：移除蓝色光环，增加轻微缩放
        isActive ? "scale-105 shadow-lg" : "scale-100"
      )}>
        <Icon 
          className="w-6 h-6 transition-all duration-500 ease-[cubic-bezier(0.22,1,0.36,1)]" 
          // 选中：黑色(Label色)，未选中：灰色
          color={isActive ? 'var(--label)' : 'var(--secondary-label)'} 
          // 选中：加粗线条 (3)
          strokeWidth={isActive ? 3 : 1.5}
        />
      </div>
    </NavLink>
  )
  
  return (
    <div className="bg-system-background min-h-screen font-ui overflow-x-hidden w-full max-w-full">
      {/* 离线状态指示器 */}
      <OfflineIndicator pendingCount={pendingCount} />
      
      {/* PWA 更新提示 */}
      <UpdatePrompt />
      
      {/* 阅读页面不需要 pb-24，因为导航栏是沉浸式隐藏的 */}
      <main className={cn(
        'bg-system-background w-full max-w-full overflow-x-hidden',
        !isOnline && 'pt-10',
        !isReaderPage && 'pb-24'
      )}>
        <Outlet />
      </main>

      <motion.nav 
        initial={false}
        animate={{ y: isNavVisible ? 0 : '100%' }}
        transition={{ type: 'spring', stiffness: 300, damping: 30 }}
        className="fixed bottom-0 left-0 right-0 z-50 pointer-events-none"
        style={{ paddingBottom: 'env(safe-area-inset-bottom)' }}
      >
        {/* 
           容器：
           - 移除背景色和模糊，改为透明
           - 内部元素 pointer-events-auto 恢复点击
        */}
        <div className="max-w-4xl mx-auto px-6 h-24 flex items-center justify-between pointer-events-auto">
          <NavItem to="/app/home" icon={Home} isActive={active('/app/home')} />
          <NavItem to="/app/library" icon={Library} isActive={active('/app/library')} />
          <NavItem to="/app/ai-conversations" icon={Bot} isActive={active('/app/ai') || active('/app/ai-conversations')} />
          <NavItem to="/app/search" icon={Search} isActive={active('/app/search')} />
        </div>
      </motion.nav>
    </div>
  )
}


==================================================
FILE_PATH: web/src/layouts/AuthLayout.tsx
==================================================

import { Outlet } from 'react-router-dom'

/**
 * 认证页通用卡片布局
 * - 居中卡片容器，承载登录/注册等子路由
 */
export default function AuthLayout() {
  return (
    <div className="bg-system-background min-h-screen flex items-center justify-center p-4 font-ui">
      <div className="w-full max-w-sm bg-secondary-background rounded-2xl p-6 border border-separator">
        <Outlet />
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/types/stubs.d.ts
==================================================

// Radix UI module stubs
declare module '@radix-ui/react-alert-dialog';
declare module '@radix-ui/react-dialog' {
  import * as React from 'react';
  export const Root: React.FC<any>;
  export const Trigger: React.FC<any>;
  export const Portal: React.FC<any>;
  export const Overlay: React.FC<any>;
  export const Content: React.FC<any>;
  export const Title: React.FC<React.PropsWithChildren<any>>;
  export const Description: React.FC<React.PropsWithChildren<any>>;
  export const Close: React.FC<any>;
}
declare module '@radix-ui/react-label' {
  import * as React from 'react';
  export const Root: React.FC<React.PropsWithChildren<any>>;
}
declare module '@radix-ui/react-scroll-area' {
  import * as React from 'react';
  export const Root: React.FC<React.PropsWithChildren<any>>;
  export const Viewport: React.FC<React.PropsWithChildren<any>>;
  export const Scrollbar: React.FC<any>;
  export const ScrollAreaScrollbar: React.FC<any>;
  export const ScrollAreaThumb: React.FC<any>;
  export const Corner: React.FC<any>;
}
declare module '@radix-ui/react-dropdown-menu';
declare module '@radix-ui/react-select';
declare module '@radix-ui/react-tabs';
declare module '@radix-ui/react-toggle';
declare module '@radix-ui/react-toggle-group';
declare module '@radix-ui/react-tooltip';
declare module '@radix-ui/react-switch';
declare module '@radix-ui/react-slider';
declare module '@radix-ui/react-separator';
declare module '@radix-ui/react-progress';
declare module '@radix-ui/react-navigation-menu';
declare module '@radix-ui/react-menubar';

// date-fns stub
declare module 'date-fns' {
  export function formatDistanceToNow(date: Date | number, options?: any): string;
}
declare module 'date-fns/locale' {
  export const zhCN: any;
}

// Framer Motion types fix
declare module 'framer-motion' {
  import * as React from 'react';
  export interface MotionProps {
    initial?: any;
    animate?: any;
    exit?: any;
    transition?: any;
    whileInView?: any;
    whileHover?: any;
    viewport?: any;
    style?: React.CSSProperties;
    className?: string;
    children?: React.ReactNode;
    [key: string]: any;
  }
  export const motion: {
    div: React.FC<MotionProps & React.HTMLAttributes<HTMLDivElement>>;
    nav: React.FC<MotionProps & React.HTMLAttributes<HTMLElement>>;
    [key: string]: React.FC<any>;
  };
  export const AnimatePresence: React.FC<any>;
  export function useScroll(options?: any): any;
  export function useTransform(...args: any[]): any;
}

==================================================
FILE_PATH: web/src/components/BookCardMenu.tsx
==================================================

import { useState, useRef, useEffect, useCallback } from 'react'
import { createPortal } from 'react-dom'
import { useTranslation } from 'react-i18next'
import { MoreHorizontal, Trash2, CheckCircle, BookOpen, Loader2, FileText, Scan, FolderPlus } from 'lucide-react'
import { cn, generateUUID, getDeviceId } from '@/lib/utils'
import { usePowerSync } from '@powersync/react'
import { useAuthStore } from '@/stores/auth'
import { bookStorage } from '@/lib/bookStorage'
import BookMetadataDialog from './BookMetadataDialog'
import OcrTriggerDialog from './OcrTriggerDialog'
import AddToShelfDialog from './AddToShelfDialog'

type Props = {
  bookId: string
  bookTitle: string
  bookAuthor?: string
  isFinished?: boolean
  /** OCR 状态: 'pending' | 'processing' | 'completed' | 'failed' | null */
  ocrStatus?: string | null
  /** 是否为图片型 PDF（需要 OCR） */
  isImageBased?: boolean
  onDeleted?: () => void
  onFinishedChange?: (finished: boolean) => void
  /** 元数据更新后的回调 */
  onMetadataChange?: (metadata: { title?: string; author?: string }) => void
  /** OCR 触发成功后的回调 */
  onOcrTrigger?: () => void
  /** 按钮颜色类名 (用于智能反色) */
  buttonClassName?: string
  /** 菜单位置 */
  position?: 'left' | 'right'
}

export default function BookCardMenu({
  bookId,
  bookTitle,
  bookAuthor,
  isFinished = false,
  ocrStatus,
  isImageBased = false,
  onDeleted,
  onFinishedChange,
  onMetadataChange,
  onOcrTrigger,
  buttonClassName = 'text-white',
  position = 'right',
}: Props) {
  const { t } = useTranslation('common')
  const db = usePowerSync()
  const [open, setOpen] = useState(false)
  const [showConfirm, setShowConfirm] = useState(false)
  const [showMetadataDialog, setShowMetadataDialog] = useState(false)
  const [showOcrDialog, setShowOcrDialog] = useState(false)
  const [showShelfDialog, setShowShelfDialog] = useState(false)
  const [loading, setLoading] = useState(false)
  const [menuPosition, setMenuPosition] = useState({ top: 0, left: 0, openUpward: false })
  const menuRef = useRef<HTMLDivElement>(null)
  const buttonRef = useRef<HTMLButtonElement>(null)

  // 计算菜单位置
  const updateMenuPosition = useCallback(() => {
    if (buttonRef.current) {
      const rect = buttonRef.current.getBoundingClientRect()
      const menuWidth = 180
      const menuHeight = 280 // 预估菜单高度
      
      // 根据 position 属性决定左右对齐
      let left = position === 'right' 
        ? rect.right - menuWidth 
        : rect.left
      
      // 确保菜单不超出视口左右边界
      if (left < 8) left = 8
      if (left + menuWidth > window.innerWidth - 8) {
        left = window.innerWidth - menuWidth - 8
      }
      
      // 检查是否需要向上打开（底部空间不足）
      const spaceBelow = window.innerHeight - rect.bottom
      const spaceAbove = rect.top
      const openUpward = spaceBelow < menuHeight && spaceAbove > spaceBelow
      
      setMenuPosition({
        top: openUpward ? rect.top : rect.bottom + 4,
        left,
        openUpward
      })
    }
  }, [position])

  // 点击外部关闭菜单
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (
        menuRef.current &&
        !menuRef.current.contains(e.target as Node) &&
        buttonRef.current &&
        !buttonRef.current.contains(e.target as Node)
      ) {
        setOpen(false)
      }
    }
    
    const handleScroll = () => {
      if (open) {
        updateMenuPosition()
      }
    }
    
    if (open) {
      document.addEventListener('mousedown', handleClickOutside)
      window.addEventListener('scroll', handleScroll, true)
      window.addEventListener('resize', updateMenuPosition)
      return () => {
        document.removeEventListener('mousedown', handleClickOutside)
        window.removeEventListener('scroll', handleScroll, true)
        window.removeEventListener('resize', updateMenuPosition)
      }
    }
  }, [open, updateMenuPosition])

  const handleToggleFinished = async () => {
    setLoading(true)
    
    const newFinishedState = !isFinished
    const now = new Date().toISOString()
    const userId = useAuthStore.getState().user?.id || ''
    const deviceId = getDeviceId()
    
    try {
      // 使用 reading_progress 表更新进度
      // progress = 1.0 表示已读完, finished_at 记录完成时间
      const newProgress = newFinishedState ? 1.0 : 0.0
      const finishedAt = newFinishedState ? now : null
      
      // 检查是否已有进度记录 - 使用 book_id + user_id 匹配
      const existing = await db.getAll<{ id: string }>(
        'SELECT id FROM reading_progress WHERE book_id = ? AND user_id = ?',
        [bookId, userId]
      )
      
      if (existing.length > 0) {
        // 更新现有记录 - 使用 book_id + user_id 匹配
        await db.execute(
          'UPDATE reading_progress SET progress = ?, finished_at = ?, updated_at = ? WHERE book_id = ? AND user_id = ?',
          [newProgress, finishedAt, now, bookId, userId]
        )
      } else {
        // 插入新记录
        await db.execute(
          `INSERT INTO reading_progress (id, book_id, user_id, device_id, progress, finished_at, updated_at) 
           VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [generateUUID(), bookId, userId, deviceId, newProgress, finishedAt, now]
        )
      }
      
      // 同时更新 books 表的 updated_at
      await db.execute(
        'UPDATE books SET updated_at = ? WHERE id = ?',
        [now, bookId]
      )
      
      console.log('[BookCardMenu] Updated finished status:', bookId, newFinishedState)
      
      onFinishedChange?.(newFinishedState)
      setOpen(false)
    } catch (e) {
      console.error('Failed to toggle finished status:', e)
    } finally {
      setLoading(false)
    }
  }

  const handleDelete = async () => {
    setLoading(true)
    try {
      console.log('[BookCardMenu] Soft deleting book:', bookId)
      console.log('[BookCardMenu] Database instance:', db)
      
      if (!db) {
        console.error('[BookCardMenu] Database not available!')
        return
      }
      
      // 软删除：设置 deleted_at 时间戳，保留30天
      const now = new Date().toISOString()
      console.log('[BookCardMenu] Executing UPDATE with:', { now, bookId })
      
      await db.execute(
        'UPDATE books SET deleted_at = ?, updated_at = ? WHERE id = ?',
        [now, now, bookId]
      )
      
      console.log('[BookCardMenu] Execute completed, checking CRUD queue...')
      
      // 检查 CRUD 队列
      try {
        const crudCount = await db.getAll('SELECT count(*) as count FROM ps_crud')
        console.log('[BookCardMenu] CRUD queue count:', crudCount)
      } catch (e) {
        console.log('[BookCardMenu] Could not check CRUD queue:', e)
      }
      
      // 注意：不删除本地文件，保留用于恢复
      // await bookStorage.deleteBook(bookId) // 移除硬删除
      
      console.log('[BookCardMenu] Book soft deleted successfully')
      setShowConfirm(false)
      setOpen(false)
      
      onDeleted?.()
    } catch (e) {
      console.error('[BookCardMenu] Failed to soft delete book:', e)
    } finally {
      setLoading(false)
    }
  }

  return (
    <>
      {/* 触发按钮 */}
      <button
        ref={buttonRef}
        onClick={(e) => {
          e.preventDefault()
          e.stopPropagation()
          updateMenuPosition()
          setOpen(!open)
        }}
        className={cn(
          'p-2 rounded-full transition-colors',
          'hover:bg-black/10 dark:hover:bg-white/20',
          buttonClassName
        )}
        aria-label={t('common.more_actions')}
      >
        <MoreHorizontal className="w-5 h-5" />
      </button>

      {/* 下拉菜单 - 使用 Portal 渲染到 body 层，避免被父容器裁剪 */}
      {open && createPortal(
        <div
          ref={menuRef}
          className={cn(
            'fixed min-w-[180px]',
            'bg-white/95 dark:bg-gray-900/95 backdrop-blur-xl',
            'shadow-2xl border border-gray-200/50 dark:border-white/10',
            'rounded-xl overflow-hidden',
            'animate-in fade-in-0 zoom-in-95 duration-fast',
            'z-[9999]'
          )}
          style={{ 
            top: menuPosition.openUpward ? 'auto' : menuPosition.top,
            bottom: menuPosition.openUpward ? `${window.innerHeight - menuPosition.top + 4}px` : 'auto',
            left: menuPosition.left,
            transformOrigin: menuPosition.openUpward 
              ? (position === 'right' ? 'bottom right' : 'bottom left')
              : (position === 'right' ? 'top right' : 'top left')
          }}
        >
          {/* 编辑书籍信息 */}
          <button
            onClick={(e) => {
              e.preventDefault()
              e.stopPropagation()
              setShowMetadataDialog(true)
              setOpen(false)
            }}
            className={cn(
              'w-full flex items-center gap-3 px-4 py-3',
              'text-left text-sm font-medium',
              'text-label hover:bg-secondary-background',
              'transition-colors duration-fast'
            )}
          >
            <FileText className="w-4 h-4 text-system-blue" />
            <span>{t('book_menu.edit_info')}</span>
          </button>

          {/* OCR 本书 - 仅对图片型 PDF 且未完成 OCR 显示 */}
          {isImageBased && (ocrStatus === null || ocrStatus === 'failed') && (
            <button
              onClick={(e) => {
                e.preventDefault()
                e.stopPropagation()
                setShowOcrDialog(true)
                setOpen(false)
              }}
              className={cn(
                'w-full flex items-center gap-3 px-4 py-3',
                'text-left text-sm font-medium',
                'text-label hover:bg-secondary-background',
                'transition-colors duration-fast'
              )}
            >
              <Scan className="w-4 h-4 text-system-orange" />
              <span>{t('book_menu.ocr_book')}</span>
            </button>
          )}
          
          {/* OCR 进行中 - 显示进度状态 */}
          {isImageBased && (ocrStatus === 'processing' || ocrStatus === 'pending') && (
            <div
              className={cn(
                'w-full flex items-center gap-3 px-4 py-3',
                'text-left text-sm font-medium',
                'text-secondary-label'
              )}
            >
              <Loader2 className="w-4 h-4 animate-spin text-system-orange" />
              <span>{t('book_menu.ocr_processing')}</span>
            </div>
          )}

          {/* 加入书架 */}
          <button
            onClick={(e) => {
              e.preventDefault()
              e.stopPropagation()
              setShowShelfDialog(true)
              setOpen(false)
            }}
            className={cn(
              'w-full flex items-center gap-3 px-4 py-3',
              'text-left text-sm font-medium',
              'text-label hover:bg-secondary-background',
              'transition-colors duration-fast'
            )}
          >
            <FolderPlus className="w-4 h-4 text-system-purple" />
            <span>{t('shelf.add_to_shelf')}</span>
          </button>

          {/* 分隔线 */}
          <div className="h-px bg-separator mx-2" />
          
          {/* 标记为已读完 / 继续阅读 */}
          <button
            onClick={(e) => {
              e.preventDefault()
              e.stopPropagation()
              handleToggleFinished()
            }}
            disabled={loading}
            className={cn(
              'w-full flex items-center gap-3 px-4 py-3',
              'text-left text-sm font-medium',
              'text-label hover:bg-secondary-background',
              'transition-colors duration-fast',
              'disabled:opacity-50'
            )}
          >
            {loading ? (
              <Loader2 className="w-4 h-4 animate-spin text-secondary-label" />
            ) : isFinished ? (
              <BookOpen className="w-4 h-4 text-system-blue" />
            ) : (
              <CheckCircle className="w-4 h-4 text-system-green" />
            )}
            <span>
              {isFinished ? t('book_menu.mark_continue') : t('book_menu.mark_finished')}
            </span>
          </button>

          {/* 分隔线 */}
          <div className="h-px bg-separator mx-2" />

          {/* 移除本书 */}
          <button
            onClick={(e) => {
              e.preventDefault()
              e.stopPropagation()
              setShowConfirm(true)
              setOpen(false)
            }}
            className={cn(
              'w-full flex items-center gap-3 px-4 py-3',
              'text-left text-sm font-medium',
              'text-system-red hover:bg-system-red/10',
              'transition-colors duration-fast'
            )}
          >
            <Trash2 className="w-4 h-4" />
            <span>{t('book_menu.remove_book')}</span>
          </button>
        </div>,
        document.body
      )}

      {/* 删除确认对话框 */}
      {showConfirm && createPortal(
        <div
          className="fixed inset-0 z-[100] flex items-center justify-center p-4"
          onClick={(e) => {
            e.preventDefault()
            e.stopPropagation()
          }}
        >
          {/* 遮罩层 */}
          <div
            className="absolute inset-0 bg-black/20 backdrop-blur-sm"
            onClick={() => setShowConfirm(false)}
          />

          {/* 对话框内容 */}
          <div
            className={cn(
              'relative w-full max-w-sm',
              'bg-white/95 dark:bg-gray-900/95 backdrop-blur-xl',
              'shadow-2xl border border-gray-200/50 dark:border-white/10',
              'rounded-2xl p-6',
              'animate-in fade-in-0 zoom-in-95 duration-fast'
            )}
          >
            <div className="flex flex-col items-center text-center">
              {/* 警告图标 */}
              <div className="w-12 h-12 rounded-full bg-system-red/10 flex items-center justify-center mb-4">
                <Trash2 className="w-6 h-6 text-system-red" />
              </div>

              {/* 标题 */}
              <h3 className="text-lg font-bold text-label mb-2">
                {t('book_menu.confirm_remove_title', '确认删除')}
              </h3>

              {/* 书名 */}
              <p className="text-base font-medium text-label mb-2 line-clamp-2">
                "{bookTitle}"
              </p>

              {/* 30天恢复提示 */}
              <div className="bg-blue-50 dark:bg-blue-900/20 rounded-lg p-3 mb-6 w-full">
                <p className="text-sm text-blue-700 dark:text-blue-300">
                  {t('book_menu.soft_delete_notice', '书籍将移至「最近删除」，30天后自动永久删除。在此期间可随时恢复。')}
                </p>
              </div>

              {/* 按钮组 */}
              <div className="flex gap-3 w-full">
                <button
                  onClick={() => setShowConfirm(false)}
                  disabled={loading}
                  className={cn(
                    'flex-1 py-3 px-4 rounded-full',
                    'bg-secondary-background text-label',
                    'border border-separator',
                    'font-medium text-sm',
                    'hover:bg-tertiary-background transition-colors',
                    'disabled:opacity-50'
                  )}
                >
                  {t('common.cancel', '取消')}
                </button>
                <button
                  onClick={handleDelete}
                  disabled={loading}
                  className={cn(
                    'flex-1 py-3 px-4 rounded-full',
                    'bg-system-red text-white',
                    'font-medium text-sm',
                    'hover:opacity-90 transition-opacity',
                    'disabled:opacity-50',
                    'flex items-center justify-center gap-2'
                  )}
                >
                  {loading && <Loader2 className="w-4 h-4 animate-spin" />}
                  {t('book_menu.remove_confirm', '确认删除')}
                </button>
              </div>
            </div>
          </div>
        </div>,
        document.body
      )}

      {/* 元数据编辑对话框 */}
      <BookMetadataDialog
        bookId={bookId}
        initialTitle={bookTitle}
        initialAuthor={bookAuthor}
        open={showMetadataDialog}
        onClose={() => setShowMetadataDialog(false)}
        onSuccess={(metadata) => {
          onMetadataChange?.(metadata)
        }}
      />

      {/* OCR 触发对话框 */}
      <OcrTriggerDialog
        bookId={bookId}
        bookTitle={bookTitle}
        open={showOcrDialog}
        onClose={() => setShowOcrDialog(false)}
        onSuccess={() => {
          onOcrTrigger?.()
        }}
      />

      {/* 加入书架对话框 */}
      <AddToShelfDialog
        bookId={bookId}
        bookTitle={bookTitle}
        open={showShelfDialog}
        onClose={() => setShowShelfDialog(false)}
      />
    </>
  )
}


==================================================
FILE_PATH: web/src/components/MetadataConfirmDialog.tsx
==================================================

/**
 * MetadataConfirmDialog - 书籍元数据确认对话框
 * 
 * 设计背景 (来自 PRD):
 * - 书籍的 title 和 author 会作为 AI 对话的上下文发送给上游模型
 * - 准确的元数据能显著提升 AI 回答的精准度
 * - 用户上传的可能不是书籍（私人资料），需要灵活处理
 */

import { useState, useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import { BookOpen, AlertCircle, Check } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import api from '@/lib/api'

export interface BookMetadata {
  bookId: string
  title: string
  author: string
  extractedTitle?: string
  extractedAuthor?: string
  pageCount?: number
}

interface MetadataConfirmDialogProps {
  /** 是否显示对话框 */
  open: boolean
  /** 关闭对话框回调 */
  onOpenChange: (open: boolean) => void
  /** 书籍元数据 */
  metadata: BookMetadata | null
  /** 确认完成回调 */
  onConfirmed?: (metadata: BookMetadata) => void
  /** 跳过确认回调 */
  onSkipped?: () => void
}

export function MetadataConfirmDialog({
  open,
  onOpenChange,
  metadata,
  onConfirmed,
  onSkipped,
}: MetadataConfirmDialogProps) {
  const { t } = useTranslation('common')
  
  const [title, setTitle] = useState('')
  const [author, setAuthor] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // 初始化表单值
  useEffect(() => {
    if (metadata) {
      setTitle(metadata.extractedTitle || metadata.title || '')
      setAuthor(metadata.extractedAuthor || metadata.author || '')
      setError(null)
    }
  }, [metadata])

  const hasExtractedData = metadata?.extractedTitle || metadata?.extractedAuthor

  const handleConfirm = async () => {
    if (!metadata?.bookId) return

    setIsSubmitting(true)
    setError(null)

    try {
      await api.patch(`/books/${metadata.bookId}/metadata`, {
        title: title.trim() || undefined,
        author: author.trim() || undefined,
        metadata_confirmed: true,
      })

      onConfirmed?.({
        ...metadata,
        title: title.trim(),
        author: author.trim(),
      })
      onOpenChange(false)
    } catch (err) {
      console.error('[MetadataConfirmDialog] Failed to update metadata:', err)
      setError(t('metadata.error.update_failed'))
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleSkip = async () => {
    if (!metadata?.bookId) return

    setIsSubmitting(true)
    setError(null)

    try {
      // 标记为已确认但不更改内容
      await api.patch(`/books/${metadata.bookId}/metadata`, {
        metadata_confirmed: true,
      })
      onSkipped?.()
      onOpenChange(false)
    } catch (err) {
      console.error('[MetadataConfirmDialog] Failed to skip confirmation:', err)
      setError(t('metadata.error.skip_failed'))
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <BookOpen className="h-5 w-5 text-primary" />
            {t('metadata.dialog.title')}
          </DialogTitle>
          <DialogDescription>
            {t('metadata.dialog.description')}
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* 提取状态提示 */}
          {hasExtractedData ? (
            <div className="flex items-start gap-2 p-3 bg-green-50 dark:bg-green-950/30 rounded-lg text-sm">
              <Check className="h-4 w-4 text-green-600 dark:text-green-400 mt-0.5 flex-shrink-0" />
              <span className="text-green-700 dark:text-green-300">
                {t('metadata.dialog.extracted_success')}
              </span>
            </div>
          ) : (
            <div className="flex items-start gap-2 p-3 bg-amber-50 dark:bg-amber-950/30 rounded-lg text-sm">
              <AlertCircle className="h-4 w-4 text-amber-600 dark:text-amber-400 mt-0.5 flex-shrink-0" />
              <span className="text-amber-700 dark:text-amber-300">
                {t('metadata.dialog.extracted_empty')}
              </span>
            </div>
          )}

          {/* 书名输入 */}
          <div className="space-y-2">
            <Label htmlFor="book-title">{t('metadata.field.title')}</Label>
            <Input
              id="book-title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={t('metadata.placeholder.title')}
              disabled={isSubmitting}
            />
          </div>

          {/* 作者输入 */}
          <div className="space-y-2">
            <Label htmlFor="book-author">{t('metadata.field.author')}</Label>
            <Input
              id="book-author"
              value={author}
              onChange={(e) => setAuthor(e.target.value)}
              placeholder={t('metadata.placeholder.author')}
              disabled={isSubmitting}
            />
          </div>

          {/* AI 提示 */}
          <p className="text-xs text-muted-foreground">
            {t('metadata.dialog.ai_hint')}
          </p>

          {/* 错误提示 */}
          {error && (
            <div className="flex items-center gap-2 p-3 bg-red-50 dark:bg-red-950/30 rounded-lg text-sm">
              <AlertCircle className="h-4 w-4 text-red-600 dark:text-red-400" />
              <span className="text-red-700 dark:text-red-300">{error}</span>
            </div>
          )}
        </div>

        <DialogFooter className="flex-col sm:flex-row gap-2">
          <Button
            variant="ghost"
            onClick={handleSkip}
            disabled={isSubmitting}
          >
            {t('metadata.action.skip')}
          </Button>
          <Button
            onClick={handleConfirm}
            disabled={isSubmitting}
          >
            {isSubmitting ? t('common.saving') : t('metadata.action.confirm')}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}


==================================================
FILE_PATH: web/src/components/UploadPostProcessDialog.tsx
==================================================

/**
 * UploadPostProcessDialog.tsx
 * 
 * 上传完成后的处理对话框
 * 负责显示元数据确认提示和 OCR 触发提示
 */

import { useState, useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import { BookOpen, FileText, AlertCircle, Check, Loader2 } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import api from '@/lib/api'

interface UploadPostProcessDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  bookId: string
  bookTitle: string
  /** 元数据相关 */
  needsMetadataConfirm: boolean
  extractedTitle?: string
  extractedAuthor?: string
  /** OCR 相关 */
  isImageBasedPdf: boolean
  pageCount?: number
  /** 回调 */
  onComplete?: () => void
}

export function UploadPostProcessDialog({
  open,
  onOpenChange,
  bookId,
  bookTitle,
  needsMetadataConfirm,
  extractedTitle,
  extractedAuthor,
  isImageBasedPdf,
  pageCount,
  onComplete,
}: UploadPostProcessDialogProps) {
  const { t } = useTranslation('common')
  
  // 当前步骤：'metadata' | 'ocr' | 'done'
  const [step, setStep] = useState<'metadata' | 'ocr' | 'done'>('metadata')
  const [title, setTitle] = useState('')
  const [author, setAuthor] = useState('')
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // 初始化状态
  useEffect(() => {
    if (open) {
      setTitle(extractedTitle || bookTitle || '')
      setAuthor(extractedAuthor || '')
      setError(null)
      // 决定从哪个步骤开始
      if (needsMetadataConfirm) {
        setStep('metadata')
      } else if (isImageBasedPdf) {
        setStep('ocr')
      } else {
        // 不需要任何处理，直接关闭
        onOpenChange(false)
        onComplete?.()
      }
    }
  }, [open, needsMetadataConfirm, isImageBasedPdf, extractedTitle, extractedAuthor, bookTitle, onOpenChange, onComplete])

  const hasExtractedMetadata = !!(extractedTitle || extractedAuthor)

  // 确认元数据
  const handleConfirmMetadata = async () => {
    setIsSubmitting(true)
    setError(null)

    try {
      await api.patch(`/books/${bookId}/metadata`, {
        title: title.trim() || undefined,
        author: author.trim() || undefined,
        metadata_confirmed: true,
      })

      // 如果是图片型 PDF，进入 OCR 步骤
      if (isImageBasedPdf) {
        setStep('ocr')
      } else {
        setStep('done')
        setTimeout(() => {
          onOpenChange(false)
          onComplete?.()
        }, 500)
      }
    } catch (err) {
      console.error('[UploadPostProcess] Failed to update metadata:', err)
      setError(t('metadata.error.update_failed'))
    } finally {
      setIsSubmitting(false)
    }
  }

  // 跳过元数据确认
  const handleSkipMetadata = async () => {
    setIsSubmitting(true)
    setError(null)

    try {
      await api.patch(`/books/${bookId}/metadata`, {
        metadata_confirmed: true,
      })

      if (isImageBasedPdf) {
        setStep('ocr')
      } else {
        setStep('done')
        setTimeout(() => {
          onOpenChange(false)
          onComplete?.()
        }, 500)
      }
    } catch (err) {
      console.error('[UploadPostProcess] Failed to skip metadata:', err)
      setError(t('metadata.error.skip_failed'))
    } finally {
      setIsSubmitting(false)
    }
  }

  // 触发 OCR
  const handleTriggerOcr = async () => {
    setIsSubmitting(true)
    setError(null)

    try {
      await api.post(`/books/${bookId}/ocr`)
      
      // 【关键】立即广播 OCR 开始事件，通知 LibraryPage 更新书籍状态为 pending
      // 这确保书籍被立即锁定，防止用户在 OCR 期间打开阅读页面
      window.dispatchEvent(new CustomEvent('ocr_started', {
        detail: { bookId }
      }))
      console.log('[UploadPostProcess] OCR started, broadcasted ocr_started event for book:', bookId)
      
      setStep('done')
      setTimeout(() => {
        onOpenChange(false)
        onComplete?.()
      }, 1000)
    } catch (err: any) {
      console.error('[UploadPostProcess] Failed to trigger OCR:', err)
      const msg = err.response?.data?.message || err.response?.data?.detail || t('ocr.error.trigger_failed')
      setError(msg)
    } finally {
      setIsSubmitting(false)
    }
  }

  // 稍后处理 OCR
  const handleSkipOcr = () => {
    setStep('done')
    setTimeout(() => {
      onOpenChange(false)
      onComplete?.()
    }, 500)
  }

  // 渲染元数据确认步骤
  const renderMetadataStep = () => (
    <>
      <DialogHeader>
        <DialogTitle className="flex items-center gap-2">
          <BookOpen className="h-5 w-5 text-primary" />
          {t('metadata.dialog.title')}
        </DialogTitle>
        <DialogDescription>
          {t('metadata.dialog.description')}
        </DialogDescription>
      </DialogHeader>

      <div className="space-y-4 py-4">
        {/* 提取状态提示 */}
        {hasExtractedMetadata ? (
          <div className="flex items-start gap-2 p-3 bg-green-50 dark:bg-green-950/30 rounded-lg text-sm">
            <Check className="h-4 w-4 text-green-600 dark:text-green-400 mt-0.5 flex-shrink-0" />
            <span className="text-green-700 dark:text-green-300">
              {t('metadata.dialog.extracted_success')}
            </span>
          </div>
        ) : (
          <div className="flex items-start gap-2 p-3 bg-amber-50 dark:bg-amber-950/30 rounded-lg text-sm">
            <AlertCircle className="h-4 w-4 text-amber-600 dark:text-amber-400 mt-0.5 flex-shrink-0" />
            <span className="text-amber-700 dark:text-amber-300">
              {t('metadata.dialog.extracted_empty')}
            </span>
          </div>
        )}

        {/* 书名输入 */}
        <div className="space-y-2">
          <Label htmlFor="book-title">{t('metadata.field.title')}</Label>
          <Input
            id="book-title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder={t('metadata.placeholder.title')}
            disabled={isSubmitting}
          />
        </div>

        {/* 作者输入 */}
        <div className="space-y-2">
          <Label htmlFor="book-author">{t('metadata.field.author')}</Label>
          <Input
            id="book-author"
            value={author}
            onChange={(e) => setAuthor(e.target.value)}
            placeholder={t('metadata.placeholder.author')}
            disabled={isSubmitting}
          />
        </div>

        {/* AI 提示 */}
        <p className="text-xs text-muted-foreground">
          {t('metadata.dialog.ai_hint')}
        </p>

        {/* 错误提示 */}
        {error && (
          <div className="flex items-center gap-2 p-3 bg-red-50 dark:bg-red-950/30 rounded-lg text-sm">
            <AlertCircle className="h-4 w-4 text-red-600 dark:text-red-400" />
            <span className="text-red-700 dark:text-red-300">{error}</span>
          </div>
        )}
      </div>

      <DialogFooter className="flex-col sm:flex-row gap-2">
        <Button variant="ghost" onClick={handleSkipMetadata} disabled={isSubmitting}>
          {t('metadata.action.skip')}
        </Button>
        <Button onClick={handleConfirmMetadata} disabled={isSubmitting}>
          {isSubmitting ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : null}
          {t('metadata.action.confirm')}
        </Button>
      </DialogFooter>
    </>
  )

  // 渲染 OCR 提示步骤
  const renderOcrStep = () => (
    <>
      <DialogHeader>
        <DialogTitle className="flex items-center gap-2">
          <FileText className="h-5 w-5 text-primary" />
          {t('ocr.dialog.title', { defaultValue: '文字识别服务' })}
        </DialogTitle>
        <DialogDescription>
          {t('ocr.dialog.description', { defaultValue: '检测到这是一本图片格式的 PDF，需要进行文字识别才能使用高亮、笔记和 AI 对话功能。' })}
        </DialogDescription>
      </DialogHeader>

      <div className="space-y-4 py-4">
        {/* 图片 PDF 提示 */}
        <div className="flex items-start gap-2 p-3 bg-amber-50 dark:bg-amber-950/30 rounded-lg text-sm">
          <AlertCircle className="h-4 w-4 text-amber-600 dark:text-amber-400 mt-0.5 flex-shrink-0" />
          <div className="text-amber-700 dark:text-amber-300">
            <p className="font-medium">{t('ocr.dialog.image_pdf_detected', { defaultValue: '检测到图片型 PDF' })}</p>
            {pageCount && (
              <p className="mt-1">{t('ocr.dialog.page_count', { count: pageCount, defaultValue: `共 ${pageCount} 页` })}</p>
            )}
          </div>
        </div>

        {/* 功能说明 */}
        <div className="text-sm text-muted-foreground space-y-1">
          <p>{t('ocr.dialog.features_hint', { defaultValue: 'OCR 文字识别后，您可以：' })}</p>
          <ul className="list-disc list-inside pl-2 space-y-1">
            <li>{t('ocr.dialog.feature_select', { defaultValue: '选择和复制文字' })}</li>
            <li>{t('ocr.dialog.feature_highlight', { defaultValue: '添加高亮和笔记' })}</li>
            <li>{t('ocr.dialog.feature_search', { defaultValue: '全文搜索' })}</li>
            <li>{t('ocr.dialog.feature_ai', { defaultValue: 'AI 对话问答' })}</li>
          </ul>
        </div>

        {/* 配额提示 */}
        <p className="text-xs text-muted-foreground">
          {t('ocr.dialog.quota_hint', { defaultValue: 'OCR 服务会消耗配额，您也可以稍后在书籍菜单中触发。' })}
        </p>

        {/* 错误提示 */}
        {error && (
          <div className="flex items-center gap-2 p-3 bg-red-50 dark:bg-red-950/30 rounded-lg text-sm">
            <AlertCircle className="h-4 w-4 text-red-600 dark:text-red-400" />
            <span className="text-red-700 dark:text-red-300">{error}</span>
          </div>
        )}
      </div>

      <DialogFooter className="flex-col sm:flex-row gap-2">
        <Button variant="ghost" onClick={handleSkipOcr} disabled={isSubmitting}>
          {t('ocr.action.later', { defaultValue: '稍后处理' })}
        </Button>
        <Button onClick={handleTriggerOcr} disabled={isSubmitting}>
          {isSubmitting ? <Loader2 className="h-4 w-4 animate-spin mr-2" /> : null}
          {t('ocr.action.trigger', { defaultValue: '立即识别' })}
        </Button>
      </DialogFooter>
    </>
  )

  // 渲染完成步骤
  const renderDoneStep = () => (
    <>
      <DialogHeader>
        <DialogTitle className="flex items-center gap-2">
          <Check className="h-5 w-5 text-green-600" />
          {t('upload.post_process.done_title', { defaultValue: '处理完成' })}
        </DialogTitle>
      </DialogHeader>
      <div className="py-4 text-center text-muted-foreground">
        {t('upload.post_process.done_message', { defaultValue: '书籍已准备就绪，可以开始阅读了！' })}
      </div>
    </>
  )

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md">
        {step === 'metadata' && renderMetadataStep()}
        {step === 'ocr' && renderOcrStep()}
        {step === 'done' && renderDoneStep()}
      </DialogContent>
    </Dialog>
  )
}


==================================================
FILE_PATH: web/src/components/BookMetadataDialog.tsx
==================================================

/**
 * BookMetadataDialog.tsx
 * 
 * 书籍元数据编辑对话框
 * 允许用户修改书籍标题、作者等信息
 * 
 * 使用后端 API 修改，PowerSync 自动同步更新到本地
 */

import { useState, useEffect } from 'react'
import { createPortal } from 'react-dom'
import { useTranslation } from 'react-i18next'
import { FileText, Loader2, X, AlertTriangle } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useAuthStore } from '@/stores/auth'

interface BookMetadataDialogProps {
  bookId: string
  initialTitle: string
  initialAuthor?: string
  open: boolean
  onClose: () => void
  onSuccess?: (metadata: { title: string; author?: string }) => void
}

export default function BookMetadataDialog({
  bookId,
  initialTitle,
  initialAuthor,
  open,
  onClose,
  onSuccess,
}: BookMetadataDialogProps) {
  const { t } = useTranslation('common')
  const [title, setTitle] = useState(initialTitle)
  const [author, setAuthor] = useState(initialAuthor || '')
  const [saving, setSaving] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  const accessToken = useAuthStore(s => s.accessToken)

  // 重置表单当对话框打开时
  useEffect(() => {
    if (open) {
      setTitle(initialTitle)
      setAuthor(initialAuthor || '')
      setError(null)
    }
  }, [open, initialTitle, initialAuthor])

  const handleSave = async () => {
    if (!title.trim()) {
      setError(t('metadata.title_required'))
      return
    }

    setSaving(true)
    setError(null)

    const newMetadata = {
      title: title.trim(),
      author: author.trim() || undefined,
    }

    try {
      // 使用后端 API 更新元数据
      const token = accessToken || localStorage.getItem('access_token') || ''
      const response = await fetch(`/api/v1/books/${bookId}/metadata`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          title: newMetadata.title,
          author: newMetadata.author,
          confirmed: true,
        }),
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}))
        throw new Error(errorData.detail || errorData.message || `更新失败: ${response.status}`)
      }

      console.log('[BookMetadataDialog] Updated book metadata via API:', bookId)

      onSuccess?.(newMetadata)
      onClose()
    } catch (e: any) {
      console.error('[BookMetadataDialog] Failed to save metadata:', e)
      setError(e.message)
    } finally {
      setSaving(false)
    }
  }

  if (!open) return null

  return createPortal(
    <div
      className="fixed inset-0 z-[100] flex items-center justify-center p-4"
      onClick={(e) => e.stopPropagation()}
    >
      {/* 遮罩层 */}
      <div
        className="absolute inset-0 bg-black/20 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* 对话框 */}
      <div
        className={cn(
          'relative w-full max-w-md',
          'bg-white/95 dark:bg-gray-900/95 backdrop-blur-xl',
          'shadow-2xl border border-gray-200/50 dark:border-white/10',
          'rounded-2xl overflow-hidden',
          'animate-in fade-in-0 zoom-in-95 duration-fast'
        )}
      >
        {/* 头部 */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-separator">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-xl bg-system-blue/10 flex items-center justify-center">
              <FileText className="w-5 h-5 text-system-blue" />
            </div>
            <div>
              <h3 className="text-base font-bold text-label">{t('metadata.edit_title')}</h3>
              <p className="text-xs text-secondary-label">{t('metadata.edit_subtitle')}</p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="p-2 rounded-full hover:bg-secondary-background transition-colors"
          >
            <X className="w-5 h-5 text-secondary-label" />
          </button>
        </div>

        {/* 内容 */}
        <div className="px-6 py-5 space-y-4">
          {/* 标题输入 */}
          <div className="space-y-2">
            <label className="text-sm font-medium text-label">
              {t('metadata.field_title')} <span className="text-system-red">*</span>
            </label>
            <input
              type="text"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={t('metadata.title_placeholder')}
              className={cn(
                'w-full px-4 py-3 rounded-xl',
                'bg-secondary-background text-label',
                'border border-separator',
                'focus:outline-none focus:ring-2 focus:ring-system-blue/50',
                'placeholder:text-tertiary-label'
              )}
            />
          </div>

          {/* 作者输入 */}
          <div className="space-y-2">
            <label className="text-sm font-medium text-label">
              {t('metadata.field_author')}
            </label>
            <input
              type="text"
              value={author}
              onChange={(e) => setAuthor(e.target.value)}
              placeholder={t('metadata.author_placeholder')}
              className={cn(
                'w-full px-4 py-3 rounded-xl',
                'bg-secondary-background text-label',
                'border border-separator',
                'focus:outline-none focus:ring-2 focus:ring-system-blue/50',
                'placeholder:text-tertiary-label'
              )}
            />
          </div>

          {/* 错误提示 */}
          {error && (
            <div className="flex items-start gap-2 p-3 rounded-xl bg-system-red/10">
              <AlertTriangle className="w-4 h-4 text-system-red flex-shrink-0 mt-0.5" />
              <span className="text-sm text-system-red">{error}</span>
            </div>
          )}
        </div>

        {/* 底部按钮 */}
        <div className="px-6 py-4 border-t border-separator flex gap-3">
          <button
            onClick={onClose}
            disabled={saving}
            className={cn(
              'flex-1 py-3 px-4 rounded-full',
              'bg-secondary-background text-label',
              'border border-separator',
              'font-medium text-sm',
              'hover:bg-tertiary-background transition-colors',
              'disabled:opacity-50'
            )}
          >
            {t('common.cancel')}
          </button>
          <button
            onClick={handleSave}
            disabled={saving || !title.trim()}
            className={cn(
              'flex-1 py-3 px-4 rounded-full',
              'bg-system-blue text-white',
              'font-medium text-sm',
              'hover:opacity-90 transition-opacity',
              'disabled:opacity-50',
              'flex items-center justify-center gap-2'
            )}
          >
            {saving && <Loader2 className="w-4 h-4 animate-spin" />}
            {t('common.save')}
          </button>
        </div>
      </div>
    </div>,
    document.body
  )
}


==================================================
FILE_PATH: web/src/components/UpdatePrompt.tsx
==================================================

/**
 * UpdatePrompt.tsx - PWA 更新提示组件
 * 
 * 功能:
 * - 检测 Service Worker 更新
 * - 显示更新提示 Toast
 * - 一键刷新更新
 * 
 * @see App-First改造计划.md - Phase 4.2
 */

import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useRegisterSW } from 'virtual:pwa-register/react'
import { motion, AnimatePresence } from 'framer-motion'
import { RefreshCw, X } from 'lucide-react'

interface UpdatePromptProps {
  /** 自动检查更新间隔（毫秒），0 表示禁用 */
  checkInterval?: number
}

export function UpdatePrompt({ checkInterval = 60 * 60 * 1000 }: UpdatePromptProps) {
  const { t } = useTranslation()
  const [dismissed, setDismissed] = useState(false)

  const {
    needRefresh: [needRefresh, setNeedRefresh],
    offlineReady: [offlineReady, setOfflineReady],
    updateServiceWorker,
  } = useRegisterSW({
    onRegisteredSW(swUrl, registration) {
      console.log('[PWA] Service Worker registered:', swUrl)

      // 定期检查更新
      if (checkInterval > 0 && registration) {
        setInterval(() => {
          console.log('[PWA] Checking for updates...')
          registration.update()
        }, checkInterval)
      }
    },
    onRegisterError(error) {
      console.error('[PWA] Service Worker registration error:', error)
    },
  })

  // 显示离线就绪通知（可选，3秒后自动消失）
  useEffect(() => {
    if (offlineReady) {
      console.log('[PWA] App is ready for offline use')
      const timer = setTimeout(() => {
        setOfflineReady(false)
      }, 3000)
      return () => clearTimeout(timer)
    }
  }, [offlineReady, setOfflineReady])

  // 处理更新
  const handleUpdate = () => {
    updateServiceWorker(true)
  }

  // 关闭提示
  const handleDismiss = () => {
    setDismissed(true)
    setNeedRefresh(false)
  }

  // 如果用户已关闭提示，不再显示
  if (dismissed && !needRefresh) {
    return null
  }

  return (
    <AnimatePresence>
      {/* 更新提示 */}
      {needRefresh && !dismissed && (
        <motion.div
          initial={{ opacity: 0, y: 50, scale: 0.95 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          exit={{ opacity: 0, y: 50, scale: 0.95 }}
          transition={{ duration: 0.3 }}
          className="fixed bottom-4 right-4 z-50 max-w-sm"
        >
          <div className="rounded-lg bg-indigo-600 p-4 shadow-lg shadow-indigo-500/25">
            <div className="flex items-start gap-3">
              <div className="shrink-0">
                <RefreshCw className="h-6 w-6 text-white" />
              </div>
              <div className="flex-1">
                <p className="text-sm font-medium text-white">
                  {t('pwa.updateAvailable', '发现新版本')}
                </p>
                <p className="mt-1 text-sm text-indigo-100">
                  {t('pwa.updateDescription', '点击更新以获取最新功能和修复')}
                </p>
                <div className="mt-3 flex gap-2">
                  <button
                    onClick={handleUpdate}
                    className="rounded-md bg-white px-3 py-1.5 text-sm font-semibold text-indigo-600 shadow-sm hover:bg-indigo-50"
                  >
                    {t('pwa.updateNow', '立即更新')}
                  </button>
                  <button
                    onClick={handleDismiss}
                    className="rounded-md px-3 py-1.5 text-sm font-semibold text-white hover:bg-indigo-500"
                  >
                    {t('pwa.updateLater', '稍后')}
                  </button>
                </div>
              </div>
              <button
                onClick={handleDismiss}
                className="shrink-0 rounded-md p-1 text-indigo-200 hover:bg-indigo-500 hover:text-white"
              >
                <X className="h-5 w-5" />
              </button>
            </div>
          </div>
        </motion.div>
      )}

      {/* 离线就绪提示（短暂显示） */}
      {offlineReady && (
        <motion.div
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 50 }}
          transition={{ duration: 0.3 }}
          className="fixed bottom-4 right-4 z-50"
        >
          <div className="rounded-lg bg-green-600 px-4 py-3 shadow-lg">
            <p className="text-sm font-medium text-white">
              ✓ {t('pwa.offlineReady', '应用已准备好离线使用')}
            </p>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

export default UpdatePrompt


==================================================
FILE_PATH: web/src/components/OfflineIndicator.tsx
==================================================

/**
 * OfflineIndicator.tsx
 * 
 * 离线状态指示器组件
 * 
 * 功能:
 * - 顶部固定横幅，离线时显示
 * - Apple 风格的橙色警告样式
 * - 显示离线持续时间和待同步项数量
 * - 网络恢复时自动隐藏（带动画）
 * 
 * @see App-First改造计划.md - Phase 1.2
 */

import React from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { WifiOff, RefreshCw, CloudOff } from 'lucide-react'
import { useTranslation } from 'react-i18next'
import { useOnlineStatus, formatOfflineDuration } from '@/hooks/useOnlineStatus'
import { Badge } from '@/components/ui/badge'
import { cn } from '@/components/ui/utils'

export interface OfflineIndicatorProps {
  /** 待同步项数量 */
  pendingCount?: number
  /** 自定义类名 */
  className?: string
  /** 是否显示在固定位置（顶部） */
  fixed?: boolean
}

/**
 * 离线状态指示器组件
 * 
 * @example
 * ```tsx
 * // 基础用法
 * <OfflineIndicator />
 * 
 * // 显示待同步数量
 * <OfflineIndicator pendingCount={5} />
 * 
 * // 非固定位置（嵌入到其他容器）
 * <OfflineIndicator fixed={false} className="rounded-lg" />
 * ```
 */
export function OfflineIndicator({
  pendingCount = 0,
  className,
  fixed = true
}: OfflineIndicatorProps) {
  const { t } = useTranslation('common')
  const { isOnline, offlineDuration } = useOnlineStatus()

  // 在线时不显示
  if (isOnline) return null

  return (
    <AnimatePresence>
      {!isOnline && (
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={{
            duration: 0.3,
            ease: [0.22, 1, 0.36, 1]  // Apple 风格 easing
          }}
          className={cn(
            // 基础样式
            'flex items-center justify-center gap-2 px-4 py-2',
            'bg-linear-to-r from-orange-500 to-amber-500',
            'text-white text-sm font-medium',
            'shadow-lg',
            // 固定位置样式
            fixed && 'fixed top-0 left-0 right-0 z-50',
            // 非固定位置可自定义
            !fixed && 'rounded-lg',
            className
          )}
          role="alert"
          aria-live="polite"
        >
          {/* 离线图标 */}
          <WifiOff className="w-4 h-4 shrink-0" aria-hidden="true" />

          {/* 主文案 */}
          <span className="shrink-0">
            {t('offline.mode', '离线模式')}
          </span>

          {/* 分隔符 */}
          <span className="text-white/60 hidden sm:inline">—</span>

          {/* 附加信息 */}
          <span className="text-white/90 text-xs sm:text-sm hidden sm:inline">
            {t('offline.sync_when_online', '您的操作将在恢复网络后同步')}
          </span>

          {/* 待同步数量徽章 */}
          {pendingCount > 0 && (
            <Badge
              variant="outline"
              className="bg-white/20 border-white/30 text-white text-xs ml-1"
            >
              <RefreshCw className="w-3 h-3 mr-1 animate-spin" />
              {t('offline.pending_count', '{{count}} 项待同步', { count: pendingCount })}
            </Badge>
          )}

          {/* 离线时长（仅在长时间离线时显示） */}
          {offlineDuration > 60000 && (
            <span className="text-white/70 text-xs hidden md:inline ml-2">
              {t('offline.duration', '已离线 {{duration}}', {
                duration: formatOfflineDuration(offlineDuration)
              })}
            </span>
          )}
        </motion.div>
      )}
    </AnimatePresence>
  )
}

/**
 * 简洁的离线状态徽章
 * 用于在界面某个角落显示离线状态
 */
export function OfflineBadge({ className }: { className?: string }) {
  const { t } = useTranslation('common')
  const { isOnline } = useOnlineStatus()

  if (isOnline) return null

  return (
    <AnimatePresence>
      {!isOnline && (
        <motion.div
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.9 }}
          transition={{ duration: 0.2 }}
        >
          <Badge
            variant="outline"
            className={cn(
              'bg-orange-100 border-orange-300 text-orange-700',
              'dark:bg-orange-900/30 dark:border-orange-700 dark:text-orange-300',
              className
            )}
          >
            <CloudOff className="w-3 h-3 mr-1" />
            {t('offline.badge', '离线')}
          </Badge>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

export default OfflineIndicator


==================================================
FILE_PATH: web/src/components/StorageManager.tsx
==================================================

/**
 * StorageManager.tsx - 存储空间管理组件
 * 
 * 功能:
 * - 显示存储空间使用情况
 * - 分类显示（书籍、缓存、笔记等）
 * - 清理功能（LRU 策略）
 * - 存储配额警告
 * 
 * @see App-First改造计划.md - Phase 5
 */

import { useEffect, useState, useCallback } from 'react'
import { useTranslation } from 'react-i18next'
import { motion } from 'framer-motion'
import {
  Cloud,
  Trash2,
  AlertTriangle,
  BookOpen,
  FileText,
  Image,
  Archive,
} from 'lucide-react'

interface StorageBreakdown {
  books: number
  notes: number
  cache: number
  other: number
  total: number
}

interface StorageInfo {
  used: number
  quota: number
  usagePercent: number
  breakdown: StorageBreakdown
}

interface StorageManagerProps {
  /** 存储使用率警告阈值（0-1） */
  warningThreshold?: number
  /** 是否显示详细分类 */
  showBreakdown?: boolean
  /** 清理完成回调 */
  onCleanup?: (freedBytes: number) => void
}

// 格式化字节数
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`
}

export function StorageManager({
  warningThreshold = 0.8,
  showBreakdown = true,
  onCleanup,
}: StorageManagerProps) {
  const { t } = useTranslation()
  const [storageInfo, setStorageInfo] = useState<StorageInfo | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [isCleaning, setIsCleaning] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // 获取存储信息
  const fetchStorageInfo = useCallback(async () => {
    setIsLoading(true)
    setError(null)

    try {
      // 检查 Storage Manager API 支持
      if (!navigator.storage?.estimate) {
        throw new Error('Storage Manager API not supported')
      }

      const estimate = await navigator.storage.estimate()
      const used = estimate.usage || 0
      const quota = estimate.quota || 0

      // 估算各类数据大小
      const breakdown: StorageBreakdown = {
        books: 0,
        notes: 0,
        cache: 0,
        other: 0,
        total: used,
      }

      // 尝试获取 IndexedDB 数据库大小
      if ('indexedDB' in window) {
        try {
          // 估算书籍数据库大小
          const booksDb = await new Promise<IDBDatabase>((resolve, reject) => {
            const request = indexedDB.open('athena_books', 3)
            request.onsuccess = () => resolve(request.result)
            request.onerror = () => reject(request.error)
          })

          const booksTransaction = booksDb.transaction(['books', 'chapters'], 'readonly')
          let booksSize = 0

          await Promise.all([
            new Promise<void>((resolve) => {
              const request = booksTransaction.objectStore('books').openCursor()
              request.onsuccess = () => {
                const cursor = request.result
                if (cursor) {
                  booksSize += JSON.stringify(cursor.value).length
                  cursor.continue()
                } else {
                  resolve()
                }
              }
            }),
            new Promise<void>((resolve) => {
              const request = booksTransaction.objectStore('chapters').openCursor()
              request.onsuccess = () => {
                const cursor = request.result
                if (cursor) {
                  booksSize += JSON.stringify(cursor.value).length
                  cursor.continue()
                } else {
                  resolve()
                }
              }
            }),
          ])

          booksDb.close()
          breakdown.books = booksSize

          // 估算笔记数据库大小
          const notesDb = await new Promise<IDBDatabase>((resolve, reject) => {
            const request = indexedDB.open('athena_notes', 1)
            request.onsuccess = () => resolve(request.result)
            request.onerror = () => reject(request.error)
          })

          const notesTransaction = notesDb.transaction(['notes', 'highlights'], 'readonly')
          let notesSize = 0

          await Promise.all([
            new Promise<void>((resolve) => {
              const request = notesTransaction.objectStore('notes').openCursor()
              request.onsuccess = () => {
                const cursor = request.result
                if (cursor) {
                  notesSize += JSON.stringify(cursor.value).length
                  cursor.continue()
                } else {
                  resolve()
                }
              }
            }),
            new Promise<void>((resolve) => {
              const request = notesTransaction.objectStore('highlights').openCursor()
              request.onsuccess = () => {
                const cursor = request.result
                if (cursor) {
                  notesSize += JSON.stringify(cursor.value).length
                  cursor.continue()
                } else {
                  resolve()
                }
              }
            }),
          ])

          notesDb.close()
          breakdown.notes = notesSize
        } catch (e) {
          console.warn('[StorageManager] Failed to estimate IndexedDB size:', e)
        }
      }

      // 估算缓存大小
      if ('caches' in window) {
        try {
          const cacheNames = await caches.keys()
          for (const cacheName of cacheNames) {
            const cache = await caches.open(cacheName)
            const keys = await cache.keys()
            for (const request of keys) {
              const response = await cache.match(request)
              if (response) {
                const blob = await response.clone().blob()
                breakdown.cache += blob.size
              }
            }
          }
        } catch (e) {
          console.warn('[StorageManager] Failed to estimate cache size:', e)
        }
      }

      // 其他数据
      breakdown.other = Math.max(0, used - breakdown.books - breakdown.notes - breakdown.cache)

      setStorageInfo({
        used,
        quota,
        usagePercent: quota > 0 ? used / quota : 0,
        breakdown,
      })
    } catch (e) {
      console.error('[StorageManager] Failed to fetch storage info:', e)
      setError((e as Error).message)
    } finally {
      setIsLoading(false)
    }
  }, [])

  // 清理缓存（LRU 策略）
  const cleanupCache = useCallback(async () => {
    setIsCleaning(true)
    let freedBytes = 0

    try {
      // 清理 Service Worker 缓存
      if ('caches' in window) {
        const cacheNames = await caches.keys()

        // 只清理图片和 API 缓存，保留静态资源和书籍内容
        const cachesToClean = cacheNames.filter(name =>
          name.includes('images') || name.includes('api')
        )

        for (const cacheName of cachesToClean) {
          const cache = await caches.open(cacheName)
          const keys = await cache.keys()

          for (const request of keys) {
            const response = await cache.match(request)
            if (response) {
              const blob = await response.clone().blob()
              freedBytes += blob.size
            }
            await cache.delete(request)
          }
        }
      }

      // 清理过期的同步队列数据
      try {
        const syncDb = await new Promise<IDBDatabase>((resolve, reject) => {
          const request = indexedDB.open('athena_sync', 1)
          request.onsuccess = () => resolve(request.result)
          request.onerror = () => reject(request.error)
        })

        const transaction = syncDb.transaction(['sync_queue'], 'readwrite')
        const store = transaction.objectStore('sync_queue')
        const syncedIndex = store.index('synced')

        // 删除已同步的记录
        await new Promise<void>((resolve, reject) => {
          const request = syncedIndex.openCursor(IDBKeyRange.only(1))
          request.onsuccess = () => {
            const cursor = request.result
            if (cursor) {
              freedBytes += JSON.stringify(cursor.value).length
              cursor.delete()
              cursor.continue()
            } else {
              resolve()
            }
          }
          request.onerror = () => reject(request.error)
        })

        syncDb.close()
      } catch (e) {
        console.warn('[StorageManager] Failed to cleanup sync queue:', e)
      }

      // 刷新存储信息
      await fetchStorageInfo()

      // 回调
      onCleanup?.(freedBytes)

      console.log('[StorageManager] Cleanup complete, freed:', formatBytes(freedBytes))
    } catch (e) {
      console.error('[StorageManager] Cleanup failed:', e)
      setError((e as Error).message)
    } finally {
      setIsCleaning(false)
    }
  }, [fetchStorageInfo, onCleanup])

  // 初始化加载
  useEffect(() => {
    fetchStorageInfo()
  }, [fetchStorageInfo])

  // 警告状态
  const isWarning = storageInfo && storageInfo.usagePercent >= warningThreshold

  if (isLoading) {
    return (
      <div className="animate-pulse rounded-lg bg-gray-100 p-4 dark:bg-gray-800">
        <div className="h-4 w-1/3 rounded bg-gray-200 dark:bg-gray-700" />
        <div className="mt-3 h-2 rounded bg-gray-200 dark:bg-gray-700" />
      </div>
    )
  }

  if (error) {
    return (
      <div className="rounded-lg border border-red-200 bg-red-50 p-4 dark:border-red-800 dark:bg-red-900/20">
        <p className="text-sm text-red-600 dark:text-red-400">
          {t('storage.error', '无法获取存储信息')}: {error}
        </p>
      </div>
    )
  }

  if (!storageInfo) return null

  return (
    <div className="rounded-lg border border-gray-200 bg-white p-4 dark:border-gray-700 dark:bg-gray-800">
      {/* 标题和警告 */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Cloud className="h-5 w-5 text-gray-400" />
          <h3 className="font-medium text-gray-900 dark:text-white">
            {t('storage.title', '存储空间')}
          </h3>
        </div>
        {isWarning && (
          <div className="flex items-center gap-1 text-amber-500">
            <AlertTriangle className="h-4 w-4" />
            <span className="text-xs">{t('storage.warning', '空间不足')}</span>
          </div>
        )}
      </div>

      {/* 使用量进度条 */}
      <div className="mt-3">
        <div className="flex justify-between text-sm">
          <span className="text-gray-500 dark:text-gray-400">
            {formatBytes(storageInfo.used)} / {formatBytes(storageInfo.quota)}
          </span>
          <span className={isWarning ? 'text-amber-500' : 'text-gray-500 dark:text-gray-400'}>
            {(storageInfo.usagePercent * 100).toFixed(1)}%
          </span>
        </div>
        <div className="mt-1 h-2 overflow-hidden rounded-full bg-gray-200 dark:bg-gray-700">
          <motion.div
            initial={{ width: 0 }}
            animate={{ width: `${storageInfo.usagePercent * 100}%` }}
            transition={{ duration: 0.5, ease: 'easeOut' }}
            className={`h-full rounded-full ${isWarning
                ? 'bg-amber-500'
                : 'bg-indigo-500'
              }`}
          />
        </div>
      </div>

      {/* 分类明细 */}
      {showBreakdown && (
        <div className="mt-4 grid grid-cols-2 gap-3">
          <div className="flex items-center gap-2">
            <BookOpen className="h-4 w-4 text-blue-500" />
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {t('storage.books', '书籍')}: {formatBytes(storageInfo.breakdown.books)}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <FileText className="h-4 w-4 text-green-500" />
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {t('storage.notes', '笔记')}: {formatBytes(storageInfo.breakdown.notes)}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Image className="h-4 w-4 text-purple-500" />
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {t('storage.cache', '缓存')}: {formatBytes(storageInfo.breakdown.cache)}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <Archive className="h-4 w-4 text-gray-500" />
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {t('storage.other', '其他')}: {formatBytes(storageInfo.breakdown.other)}
            </span>
          </div>
        </div>
      )}

      {/* 清理按钮 */}
      <div className="mt-4">
        <button
          onClick={cleanupCache}
          disabled={isCleaning}
          className="flex w-full items-center justify-center gap-2 rounded-md bg-gray-100 px-3 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
        >
          <Trash2 className={`h-4 w-4 ${isCleaning ? 'animate-spin' : ''}`} />
          {isCleaning
            ? t('storage.cleaning', '清理中...')
            : t('storage.cleanup', '清理缓存')
          }
        </button>
      </div>
    </div>
  )
}

export default StorageManager


==================================================
FILE_PATH: web/src/components/BookCard.tsx
==================================================

/**
 * BookCard 组件 - 向后兼容导出
 * 
 * 此文件保留用于向后兼容，实际实现已迁移至 BookCard/ 目录
 * 
 * @deprecated 建议直接从 '@/components/BookCard' 导入（会解析到 BookCard/index.tsx）
 */

// 重新导出 BookCard 目录中的所有内容
// 注意：必须使用完整路径避免循环导入
export { default } from './BookCard/index'
export * from './BookCard/index'
export type { BookCardProps, BookStatus } from './BookCard/types'


==================================================
FILE_PATH: web/src/components/OcrTriggerDialog.tsx
==================================================

/**
 * OcrTriggerDialog.tsx
 * 
 * OCR 文字识别触发对话框
 * 显示书籍页数、配额消耗、剩余配额，并提供触发 OCR 的功能
 */

import { useState, useEffect, useCallback } from 'react'
import { createPortal } from 'react-dom'
import { useTranslation } from 'react-i18next'
import { FileText, Loader2, AlertTriangle, X, Zap, Info } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useAuthStore } from '@/stores/auth'

interface OcrQuotaInfo {
  pageCount: number | null
  tier: number  // 1, 2, 3
  cost: number  // 消耗的配额单位数
  canTrigger: boolean
  reason?: string
  freeRemaining: number
  proRemaining: number
  addonRemaining: number
  isPro: boolean
  maxPages: number
}

interface OcrTriggerDialogProps {
  bookId: string
  bookTitle: string
  open: boolean
  onClose: () => void
  onSuccess?: () => void
}

interface OcrTriggerResult {
  status: 'queued' | 'instant_completed'
  queuePosition?: number
  estimatedMinutes?: number
  estimatedSeconds?: number  // 用于 instant_completed
  pageCount?: number
}

/** 获取配额信息 */
async function fetchOcrQuotaInfo(bookId: string): Promise<OcrQuotaInfo> {
  const token = useAuthStore.getState().accessToken
  const res = await fetch(`/api/v1/books/${bookId}/ocr/quota`, {
    headers: { Authorization: `Bearer ${token}` },
  })
  if (!res.ok) {
    throw new Error('Failed to fetch OCR quota info')
  }
  const data = await res.json()
  return data.data
}

/** 触发 OCR */
async function triggerOcr(bookId: string): Promise<OcrTriggerResult> {
  const token = useAuthStore.getState().accessToken
  const res = await fetch(`/api/v1/books/${bookId}/ocr`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  })
  if (!res.ok) {
    const err = await res.json().catch(() => ({}))
    throw new Error(err.message || err.detail || 'OCR trigger failed')
  }
  return res.json()
}

export default function OcrTriggerDialog({
  bookId,
  bookTitle,
  open,
  onClose,
  onSuccess,
}: OcrTriggerDialogProps) {
  const { t } = useTranslation('common')
  const [loading, setLoading] = useState(true)
  const [triggering, setTriggering] = useState(false)
  const [quotaInfo, setQuotaInfo] = useState<OcrQuotaInfo | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [fakeProcessing, setFakeProcessing] = useState(false)
  const [fakeProgress, setFakeProgress] = useState(0)

  // 加载配额信息
  useEffect(() => {
    if (open && bookId) {
      setLoading(true)
      setError(null)
      setFakeProcessing(false)
      setFakeProgress(0)
      fetchOcrQuotaInfo(bookId)
        .then(setQuotaInfo)
        .catch((e) => setError(e.message))
        .finally(() => setLoading(false))
    }
  }, [open, bookId])

  // 触发 OCR
  const handleTrigger = useCallback(async () => {
    if (!quotaInfo?.canTrigger) return
    setTriggering(true)
    setError(null)
    try {
      const result = await triggerOcr(bookId)
      
      // 【关键】立即广播 OCR 开始事件，确保书籍被锁定
      window.dispatchEvent(new CustomEvent('ocr_started', {
        detail: { bookId }
      }))
      console.log('[OcrTriggerDialog] OCR triggered, broadcasted ocr_started event for book:', bookId)
      
      // 如果是 instant_completed，显示假处理动画
      if (result.status === 'instant_completed' && result.estimatedSeconds) {
        setTriggering(false)
        setFakeProcessing(true)
        
        const totalMs = result.estimatedSeconds * 1000
        const interval = 100  // 每 100ms 更新一次进度
        const steps = totalMs / interval
        let currentStep = 0
        
        const progressInterval = setInterval(() => {
          currentStep++
          // 使用缓动函数让进度更自然
          const progress = Math.min(100, Math.pow(currentStep / steps, 0.8) * 100)
          setFakeProgress(progress)
          
          if (currentStep >= steps) {
            clearInterval(progressInterval)
            setFakeProcessing(false)
            setFakeProgress(100)
            onSuccess?.()
            onClose()
          }
        }, interval)
        
        return
      }
      
      // 正常 queued 状态
      onSuccess?.()
      onClose()
    } catch (e: any) {
      setError(e.message)
    } finally {
      setTriggering(false)
    }
  }, [bookId, quotaInfo, onSuccess, onClose])

  if (!open) return null

  // 根据 tier 获取描述
  const getTierLabel = (tier: number) => {
    switch (tier) {
      case 1: return t('ocr.tier_1')
      case 2: return t('ocr.tier_2')
      case 3: return t('ocr.tier_3')
      default: return ''
    }
  }

  return createPortal(
    <div
      className="fixed inset-0 z-[100] flex items-center justify-center p-4"
      onClick={(e) => e.stopPropagation()}
    >
      {/* 遮罩层 - 假处理时禁止关闭 */}
      <div
        className="absolute inset-0 bg-black/20 backdrop-blur-sm"
        onClick={fakeProcessing ? undefined : onClose}
      />

      {/* 对话框 */}
      <div
        className={cn(
          'relative w-full max-w-md',
          'bg-white/95 dark:bg-gray-900/95 backdrop-blur-xl',
          'shadow-2xl border border-gray-200/50 dark:border-white/10',
          'rounded-2xl overflow-hidden',
          'animate-in fade-in-0 zoom-in-95 duration-fast'
        )}
      >
        {/* 头部 */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-separator">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-xl bg-system-blue/10 flex items-center justify-center">
              <FileText className="w-5 h-5 text-system-blue" />
            </div>
            <div>
              <h3 className="text-base font-bold text-label">{t('ocr.confirm_title')}</h3>
              <p className="text-xs text-secondary-label line-clamp-1">{bookTitle}</p>
            </div>
          </div>
          <button
            onClick={onClose}
            disabled={fakeProcessing}
            className="p-2 rounded-full hover:bg-secondary-background transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <X className="w-5 h-5 text-secondary-label" />
          </button>
        </div>

        {/* 内容 */}
        <div className="px-6 py-5">
          {fakeProcessing ? (
            /* 假处理动画 - 复用原书 OCR 时显示 */
            <div className="flex flex-col items-center justify-center py-8">
              <div className="relative w-20 h-20 mb-4">
                <svg className="w-20 h-20 transform -rotate-90" viewBox="0 0 80 80">
                  <circle
                    cx="40"
                    cy="40"
                    r="36"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="6"
                    className="text-gray-200 dark:text-gray-700"
                  />
                  <circle
                    cx="40"
                    cy="40"
                    r="36"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="6"
                    strokeLinecap="round"
                    className="text-system-blue transition-all duration-100"
                    style={{
                      strokeDasharray: `${2 * Math.PI * 36}`,
                      strokeDashoffset: `${2 * Math.PI * 36 * (1 - fakeProgress / 100)}`,
                    }}
                  />
                </svg>
                <div className="absolute inset-0 flex items-center justify-center">
                  <span className="text-lg font-bold text-system-blue">
                    {Math.round(fakeProgress)}%
                  </span>
                </div>
              </div>
              <span className="text-base font-medium text-label mb-1">
                {t('ocr.processing_title', { defaultValue: 'OCR 处理中' })}
              </span>
              <span className="text-sm text-secondary-label">
                {t('ocr.processing_hint', { defaultValue: '正在识别文字，请稍候...' })}
              </span>
            </div>
          ) : loading ? (
            <div className="flex flex-col items-center justify-center py-8">
              <Loader2 className="w-8 h-8 text-system-blue animate-spin mb-3" />
              <span className="text-sm text-secondary-label">加载中...</span>
            </div>
          ) : error ? (
            <div className="flex flex-col items-center justify-center py-8">
              <AlertTriangle className="w-8 h-8 text-system-orange mb-3" />
              <span className="text-sm text-secondary-label">{error}</span>
            </div>
          ) : quotaInfo ? (
            <div className="space-y-4">
              {/* 页数信息 */}
              <div className="bg-secondary-background rounded-xl p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm text-secondary-label">书籍页数</span>
                  <span className="text-lg font-bold text-label">
                    {quotaInfo.pageCount ? t('ocr.page_count', { count: quotaInfo.pageCount }) : '未知'}
                  </span>
                </div>
                {quotaInfo.pageCount && (
                  <div className="flex items-center justify-between">
                    <span className="text-sm text-secondary-label">书籍规模</span>
                    <span className="text-sm font-medium text-label">{getTierLabel(quotaInfo.tier)}</span>
                  </div>
                )}
              </div>

              {/* 配额消耗 */}
              <div className="bg-system-blue/5 dark:bg-system-blue/10 rounded-xl p-4">
                <div className="flex items-center gap-2 mb-3">
                  <Zap className="w-4 h-4 text-system-blue" />
                  <span className="text-sm font-medium text-label">配额消耗</span>
                </div>
                <div className="text-2xl font-bold text-system-blue mb-1">
                  {t('ocr.cost_units', { count: quotaInfo.cost })}
                </div>
                <p className="text-xs text-secondary-label">
                  {t('ocr.confirm_message')}
                </p>
              </div>

              {/* 剩余配额 */}
              <div className="space-y-2">
                <div className="flex items-center gap-2 text-sm">
                  <Info className="w-4 h-4 text-secondary-label" />
                  <span className="text-secondary-label">剩余配额</span>
                </div>
                <div className="grid grid-cols-2 gap-2 text-sm">
                  {!quotaInfo.isPro && (
                    <div className="bg-secondary-background rounded-lg px-3 py-2">
                      <span className="text-secondary-label">免费额度: </span>
                      <span className="font-medium text-label">{quotaInfo.freeRemaining}</span>
                    </div>
                  )}
                  {quotaInfo.isPro && (
                    <div className="bg-secondary-background rounded-lg px-3 py-2">
                      <span className="text-secondary-label">Pro 赠送: </span>
                      <span className="font-medium text-label">{quotaInfo.proRemaining}</span>
                    </div>
                  )}
                  <div className="bg-secondary-background rounded-lg px-3 py-2">
                    <span className="text-secondary-label">加油包: </span>
                    <span className="font-medium text-label">{quotaInfo.addonRemaining}</span>
                  </div>
                </div>
              </div>

              {/* 不能触发的原因 */}
              {!quotaInfo.canTrigger && quotaInfo.reason && (
                <div className="bg-system-red/10 rounded-xl p-4 flex items-start gap-3">
                  <AlertTriangle className="w-5 h-5 text-system-red flex-shrink-0 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-system-red">{quotaInfo.reason}</p>
                    {quotaInfo.reason.includes('配额') && (
                      <button className="mt-2 text-sm text-system-blue font-medium hover:underline">
                        {t('ocr.buy_addon')}
                      </button>
                    )}
                  </div>
                </div>
              )}
            </div>
          ) : null}
        </div>

        {/* 底部按钮 - 假处理时隐藏 */}
        {!fakeProcessing && (
          <div className="px-6 py-4 border-t border-separator flex gap-3">
            <button
              onClick={onClose}
              disabled={triggering}
              className={cn(
                'flex-1 py-3 px-4 rounded-full',
                'bg-secondary-background text-label',
                'border border-separator',
                'font-medium text-sm',
                'hover:bg-tertiary-background transition-colors',
                'disabled:opacity-50'
              )}
            >
              {t('common.cancel')}
            </button>
            <button
              onClick={handleTrigger}
              disabled={loading || triggering || !quotaInfo?.canTrigger}
              className={cn(
                'flex-1 py-3 px-4 rounded-full',
                'bg-system-blue text-white',
                'font-medium text-sm',
                'hover:opacity-90 transition-opacity',
                'disabled:opacity-50',
                'flex items-center justify-center gap-2'
              )}
            >
              {triggering && <Loader2 className="w-4 h-4 animate-spin" />}
              {t('ocr.confirm_button')}
            </button>
          </div>
        )}
      </div>
    </div>,
    document.body
  )
}


==================================================
FILE_PATH: web/src/components/ConflictResolverDialog.tsx
==================================================

/**
 * ConflictResolverDialog.tsx - 笔记冲突解决对话框 (PowerSync 版)
 * 
 * PowerSync 采用 conflict_copy 策略，冲突会自动创建副本
 * 此组件提供简化的冲突查看界面
 * 
 * @see 09 - APP-FIRST架构改造计划.md
 * @see docker/powersync/sync_rules.yaml - conflict_resolution: conflict_copy
 */

import React from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { AlertCircle } from 'lucide-react'

interface ConflictResolverDialogProps {
  /** 是否打开对话框 */
  open: boolean
  /** 关闭对话框回调 */
  onClose: () => void
  /** 解决冲突后的回调 */
  onResolved?: () => void
}

/**
 * 冲突解决对话框组件 (PowerSync 版)
 * 
 * PowerSync 自动处理冲突，此对话框仅作为通知
 */
export function ConflictResolverDialog({
  open,
  onClose,
}: ConflictResolverDialogProps) {
  return (
    <Dialog open={open} onOpenChange={(o) => !o && onClose()}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <AlertCircle className="w-5 h-5 text-amber-500" />
            同步冲突已处理
          </DialogTitle>
          <DialogDescription>
            PowerSync 已自动创建冲突副本。您可以在笔记列表中查看并手动合并。
          </DialogDescription>
        </DialogHeader>

        <div className="py-4 text-sm text-gray-600 dark:text-gray-400">
          <p>当同一笔记在多个设备上被修改时，系统会自动保留所有版本：</p>
          <ul className="list-disc list-inside mt-2 space-y-1">
            <li>原始版本保持不变</li>
            <li>冲突版本会标记为副本</li>
            <li>您可以选择保留或删除任一版本</li>
          </ul>
        </div>

        <div className="flex justify-end">
          <Button onClick={onClose}>
            我知道了
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}

export default ConflictResolverDialog


==================================================
FILE_PATH: web/src/components/AddToShelfDialog.tsx
==================================================

/**
 * AddToShelfDialog.tsx
 * 
 * 「加入书架」对话框组件
 * - 显示已有书架列表供用户选择（可多选）
 * - 支持创建新书架
 * - 使用 PowerSync 进行本地数据操作
 * 
 * 遵循 UIUX 设计规范：
 * - 毛玻璃效果：bg-white/95 backdrop-blur-xl
 * - 圆角：rounded-2xl
 * - 动效：duration-fast (150ms) - 使用 Motion Token
 */

import { useState, useEffect, useCallback, useMemo } from 'react'
import { createPortal } from 'react-dom'
import { useTranslation } from 'react-i18next'
import {
  Library,
  X,
  Loader2,
  Check,
  AlertCircle,
  FolderPlus,
} from 'lucide-react'
import { cn, generateUUID, getDeviceId } from '@/lib/utils'
import { usePowerSync, useQuery } from '@powersync/react'
import { useAuthStore } from '@/stores/auth'

// ================== 类型定义 ==================

interface ShelfRow {
  id: string
  name: string
  description: string | null
  book_count: number
}

interface ShelfBookRow {
  shelf_id: string
}

interface AddToShelfDialogProps {
  bookId: string
  bookTitle: string
  open: boolean
  onClose: () => void
  onSuccess?: () => void
}

// ================== 组件 ==================

export default function AddToShelfDialog({
  bookId,
  bookTitle,
  open,
  onClose,
  onSuccess,
}: AddToShelfDialogProps) {
  const { t } = useTranslation('common')
  const db = usePowerSync()

  // 使用 PowerSync 查询书架列表
  // 注意：is_deleted 可能是 NULL、0 或 FALSE，需要正确处理
  const shelvesQuery = open
    ? `SELECT s.id, s.name, s.description, COALESCE(sb.book_count, 0) as book_count
       FROM shelves s
       LEFT JOIN (
         SELECT shelf_id, COUNT(*) as book_count
         FROM shelf_books
         GROUP BY shelf_id
       ) sb ON s.id = sb.shelf_id
       WHERE s.deleted_at IS NULL
       AND (s.is_deleted IS NULL OR s.is_deleted = 0)
       ORDER BY s.sort_order ASC, s.name ASC`
    : 'SELECT id, name, description, 0 as book_count FROM shelves WHERE 1=0'
  
  const { data: shelvesData, isLoading: shelvesLoading, error: shelvesError } = useQuery<ShelfRow>(shelvesQuery, [])

  // 查询书籍当前所属的书架
  const bookShelvesQuery = open && bookId
    ? 'SELECT shelf_id FROM shelf_books WHERE book_id = ?'
    : 'SELECT shelf_id FROM shelf_books WHERE 1=0'
  
  const { data: bookShelvesData, isLoading: bookShelvesLoading } = useQuery<ShelfBookRow>(
    bookShelvesQuery,
    open && bookId ? [bookId] : []
  )

  // 状态
  const [selectedShelfIds, setSelectedShelfIds] = useState<Set<string>>(new Set())
  const [originalShelfIds, setOriginalShelfIds] = useState<Set<string>>(new Set())
  const [error, setError] = useState<string | null>(null)

  // 创建新书架
  const [showCreateForm, setShowCreateForm] = useState(false)
  const [newShelfName, setNewShelfName] = useState('')
  const [creating, setCreating] = useState(false)
  const [nameError, setNameError] = useState<string | null>(null)

  // 保存状态
  const [saving, setSaving] = useState(false)

  const loading = shelvesLoading || bookShelvesLoading

  // 如果查询出错，设置错误信息
  useEffect(() => {
    if (shelvesError) {
      console.error('[AddToShelfDialog] Query error:', shelvesError)
      setError(shelvesError.message || '查询书架失败')
    }
  }, [shelvesError])

  // 转换书架数据
  const shelves = useMemo(() => shelvesData || [], [shelvesData])

  // 当对话框打开或书籍书架数据变化时，更新选中状态
  useEffect(() => {
    if (open && bookShelvesData) {
      const ids = new Set(bookShelvesData.map(sb => sb.shelf_id))
      setSelectedShelfIds(ids)
      setOriginalShelfIds(ids)
      setShowCreateForm(false)
      setNewShelfName('')
      setNameError(null)
      setError(null)
    }
  }, [open, bookShelvesData])

  // 校验书架名称
  useEffect(() => {
    if (newShelfName.trim()) {
      const exists = shelves.some(
        (s) => s.name?.toLowerCase() === newShelfName.trim().toLowerCase()
      )
      if (exists) {
        setNameError(t('shelf.error.name_exists'))
      } else {
        setNameError(null)
      }
    } else {
      setNameError(null)
    }
  }, [newShelfName, shelves, t])

  // 切换书架选中状态
  const toggleShelf = useCallback((shelfId: string) => {
    setSelectedShelfIds((prev) => {
      const next = new Set(prev)
      if (next.has(shelfId)) {
        next.delete(shelfId)
      } else {
        next.add(shelfId)
      }
      return next
    })
  }, [])

  // 创建新书架
  const handleCreateShelf = useCallback(async () => {
    const name = newShelfName.trim()
    if (!name || nameError || !db) return

    setCreating(true)
    try {
      const id = generateUUID()
      const now = new Date().toISOString()

      // 获取最大排序值 - 使用 getAll 避免空结果异常
      const maxOrderResults = await db.getAll<{ max_order: number }>(
        'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelves'
      )
      const maxOrder = maxOrderResults[0]?.max_order ?? 0

      // 使用正确的 user_id - 从 AuthStore 获取
      const userId = useAuthStore.getState().user?.id || ''
      await db.execute(
        `INSERT INTO shelves (id, user_id, name, description, sort_order, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [id, userId, name, null, maxOrder + 1, now, now]
      )

      // 自动选中新创建的书架
      setSelectedShelfIds((prev) => new Set(prev).add(id))
      setNewShelfName('')
      setShowCreateForm(false)
    } catch (e: any) {
      console.error('[AddToShelfDialog] Failed to create shelf:', e)
      setError(e.message || '创建书架失败')
    } finally {
      setCreating(false)
    }
  }, [newShelfName, nameError, db])

  // 保存更改
  const handleSave = useCallback(async () => {
    if (!db) return
    
    setSaving(true)
    setError(null)

    try {
      // 计算需要添加和移除的书架
      const toAdd = [...selectedShelfIds].filter((id) => !originalShelfIds.has(id))
      const toRemove = [...originalShelfIds].filter((id) => !selectedShelfIds.has(id))

      const now = new Date().toISOString()

      // 执行添加操作
      for (const shelfId of toAdd) {
        // 检查是否已存在 - 使用 getAll 避免空结果异常
        const existingRows = await db.getAll<{ id: string }>(
          'SELECT id FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
          [shelfId, bookId]
        )
        
        if (existingRows.length === 0) {
          const id = generateUUID()
          const maxOrderRows = await db.getAll<{ max_order: number }>(
            'SELECT COALESCE(MAX(sort_order), 0) as max_order FROM shelf_books WHERE shelf_id = ?',
            [shelfId]
          )
          const maxOrder = maxOrderRows[0]?.max_order ?? 0
          
          // 使用正确的 user_id - 从 AuthStore 获取
          const userId = useAuthStore.getState().user?.id || ''
          await db.execute(
            `INSERT INTO shelf_books (id, user_id, shelf_id, book_id, sort_order, added_at)
             VALUES (?, ?, ?, ?, ?, ?)`,
            [id, userId, shelfId, bookId, maxOrder + 1, now]
          )
        }
      }

      // 执行移除操作
      for (const shelfId of toRemove) {
        await db.execute(
          'DELETE FROM shelf_books WHERE shelf_id = ? AND book_id = ?',
          [shelfId, bookId]
        )
      }

      console.log('[AddToShelfDialog] Saved changes:', { added: toAdd, removed: toRemove })

      onSuccess?.()
      onClose()
    } catch (e: any) {
      console.error('[AddToShelfDialog] Failed to save:', e)
      setError(e.message || '保存失败')
    } finally {
      setSaving(false)
    }
  }, [db, bookId, selectedShelfIds, originalShelfIds, onSuccess, onClose])

  // 检查是否有更改
  const hasChanges = useMemo(() => {
    if (selectedShelfIds.size !== originalShelfIds.size) return true
    for (const id of selectedShelfIds) {
      if (!originalShelfIds.has(id)) return true
    }
    return false
  }, [selectedShelfIds, originalShelfIds])

  if (!open) return null

  return createPortal(
    <div
      className="fixed inset-0 z-50 flex items-center justify-center p-4"
      role="dialog"
      aria-modal="true"
      aria-labelledby="add-to-shelf-title"
      onClick={(e) => {
        e.preventDefault()
        e.stopPropagation()
      }}
    >
      {/* Overlay */}
      <div
        className="absolute inset-0 bg-black/50 animate-in fade-in-0 duration-fast"
        onClick={(e) => {
          e.preventDefault()
          e.stopPropagation()
          onClose()
        }}
      />

      {/* Dialog Content */}
      <div
        className={cn(
          'relative z-10 w-full max-w-md',
          'rounded-2xl shadow-2xl',
          'animate-in fade-in-0 zoom-in-95 duration-fast'
        )}
        style={{
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          backdropFilter: 'blur(20px) saturate(180%)',
          WebkitBackdropFilter: 'blur(20px) saturate(180%)',
        }}
        onClick={(e) => {
          e.preventDefault()
          e.stopPropagation()
        }}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200/50">
          <div className="flex items-center gap-3">
            <div className="flex items-center justify-center w-10 h-10 rounded-xl bg-blue-500/10">
              <Library className="w-5 h-5 text-blue-600" />
            </div>
            <div>
              <h2 id="add-to-shelf-title" className="text-lg font-semibold text-gray-900">
                {t('shelf.add_to_shelf')}
              </h2>
              <p className="text-sm text-gray-500 truncate max-w-60">
                {bookTitle}
              </p>
            </div>
          </div>
          <button
            onClick={(e) => {
              e.preventDefault()
              e.stopPropagation()
              onClose()
            }}
            className="p-2 rounded-lg hover:bg-gray-100 transition-colors duration-fast"
            aria-label={t('common.close')}
          >
            <X className="w-5 h-5 text-gray-500" />
          </button>
        </div>

        {/* Body */}
        <div className="px-6 py-4 max-h-[400px] overflow-y-auto">
          {loading ? (
            <div className="flex items-center justify-center py-12">
              <Loader2 className="w-6 h-6 text-blue-500 animate-spin" />
            </div>
          ) : error && !shelves.length ? (
            <div className="flex flex-col items-center justify-center py-12 text-center">
              <AlertCircle className="w-8 h-8 text-red-500 mb-2" />
              <p className="text-sm text-gray-600">{error}</p>
              <button
                onClick={(e) => {
                  e.preventDefault()
                  e.stopPropagation()
                  setError(null)
                }}
                className="mt-4 px-4 py-2 text-sm text-blue-600 hover:bg-blue-50 rounded-lg transition-colors"
              >
                {t('common.retry')}
              </button>
            </div>
          ) : (
            <>
              {/* 书架列表 */}
              {shelves.length > 0 && (
                <div className="space-y-2 mb-4">
                  <p className="text-sm font-medium text-gray-700 mb-3">
                    {t('shelf.select_shelf')}
                  </p>
                  <div className="grid grid-cols-2 gap-2">
                    {shelves.map((shelf) => {
                      const isSelected = selectedShelfIds.has(shelf.id)
                      return (
                        <button
                          key={shelf.id}
                          onClick={(e) => {
                            e.preventDefault()
                            e.stopPropagation()
                            toggleShelf(shelf.id)
                          }}
                          className={cn(
                            'flex items-center gap-2 p-3 rounded-xl text-left transition-all duration-fast',
                            'border-2',
                            isSelected
                              ? 'border-blue-500 bg-blue-50'
                              : 'border-gray-200 hover:border-gray-300 hover:bg-gray-50'
                          )}
                        >
                          <div
                            className={cn(
                              'shrink-0 w-5 h-5 rounded-md flex items-center justify-center',
                              isSelected ? 'bg-blue-500' : 'bg-gray-200'
                            )}
                          >
                            {isSelected && <Check className="w-3 h-3 text-white" />}
                          </div>
                          <div className="min-w-0 flex-1">
                            <p className="text-sm font-medium text-gray-900 truncate">
                              {shelf.name}
                            </p>
                            <p className="text-xs text-gray-500">
                              {t('shelf.book_count', { count: shelf.book_count })}
                            </p>
                          </div>
                        </button>
                      )
                    })}
                  </div>
                </div>
              )}

              {/* 分隔线 */}
              {shelves.length > 0 && (
                <div className="flex items-center gap-3 my-4">
                  <div className="flex-1 h-px bg-gray-200" />
                  <span className="text-xs text-gray-400">{t('shelf.or')}</span>
                  <div className="flex-1 h-px bg-gray-200" />
                </div>
              )}

              {/* 创建新书架 */}
              {showCreateForm ? (
                <div className="space-y-3">
                  <p className="text-sm font-medium text-gray-700">
                    {t('shelf.create_new')}
                  </p>
                  <div className="relative">
                    <input
                      type="text"
                      value={newShelfName}
                      onChange={(e) => setNewShelfName(e.target.value)}
                      placeholder={t('shelf.name_placeholder')}
                      className={cn(
                        'w-full px-4 py-3 rounded-xl border-2 text-sm',
                        'focus:outline-none focus:ring-0 transition-colors duration-fast',
                        nameError
                          ? 'border-red-300 focus:border-red-500'
                          : 'border-gray-200 focus:border-blue-500'
                      )}
                      autoFocus
                      onKeyDown={(e) => {
                        if (e.key === 'Enter' && !nameError && newShelfName.trim()) {
                          e.preventDefault()
                          e.stopPropagation()
                          handleCreateShelf()
                        }
                        if (e.key === 'Escape') {
                          e.preventDefault()
                          e.stopPropagation()
                          setShowCreateForm(false)
                          setNewShelfName('')
                        }
                      }}
                    />
                    {nameError && (
                      <p className="absolute -bottom-5 left-0 text-xs text-red-500">
                        {nameError}
                      </p>
                    )}
                  </div>
                  <div className="flex gap-2 mt-6">
                    <button
                      onClick={(e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        setShowCreateForm(false)
                        setNewShelfName('')
                      }}
                      className="flex-1 px-4 py-2.5 text-sm text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors duration-fast"
                    >
                      {t('common.cancel')}
                    </button>
                    <button
                      onClick={(e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        handleCreateShelf()
                      }}
                      disabled={!newShelfName.trim() || !!nameError || creating}
                      className={cn(
                        'flex-1 px-4 py-2.5 text-sm text-white rounded-xl transition-colors duration-fast',
                        'flex items-center justify-center gap-2',
                        !newShelfName.trim() || !!nameError || creating
                          ? 'bg-blue-300 cursor-not-allowed'
                          : 'bg-blue-500 hover:bg-blue-600'
                      )}
                    >
                      {creating && <Loader2 className="w-4 h-4 animate-spin" />}
                      {t('shelf.create_and_add')}
                    </button>
                  </div>
                </div>
              ) : (
                <button
                  onClick={(e) => {
                    e.preventDefault()
                    e.stopPropagation()
                    setShowCreateForm(true)
                  }}
                  className={cn(
                    'w-full flex items-center justify-center gap-2 p-4 rounded-xl',
                    'border-2 border-dashed border-gray-300 hover:border-blue-400',
                    'text-gray-600 hover:text-blue-600',
                    'transition-colors duration-fast'
                  )}
                >
                  <FolderPlus className="w-5 h-5" />
                  <span className="text-sm font-medium">{t('shelf.create_new')}</span>
                </button>
              )}

              {/* 错误提示 */}
              {error && shelves.length > 0 && (
                <div className="mt-4 p-3 bg-red-50 rounded-xl flex items-start gap-2">
                  <AlertCircle className="w-4 h-4 text-red-500 shrink-0 mt-0.5" />
                  <p className="text-sm text-red-600">{error}</p>
                </div>
              )}
            </>
          )}
        </div>

        {/* Footer */}
        {!loading && shelves.length > 0 && !showCreateForm && (
          <div className="px-6 py-4 border-t border-gray-200/50 flex gap-3">
            <button
              onClick={(e) => {
                e.preventDefault()
                e.stopPropagation()
                onClose()
              }}
              className="flex-1 px-4 py-2.5 text-sm text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-xl transition-colors duration-fast"
            >
              {t('common.cancel')}
            </button>
            <button
              onClick={(e) => {
                e.preventDefault()
                e.stopPropagation()
                handleSave()
              }}
              disabled={!hasChanges || saving}
              className={cn(
                'flex-1 px-4 py-2.5 text-sm text-white rounded-xl transition-colors duration-fast',
                'flex items-center justify-center gap-2',
                !hasChanges || saving
                  ? 'bg-blue-300 cursor-not-allowed'
                  : 'bg-blue-500 hover:bg-blue-600'
              )}
            >
              {saving && <Loader2 className="w-4 h-4 animate-spin" />}
              {t('common.save')}
            </button>
          </div>
        )}
      </div>
    </div>,
    document.body
  )
}


==================================================
FILE_PATH: web/src/components/NoteConflictDialog.tsx
==================================================

/**
 * NoteConflictDialog - 笔记冲突解决对话框
 * 
 * 当多设备同步时检测到笔记冲突，显示此对话框让用户选择解决方案：
 * 1. 保留本设备版本
 * 2. 保留其他设备版本
 * 3. 保留两者（创建副本）
 */

import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { AlertTriangle, Check, Copy, Monitor, Smartphone } from 'lucide-react'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { ScrollArea } from '@/components/ui/scroll-area'
import api from '@/lib/api'

export interface ConflictNote {
  /** 冲突副本的服务器 ID */
  id: string
  /** 笔记内容 */
  content: string
  /** 创建设备 */
  deviceId: string
  /** 创建时间 */
  createdAt: string
  /** 原始笔记 ID（被冲突的笔记） */
  conflictOf: string
  /** 位置信息 */
  location?: string
  /** 章节 */
  chapter?: string
}

export interface OriginalNote {
  id: string
  content: string
  deviceId: string
  updatedAt: string
  location?: string
  chapter?: string
}

interface NoteConflictDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  /** 冲突副本 */
  conflictNote: ConflictNote | null
  /** 原始笔记 */
  originalNote: OriginalNote | null
  /** 书籍 ID */
  bookId: string
  /** 解决完成回调 */
  onResolved?: (resolution: 'keep_original' | 'keep_conflict' | 'keep_both') => void
}

export function NoteConflictDialog({
  open,
  onOpenChange,
  conflictNote,
  originalNote,
  bookId,
  onResolved,
}: NoteConflictDialogProps) {
  const { t } = useTranslation('common')
  const [isResolving, setIsResolving] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleResolve = async (resolution: 'keep_original' | 'keep_conflict' | 'keep_both') => {
    if (!conflictNote || !originalNote) return

    setIsResolving(true)
    setError(null)

    try {
      await api.post(`/books/${bookId}/notes/${conflictNote.id}/resolve-conflict`, {
        resolution,
        original_note_id: originalNote.id,
      })

      onResolved?.(resolution)
      onOpenChange(false)
    } catch (err) {
      console.error('[NoteConflictDialog] Failed to resolve:', err)
      setError(t('conflict.error.resolve_failed'))
    } finally {
      setIsResolving(false)
    }
  }

  const formatDate = (dateStr: string) => {
    try {
      return new Date(dateStr).toLocaleString()
    } catch {
      return dateStr
    }
  }

  const getDeviceIcon = (deviceId: string) => {
    if (deviceId.startsWith('web_')) {
      return <Monitor className="h-4 w-4" />
    }
    return <Smartphone className="h-4 w-4" />
  }

  const getDeviceName = (deviceId: string) => {
    if (deviceId.startsWith('web_')) {
      return t('conflict.device.web')
    }
    if (deviceId.startsWith('ios_')) {
      return t('conflict.device.ios')
    }
    if (deviceId.startsWith('android_')) {
      return t('conflict.device.android')
    }
    return t('conflict.device.unknown')
  }

  if (!conflictNote || !originalNote) return null

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-2xl">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <AlertTriangle className="h-5 w-5 text-amber-500" />
            {t('conflict.dialog.title')}
          </DialogTitle>
          <DialogDescription>
            {t('conflict.dialog.description')}
          </DialogDescription>
        </DialogHeader>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 py-4">
          {/* 原始笔记 */}
          <div className="border rounded-lg p-4 space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium text-muted-foreground">
                {t('conflict.label.original')}
              </span>
              <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
                {getDeviceIcon(originalNote.deviceId)}
                <span>{getDeviceName(originalNote.deviceId)}</span>
              </div>
            </div>
            <ScrollArea className="h-32 rounded border p-2 bg-muted/30">
              <p className="text-sm whitespace-pre-wrap">{originalNote.content}</p>
            </ScrollArea>
            <p className="text-xs text-muted-foreground">
              {t('conflict.label.updated_at')}: {formatDate(originalNote.updatedAt)}
            </p>
            <Button
              variant="outline"
              className="w-full"
              onClick={() => handleResolve('keep_original')}
              disabled={isResolving}
            >
              <Check className="h-4 w-4 mr-2" />
              {t('conflict.action.keep_this')}
            </Button>
          </div>

          {/* 冲突副本 */}
          <div className="border rounded-lg p-4 space-y-3 border-amber-200 dark:border-amber-800 bg-amber-50/50 dark:bg-amber-950/20">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium text-amber-700 dark:text-amber-300">
                {t('conflict.label.conflict_copy')}
              </span>
              <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
                {getDeviceIcon(conflictNote.deviceId)}
                <span>{getDeviceName(conflictNote.deviceId)}</span>
              </div>
            </div>
            <ScrollArea className="h-32 rounded border p-2 bg-background">
              <p className="text-sm whitespace-pre-wrap">{conflictNote.content}</p>
            </ScrollArea>
            <p className="text-xs text-muted-foreground">
              {t('conflict.label.created_at')}: {formatDate(conflictNote.createdAt)}
            </p>
            <Button
              variant="outline"
              className="w-full border-amber-300 dark:border-amber-700"
              onClick={() => handleResolve('keep_conflict')}
              disabled={isResolving}
            >
              <Check className="h-4 w-4 mr-2" />
              {t('conflict.action.keep_this')}
            </Button>
          </div>
        </div>

        {/* 位置信息 */}
        {(originalNote.chapter || originalNote.location) && (
          <div className="text-xs text-muted-foreground border-t pt-3">
            {originalNote.chapter && (
              <span>{t('conflict.label.chapter')}: {originalNote.chapter}</span>
            )}
            {originalNote.location && (
              <span className="ml-4">{t('conflict.label.location')}: {originalNote.location}</span>
            )}
          </div>
        )}

        {/* 错误提示 */}
        {error && (
          <div className="flex items-center gap-2 p-3 bg-red-50 dark:bg-red-950/30 rounded-lg text-sm">
            <AlertTriangle className="h-4 w-4 text-red-600 dark:text-red-400" />
            <span className="text-red-700 dark:text-red-300">{error}</span>
          </div>
        )}

        <DialogFooter className="flex-col sm:flex-row gap-2">
          <Button
            variant="secondary"
            onClick={() => handleResolve('keep_both')}
            disabled={isResolving}
            className="flex-1"
          >
            <Copy className="h-4 w-4 mr-2" />
            {t('conflict.action.keep_both')}
          </Button>
          <Button
            variant="ghost"
            onClick={() => onOpenChange(false)}
            disabled={isResolving}
          >
            {t('conflict.action.decide_later')}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}

/**
 * 冲突列表组件 - 显示所有待解决的冲突
 */
interface ConflictListProps {
  bookId: string
  conflicts: Array<{
    conflictNote: ConflictNote
    originalNote: OriginalNote
  }>
  onResolve: (conflictId: string, resolution: 'keep_original' | 'keep_conflict' | 'keep_both') => void
}

export function NoteConflictList({ bookId, conflicts, onResolve }: ConflictListProps) {
  const { t } = useTranslation('common')
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null)

  if (conflicts.length === 0) return null

  return (
    <div className="space-y-2">
      <div className="flex items-center gap-2 text-amber-600 dark:text-amber-400">
        <AlertTriangle className="h-4 w-4" />
        <span className="text-sm font-medium">
          {t('conflict.list.title', { count: conflicts.length })}
        </span>
      </div>

      <div className="space-y-2">
        {conflicts.map((conflict, index) => (
          <button
            key={conflict.conflictNote.id}
            onClick={() => setSelectedIndex(index)}
            className="w-full text-left p-3 rounded-lg border border-amber-200 dark:border-amber-800 bg-amber-50/50 dark:bg-amber-950/20 hover:bg-amber-100/50 dark:hover:bg-amber-900/30 transition-colors"
          >
            <p className="text-sm line-clamp-2">{conflict.conflictNote.content}</p>
            <p className="text-xs text-muted-foreground mt-1">
              {new Date(conflict.conflictNote.createdAt).toLocaleString()}
            </p>
          </button>
        ))}
      </div>

      {selectedIndex !== null && conflicts[selectedIndex] && (
        <NoteConflictDialog
          open={true}
          onOpenChange={(open) => !open && setSelectedIndex(null)}
          conflictNote={conflicts[selectedIndex].conflictNote}
          originalNote={conflicts[selectedIndex].originalNote}
          bookId={bookId}
          onResolved={(resolution) => {
            onResolve(conflicts[selectedIndex].conflictNote.id, resolution)
            setSelectedIndex(null)
          }}
        />
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/reader/PdfPageWithOcr.tsx
==================================================

/**
 * PdfPageWithOcr - PDF 页面组件（简化版）
 * 
 * **架构重构说明 (2025-12-09)**：
 * - 旧方案：前端渲染透明 DOM 叠加层（存在严重的文字对齐问题）
 * - 新方案：后端生成双层 PDF (Invisible Text Layer)，前端直接使用 react-pdf 渲染
 * 
 * 现在这个组件只是 react-pdf Page 的简单封装：
 * - 始终启用 renderTextLayer={true}，让 react-pdf 渲染 PDF 自带的透明文字层
 * - 对于经过 OCR 处理的图片式 PDF，文字层已经由后端嵌入到 PDF 中
 * - 文字选择功能由 PDF 引擎原生支持，完美对齐
 * 
 * @see App-First改造计划.md - OCR 架构重构
 */

import { memo, useCallback } from 'react'
import { Page } from 'react-pdf'

interface PdfPageWithOcrProps {
  /** 书籍 ID（保留接口兼容性，但不再使用） */
  bookId?: string
  /** 页码（从 1 开始） */
  pageNumber: number
  /** 页面宽度 */
  width: number
  /** 是否启用 OCR 叠加层（已废弃，保留接口兼容性） */
  enableOcrLayer?: boolean
  /** 当前页的 OCR 区域数据（已废弃，保留接口兼容性） */
  ocrRegions?: unknown[]
  /** OCR 图片尺寸（已废弃，保留接口兼容性） */
  ocrImageWidth?: number
  ocrImageHeight?: number
  /** 是否显示调试边框（已废弃，保留接口兼容性） */
  debugOcr?: boolean
  /** 页面渲染成功回调 */
  onRenderSuccess?: (page: { pageNumber: number; originalWidth: number; originalHeight: number }) => void
}

/**
 * PDF 页面组件
 * 
 * 使用 react-pdf 渲染 PDF 页面，始终启用文字层。
 * 对于双层 PDF（后端 OCR 处理后生成），文字层已嵌入，可直接选择。
 */
export const PdfPageWithOcr = memo(function PdfPageWithOcr({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bookId: _bookId,  // 保留接口兼容性
  pageNumber,
  width,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  enableOcrLayer: _enableOcrLayer,  // 已废弃：双层 PDF 不需要前端 OCR 层
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ocrRegions: _ocrRegions,  // 已废弃
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ocrImageWidth: _ocrImageWidth,  // 已废弃
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  ocrImageHeight: _ocrImageHeight,  // 已废弃
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  debugOcr: _debugOcr,  // 已废弃
  onRenderSuccess,
}: PdfPageWithOcrProps) {

  const handleRenderSuccess = useCallback((page: { pageNumber: number; originalWidth: number; originalHeight: number }) => {
    // 调用外部回调
    onRenderSuccess?.(page)
  }, [onRenderSuccess])

  return (
    <div
      className="pdf-page-container"
      style={{
        position: 'relative',
        display: 'inline-block',
      }}
    >
      {/* PDF 页面渲染 - 始终启用文字层 */}
      <Page
        pageNumber={pageNumber}
        // 【关键】始终启用 TextLayer，让 react-pdf 渲染 PDF 自带的透明文字
        // 对于双层 PDF，文字层已由后端嵌入，可直接选择
        renderTextLayer={true}
        renderAnnotationLayer={false}
        width={width}
        onRenderSuccess={handleRenderSuccess}
      />
    </div>
  )
})

export default PdfPageWithOcr


==================================================
FILE_PATH: web/src/components/ui/slider.tsx
==================================================

"use client"

import * as React from 'react'
import * as SliderPrimitive from '@radix-ui/react-slider'
import { cn } from './utils'

function Slider({ className, defaultValue, value, min = 0, max = 100, ...props }: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(() => (Array.isArray(value) ? value : Array.isArray(defaultValue) ? defaultValue : [min, max]), [value, defaultValue, min, max])
  return (
    <SliderPrimitive.Root data-slot="slider" defaultValue={defaultValue} value={value} min={min} max={max} className={cn('relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col', className)} {...props}>
      <SliderPrimitive.Track data-slot="slider-track" className={cn('bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-4 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5')}>
        <SliderPrimitive.Range data-slot="slider-range" className={cn('bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full')} />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb data-slot="slider-thumb" key={index} className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50" />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }

==================================================
FILE_PATH: web/src/components/ui/textarea.tsx
==================================================

import * as React from 'react'
import { cn } from './utils'

function Textarea({ className, ...props }: React.ComponentProps<'textarea'>) {
  return <textarea data-slot="textarea" className={cn('resize-none border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-input-background px-3 py-2 text-base transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm', className)} {...props} />
}

export { Textarea }

==================================================
FILE_PATH: web/src/components/ui/toggle-group.tsx
==================================================

"use client"

import * as React from 'react'
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group'
import { cn } from './utils'

function ToggleGroup({ className, ...props }: React.ComponentProps<typeof ToggleGroupPrimitive.Root>) {
  return <ToggleGroupPrimitive.Root data-slot="toggle-group" className={cn('inline-flex items-center gap-1 rounded-md', className)} {...props} />
}
function ToggleGroupItem({ className, ...props }: React.ComponentProps<typeof ToggleGroupPrimitive.Item>) {
  return <ToggleGroupPrimitive.Item data-slot="toggle-group-item" className={cn('hover:bg-accent hover:text-accent-foreground focus-visible:ring-ring/50 inline-flex items-center justify-center gap-2 rounded-md border border-transparent bg-transparent px-2 py-1 text-sm transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground', className)} {...props} />
}

export { ToggleGroup, ToggleGroupItem }

==================================================
FILE_PATH: web/src/components/ui/label.tsx
==================================================

"use client"

import * as React from 'react'
import * as LabelPrimitive from '@radix-ui/react-label'
import { cn } from './utils'

function Label({ className, ...props }: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return <LabelPrimitive.Root data-slot="label" className={cn('flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50', className)} {...props} />
}

export { Label }

==================================================
FILE_PATH: web/src/components/ui/card.tsx
==================================================

import * as React from 'react'
import { cn } from './utils'

function Card({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="card" className={cn('bg-card text-card-foreground flex flex-col gap-6 rounded-xl border', className)} {...props} /> }
function CardHeader({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="card-header" className={cn('@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 pt-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6', className)} {...props} /> }
function CardTitle({ className, ...props }: React.ComponentProps<'div'>) { return <h4 data-slot="card-title" className={cn('leading-none', className)} {...props} /> }
function CardDescription({ className, ...props }: React.ComponentProps<'div'>) { return <p data-slot="card-description" className={cn('text-muted-foreground', className)} {...props} /> }
function CardAction({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="card-action" className={cn('col-start-2 row-span-2 row-start-1 self-start justify-self-end', className)} {...props} /> }
function CardContent({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="card-content" className={cn('px-6 [&:last-child]:pb-6', className)} {...props} /> }
function CardFooter({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="card-footer" className={cn('flex items-center px-6 pb-6 [.border-t]:pt-6', className)} {...props} /> }

export { Card, CardHeader, CardFooter, CardTitle, CardAction, CardDescription, CardContent }

==================================================
FILE_PATH: web/src/components/ui/utils.ts
==================================================

/**
 * UI 工具函数
 * - `cn`: 合并类名并应用 tailwind-merge 规则
 */
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


==================================================
FILE_PATH: web/src/components/ui/sheet.tsx
==================================================

/**
 * 侧边抽屉组件（Radix Dialog 实现）
 * - 支持 left/right/top/bottom 四个方向
 * - 封装 Overlay/Content/Header/Footer 等结构
 */
"use client"

import * as React from 'react'
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { cn } from './utils'

function Sheet(props: React.ComponentProps<typeof DialogPrimitive.Root>) { return <DialogPrimitive.Root data-slot="sheet" {...props} /> }
function SheetTrigger(props: React.ComponentProps<typeof DialogPrimitive.Trigger>) { return <DialogPrimitive.Trigger data-slot="sheet-trigger" {...props} /> }
function SheetPortal(props: React.ComponentProps<typeof DialogPrimitive.Portal>) { return <DialogPrimitive.Portal data-slot="sheet-portal" {...props} /> }

// 使用 forwardRef 修复警告
const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay 
    ref={ref}
    data-slot="sheet-overlay" 
    className={cn('fixed inset-0 z-50 bg-black/50', className)} 
    {...props} 
  />
))
SheetOverlay.displayName = 'SheetOverlay'

function SheetContent({ className, side = 'right', ...props }: React.ComponentProps<typeof DialogPrimitive.Content> & { side?: 'left' | 'right' | 'top' | 'bottom' }) {
  // 根据方向设置位置样式
  const positionStyles = {
    right: 'inset-y-0 right-0 w-3/4 sm:w-96',
    left: 'inset-y-0 left-0 w-3/4 sm:w-96',
    top: 'inset-x-0 top-0 h-1/2',
    bottom: 'inset-x-0 bottom-0'
  }
  // 根据方向设置动画样式 - 使用 Motion Token duration-slow (500ms)
  const animationStyles = {
    right: 'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right duration-slow ease-apple',
    left: 'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left duration-slow ease-apple',
    top: 'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top duration-slow ease-apple',
    bottom: 'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom duration-slow ease-apple'
  }
  return (
    <SheetPortal>
      <SheetOverlay className="data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0" />
      <DialogPrimitive.Content 
        data-slot="sheet-content" 
        className={cn(
          'bg-popover text-popover-foreground fixed z-50 border shadow-lg transition-transform duration-medium ease-apple',
          positionStyles[side],
          animationStyles[side],
          className
        )} 
        {...props} 
      />
    </SheetPortal>
  )
}
function SheetHeader(props: React.ComponentProps<'div'>) { return <div data-slot="sheet-header" className={cn('grid gap-2 p-4', props.className)} {...props} /> }
function SheetFooter(props: React.ComponentProps<'div'>) { return <div data-slot="sheet-footer" className={cn('grid gap-2 p-4', props.className)} {...props} /> }
function SheetTitle(props: React.ComponentProps<typeof DialogPrimitive.Title>) { return <DialogPrimitive.Title data-slot="sheet-title" className={cn('text-lg font-semibold', props.className)} {...props} /> }
function SheetDescription(props: React.ComponentProps<typeof DialogPrimitive.Description>) { return <DialogPrimitive.Description data-slot="sheet-description" className={cn('text-sm text-muted-foreground', props.className)} {...props} /> }

export { Sheet, SheetTrigger, SheetPortal, SheetOverlay, SheetContent, SheetHeader, SheetFooter, SheetTitle, SheetDescription }


==================================================
FILE_PATH: web/src/components/ui/dialog.tsx
==================================================

/**
 * 通用对话框组件（Radix Dialog）
 * - 封装 Overlay/Content/Title/Description 等子组件
 * - 提供毛玻璃样式与进出场动效
 */
"use client"

import * as React from 'react'
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { XIcon } from 'lucide-react'
import { cn } from './utils'

function Dialog(props: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger(props: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal(props: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose(props: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    data-slot="dialog-overlay"
    className={cn(
      'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = 'DialogOverlay'

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal data-slot="dialog-portal">
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      role="dialog"
      aria-modal="true"
      aria-describedby={props['aria-describedby'] ?? 'dialog-desc'}
      data-slot="dialog-content"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border border-gray-200 p-6 shadow-2xl duration-fast sm:max-w-lg',
        className
      )}
      style={{
        backgroundColor: 'rgba(255, 255, 255, 0.95)',
        backdropFilter: 'blur(20px) saturate(180%)',
        WebkitBackdropFilter: 'blur(20px) saturate(180%)'
      }}
      {...props}
    >
      <span id="dialog-desc" className="sr-only">Dialog</span>
      {children}
      <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
        <XIcon />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = 'DialogContent'

function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="dialog-header" className={cn('flex flex-col gap-2 text-center sm:text-left', className)} {...props} />
}

function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div data-slot="dialog-footer" className={cn('flex flex-col-reverse gap-2 sm:flex-row sm:justify-end', className)} {...props} />
  )
}

function DialogTitle({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return <DialogPrimitive.Title data-slot="dialog-title" className={cn('text-lg leading-none font-semibold', className)} {...props} />
}

function DialogDescription({ className, ...props }: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description data-slot="dialog-description" className={cn('text-muted-foreground text-sm', className)} {...props} />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger
}


==================================================
FILE_PATH: web/src/components/ui/resizable.tsx
==================================================

"use client"

import * as React from 'react'
import * as ResizablePrimitive from 'react-resizable-panels'
import { cn } from './utils'

function ResizablePanelGroup({ className, ...props }: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return <ResizablePrimitive.PanelGroup data-slot="resizable-panel-group" className={cn('flex', className)} {...props} />
}
function ResizablePanel({ className, ...props }: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" className={cn('min-w-0', className)} {...props} />
}
function ResizableHandle({ className, ...props }: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle>) {
  return <ResizablePrimitive.PanelResizeHandle data-slot="resizable-handle" className={cn('bg-border data-[resize-handle-active=true]:bg-primary relative w-2.5 cursor-col-resize rounded-full', className)} {...props} />
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

==================================================
FILE_PATH: web/src/components/ui/progress.tsx
==================================================

"use client"

import * as React from 'react'
import * as ProgressPrimitive from '@radix-ui/react-progress'
import { cn } from './utils'

function Progress({ className, value, ...props }: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root data-slot="progress" className={cn('bg-primary/20 relative h-2 w-full overflow-hidden rounded-full', className)} {...props}>
      <ProgressPrimitive.Indicator data-slot="progress-indicator" className="bg-primary h-full w-full flex-1 transition-all" style={{ transform: `translateX(-${100 - (value || 0)}%)` }} />
    </ProgressPrimitive.Root>
  )
}

export { Progress }

==================================================
FILE_PATH: web/src/components/ui/input-otp.tsx
==================================================

"use client"

import * as React from 'react'
import { OTPInput } from 'input-otp'
import { cn } from './utils'

function InputOTP({ className, containerClassName, maxLength = 6, renderSeparator, renderInput, ...props }: any) {
  return (
    <OTPInput data-slot="input-otp" maxLength={maxLength} className={cn('group flex *:data-[slot=input-otp-group]:gap-2', className)} containerClassName={containerClassName} renderSeparator={renderSeparator} renderInput={renderInput} {...props} />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="input-otp-group" className={cn('flex items-center gap-1', className)} {...props} /> }
function InputOTPSlot(props: any) { return (<div data-slot="input-otp-slot" className={cn('border-input text-foreground focus-within:border-ring focus-within:ring-ring/50 dark:bg-input/30 relative flex h-9 w-9 items-center justify-center rounded-md border ring-offset-background transition-[color,box-shadow] outline-none focus-within:ring-[3px] [&:has(input[data-input-otp])]:bg-input-background [&:has(input[data-input-otp])]:shadow-xs [&:has(input[data-input-otp])]:ring-offset-2', (props.value || props.char) ? 'bg-input-background shadow-xs ring-offset-2' : '')}><input data-input-otp {...props} className="text-muted-foreground font-medium absolute inset-0 size-full rounded-md bg-transparent text-center outline-hidden focus-visible:bg-transparent focus-visible:ring-0" /></div>) }
function InputOTPSeparator({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="input-otp-separator" role="separator" aria-orientation="vertical" className={cn('bg-border mx-2 w-px shrink-0', className)} {...props} /> }

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

==================================================
FILE_PATH: web/src/components/ui/skeleton.tsx
==================================================

import * as React from 'react'
import { cn } from './utils'

function Skeleton({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="skeleton" className={cn('bg-muted animate-pulse rounded-md', className)} {...props} /> }

export { Skeleton }

==================================================
FILE_PATH: web/src/components/ui/table.tsx
==================================================

/**
 * 表格组件
 * - 轻量封装语义化 `<table>` 结构与样式
 */
import * as React from 'react'
import { cn } from './utils'

function Table({ className, ...props }: React.ComponentProps<'table'>) { return <table data-slot="table" className={cn('w-full caption-bottom text-sm', className)} {...props} /> }
function TableHeader({ className, ...props }: React.ComponentProps<'thead'>) { return <thead data-slot="table-header" className={cn('[&_tr]:border-b', className)} {...props} /> }
function TableBody({ className, ...props }: React.ComponentProps<'tbody'>) { return <tbody data-slot="table-body" className={cn('[&_tr:last-child]:border-0', className)} {...props} /> }
function TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) { return <tfoot data-slot="table-footer" className={cn('bg-muted font-medium text-muted-foreground', className)} {...props} /> }
function TableRow({ className, ...props }: React.ComponentProps<'tr'>) { return <tr data-slot="table-row" className={cn('border-b transition-colors hover:bg-muted/50', className)} {...props} /> }
function TableHead({ className, ...props }: React.ComponentProps<'th'>) { return <th data-slot="table-head" className={cn('text-muted-foreground h-10 px-2 text-left align-middle font-medium', className)} {...props} /> }
function TableCell({ className, ...props }: React.ComponentProps<'td'>) { return <td data-slot="table-cell" className={cn('p-2 align-middle', className)} {...props} /> }
function TableCaption({ className, ...props }: React.ComponentProps<'caption'>) { return <caption data-slot="table-caption" className={cn('text-muted-foreground mt-4 text-sm', className)} {...props} /> }

export { Table, TableHeader, TableBody, TableFooter, TableRow, TableHead, TableCell, TableCaption }


==================================================
FILE_PATH: web/src/components/ui/ScrollText.tsx
==================================================

import { useEffect, useRef, useState } from 'react'
import { cn } from '@/lib/utils'

interface ScrollTextProps {
  text: string
  className?: string
  containerClassName?: string
}

export function ScrollText({ text, className, containerClassName }: ScrollTextProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const textRef = useRef<HTMLSpanElement>(null)
  const [shouldScroll, setShouldScroll] = useState(false)
  const [duration, setDuration] = useState(0)
  const [offset, setOffset] = useState(0)

  useEffect(() => {
    const checkScroll = () => {
      if (containerRef.current && textRef.current) {
        const containerWidth = containerRef.current.offsetWidth
        const textWidth = textRef.current.offsetWidth
        
        if (textWidth > containerWidth) {
          setShouldScroll(true)
          setOffset(textWidth - containerWidth + 8) // Add a bit of buffer
          
          // Calculate duration
          // Speed: 30px/s
          const scrollTime = (textWidth - containerWidth) / 30
          // Total: Start Pause (1.5s) + Scroll + End Pause (1.5s) + Scroll Back
          setDuration(3 + scrollTime * 2) 
        } else {
          setShouldScroll(false)
        }
      }
    }

    checkScroll()
    // Re-check on window resize
    window.addEventListener('resize', checkScroll)
    return () => window.removeEventListener('resize', checkScroll)
  }, [text])

  return (
    <div 
      ref={containerRef} 
      className={cn("overflow-hidden whitespace-nowrap relative mask-linear-fade", containerClassName)}
      title={text}
    >
      <span
        ref={textRef}
        className={cn(
          "inline-block",
          className
        )}
        style={shouldScroll ? {
          animation: `scroll-horizontal-once ${duration}s linear 1 forwards`,
          '--scroll-offset': `-${offset}px`
        } as React.CSSProperties : undefined}
      >
        {text}
      </span>
      <style>{`
        @keyframes scroll-horizontal-once {
          0%, 20% { transform: translateX(0); }
          45%, 65% { transform: translateX(var(--scroll-offset)); }
          90%, 100% { transform: translateX(0); }
        }
      `}</style>
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/ui/popover.tsx
==================================================

"use client"

import * as React from 'react'
import * as PopoverPrimitive from '@radix-ui/react-popover'
import { cn } from './utils'

function Popover(props: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger(props: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({ className, align = 'center', sideOffset = 4, ...props }: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden',
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor(props: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

==================================================
FILE_PATH: web/src/components/ui/select.tsx
==================================================

/**
 * 下拉选择组件（Radix Select）
 * - 封装 Trigger/Content/Item 等子组件
 * - 支持 Popper 定位与键盘可访问性
 */
"use client"

import * as React from 'react'
import * as SelectPrimitive from '@radix-ui/react-select'
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from 'lucide-react'
import { cn } from './utils'

function Select(props: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup(props: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue(props: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({ className, size = 'default', children, ...props }: React.ComponentProps<typeof SelectPrimitive.Trigger> & { size?: 'sm' | 'default' }) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-full items-center justify-between gap-2 rounded-md border bg-input-background px-3 py-2 text-sm whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({ className, children, position = 'popper', ...props }: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md',
          position === 'popper' &&
            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport className={cn('p-1', position === 'popper' && 'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1')}>
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return <SelectPrimitive.Label data-slot="select-label" className={cn('text-muted-foreground px-2 py-1.5 text-xs', className)} {...props} />
}

function SelectItem({ className, children, ...props }: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return <SelectPrimitive.Separator data-slot="select-separator" className={cn('bg-border pointer-events-none -mx-1 my-1 h-px', className)} {...props} />
}

function SelectScrollUpButton({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton data-slot="select-scroll-up-button" className={cn('flex cursor-default items-center justify-center py-1', className)} {...props}>
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({ className, ...props }: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton data-slot="select-scroll-down-button" className={cn('flex cursor-default items-center justify-center py-1', className)} {...props}>
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue
}


==================================================
FILE_PATH: web/src/components/ui/alert-dialog.tsx
==================================================

"use client"

import * as React from 'react'
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog'
import { cn } from './utils'
import { buttonVariants } from './button'

function AlertDialog(props: React.ComponentProps<typeof AlertDialogPrimitive.Root>) { return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} /> }
function AlertDialogTrigger(props: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) { return <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} /> }
function AlertDialogPortal(props: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) { return <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} /> }
function AlertDialogOverlay({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) { return <AlertDialogPrimitive.Overlay data-slot="alert-dialog-overlay" className={cn('data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50', className)} {...props} /> }
function AlertDialogContent({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Content>) { return (<AlertDialogPortal><AlertDialogOverlay /><AlertDialogPrimitive.Content data-slot="alert-dialog-content" className={cn('bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-fast sm:max-w-lg', className)} {...props} /></AlertDialogPortal>) }
function AlertDialogHeader({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="alert-dialog-header" className={cn('flex flex-col gap-2 text-center sm:text-left', className)} {...props} /> }
function AlertDialogFooter({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="alert-dialog-footer" className={cn('flex flex-col-reverse gap-2 sm:flex-row sm:justify-end', className)} {...props} /> }
function AlertDialogTitle({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Title>) { return <AlertDialogPrimitive.Title data-slot="alert-dialog-title" className={cn('text-lg font-semibold', className)} {...props} /> }
function AlertDialogDescription({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Description>) { return <AlertDialogPrimitive.Description data-slot="alert-dialog-description" className={cn('text-muted-foreground text-sm', className)} {...props} /> }
function AlertDialogAction({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Action>) { return <AlertDialogPrimitive.Action className={cn(buttonVariants(), className)} {...props} /> }
function AlertDialogCancel({ className, ...props }: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) { return <AlertDialogPrimitive.Cancel className={cn(buttonVariants({ variant: 'outline' }), className)} {...props} /> }

export { AlertDialog, AlertDialogPortal, AlertDialogOverlay, AlertDialogTrigger, AlertDialogContent, AlertDialogHeader, AlertDialogFooter, AlertDialogTitle, AlertDialogDescription, AlertDialogAction, AlertDialogCancel }

==================================================
FILE_PATH: web/src/components/ui/pagination.tsx
==================================================

import * as React from 'react'
import { cn } from './utils'
import { buttonVariants } from './button'

function Pagination({ className, ...props }: React.ComponentProps<'nav'>) { return <nav data-slot="pagination" className={cn('flex items-center justify-between gap-2 py-2', className)} {...props} /> }
function PaginationContent({ className, ...props }: React.ComponentProps<'ul'>) { return <ul data-slot="pagination-content" className={cn('flex items-center gap-1', className)} {...props} /> }
function PaginationItem({ className, ...props }: React.ComponentProps<'li'>) { return <li data-slot="pagination-item" className={cn('list-none', className)} {...props} /> }
function PaginationLink({ className, isActive, ...props }: React.ComponentProps<'a'> & { isActive?: boolean }) { return <a data-slot="pagination-link" aria-current={isActive ? 'page' : undefined} className={cn(buttonVariants({ variant: isActive ? 'default' : 'outline', size: 'sm' }), 'min-w-9 justify-center', className)} {...props} /> }
function PaginationPrevious({ className, ...props }: React.ComponentProps<'a'>) { return <a data-slot="pagination-previous" className={cn(buttonVariants({ variant: 'outline', size: 'sm' }), className)} {...props} /> }
function PaginationNext({ className, ...props }: React.ComponentProps<'a'>) { return <a data-slot="pagination-next" className={cn(buttonVariants({ variant: 'outline', size: 'sm' }), className)} {...props} /> }
function PaginationEllipsis({ className, ...props }: React.ComponentProps<'span'>) { return <span data-slot="pagination-ellipsis" className={cn('px-2 text-muted-foreground', className)} {...props}>…</span> }

export { Pagination, PaginationContent, PaginationItem, PaginationLink, PaginationPrevious, PaginationNext, PaginationEllipsis }

==================================================
FILE_PATH: web/src/components/ui/calendar.tsx
==================================================

"use client"

import * as React from 'react'
import { ChevronLeft, ChevronRight } from 'lucide-react'
import { DayPicker } from 'react-day-picker'
import { cn } from './utils'
import { buttonVariants } from './button'

function Calendar({ className, classNames, showOutsideDays = true, ...props }: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn('p-3', className)}
      classNames={{
        months: 'flex flex-col sm:flex-row gap-2',
        month: 'flex flex-col gap-4',
        caption: 'flex justify-center pt-1 relative items-center w-full',
        caption_label: 'text-sm font-medium',
        nav: 'flex items-center gap-1',
        nav_button: cn(buttonVariants({ variant: 'outline' }), 'size-7 bg-transparent p-0 opacity-50 hover:opacity-100'),
        nav_button_previous: 'absolute left-1',
        nav_button_next: 'absolute right-1',
        table: 'w-full border-collapse space-x-1',
        head_row: 'flex',
        head_cell: 'text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]',
        row: 'flex w-full mt-2',
        cell: cn('relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md', props.mode === 'range' ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md" : "[&:has([aria-selected])]:rounded-md"),
        day: cn(buttonVariants({ variant: 'ghost' }), 'size-8 p-0 font-normal aria-selected:opacity-100'),
        day_range_start: 'day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground',
        day_range_end: 'day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground',
        day_selected: 'bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground',
        day_today: 'bg-accent text-accent-foreground',
        day_outside: 'day-outside text-muted-foreground aria-selected:text-muted-foreground',
        day_disabled: 'text-muted-foreground opacity-50',
        day_range_middle: 'aria-selected:bg-accent aria-selected:text-accent-foreground',
        day_hidden: 'invisible',
        ...classNames,
      }}
      components={
        {
          IconLeft: (props: any) => <ChevronLeft className={cn('size-4', props?.className)} {...props} />,
          IconRight: (props: any) => <ChevronRight className={cn('size-4', props?.className)} {...props} />,
        } as any
      }
      {...props}
    />
  )
}

export { Calendar }

==================================================
FILE_PATH: web/src/components/ui/button.tsx
==================================================

/**
 * 通用按钮组件（Shadcn 风格）
 * - 使用 `class-variance-authority` 管理 `variant`/`size`
 * - 通过 `asChild` 支持将样式透传到自定义元素
 */
import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from './utils'

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive:
          'bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background text-foreground hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9 rounded-md',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

function Button({ className, variant, size, asChild = false, ...props }: React.ComponentProps<'button'> & VariantProps<typeof buttonVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button'
  return <Comp data-slot="button" className={cn(buttonVariants({ variant, size, className }))} {...props} />
}

export { Button, buttonVariants }


==================================================
FILE_PATH: web/src/components/ui/tooltip.tsx
==================================================

/**
 * 提示气泡组件（Radix Tooltip）
 * - Provider 包装以控制延迟
 * - 封装 Trigger/Content/Arrow
 */
"use client"

import * as React from 'react'
import * as TooltipPrimitive from '@radix-ui/react-tooltip'
import { cn } from './utils'

function TooltipProvider({ delayDuration = 0, ...props }: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return <TooltipPrimitive.Provider data-slot="tooltip-provider" delayDuration={delayDuration} {...props} />
}

function Tooltip(props: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger(props: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({ className, sideOffset = 0, children, ...props }: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance',
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


==================================================
FILE_PATH: web/src/components/ui/carousel.tsx
==================================================

"use client"

import * as React from 'react'
import useEmblaCarousel from 'embla-carousel-react'
import { cn } from './utils'

function Carousel({ className, options, children }: { className?: string; options?: any; children: React.ReactNode }) {
  const [emblaRef] = useEmblaCarousel(options)
  return (
    <div data-slot="carousel" className={cn('overflow-hidden', className)} ref={emblaRef}>
      <div className="flex">{children}</div>
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<'div'>) {
  return <div data-slot="carousel-item" className={cn('min-w-0 flex-[0_0_100%]', className)} {...props} />
}

export { Carousel, CarouselItem }

==================================================
FILE_PATH: web/src/components/ui/dropdown-menu.tsx
==================================================

"use client"

import * as React from 'react'
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'
import { cn } from './utils'

function DropdownMenu(props: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal(props: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
}

function DropdownMenuTrigger(props: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return <DropdownMenuPrimitive.Trigger data-slot="dropdown-menu-trigger" {...props} />
}

function DropdownMenuContent({ className, sideOffset = 4, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          // 使用明确的白色背景避免透明问题
          'bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100',
          'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          'z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-xl border border-gray-200 dark:border-gray-700 p-1 shadow-lg backdrop-blur-xl',
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup(props: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
}

function DropdownMenuItem({ className, inset, variant = 'default', ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & { inset?: boolean; variant?: 'default' | 'destructive' }) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({ className, children, checked, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        '[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*\'size-\'])]:size-4 focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup(props: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return <DropdownMenuPrimitive.RadioGroup data-slot="dropdown-menu-radio-group" {...props} />
}

function DropdownMenuRadioItem({ className, children, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        '[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*\'size-\'])]:size-4 focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({ className, inset, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & { inset?: boolean }) {
  return <DropdownMenuPrimitive.Label data-slot="dropdown-menu-label" data-inset={inset} className={cn('px-2 py-1.5 text-sm font-medium data-[inset]:pl-8', className)} {...props} />
}

function DropdownMenuSeparator({ className, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return <DropdownMenuPrimitive.Separator data-slot="dropdown-menu-separator" className={cn('bg-border -mx-1 my-1 h-px', className)} {...props} />
}

function DropdownMenuShortcut({ className, ...props }: React.ComponentProps<'span'>) {
  return <span data-slot="dropdown-menu-shortcut" className={cn('text-muted-foreground ml-auto text-xs tracking-widest', className)} {...props} />
}

function DropdownMenuSub(props: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({ className, inset, children, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & { inset?: boolean }) {
  return (
    <DropdownMenuPrimitive.SubTrigger data-slot="dropdown-menu-sub-trigger" data-inset={inset} className={cn('focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8', className)} {...props}>
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({ className, ...props }: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return <DropdownMenuPrimitive.SubContent data-slot="dropdown-menu-sub-content" className={cn('bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg', className)} {...props} />
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent
}

==================================================
FILE_PATH: web/src/components/ui/hover-card.tsx
==================================================

"use client"

import * as React from 'react'
import * as HoverCardPrimitive from '@radix-ui/react-hover-card'
import { cn } from './utils'

function HoverCard(props: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger(props: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
}

function HoverCardContent({ className, align = 'center', sideOffset = 4, ...props }: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn('bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden', className)}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }

==================================================
FILE_PATH: web/src/components/ui/sonner.tsx
==================================================

"use client"

import { Toaster, toast } from 'sonner'

export { Toaster, toast }

==================================================
FILE_PATH: web/src/components/ui/alert.tsx
==================================================

import * as React from 'react'
import { cn } from './utils'

function Alert({ className, variant = 'default', ...props }: React.ComponentProps<'div'> & { variant?: 'default' | 'destructive' }) {
  return <div data-slot="alert" data-variant={variant} className={cn('bg-card text-card-foreground relative w-full rounded-lg border p-4 [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg~*]:pl-7 [&>svg]:size-4 data-[variant=destructive]:border-destructive/80 data-[variant=destructive]:text-destructive [&>svg]:text-muted-foreground', className)} {...props} />
}
function AlertTitle({ className, ...props }: React.ComponentProps<'div'>) { return <h5 data-slot="alert-title" className={cn('leading-none font-medium tracking-tight', className)} {...props} /> }
function AlertDescription({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="alert-description" className={cn('text-sm [&_p]:leading-relaxed', className)} {...props} /> }

export { Alert, AlertTitle, AlertDescription }

==================================================
FILE_PATH: web/src/components/ui/use-mobile.ts
==================================================

import { useEffect, useState } from 'react'

function useMobile(breakpoint = 768) {
  const [isMobile, setIsMobile] = useState(false)
  useEffect(() => {
    const onResize = () => setIsMobile(window.innerWidth < breakpoint)
    onResize()
    window.addEventListener('resize', onResize)
    return () => window.removeEventListener('resize', onResize)
  }, [breakpoint])
  return isMobile
}

export { useMobile }

==================================================
FILE_PATH: web/src/components/ui/sidebar.tsx
==================================================

/**
 * 侧边栏组件
 * - 提供侧栏基础结构与菜单样式
 */
import * as React from 'react'
import { cn } from './utils'

function Sidebar({ className, ...props }: React.ComponentProps<'aside'>) { return <aside data-slot="sidebar" className={cn('bg-sidebar text-sidebar-foreground sticky top-0 z-40 flex h-screen max-h-screen w-64 flex-col border-r', className)} {...props} /> }
function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="sidebar-header" className={cn('p-4', className)} {...props} /> }
function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="sidebar-footer" className={cn('mt-auto p-4', className)} {...props} /> }
function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="sidebar-content" className={cn('flex-1 overflow-y-auto p-2', className)} {...props} /> }
function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="sidebar-group" className={cn('mb-2', className)} {...props} /> }
function SidebarGroupLabel({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="sidebar-group-label" className={cn('px-2 py-1 text-xs font-medium text-muted-foreground', className)} {...props} /> }
function SidebarGroupContent({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="sidebar-group-content" className={cn('grid gap-1', className)} {...props} /> }
function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) { return <ul data-slot="sidebar-menu" className={cn('grid gap-1', className)} {...props} /> }
function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) { return <li data-slot="sidebar-menu-item" className={cn('list-none', className)} {...props} /> }
function SidebarMenuButton({ className, ...props }: React.ComponentProps<'button'>) { return <button data-slot="sidebar-menu-button" className={cn('hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-sidebar-ring/50 inline-flex h-9 w-full items-center gap-2 rounded-md px-2 text-sm outline-hidden focus-visible:ring-[3px]', className)} {...props} /> }

export { Sidebar, SidebarHeader, SidebarFooter, SidebarContent, SidebarGroup, SidebarGroupLabel, SidebarGroupContent, SidebarMenu, SidebarMenuItem, SidebarMenuButton }


==================================================
FILE_PATH: web/src/components/ui/checkbox.tsx
==================================================

"use client"

import * as React from 'react'
import * as CheckboxPrimitive from '@radix-ui/react-checkbox'
import { CheckIcon } from 'lucide-react'
import { cn } from './utils'

function Checkbox({ className, ...props }: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        'peer border bg-input-background dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator data-slot="checkbox-indicator" className="flex items-center justify-center text-current transition-none">
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }

==================================================
FILE_PATH: web/src/components/ui/navigation-menu.tsx
==================================================

import * as React from 'react'
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu'
import { cva } from 'class-variance-authority'
import { ChevronDownIcon } from 'lucide-react'
import { cn } from './utils'

function NavigationMenu({ className, children, viewport = true, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & { viewport?: boolean }) {
  return (
    <NavigationMenuPrimitive.Root data-slot="navigation-menu" data-viewport={viewport} className={cn('group/navigation-menu relative flex max-w-max flex-1 items-center justify-center', className)} {...props}>
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({ className, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return <NavigationMenuPrimitive.List data-slot="navigation-menu-list" className={cn('group flex flex-1 list-none items-center justify-center gap-1', className)} {...props} />
}

function NavigationMenuItem({ className, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return <NavigationMenuPrimitive.Item data-slot="navigation-menu-item" className={cn('relative', className)} {...props} />
}

const navigationMenuTriggerStyle = cva('group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1')

function NavigationMenuTrigger({ className, children, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger data-slot="navigation-menu-trigger" className={cn(navigationMenuTriggerStyle(), 'group', className)} {...props}>
      {children}
      <ChevronDownIcon className="relative top-[1px] ml-1 size-3 transition duration-medium group-data-[state=open]:rotate-180" aria-hidden="true" />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({ className, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        'data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto',
        'group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-fast **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none',
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({ className, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div className={cn('absolute top-full left-0 isolate z-50 flex justify-center')}>
      <NavigationMenuPrimitive.Viewport data-slot="navigation-menu-viewport" className={cn('origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]', className)} {...props} />
    </div>
  )
}

function NavigationMenuLink({ className, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return <NavigationMenuPrimitive.Link data-slot="navigation-menu-link" className={cn("data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:ring-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-all outline-none focus-visible:ring-[3px] focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4", className)} {...props} />
}

function NavigationMenuIndicator({ className, ...props }: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator data-slot="navigation-menu-indicator" className={cn('data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden', className)} {...props}>
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle
}

==================================================
FILE_PATH: web/src/components/ui/badge.tsx
==================================================

import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from './utils'

const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default: 'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary: 'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive: 'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline: 'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground'
      }
    },
    defaultVariants: { variant: 'default' }
  }
)

function Badge({ className, variant, asChild = false, ...props }: React.ComponentProps<'span'> & VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span'
  return <Comp data-slot="badge" className={cn(badgeVariants({ variant }), className)} {...props} />
}

export { Badge, badgeVariants }

==================================================
FILE_PATH: web/src/components/ui/context-menu.tsx
==================================================

"use client"

import * as React from 'react'
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'
import { cn } from './utils'

function ContextMenu(props: React.ComponentProps<typeof ContextMenuPrimitive.Root>) { return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} /> }
function ContextMenuTrigger(props: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) { return <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} /> }
function ContextMenuContent({ className, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Content>) { return <ContextMenuPrimitive.Content data-slot="context-menu-content" className={cn('bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md', className)} {...props} /> }
function ContextMenuItem({ className, inset, variant = 'default', ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Item> & { inset?: boolean; variant?: 'default' | 'destructive' }) { return <ContextMenuPrimitive.Item data-slot="context-menu-item" data-inset={inset} data-variant={variant} className={cn("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className)} {...props} /> }
function ContextMenuSeparator({ className, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) { return <ContextMenuPrimitive.Separator data-slot="context-menu-separator" className={cn('bg-border -mx-1 my-1 h-px', className)} {...props} /> }
function ContextMenuLabel({ className, inset, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.Label> & { inset?: boolean }) { return <ContextMenuPrimitive.Label data-slot="context-menu-label" data-inset={inset} className={cn('px-2 py-1.5 text-sm font-medium data-[inset]:pl-8', className)} {...props} /> }
function ContextMenuCheckboxItem({ className, children, checked, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) { return (<ContextMenuPrimitive.CheckboxItem data-slot="context-menu-checkbox-item" className={cn('[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*\'size-\'])]:size-4 focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className)} checked={checked} {...props}><span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"><ContextMenuPrimitive.ItemIndicator><CheckIcon className="size-4" /></ContextMenuPrimitive.ItemIndicator></span>{children}</ContextMenuPrimitive.CheckboxItem>) }
function ContextMenuRadioGroup(props: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) { return <ContextMenuPrimitive.RadioGroup data-slot="context-menu-radio-group" {...props} /> }
function ContextMenuRadioItem({ className, children, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) { return (<ContextMenuPrimitive.RadioItem data-slot="context-menu-radio-item" className={cn('[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*\'size-\'])]:size-4 focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className)} {...props}><span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center"><ContextMenuPrimitive.ItemIndicator><CircleIcon className="size-2 fill-current" /></ContextMenuPrimitive.ItemIndicator></span>{children}</ContextMenuPrimitive.RadioItem>) }
function ContextMenuSub(props: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) { return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} /> }
function ContextMenuSubTrigger({ className, inset, children, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & { inset?: boolean }) { return (<ContextMenuPrimitive.SubTrigger data-slot="context-menu-sub-trigger" data-inset={inset} className={cn('focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8', className)} {...props}>{children}<ChevronRightIcon className="ml-auto size-4" /></ContextMenuPrimitive.SubTrigger>) }
function ContextMenuSubContent({ className, ...props }: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) { return <ContextMenuPrimitive.SubContent data-slot="context-menu-sub-content" className={cn('bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg', className)} {...props} /> }

export { ContextMenu, ContextMenuTrigger, ContextMenuContent, ContextMenuItem, ContextMenuSeparator, ContextMenuLabel, ContextMenuCheckboxItem, ContextMenuRadioGroup, ContextMenuRadioItem, ContextMenuSub, ContextMenuSubTrigger, ContextMenuSubContent }

==================================================
FILE_PATH: web/src/components/ui/breadcrumb.tsx
==================================================

import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { ChevronRight, MoreHorizontal } from 'lucide-react'
import { cn } from './utils'

function Breadcrumb(props: React.ComponentProps<'nav'>) { return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} /> }
function BreadcrumbList({ className, ...props }: React.ComponentProps<'ol'>) { return <ol data-slot="breadcrumb-list" className={cn('text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5', className)} {...props} /> }
function BreadcrumbItem({ className, ...props }: React.ComponentProps<'li'>) { return <li data-slot="breadcrumb-item" className={cn('inline-flex items-center gap-1.5', className)} {...props} /> }
function BreadcrumbLink({ asChild, className, ...props }: React.ComponentProps<'a'> & { asChild?: boolean }) { const Comp = asChild ? Slot : 'a'; return <Comp data-slot="breadcrumb-link" className={cn('hover:text-foreground transition-colors', className)} {...props} /> }
function BreadcrumbPage({ className, ...props }: React.ComponentProps<'span'>) { return <span data-slot="breadcrumb-page" role="link" aria-disabled="true" aria-current="page" className={cn('text-foreground font-normal', className)} {...props} /> }
function BreadcrumbSeparator({ children, className, ...props }: React.ComponentProps<'li'>) { return <li data-slot="breadcrumb-separator" role="presentation" aria-hidden="true" className={cn('[&>svg]:size-3.5', className)} {...props}>{children ?? <ChevronRight />}</li> }
function BreadcrumbEllipsis({ className, ...props }: React.ComponentProps<'span'>) { return <span data-slot="breadcrumb-ellipsis" role="presentation" aria-hidden="true" className={cn('flex size-9 items-center justify-center', className)} {...props}><MoreHorizontal className="size-4" /><span className="sr-only">More</span></span> }

export { Breadcrumb, BreadcrumbList, BreadcrumbItem, BreadcrumbLink, BreadcrumbPage, BreadcrumbSeparator, BreadcrumbEllipsis }

==================================================
FILE_PATH: web/src/components/ui/command.tsx
==================================================

"use client"

import * as React from 'react'
import { Command as CommandPrimitive } from 'cmdk'
import { SearchIcon } from 'lucide-react'
import { cn } from './utils'
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from './dialog'

function Command(props: React.ComponentProps<typeof CommandPrimitive>) {
  return <CommandPrimitive data-slot="command" className={cn('bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md', props.className)} {...props} />
}

function CommandDialog({ title = 'Command Palette', description = 'Search for a command to run...', children, ...props }: React.ComponentProps<typeof Dialog> & { title?: string; description?: string }) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput(props: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div data-slot="command-input-wrapper" className="flex h-9 items-center gap-2 border-b px-3">
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input data-slot="command-input" className={cn('placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50', props.className)} {...props} />
    </div>
  )
}

function CommandList(props: React.ComponentProps<typeof CommandPrimitive.List>) {
  return <CommandPrimitive.List data-slot="command-list" className={cn('max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto', props.className)} {...props} />
}

function CommandEmpty(props: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return <CommandPrimitive.Empty data-slot="command-empty" className="py-6 text-center text-sm" {...props} />
}

function CommandGroup(props: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return <CommandPrimitive.Group data-slot="command-group" className={cn('text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium', props.className)} {...props} />
}

function CommandSeparator(props: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return <CommandPrimitive.Separator data-slot="command-separator" className={cn('bg-border -mx-1 h-px', props.className)} {...props} />
}

function CommandItem(props: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return <CommandPrimitive.Item data-slot="command-item" className={cn("data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", props.className)} {...props} />
}

function CommandShortcut(props: React.ComponentProps<'span'>) {
  return <span data-slot="command-shortcut" className={cn('text-muted-foreground ml-auto text-xs tracking-widest', props.className)} {...props} />
}

export { Command, CommandDialog, CommandInput, CommandList, CommandEmpty, CommandGroup, CommandItem, CommandShortcut, CommandSeparator }

==================================================
FILE_PATH: web/src/components/ui/form.tsx
==================================================

import * as React from 'react'
import { cn } from './utils'

function Form({ className, ...props }: React.ComponentProps<'form'>) { return <form data-slot="form" className={cn('grid gap-4', className)} {...props} /> }
function FormField({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="form-field" className={cn('grid gap-2', className)} {...props} /> }
function FormLabel({ className, ...props }: React.ComponentProps<'label'>) { return <label data-slot="form-label" className={cn('text-sm font-medium', className)} {...props} /> }
function FormControl({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="form-control" className={cn('grid', className)} {...props} /> }
function FormDescription({ className, ...props }: React.ComponentProps<'p'>) { return <p data-slot="form-description" className={cn('text-muted-foreground text-xs', className)} {...props} /> }
function FormMessage({ className, ...props }: React.ComponentProps<'p'>) { return <p data-slot="form-message" className={cn('text-destructive text-xs', className)} {...props} /> }

export { Form, FormField, FormLabel, FormControl, FormDescription, FormMessage }

==================================================
FILE_PATH: web/src/components/ui/separator.tsx
==================================================

"use client"

import * as React from 'react'
import * as SeparatorPrimitive from '@radix-ui/react-separator'
import { cn } from './utils'

function Separator({ className, orientation = 'horizontal', decorative = true, ...props }: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn('bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px', className)}
      {...props}
    />
  )
}

export { Separator }

==================================================
FILE_PATH: web/src/components/ui/input.tsx
==================================================

/**
 * 通用输入框组件
 * - 统一表单输入样式与焦点态
 */
import * as React from 'react'
import { cn } from './utils'

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return <input data-slot="input" type={type} className={cn('border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex h-9 w-full rounded-md border bg-input-background px-3 py-2 text-sm transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50', className)} {...props} />
}

export { Input }


==================================================
FILE_PATH: web/src/components/ui/radio-group.tsx
==================================================

"use client"

import * as React from 'react'
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group'
import { CircleIcon } from 'lucide-react'
import { cn } from './utils'

function RadioGroup({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return <RadioGroupPrimitive.Root data-slot="radio-group" className={cn('grid gap-3', className)} {...props} />
}

function RadioGroupItem({ className, ...props }: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item data-slot="radio-group-item" className={cn('border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50', className)} {...props}>
      <RadioGroupPrimitive.Indicator data-slot="radio-group-indicator" className="relative flex items-center justify-center">
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }

==================================================
FILE_PATH: web/src/components/ui/drawer.tsx
==================================================

/**
 * 抽屉组件（Vaul）
 * - 提供底部弹出抽屉的结构与样式
 * - 封装 Trigger/Overlay/Content 等子组件
 */
"use client"

import * as React from 'react'
import { Drawer as VaulDrawer } from 'vaul'
import { cn } from './utils'

function Drawer({ className, ...props }: any) {
  return <VaulDrawer.Root data-slot="drawer" className={cn(className)} {...props} />
}

function DrawerTrigger(props: React.ComponentProps<typeof VaulDrawer.Trigger>) { return <VaulDrawer.Trigger data-slot="drawer-trigger" {...props} /> }
function DrawerPortal(props: React.ComponentProps<typeof VaulDrawer.Portal>) { return <VaulDrawer.Portal data-slot="drawer-portal" {...props} /> }
function DrawerOverlay(props: React.ComponentProps<typeof VaulDrawer.Overlay>) { return <VaulDrawer.Overlay data-slot="drawer-overlay" {...props} /> }
function DrawerContent({ className, ...props }: React.ComponentProps<typeof VaulDrawer.Content>) { return <VaulDrawer.Content data-slot="drawer-content" className={cn('bg-popover text-popover-foreground fixed inset-x-0 bottom-0 z-50 flex h-auto w-full flex-col rounded-t-[10px] border', className)} {...props} /> }
function DrawerHeader({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="drawer-header" className={cn('grid gap-2 px-4 pt-4', className)} {...props} /> }
function DrawerFooter({ className, ...props }: React.ComponentProps<'div'>) { return <div data-slot="drawer-footer" className={cn('grid gap-2 px-4 pb-4', className)} {...props} /> }
function DrawerTitle({ className, ...props }: React.ComponentProps<'div'>) { return <h5 data-slot="drawer-title" className={cn('text-lg font-semibold', className)} {...props} /> }
function DrawerDescription({ className, ...props }: React.ComponentProps<'div'>) { return <p data-slot="drawer-description" className={cn('text-sm text-muted-foreground', className)} {...props} /> }

export { Drawer, DrawerTrigger, DrawerPortal, DrawerOverlay, DrawerContent, DrawerHeader, DrawerFooter, DrawerTitle, DrawerDescription }


==================================================
FILE_PATH: web/src/components/ui/tabs.tsx
==================================================

"use client"

import * as React from 'react'
import * as TabsPrimitive from '@radix-ui/react-tabs'
import { cn } from './utils'

function Tabs({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return <TabsPrimitive.Root data-slot="tabs" className={cn('flex flex-col gap-2', className)} {...props} />
}

function TabsList({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn('bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-xl p-[3px] flex', className)}
      {...props}
    />
  )
}

function TabsTrigger({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-card dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-xl border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({ className, ...props }: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return <TabsPrimitive.Content data-slot="tabs-content" className={cn('flex-1 outline-none', className)} {...props} />
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

==================================================
FILE_PATH: web/src/components/ui/accordion.tsx
==================================================

"use client"

import * as React from 'react'
import * as AccordionPrimitive from '@radix-ui/react-accordion'
import { ChevronDownIcon } from 'lucide-react'
import { cn } from './utils'

function Accordion(props: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({ className, ...props }: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return <AccordionPrimitive.Item data-slot="accordion-item" className={cn('border-b last:border-b-0', className)} {...props} />
}

function AccordionTrigger({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-fast" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({ className, children, ...props }: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content data-slot="accordion-content" className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm" {...props}>
      <div className={cn('pt-0 pb-4', className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

==================================================
FILE_PATH: web/src/components/ui/switch.tsx
==================================================

"use client"

import * as React from 'react'
import * as SwitchPrimitive from '@radix-ui/react-switch'
import { cn } from './utils'

function Switch({ className, ...props }: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        'peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-switch-background focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb data-slot="switch-thumb" className={cn('bg-card dark:data-[state=unchecked]:bg-card-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0')} />
    </SwitchPrimitive.Root>
  )
}

export { Switch }

==================================================
FILE_PATH: web/src/components/ui/menubar.tsx
==================================================

"use client"

import * as React from 'react'
import * as MenubarPrimitive from '@radix-ui/react-menubar'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'
import { cn } from './utils'

function Menubar({ className, ...props }: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return <MenubarPrimitive.Root data-slot="menubar" className={cn('bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs', className)} {...props} />
}

function MenubarMenu(props: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup(props: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal(props: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup(props: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
}

function MenubarTrigger({ className, ...props }: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return <MenubarPrimitive.Trigger data-slot="menubar-trigger" className={cn('focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none', className)} {...props} />
}

function MenubarContent({ className, align = 'start', alignOffset = -4, sideOffset = 8, ...props }: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn('bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md', className)}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({ className, inset, variant = 'default', ...props }: React.ComponentProps<typeof MenubarPrimitive.Item> & { inset?: boolean; variant?: 'default' | 'destructive' }) {
  return (
    <MenubarPrimitive.Item data-slot="menubar-item" data-inset={inset} data-variant={variant} className={cn("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", className)} {...props} />
  )
}

function MenubarCheckboxItem({ className, children, checked, ...props }: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem data-slot="menubar-checkbox-item" className={cn('[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*\'size-\'])]:size-4 focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className)} checked={checked} {...props}>
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({ className, children, ...props }: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem data-slot="menubar-radio-item" className={cn('[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*\'size-\'])]:size-4 focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className)} {...props}>
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({ className, inset, ...props }: React.ComponentProps<typeof MenubarPrimitive.Label> & { inset?: boolean }) {
  return <MenubarPrimitive.Label data-slot="menubar-label" data-inset={inset} className={cn('px-2 py-1.5 text-sm font-medium data-[inset]:pl-8', className)} {...props} />
}

function MenubarSeparator({ className, ...props }: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return <MenubarPrimitive.Separator data-slot="menubar-separator" className={cn('bg-border -mx-1 my-1 h-px', className)} {...props} />
}

function MenubarShortcut({ className, ...props }: React.ComponentProps<'span'>) {
  return <span data-slot="menubar-shortcut" className={cn('text-muted-foreground ml-auto text-xs tracking-widest', className)} {...props} />
}

function MenubarSub(props: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({ className, inset, children, ...props }: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & { inset?: boolean }) {
  return (
    <MenubarPrimitive.SubTrigger data-slot="menubar-sub-trigger" data-inset={inset} className={cn('focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8', className)} {...props}>
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({ className, ...props }: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return <MenubarPrimitive.SubContent data-slot="menubar-sub-content" className={cn('bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg', className)} {...props} />
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent
}

==================================================
FILE_PATH: web/src/components/ui/toggle.tsx
==================================================

"use client"

import * as React from 'react'
import * as TogglePrimitive from '@radix-ui/react-toggle'
import { cn } from './utils'

function Toggle({ className, ...props }: React.ComponentProps<typeof TogglePrimitive.Root>) {
  return <TogglePrimitive.Root data-slot="toggle" className={cn('hover:bg-accent hover:text-accent-foreground focus-visible:ring-ring/50 inline-flex items-center justify-center gap-2 rounded-md border border-transparent bg-transparent px-2 py-1 text-sm transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground', className)} {...props} />
}

export { Toggle }

==================================================
FILE_PATH: web/src/components/ui/aspect-ratio.tsx
==================================================

"use client"

import * as React from 'react'
import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio'

function AspectRatio(props: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }

==================================================
FILE_PATH: web/src/components/ui/Modal.tsx
==================================================

import { useEffect, useCallback } from 'react'
import { createPortal } from 'react-dom'
import { X } from 'lucide-react'
import { cn } from '@/lib/utils'

interface ModalProps {
  children: React.ReactNode
  onClose?: () => void
  showCloseButton?: boolean
  /** 自定义类名 */
  className?: string
}

export default function Modal({ children, onClose, showCloseButton = false, className }: ModalProps) {
  // ESC 键关闭
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (e.key === 'Escape' && onClose) {
      onClose()
    }
  }, [onClose])

  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown)
    // 阻止背景滚动
    document.body.style.overflow = 'hidden'
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.body.style.overflow = ''
    }
  }, [handleKeyDown])

  // 点击遮罩关闭
  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget && onClose) {
      onClose()
    }
  }, [onClose])

  return createPortal(
    <div 
      className="fixed inset-0 z-[100] grid place-items-center bg-black/20 backdrop-blur-sm animate-in fade-in-0 duration-fast"
      onClick={handleBackdropClick}
    >
      <div 
        className={cn(
          // 白色毛玻璃效果 + 强阴影 (统一风格)
          // 移动端适配: w-[calc(100%-2rem)] 确保左右留有间隙, max-w-md 限制最大宽度
          'relative w-[calc(100%-2rem)] max-w-md rounded-2xl p-6',
          'bg-white/95 dark:bg-gray-900/95 backdrop-blur-xl',
          'shadow-2xl',
          'border border-gray-200/50 dark:border-white/10',
          // 缩放进入动效 - 从中心由小变大
          'animate-in fade-in-0 zoom-in-95 duration-fast',
          className
        )}
        style={{ transformOrigin: 'center' }}
        onClick={(e) => e.stopPropagation()}
      >
        {showCloseButton && onClose && (
          <button
            onClick={onClose}
            className="absolute top-4 right-4 p-2 rounded-full hover:bg-secondary-background transition-colors"
            aria-label="Close"
          >
            <X className="h-5 w-5 text-secondary-label" />
          </button>
        )}
        {children}
      </div>
    </div>,
    document.body
  )
}

==================================================
FILE_PATH: web/src/components/ui/chart.tsx
==================================================

"use client"

import * as React from 'react'
import * as RechartsPrimitive from 'recharts'
import { cn } from './utils'

const THEMES = { light: '', dark: '.dark' } as const

export type ChartConfig = { [k: string]: { label?: React.ReactNode; icon?: React.ComponentType } & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> }) }

type ChartContextProps = { config: ChartConfig }
const ChartContext = React.createContext<ChartContextProps | null>(null)
function useChart() { const ctx = React.useContext(ChartContext); if (!ctx) throw new Error('useChart must be used within a <ChartContainer />'); return ctx }

function ChartContainer({ id, className, children, config, ...props }: React.ComponentProps<'div'> & { config: ChartConfig; children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>['children'] }) {
  const uniqueId = React.useId(); const chartId = `chart-${id || uniqueId.replace(/:/g, '')}`
  return (
    <ChartContext.Provider value={{ config }}>
      <div data-slot="chart" data-chart={chartId} className={cn('[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke=\'#ccc\']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke=\'#ccc\']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke=\'#ccc\']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke=\'#fff\']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke=\'#fff\']]:stroke-transparent [&_.recharts-surface]:outline-hidden', className)} {...props}>
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(([, cfg]) => cfg.theme || cfg.color)
  if (!colorConfig.length) return null
  return (
    <style dangerouslySetInnerHTML={{ __html: Object.entries(THEMES).map(([theme, prefix]) => `${prefix} [data-chart=${id}] {
${colorConfig.map(([key, item]) => { const color = item.theme?.[theme as keyof typeof item.theme] || item.color; return color ? `  --color-${key}: ${color};` : null }).join('\n')}
}` ).join('\n') }} />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({ active, payload, className, indicator = 'dot', hideLabel = false, hideIndicator = false, label, labelFormatter, labelClassName, formatter, color, nameKey, labelKey }: any) {
  const { config } = useChart()
  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) return null
    const [item] = payload
    const key = `${labelKey || (item as any)?.dataKey || (item as any)?.name || 'value'}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value = !labelKey && typeof label === 'string' ? (config as any)[label]?.label || label : itemConfig?.label
    if (labelFormatter) return <div className={cn('font-medium', labelClassName)}>{labelFormatter(value, payload)}</div>
    if (!value) return null
    return <div className={cn('font-medium', labelClassName)}>{value}</div>
  }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey])
  if (!active || !payload?.length) return null
  const nestLabel = payload.length === 1 && indicator !== 'dot'
  return (
    <div className={cn('border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl', className)}>
      {!nestLabel ? tooltipLabel : null}
      <div className='grid gap-1.5'>
        {payload.map((item: any, index: number) => {
          const key = `${nameKey || item.name || item.dataKey || 'value'}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload?.fill || item.color
          return (
            <div key={item.dataKey} className={cn("[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5", indicator === 'dot' && 'items-center')}>
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div className={cn('shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)', { 'h-2.5 w-2.5': indicator === 'dot', 'w-1': indicator === 'line', 'w-0 border-[1.5px] border-dashed bg-transparent': indicator === 'dashed', 'my-0.5': nestLabel && indicator === 'dashed' })} style={{ ['--color-bg' as any]: indicatorColor, ['--color-border' as any]: indicatorColor }} />
                    )
                  )}
                  <div className={cn('flex flex-1 justify-between leading-none', nestLabel ? 'items-end' : 'items-center')}>
                    <div className='grid gap-1.5'>
                      {nestLabel ? tooltipLabel : null}
                      <span className='text-muted-foreground'>{itemConfig?.label || item.name}</span>
                    </div>
                    {item.value && <span className='text-foreground font-mono font-medium tabular-nums'>{Number(item.value).toLocaleString()}</span>}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend
function ChartLegendContent({ className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey }: React.ComponentProps<'div'> & { payload?: any[]; verticalAlign?: 'top' | 'bottom' | 'middle'; hideIcon?: boolean; nameKey?: string }) {
  const { config } = useChart(); if (!payload?.length) return null
  return (
    <div className={cn('flex items-center justify-center gap-4', verticalAlign === 'top' ? 'pb-3' : 'pt-3', className)}>
      {payload.map((item: any) => {
        const key = `${nameKey || item.dataKey || 'value'}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)
        return (
          <div key={item.value} className={cn('[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3')}>
            {itemConfig?.icon && !hideIcon ? <itemConfig.icon /> : <div className='h-2 w-2 shrink-0 rounded-[2px]' style={{ backgroundColor: item.color }} />}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

function getPayloadConfigFromPayload(config: ChartConfig, payload: any, key: string) {
  if (typeof payload !== 'object' || payload === null) return undefined
  const payloadPayload = 'payload' in payload && typeof payload.payload === 'object' && payload.payload !== null ? payload.payload : undefined
  let configLabelKey: string = key
  if (key in payload && typeof (payload as any)[key] === 'string') configLabelKey = (payload as any)[key] as string
  else if (payloadPayload && key in payloadPayload && typeof (payloadPayload as any)[key] === 'string') configLabelKey = (payloadPayload as any)[key] as string
  return configLabelKey in config ? config[configLabelKey] : (config as any)[key]
}

export { ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent, ChartStyle }

==================================================
FILE_PATH: web/src/components/ui/scroll-area.tsx
==================================================

"use client"

import * as React from 'react'
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area'
import { cn } from './utils'

function ScrollArea({ className, children, ...props }: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root data-slot="scroll-area" className={cn('relative', className)} {...props}>
      <ScrollAreaPrimitive.Viewport data-slot="scroll-area-viewport" className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1">
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({ className, orientation = 'vertical', ...props }: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar data-slot="scroll-area-scrollbar" orientation={orientation} className={cn('flex touch-none p-px transition-colors select-none', orientation === 'vertical' && 'h-full w-2.5 border-l border-l-transparent', orientation === 'horizontal' && 'h-2.5 flex-col border-t border-t-transparent', className)} {...props}>
      <ScrollAreaPrimitive.ScrollAreaThumb data-slot="scroll-area-thumb" className="bg-border relative flex-1 rounded-full" />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

==================================================
FILE_PATH: web/src/components/ui/avatar.tsx
==================================================

"use client"

import * as React from 'react'
import * as AvatarPrimitive from '@radix-ui/react-avatar'
import { cn } from './utils'

function Avatar({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return <AvatarPrimitive.Root data-slot="avatar" className={cn('relative flex size-10 shrink-0 overflow-hidden rounded-full', className)} {...props} />
}

function AvatarImage({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return <AvatarPrimitive.Image data-slot="avatar-image" className={cn('aspect-square size-full', className)} {...props} />
}

function AvatarFallback({ className, ...props }: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return <AvatarPrimitive.Fallback data-slot="avatar-fallback" className={cn('bg-muted flex size-full items-center justify-center rounded-full', className)} {...props} />
}

export { Avatar, AvatarImage, AvatarFallback }

==================================================
FILE_PATH: web/src/components/BookCard/BookCardGrid.tsx
==================================================

/**
 * BookCardGrid - 网格视图书籍卡片
 * 
 * 用于书架网格布局，竖向封面展示
 * 
 * @see 06 - UIUX设计系统UI_UX_Design_system.md
 */
import { Check, Loader2, Scan } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useTranslation } from 'react-i18next'
import { toast } from '@/components/ui/sonner'
import BookCardMenu from '../BookCardMenu'
import { BookCover, ProcessingPlaceholder, StatusIcon } from './BookCardParts'
import type { NormalizedBookProps, BookCardCallbacks } from './types'

interface BookCardGridProps extends NormalizedBookProps, BookCardCallbacks {
  className?: string
}

export default function BookCardGrid(props: BookCardGridProps) {
  const { t } = useTranslation('common')
  const {
    id,
    title,
    author,
    coverUrl,
    coverColor,
    progress,
    status,
    isFinished,
    ocrStatus,
    isImageBased,
    isCompleted,
    showCloudIcon,
    isProcessing,
    isOcrProcessing,
    processingText,
    onClick,
    onSyncClick,
    onDeleted,
    onFinishedChange,
    onMetadataChange,
    onOcrTrigger,
    className,
  } = props

  // 根据状态获取处理中文本
  const getProcessingText = () => {
    if (processingText) return processingText
    switch (status) {
      case 'converting': return t('book_status.converting')
      case 'ocr': return t('book_status.ocr_processing')
      default: return t('book_status.processing')
    }
  }

  // 处理卡片点击
  const handleCardClick = () => {
    if (isProcessing || status === 'downloading') return
    
    if (isOcrProcessing) {
      toast.info(t('book_status.ocr_in_progress', '正在进行文字识别，请稍候...'))
      return
    }
    
    if (status === 'cloud' && onSyncClick) {
      onSyncClick()
    } else {
      onClick?.()
    }
  }

  // 处理中状态 - 显示脉冲动效卡片
  if (isProcessing) {
    return (
      <div className={cn('group relative flex flex-col', className)}>
        <div className="relative aspect-[2/3] w-full overflow-hidden rounded-lg shadow-md">
          <ProcessingPlaceholder 
            text={getProcessingText()} 
            className="h-full w-full rounded-lg" 
          />
        </div>
        <div className="mt-2 h-5" />
      </div>
    )
  }
    
  return (
    <div
      onClick={handleCardClick}
      className={cn(
        'group relative flex flex-col cursor-pointer transition-transform hover:scale-[1.02]',
        className
      )}
    >
      {/* 封面 - 带阴影 */}
      <div className="relative aspect-[2/3] w-full overflow-hidden rounded-lg shadow-md">
        <BookCover coverUrl={coverUrl} title={title} className="h-full w-full rounded-lg">
          {/* 云状态图标 */}
          {showCloudIcon && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/20">
              <StatusIcon status={status} coverColor={coverColor} />
            </div>
          )}
          
          {/* 底部信息栏 - 覆盖在封面上 */}
          <div className="absolute bottom-0 left-0 right-0 flex items-center justify-between p-2 bg-gradient-to-t from-black/60 to-transparent">
            {/* 左下角：进度或已读完状态 */}
            <span className="text-xs font-medium text-white">
              {isCompleted ? (
                <span className="flex items-center gap-1">
                  <Check className="h-3 w-3" /> 已读完
                </span>
              ) : (
                `${Math.round(progress)}%`
              )}
            </span>
            
            {/* 右下角：三点菜单 */}
            {id && (
              <BookCardMenu
                bookId={id}
                bookTitle={title}
                bookAuthor={author}
                isFinished={isFinished}
                ocrStatus={ocrStatus}
                isImageBased={isImageBased}
                onDeleted={() => onDeleted?.(id)}
                onFinishedChange={(finished) => onFinishedChange?.(id, finished)}
                onMetadataChange={(metadata) => onMetadataChange?.(id, metadata)}
                onOcrTrigger={() => onOcrTrigger?.(id)}
                buttonClassName="text-white"
              />
            )}
          </div>

          {/* OCR 处理中图标 */}
          {isOcrProcessing && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/30 rounded-lg">
              <div className="flex flex-col items-center gap-2">
                <Scan className="w-6 h-6 text-white animate-pulse" />
                <span className="text-xs text-white font-medium">OCR 处理中</span>
              </div>
            </div>
          )}
        </BookCover>
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/BookCard/BookCardHero.tsx
==================================================

/**
 * BookCardHero - 大尺寸继续阅读卡片
 * 
 * 用于首页"继续阅读"区域的大卡片展示
 */
import { useState, useEffect } from 'react'
import { MoreHorizontal } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useTranslation } from 'react-i18next'
import { toast } from '@/components/ui/sonner'
import { extractDominantColor } from '@/lib/color-utils'
import { BookCover, StatusIcon, ProgressBar } from './BookCardParts'
import type { NormalizedBookProps, BookCardCallbacks } from './types'

interface BookCardHeroProps extends NormalizedBookProps, BookCardCallbacks {
  className?: string
}

export default function BookCardHero(props: BookCardHeroProps) {
  const { t } = useTranslation('common')
  const {
    id,
    title,
    author,
    coverUrl,
    coverColor,
    progress,
    status,
    isCompleted,
    showProgress,
    showCloudIcon,
    isProcessing,
    isOcrProcessing,
    onClick,
    onSyncClick,
    onMoreClick,
    className,
  } = props

  // 状态用于存储提取的主色调
  const [dominantColor, setDominantColor] = useState(coverColor || '#6B7280')

  useEffect(() => {
    if (coverUrl && !coverColor) {
      extractDominantColor(coverUrl).then(setDominantColor)
    } else if (coverColor) {
      setDominantColor(coverColor)
    }
  }, [coverUrl, coverColor])

  // 处理卡片点击
  const handleCardClick = () => {
    if (isProcessing || status === 'downloading') return
    
    if (isOcrProcessing) {
      toast.info(t('book_status.ocr_in_progress', '正在进行文字识别，请稍候...'))
      return
    }
    
    if (status === 'cloud' && onSyncClick) {
      onSyncClick()
    } else {
      onClick?.()
    }
  }

  return (
    <div
      onClick={handleCardClick}
      className={cn(
        'relative flex h-40 cursor-pointer overflow-hidden rounded-xl transition-transform hover:scale-[1.02]',
        className
      )}
    >
      {/* Ambient Blur 背景 */}
      <div 
        className="absolute inset-0 blur-3xl opacity-30"
        style={{ backgroundColor: dominantColor }}
      />
      
      {/* 内容层 */}
      <div className="relative flex w-full gap-4 p-4">
        {/* 封面 */}
        <div className="relative aspect-[2/3] h-full shrink-0 overflow-hidden rounded-md shadow-lg">
          <BookCover coverUrl={coverUrl} title={title} className="h-full w-full">
            {showCloudIcon && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/20">
                <StatusIcon status={status} coverColor={dominantColor} />
              </div>
            )}
          </BookCover>
        </div>
        
        {/* 元数据 */}
        <div className="flex flex-1 flex-col justify-between py-1">
          <div>
            <h3 className="font-bold text-label line-clamp-2">{title}</h3>
            {author && (
              <p className="mt-1 text-sm text-secondary-label line-clamp-1">{author}</p>
            )}
            <p className="mt-1 text-xs text-tertiary-label">
              图书 · {isCompleted ? '已读完' : `${Math.round(progress)}%`}
            </p>
          </div>
          
          {/* 进度条 */}
          {showProgress && <ProgressBar progress={progress} />}
        </div>
        
        {/* 更多按钮 */}
        {onMoreClick && (
          <button
            onClick={(e) => { e.stopPropagation(); onMoreClick(); }}
            className="absolute bottom-4 right-4 p-1 rounded-full hover:bg-white/20 transition-colors"
          >
            <MoreHorizontal className="h-5 w-5 text-secondary-label" />
          </button>
        )}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/BookCard/BookCardDefault.tsx
==================================================

/**
 * BookCardDefault - 默认简单卡片
 * 
 * 基础卡片样式，用于兼容旧版场景
 */
import { cn } from '@/lib/utils'
import { useTranslation } from 'react-i18next'
import { toast } from '@/components/ui/sonner'
import type { NormalizedBookProps, BookCardCallbacks } from './types'

interface BookCardDefaultProps extends NormalizedBookProps, BookCardCallbacks {
  className?: string
}

export default function BookCardDefault(props: BookCardDefaultProps) {
  const { t } = useTranslation('common')
  const {
    title,
    author,
    downloadUrl,
    status,
    isProcessing,
    isOcrProcessing,
    onClick,
    onSyncClick,
    className,
  } = props

  // 处理卡片点击
  const handleCardClick = () => {
    if (isProcessing || status === 'downloading') return
    
    if (isOcrProcessing) {
      toast.info(t('book_status.ocr_in_progress', '正在进行文字识别，请稍候...'))
      return
    }
    
    if (status === 'cloud' && onSyncClick) {
      onSyncClick()
    } else {
      onClick?.()
    }
  }

  return (
    <div
      onClick={handleCardClick}
      className={cn(
        'rounded-lg border border-gray-200 dark:border-gray-700 p-3 cursor-pointer transition-all hover:shadow-md hover:border-system-blue/30',
        className
      )}
    >
      <div className="font-semibold text-label line-clamp-2">{title}</div>
      {author && (
        <p className="mt-1 text-sm text-secondary-label">{author}</p>
      )}
      {downloadUrl && (
        <a
          href={downloadUrl}
          target="_blank"
          rel="noreferrer"
          className="mt-2 inline-block text-sm text-system-blue hover:underline"
          onClick={(e) => e.stopPropagation()}
        >
          下载
        </a>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/BookCard/types.ts
==================================================

/**
 * BookCard 类型定义
 * 
 * 统一管理所有 BookCard 相关类型
 */
import { BookItem } from '@/hooks/useBooksData'

export type BookStatus = 'cloud' | 'downloading' | 'ready' | 'reading' | 'completed' | 'processing' | 'converting' | 'ocr'

export type BookCardVariant = 'default' | 'hero' | 'grid' | 'list'

export interface BookCardBaseProps {
  /** 书籍对象 (可选，如果提供则优先使用其中的属性) */
  book?: BookItem
  
  /** 书籍 ID */
  id?: string
  /** 书籍标题 */
  title?: string
  /** 作者 */
  author?: string
  /** 封面图片 URL */
  coverUrl?: string
  /** 封面主色调（用于 ambient blur） */
  coverColor?: string
  /** 阅读进度 (0-100) */
  progress?: number
  /** 书籍状态 */
  status?: BookStatus
  /** 是否已读完（手动标记） */
  isFinished?: boolean
  /** OCR 状态: 'pending' | 'processing' | 'completed' | 'failed' | null */
  ocrStatus?: string | null
  /** 是否为图片型 PDF（需要 OCR） */
  isImageBased?: boolean
  /** 处理中提示文本 */
  processingText?: string
  /** 下载 URL（兼容旧版） */
  downloadUrl?: string
  /** 自定义类名 */
  className?: string
}

export interface BookCardCallbacks {
  /** 点击回调 */
  onClick?: () => void
  /** 云图标点击回调 - 用于后台同步，不跳转阅读页 */
  onSyncClick?: () => void
  /** 更多操作回调 - 旧版兼容 */
  onMoreClick?: () => void
  /** 删除回调 - 接收 bookId 参数 */
  onDeleted?: (bookId: string) => void
  /** 已读完状态变更回调 - 接收 bookId 和 finished 参数 */
  onFinishedChange?: (bookId: string, finished: boolean) => void
  /** 元数据更新后的回调 */
  onMetadataChange?: (bookId: string, metadata: { title?: string; author?: string }) => void
  /** OCR 触发成功后的回调 */
  onOcrTrigger?: (bookId: string) => void
  /** 下载回调 (兼容 LibraryPage 传入的 onDownload) */
  onDownload?: () => void
}

export interface BookCardProps extends BookCardBaseProps, BookCardCallbacks {
  /** 卡片变体 */
  variant?: BookCardVariant
  /** 缓存状态 (兼容 LibraryPage 传入的 cacheStatus) */
  cacheStatus?: BookStatus
  /** 视图模式 (兼容 LibraryPage 传入的 viewMode) */
  viewMode?: 'grid' | 'list' | 'shelf'
  /** 是否在线 (兼容 LibraryPage 传入的 isOnline) */
  isOnline?: boolean
}

// 内部使用的标准化属性
export interface NormalizedBookProps {
  id?: string
  title: string
  author?: string
  coverUrl?: string
  coverColor?: string
  progress: number
  status: BookStatus
  isFinished: boolean
  ocrStatus?: string | null
  isImageBased?: boolean
  processingText?: string
  downloadUrl?: string
  
  // 计算属性
  isCompleted: boolean
  showProgress: boolean
  showCloudIcon: boolean
  isProcessing: boolean
  isOcrProcessing: boolean
}


==================================================
FILE_PATH: web/src/components/BookCard/BookCardParts.tsx
==================================================

/**
 * BookCard 公共子组件
 * 
 * 封面、状态图标、进度条等可复用组件
 */
import { Cloud, Check, BookOpen, Loader2 } from 'lucide-react'
import { cn } from '@/lib/utils'
import { BookStatus } from './types'

// ============================================================================
// 颜色工具函数
// ============================================================================

/** 根据封面亮度决定图标颜色 */
export function getAdaptiveColor(coverColor?: string): string {
  if (!coverColor) return 'text-white/80'
  
  try {
    const hex = coverColor.replace('#', '')
    const r = parseInt(hex.slice(0, 2), 16)
    const g = parseInt(hex.slice(2, 4), 16)
    const b = parseInt(hex.slice(4, 6), 16)
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    return luminance > 0.5 ? 'text-black/60' : 'text-white/80'
  } catch {
    return 'text-white/80'
  }
}

// ============================================================================
// 封面组件
// ============================================================================

/** 默认封面占位图 */
export function CoverPlaceholder({ className }: { className?: string }) {
  return (
    <div className={cn(
      'flex items-center justify-center bg-gradient-to-br from-gray-100 to-gray-200 dark:from-gray-700 dark:to-gray-800',
      className
    )}>
      <BookOpen className="h-8 w-8 text-gray-400" />
    </div>
  )
}

/** 处理中状态占位图 - 心跳脉冲动效 */
export function ProcessingPlaceholder({ text, className }: { text?: string; className?: string }) {
  return (
    <div className={cn(
      'flex flex-col items-center justify-center gap-3',
      'bg-gradient-to-br from-gray-200 to-gray-300 dark:from-gray-700 dark:to-gray-600',
      'animate-pulse',
      className
    )}>
      <Loader2 className="h-6 w-6 text-gray-500 dark:text-gray-400 animate-spin" />
      <span className="text-xs font-medium text-gray-500 dark:text-gray-400 text-center px-2">
        {text || '正在处理...'}
      </span>
    </div>
  )
}

/** 书籍封面图片 */
export function BookCover({ 
  coverUrl, 
  title, 
  className,
  children 
}: { 
  coverUrl?: string
  title: string
  className?: string
  children?: React.ReactNode
}) {
  return (
    <div className={cn("relative overflow-hidden", className)}>
      {coverUrl ? (
        <img src={coverUrl} alt={title} className="h-full w-full object-cover" />
      ) : (
        <CoverPlaceholder className="h-full w-full" />
      )}
      {children}
    </div>
  )
}

// ============================================================================
// 状态组件
// ============================================================================

/** 状态图标 */
export function StatusIcon({ status, coverColor }: { status: BookStatus; coverColor?: string }) {
  const colorClass = getAdaptiveColor(coverColor)
  
  switch (status) {
    case 'cloud':
      return <Cloud className={cn('h-6 w-6', colorClass)} />
    case 'downloading':
      return (
        <div className="relative">
          <Cloud className={cn('h-6 w-6 animate-pulse', colorClass)} />
        </div>
      )
    case 'completed':
      return (
        <div className="flex h-5 w-5 items-center justify-center rounded-full bg-system-blue">
          <Check className="h-3 w-3 text-white" />
        </div>
      )
    default:
      return null
  }
}

/** 进度条 */
export function ProgressBar({ 
  progress, 
  className,
  barClassName 
}: { 
  progress: number
  className?: string
  barClassName?: string
}) {
  return (
    <div className={cn("h-1 w-full overflow-hidden rounded-full bg-gray-200", className)}>
      <div 
        className={cn("h-full rounded-full bg-system-blue transition-all", barClassName)}
        style={{ width: `${progress}%` }}
      />
    </div>
  )
}

/** 已读完徽章 */
export function CompletedBadge({ className }: { className?: string }) {
  return (
    <span className={cn("flex items-center gap-1", className)}>
      <Check className="h-3 w-3" /> 已读完
    </span>
  )
}


==================================================
FILE_PATH: web/src/components/BookCard/BookCardList.tsx
==================================================

/**
 * BookCardList - 列表视图书籍卡片
 * 
 * 横向卡片布局，带 ambient blur 背景效果
 * 
 * @see 06 - UIUX设计系统UI_UX_Design_system.md
 */
import { useState, useEffect } from 'react'
import { Check, MoreHorizontal, Loader2, Scan } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useTranslation } from 'react-i18next'
import { toast } from '@/components/ui/sonner'
import { extractDominantColor, getLuminance } from '@/lib/color-utils'
import { ScrollText } from '@/components/ui/ScrollText'
import BookCardMenu from '../BookCardMenu'
import { BookCover, ProcessingPlaceholder, StatusIcon } from './BookCardParts'
import type { NormalizedBookProps, BookCardCallbacks } from './types'

interface BookCardListProps extends NormalizedBookProps, BookCardCallbacks {
  className?: string
}

export default function BookCardList(props: BookCardListProps) {
  const { t } = useTranslation('common')
  const {
    id,
    title,
    author,
    coverUrl,
    coverColor,
    progress,
    status,
    isFinished,
    ocrStatus,
    isImageBased,
    isCompleted,
    showCloudIcon,
    isProcessing,
    isOcrProcessing,
    processingText,
    onClick,
    onSyncClick,
    onMoreClick,
    onDeleted,
    onFinishedChange,
    onMetadataChange,
    onOcrTrigger,
    className,
  } = props

  // 状态用于存储提取的主色调
  const [dominantColor, setDominantColor] = useState(coverColor || '#6B7280')

  useEffect(() => {
    if (coverUrl && !coverColor) {
      extractDominantColor(coverUrl).then(setDominantColor)
    } else if (coverColor) {
      setDominantColor(coverColor)
    }
  }, [coverUrl, coverColor])

  // 根据状态获取处理中文本
  const getProcessingText = () => {
    if (processingText) return processingText
    switch (status) {
      case 'converting': return t('book_status.converting')
      case 'ocr': return t('book_status.ocr_processing')
      default: return t('book_status.processing')
    }
  }

  // 处理卡片点击
  const handleCardClick = () => {
    if (isProcessing || status === 'downloading') return
    
    if (isOcrProcessing) {
      toast.info(t('book_status.ocr_in_progress', '正在进行文字识别，请稍候...'))
      return
    }
    
    if (status === 'cloud' && onSyncClick) {
      onSyncClick()
    } else {
      onClick?.()
    }
  }

  // 处理中状态
  if (isProcessing) {
    return (
      <div
        className={cn(
          'relative flex h-[100px] overflow-hidden rounded-2xl shadow-lg',
          'bg-gradient-to-r from-gray-200 to-gray-300 dark:from-gray-700 dark:to-gray-600',
          'animate-pulse',
          className
        )}
      >
        <div className="relative w-1/4 shrink-0 flex items-center justify-center p-2">
          <div className="relative w-full max-w-[60px] overflow-hidden rounded-lg bg-gray-300 dark:bg-gray-600 flex items-center justify-center" style={{ aspectRatio: '2/3' }}>
            <Loader2 className="h-6 w-6 text-gray-500 dark:text-gray-400 animate-spin" />
          </div>
        </div>
        <div className="relative flex-1 flex flex-col justify-center px-4 py-3">
          <span className="text-sm font-medium text-gray-500 dark:text-gray-400">
            {getProcessingText()}
          </span>
        </div>
      </div>
    )
  }
    
  const luminance = getLuminance(dominantColor)
  const isLight = luminance > 0.5
  const textClass = isLight ? 'text-gray-900' : 'text-white'
  const subTextClass = isLight ? 'text-gray-700' : 'text-white/90'

  return (
    <div
      onClick={handleCardClick}
      className={cn(
        'relative flex h-[100px] overflow-hidden rounded-2xl shadow-lg transition-transform duration-fast hover:scale-[1.02] cursor-pointer',
        className
      )}
      style={{ backgroundColor: dominantColor }}
    >
      {/* Ambient Blur 背景 */}
      {coverUrl && (
        <div 
          className="absolute inset-0 blur-2xl scale-150 opacity-60"
          style={{
            backgroundImage: `url(${coverUrl})`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
          }}
        />
      )}
      
      {/* 渐变遮罩层 */}
      <div 
        className="absolute inset-0"
        style={{
          background: isLight 
            ? 'linear-gradient(to right, rgba(255,255,255,0.1), rgba(255,255,255,0.4))'
            : 'linear-gradient(to right, rgba(0,0,0,0.1), rgba(0,0,0,0.3))'
        }}
      />
      
      {/* 封面区域 - 占 1/4 宽度 */}
      <div className="relative w-1/4 shrink-0 flex items-center justify-center p-2">
        <div className="relative w-full max-w-[60px] overflow-hidden rounded-lg shadow-xl" style={{ aspectRatio: '2/3' }}>
          <BookCover coverUrl={coverUrl} title={title} className="absolute inset-0 h-full w-full">
            {showCloudIcon && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/20">
                <StatusIcon status={status} coverColor={dominantColor} />
              </div>
            )}
          </BookCover>
        </div>
      </div>
      
      {/* 内容区域 - 占 3/4 宽度 */}
      <div className="relative flex-1 flex flex-col justify-center px-4 py-3 pr-12 overflow-hidden">
        <ScrollText 
          text={title} 
          className={cn("font-semibold text-base", textClass)}
        />
        {author && (
          <div 
            className={cn("text-sm truncate mt-1", subTextClass)}
            title={author}
          >
            {author}
          </div>
        )}
        
        {/* 进度显示 */}
        {isCompleted ? (
          <div className={cn("flex items-center gap-1.5 mt-1", textClass)}>
            <div className="w-4 h-4 rounded-full bg-system-blue flex items-center justify-center">
              <Check className="w-2.5 h-2.5 text-white" />
            </div>
            <span className="text-xs font-medium">已读完</span>
          </div>
        ) : (
          <p className={cn("text-xs mt-1 opacity-60", textClass)}>
            {Math.round(progress)}%
          </p>
        )}
      </div>
      
      {/* 底部进度条 */}
      {!isCompleted && (
        <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-black/10">
          <div 
            className="h-full bg-white/80 transition-all"
            style={{ width: `${progress}%` }}
          />
        </div>
      )}

      {/* OCR 处理中图标 */}
      {isOcrProcessing && (
        <div className="absolute bottom-2 left-2 flex items-center gap-1 px-2 py-1 rounded-full bg-black/50 backdrop-blur-sm">
          <Scan className="w-3 h-3 text-white animate-pulse" />
          <span className="text-xs text-white font-medium">OCR</span>
        </div>
      )}

      {/* 更多菜单 */}
      <div className="absolute top-2 right-2 z-10">
        {id ? (
          <BookCardMenu
            bookId={id}
            bookTitle={title}
            bookAuthor={author}
            isFinished={isFinished}
            ocrStatus={ocrStatus}
            isImageBased={isImageBased}
            onDeleted={() => onDeleted?.(id)}
            onFinishedChange={(finished) => onFinishedChange?.(id, finished)}
            onMetadataChange={(metadata) => onMetadataChange?.(id, metadata)}
            onOcrTrigger={() => onOcrTrigger?.(id)}
            buttonClassName={textClass}
          />
        ) : onMoreClick && (
          <button
            onClick={(e) => { e.stopPropagation(); onMoreClick(); }}
            className={cn("p-1 rounded-full hover:bg-white/20 transition-colors", textClass)}
          >
            <MoreHorizontal className="h-5 w-5" />
          </button>
        )}
      </div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/BookCard/index.tsx
==================================================

/**
 * BookCard 组件模块
 * 
 * 统一导出入口，支持四种变体：
 * - default: 简单卡片（兼容旧版）
 * - hero: 大尺寸继续阅读卡片
 * - grid: 网格视图竖向卡片
 * - list: 列表视图横向卡片
 * 
 * 使用方式：
 * ```tsx
 * // 统一入口（自动选择变体）
 * import BookCard from '@/components/BookCard'
 * <BookCard book={book} variant="grid" />
 * 
 * // 直接使用特定变体
 * import { BookCardGrid, BookCardList } from '@/components/BookCard'
 * <BookCardGrid {...props} />
 * ```
 * 
 * @see 06 - UIUX设计系统UI_UX_Design_system.md
 */

// 类型导出
export * from './types'

// 子组件导出
export { default as BookCardGrid } from './BookCardGrid'
export { default as BookCardList } from './BookCardList'
export { default as BookCardHero } from './BookCardHero'
export { default as BookCardDefault } from './BookCardDefault'

// 公共组件导出
export * from './BookCardParts'

// 统一入口组件
import { useMemo } from 'react'
import BookCardGrid from './BookCardGrid'
import BookCardList from './BookCardList'
import BookCardHero from './BookCardHero'
import BookCardDefault from './BookCardDefault'
import type { BookCardProps, NormalizedBookProps, BookStatus } from './types'

/**
 * 规范化 props，统一处理兼容性
 */
function normalizeProps(props: BookCardProps): NormalizedBookProps {
  const { book } = props
  
  const id = props.id || book?.id
  const title = props.title || book?.title || ''
  const author = props.author || book?.author
  const coverUrl = props.coverUrl || book?.coverUrl
  const progress = props.progress ?? book?.progress ?? 0
  const isFinished = props.isFinished ?? book?.isFinished ?? false
  const ocrStatus = props.ocrStatus ?? book?.ocrStatus
  const isImageBased = props.isImageBased ?? book?.isImageBased
  const downloadUrl = props.downloadUrl || book?.downloadUrl
  const coverColor = props.coverColor
  const processingText = props.processingText
  
  // 兼容性处理：status 可能是 props.status 或 props.cacheStatus
  const status: BookStatus = props.status || props.cacheStatus || 'ready'
  
  // 计算属性
  const isCompleted = isFinished || status === 'completed' || progress >= 100
  const showProgress = !isCompleted && progress > 0 && status === 'reading'
  const showCloudIcon = status === 'cloud' || status === 'downloading'
  const isProcessing = status === 'processing' || status === 'converting' || status === 'ocr'
  const isOcrProcessing = ocrStatus === 'pending' || ocrStatus === 'processing'

  return {
    id,
    title,
    author,
    coverUrl,
    coverColor,
    progress,
    status,
    isFinished,
    ocrStatus,
    isImageBased,
    processingText,
    downloadUrl,
    isCompleted,
    showProgress,
    showCloudIcon,
    isProcessing,
    isOcrProcessing,
  }
}

/**
 * BookCard 统一入口组件
 * 
 * 根据 variant 自动选择对应的子组件
 */
export default function BookCard(props: BookCardProps) {
  const normalized = useMemo(() => normalizeProps(props), [props])
  
  // 确定变体
  let variant = props.variant || 'default'
  if (props.viewMode === 'list') variant = 'list'
  if (props.viewMode === 'grid' || props.viewMode === 'shelf') variant = 'grid'
  
  // 合并回调
  const callbacks = {
    onClick: props.onClick,
    onSyncClick: props.onSyncClick || props.onDownload,
    onMoreClick: props.onMoreClick,
    onDeleted: props.onDeleted,
    onFinishedChange: props.onFinishedChange,
    onMetadataChange: props.onMetadataChange,
    onOcrTrigger: props.onOcrTrigger,
  }
  
  const commonProps = {
    ...normalized,
    ...callbacks,
    className: props.className,
  }

  switch (variant) {
    case 'hero':
      return <BookCardHero {...commonProps} />
    case 'grid':
      return <BookCardGrid {...commonProps} />
    case 'list':
      return <BookCardList {...commonProps} />
    default:
      return <BookCardDefault {...commonProps} />
  }
}


==================================================
FILE_PATH: web/src/components/auth/AuthGuard.tsx
==================================================

/**
 * 路由守卫组件
 *
 * 说明：
 * - 检查登录状态与 Token 过期
 * - Token 过期时尝试刷新，失败则重定向登录
 * - 加载期间显示轻量提示，避免闪屏
 */
import { useEffect, useState } from 'react'
import { Navigate, useLocation } from 'react-router-dom'
import { useAuthStore } from '@/stores/auth'

export default function AuthGuard({ children }: { children: JSX.Element }) {
  const location = useLocation()
  const [isChecking, setIsChecking] = useState(true)
  const [shouldRedirect, setShouldRedirect] = useState(false)

  // 从 store 中获取状态
  const isAuthenticated = useAuthStore((s) => s.isAuthenticated)
  const isTokenExpired = useAuthStore((s) => s.isTokenExpired)
  const refreshAccessToken = useAuthStore((s) => s.refreshAccessToken)

  useEffect(() => {
    const checkAuth = async () => {
      console.log('[AuthGuard] Checking auth...', {
        isAuthenticated,
        path: location.pathname
      })

      // 未登录，直接跳转
      if (!isAuthenticated) {
        console.log('[AuthGuard] Not authenticated, redirecting to login')
        setShouldRedirect(true)
        setIsChecking(false)
        return
      }

      // Token 已过期，尝试刷新
      if (isTokenExpired()) {
        console.log('[AuthGuard] Token expired, attempting refresh...')
        const refreshed = await refreshAccessToken()

        if (!refreshed) {
          // 刷新失败，跳转登录页
          console.log('[AuthGuard] Refresh failed, redirecting to login')
          setShouldRedirect(true)
        } else {
          console.log('[AuthGuard] Refresh successful')
        }
      } else {
        console.log('[AuthGuard] Token valid')
      }

      setIsChecking(false)
    }

    checkAuth()
  }, [isAuthenticated, isTokenExpired, refreshAccessToken, location.pathname])

  // 检查中，显示加载状态
  if (isChecking) {
    return (
      <div style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        fontSize: '14px',
        color: '#666'
      }}>
        验证登录状态...
      </div>
    )
  }

  // 需要跳转，返回 Navigate
  if (shouldRedirect) {
    return <Navigate to="/login" replace state={{ from: location }} />
  }

  // 已认证且 token 有效，渲染子组件
  return children
}


==================================================
FILE_PATH: web/src/components/account/ProfileButton.tsx
==================================================

/**
 * 可滚动渐隐的个人信息按钮
 * 
 * 功能：
 * - 显示用户头像（或默认图标）
 * - 滚动时渐隐消失，滚回顶部时渐显
 * - 点击打开账户菜单
 * 
 * 设计规范：
 * - 使用 framer-motion 实现平滑动画
 * - 遵循 UIUX 设计系统的圆角和阴影
 */
import { useState } from 'react'
import { motion, useScroll, useTransform } from 'framer-motion'
import { User } from 'lucide-react'
import AccountSheet from './AccountSheet'

interface ProfileButtonProps {
  /** 自定义头像 URL */
  avatarUrl?: string
}

export default function ProfileButton({ avatarUrl }: ProfileButtonProps) {
  const [isSheetOpen, setIsSheetOpen] = useState(false)
  
  // 监听滚动位置
  const { scrollY } = useScroll()
  
  // 滚动 0-60px 时从 1 渐变到 0
  const opacity = useTransform(scrollY, [0, 60], [1, 0])
  // 同时稍微上移
  const translateY = useTransform(scrollY, [0, 60], [0, -10])
  // 缩放效果
  const scale = useTransform(scrollY, [0, 60], [1, 0.8])

  return (
    <>
      <motion.button
        style={{ opacity, y: translateY, scale }}
        className="w-10 h-10 rounded-full shadow-md bg-white dark:bg-gray-800 overflow-hidden flex items-center justify-center border border-gray-100 dark:border-gray-700 hover:shadow-lg transition-shadow"
        onClick={() => setIsSheetOpen(true)}
        aria-label="Open account menu"
      >
        {avatarUrl ? (
          <img src={avatarUrl} alt="Avatar" className="w-full h-full object-cover" />
        ) : (
          <User className="w-5 h-5 text-secondary-label" />
        )}
      </motion.button>

      <AccountSheet open={isSheetOpen} onOpenChange={setIsSheetOpen} />
    </>
  )
}


==================================================
FILE_PATH: web/src/components/account/AccountSheet.tsx
==================================================

/**
 * 账户菜单底部弹出层
 * 
 * 功能：
 * - 从底部升起的全屏菜单（移动端友好）
 * - 显示用户头像和账号信息
 * - 语言设置切换
 * - 退出登录
 * 
 * 设计规范：
 * - 遵循 UIUX 设计系统的 Liquid Glass 效果
 * - 使用 vaul Drawer 组件实现底部弹出
 */
import { useState, useRef } from 'react'
import { useTranslation } from 'react-i18next'
import { X, ChevronRight, LogOut, User, Camera, Trash2 } from 'lucide-react'
import { useAuthStore } from '@/stores/auth'
import { useNavigate } from 'react-router-dom'
import { useTolgeeLanguages } from '@/hooks/useTolgeeLanguages'
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet'

interface AccountSheetProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export default function AccountSheet({ open, onOpenChange }: AccountSheetProps) {
  const { t, i18n } = useTranslation('common')
  const navigate = useNavigate()
  const { user, logout } = useAuthStore()
  const [avatarUrl, setAvatarUrl] = useState<string | null>(null)
  const [showLanguageSelect, setShowLanguageSelect] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const langs = useTolgeeLanguages()

  // 语言名称映射
  const languageNames: Record<string, string> = {
    'en-US': 'English',
    'zh-CN': '简体中文',
    'zh-TW': '繁體中文',
    'ja': '日本語',
    'ko': '한국어',
    'fr': 'Français',
    'de': 'Deutsch',
    'es': 'Español'
  }

  // 为语言列表添加显示名称
  const displayLangs = (langs.length ? langs : [
    { code: 'en-US', name: 'English' },
    { code: 'zh-CN', name: '简体中文' }
  ]).map(l => ({
    ...l,
    name: l.name || languageNames[l.code] || l.code
  }))

  // 获取当前语言显示名称
  const currentLanguageName = displayLangs.find(l => l.code === i18n.language)?.name || i18n.language

  // 处理头像上传
  const handleAvatarClick = () => {
    fileInputRef.current?.click()
  }

  const handleAvatarChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    // TODO: 上传到服务器并压缩为 WebP
    // 目前先使用本地预览
    const reader = new FileReader()
    reader.onload = (event) => {
      setAvatarUrl(event.target?.result as string)
    }
    reader.readAsDataURL(file)
  }

  // 处理退出登录
  const handleLogout = () => {
    logout()
    onOpenChange(false)
    navigate('/')
  }

  // 处理语言切换
  const handleLanguageChange = async (langCode: string) => {
    await i18n.changeLanguage(langCode)
    setShowLanguageSelect(false)
  }

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent 
        side="bottom" 
        className="h-full rounded-t-3xl backdrop-blur-xl border-t border-separator"
        style={{ backgroundColor: 'rgba(242, 242, 247, 0.75)' }}
      >
        {/* Header */}
        <SheetHeader className="relative px-4 pt-4 pb-2">
          <div className="absolute left-1/2 top-2 -translate-x-1/2 w-10 h-1 bg-gray-300 dark:bg-gray-600 rounded-full" />
          <div className="flex items-center justify-between mt-4">
            <SheetTitle className="text-lg font-semibold text-label">
              {t('account.title', '账户')}
            </SheetTitle>
            <button
              onClick={() => onOpenChange(false)}
              className="w-8 h-8 flex items-center justify-center rounded-full bg-tertiary-background hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
            >
              <X className="w-5 h-5 text-secondary-label" />
            </button>
          </div>
        </SheetHeader>

        <div className="px-4 py-4 space-y-4">
          {/* 用户信息卡片 */}
          <div className="bg-tertiary-background rounded-2xl p-4 flex items-center gap-4">
            {/* 头像 */}
            <div 
              className="relative w-16 h-16 rounded-full overflow-hidden bg-gray-200 dark:bg-gray-700 flex-shrink-0 cursor-pointer group"
              onClick={handleAvatarClick}
            >
              {avatarUrl ? (
                <img src={avatarUrl} alt="Avatar" className="w-full h-full object-cover" />
              ) : (
                <div className="w-full h-full flex items-center justify-center">
                  <User className="w-8 h-8 text-secondary-label" />
                </div>
              )}
              {/* 相机图标悬浮层 */}
              <div className="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                <Camera className="w-5 h-5 text-white" />
              </div>
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                className="hidden"
                onChange={handleAvatarChange}
              />
            </div>
            
            {/* 用户名和邮箱 */}
            <div className="flex-1 min-w-0">
              <div className="text-label font-semibold text-base truncate">
                {user?.display_name || t('account.unnamed', '未命名用户')}
              </div>
              <div className="text-secondary-label text-sm truncate">
                {user?.email || ''}
              </div>
            </div>
          </div>

          {/* 账户设置 - 语言选择 */}
          <div className="bg-tertiary-background rounded-2xl overflow-hidden">
            <button
              className="w-full p-4 flex items-center justify-between hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
              onClick={() => setShowLanguageSelect(!showLanguageSelect)}
            >
              <span className="text-label font-medium">
                {t('account.settings', '账户设置')}
              </span>
              <div className="flex items-center gap-2">
                <span className="text-secondary-label text-sm">{currentLanguageName}</span>
                <ChevronRight className={`w-5 h-5 text-secondary-label transition-transform ${showLanguageSelect ? 'rotate-90' : ''}`} />
              </div>
            </button>
            
            {/* 语言选择展开列表 */}
            {showLanguageSelect && (
              <div className="border-t border-separator">
                {displayLangs.map((lang) => (
                  <button
                    key={lang.code}
                    className={`w-full px-6 py-3 text-left hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors flex items-center justify-between ${
                      i18n.language === lang.code ? 'text-system-blue' : 'text-label'
                    }`}
                    onClick={() => handleLanguageChange(lang.code)}
                  >
                    <span>{lang.name}</span>
                    {i18n.language === lang.code && (
                      <span className="text-system-blue">✓</span>
                    )}
                  </button>
                ))}
              </div>
            )}
          </div>

          {/* 最近删除 */}
          <button
            className="w-full bg-tertiary-background rounded-2xl p-4 flex items-center justify-between hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
            onClick={() => {
              onOpenChange(false)
              navigate('/app/recently-deleted')
            }}
          >
            <span className="text-label font-medium">
              {t('account.recently_deleted', '最近删除')}
            </span>
            <Trash2 className="w-5 h-5 text-secondary-label" />
          </button>

          {/* 退出登录 */}
          <button
            className="w-full bg-tertiary-background rounded-2xl p-4 flex items-center justify-between hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
            onClick={handleLogout}
          >
            <span className="text-label font-medium">
              {t('account.logout', '退出登录')}
            </span>
            <LogOut className="w-5 h-5 text-secondary-label" />
          </button>
        </div>
      </SheetContent>
    </Sheet>
  )
}


==================================================
FILE_PATH: web/src/components/layouts/MainLayout.tsx
==================================================

import { Outlet, useNavigate } from 'react-router-dom'
import { Search } from 'lucide-react'
import { useState } from 'react'
import i18n from '../../i18n'
import { useTolgeeLanguages } from '../../hooks/useTolgeeLanguages'
import NavItem from './NavItem'

export default function MainLayout() {
  const nav = useNavigate()
  const [menuOpen, setMenuOpen] = useState(false)
  const langs = useTolgeeLanguages()
  return (
    <div style={{ display: 'flex', flexDirection: 'column', minHeight: '100vh', background: 'var(--color-system-background)' }}>
      <header
        style={{
          position: 'sticky',
          top: 0,
          zIndex: 1000,
          backdropFilter: 'blur(12px)',
          WebkitBackdropFilter: 'blur(12px)',
          background: 'rgba(255,255,255,0.6)',
          borderBottom: '1px solid rgba(255,255,255,0.3)',
          fontFamily: 'var(--font-ui)'
        }}
      >
        <div style={{ maxWidth: 1200, margin: '0 auto', padding: '10px 16px', display: 'flex', alignItems: 'center', gap: 16 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 10, cursor: 'pointer' }} onClick={() => nav('/')}>
            <img src="/logosvg.png" alt="Athena" style={{ width: 32, height: 32, borderRadius: 6, objectFit: 'contain' }} />
            <div style={{ fontWeight: 700, fontSize: 16, color: '#111' }}>Athena</div>
          </div>
          <nav style={{ display: 'flex', alignItems: 'center', gap: 8, marginLeft: 24 }}>
            <NavItem to="/library" icon={null} label="Library" />
            <NavItem to="/search" icon={<Search size={18} />} label="" />
          </nav>
          <div style={{ display: 'flex', alignItems: 'center', gap: 10, marginLeft: 'auto' }}>
            <select value={i18n.language} onChange={(e) => { const v = e.target.value; i18n.changeLanguage(v) }} style={{ padding: 6, borderRadius: 8, background: 'rgba(255,255,255,0.7)', border: '1px solid rgba(0,0,0,0.08)' }}>
              {(langs.length ? langs : [{ code: 'zh-CN', name: '中文' }, { code: 'en-US', name: 'English' }]).map((l) => (
                <option key={l.code} value={l.code}>{l.name || l.code}</option>
              ))}
            </select>
            {!localStorage.getItem('access_token') && (
              <button onClick={() => nav('/login')} style={{ padding: '8px 12px', borderRadius: 999, background: '#007AFF', color: '#fff', border: 'none' }}>注册/登录</button>
            )}
            <div
              onClick={() => setMenuOpen((v) => !v)}
              style={{ width: 32, height: 32, borderRadius: '50%', background: 'rgba(0,0,0,0.08)', cursor: 'pointer' }}
            />
            {menuOpen && (
              <div style={{ position: 'absolute', top: 56, right: 16, background: 'rgba(255,255,255,0.9)', backdropFilter: 'blur(12px)', border: '1px solid rgba(0,0,0,0.08)', borderRadius: 8, boxShadow: '0 4px 12px rgba(0,0,0,0.08)' }}>
                <div style={{ padding: 10, cursor: 'pointer' }} onClick={() => { setMenuOpen(false); nav('/profile') }}>个人中心</div>
                <div style={{ padding: 10, cursor: 'pointer' }} onClick={() => { setMenuOpen(false); nav('/settings') }}>设置</div>
                <div style={{ padding: 10, cursor: 'pointer', color: '#c00' }} onClick={() => { localStorage.removeItem('access_token'); localStorage.removeItem('refresh_token'); setMenuOpen(false); nav('/login') }}>退出登录</div>
              </div>
            )}
          </div>
        </div>
      </header>
      <main style={{ flex: 1, background: 'var(--color-system-background)', padding: 'var(--space-xl)' }}>
        <Outlet />
      </main>
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/layouts/NavItem.tsx
==================================================

import { NavLink } from 'react-router-dom'
import { ReactNode, isValidElement, cloneElement } from 'react'
type Props = { to: string; icon: ReactNode; label: string }
export default function NavItem({ to, icon, label }: Props) {
  return (
    <NavLink to={to}>
      {({ isActive }) => (
        <span
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: 'var(--space-sm)',
            padding: 'var(--space-sm)',
            borderRadius: 6,
            background: isActive ? 'var(--color-system-fill)' : 'transparent',
            color: isActive ? 'var(--color-label)' : 'var(--color-secondary-label)'
          }}
        >
          {icon ? (
            <span style={{ display: 'inline-flex', color: 'inherit' }}>
              {isValidElement(icon)
                ? cloneElement(icon, { strokeWidth: isActive ? 2.5 : ((icon.props as any)?.strokeWidth ?? 1.5), stroke: 'currentColor' })
                : icon}
            </span>
          ) : null}
          {label ? <span style={{ color: 'inherit' }}>{label}</span> : null}
        </span>
      )}
    </NavLink>
  )
}


==================================================
FILE_PATH: web/src/components/upload/UploadDropzone.tsx
==================================================

import { useCallback, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { Upload, FileText, X } from 'lucide-react'
import { cn } from '@/lib/utils'
import { SUPPORTED_FORMATS, MAX_FILE_SIZE } from '@/hooks/useBookUpload'

/**
 * 上传拖拽选择组件
 *
 * 功能：
 * - 支持点击/拖拽选择单个文件，预览后确认上传
 * - 校验扩展名与大小，文案来源 `common` 命名空间
 * - 外部通过 `onFileSelect` 接收文件并发起上传
 */
export interface UploadDropzoneProps {
  onFileSelect: (file: File) => void
  disabled?: boolean
  className?: string
  accept?: string[]
  maxSize?: number
}

// 格式化文件大小
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]
}

export default function UploadDropzone({
  onFileSelect,
  disabled = false,
  className,
  accept = SUPPORTED_FORMATS,
  maxSize = MAX_FILE_SIZE,
}: UploadDropzoneProps) {
  const { t } = useTranslation('common')
  const inputRef = useRef<HTMLInputElement>(null)
  const [isDragOver, setIsDragOver] = useState(false)
  const [previewFile, setPreviewFile] = useState<File | null>(null)
  const [error, setError] = useState<string | null>(null)

  // 验证文件
  const validateFile = useCallback((file: File): string | null => {
    const ext = file.name.split('.').pop()?.toLowerCase() || ''
    if (!accept.includes(ext)) {
      return t('upload.error.invalid_format')
    }
    if (file.size > maxSize) {
      return t('upload.error.file_too_large', { size: formatFileSize(maxSize) })
    }
    return null
  }, [accept, maxSize, t])

  // 处理文件选择
  const handleFile = useCallback((file: File) => {
    setError(null)
    const validationError = validateFile(file)
    if (validationError) {
      setError(validationError)
      return
    }
    setPreviewFile(file)
  }, [validateFile])

  // 确认上传
  const handleConfirm = useCallback(() => {
    if (previewFile) {
      onFileSelect(previewFile)
      setPreviewFile(null)
    }
  }, [previewFile, onFileSelect])

  // 取消选择
  const handleClear = useCallback(() => {
    setPreviewFile(null)
    setError(null)
    if (inputRef.current) {
      inputRef.current.value = ''
    }
  }, [])

  // 点击选择
  const handleClick = useCallback(() => {
    if (!disabled && !previewFile) {
      inputRef.current?.click()
    }
  }, [disabled, previewFile])

  // 文件输入变更
  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      handleFile(file)
    }
  }, [handleFile])

  // 拖拽事件处理
  const handleDragEnter = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    if (!disabled) {
      setIsDragOver(true)
    }
  }, [disabled])

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    setIsDragOver(false)
  }, [])

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
  }, [])

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    setIsDragOver(false)

    if (disabled) return

    const file = e.dataTransfer.files?.[0]
    if (file) {
      handleFile(file)
    }
  }, [disabled, handleFile])

  // 构建 accept 属性
  const acceptStr = accept.map(ext => `.${ext}`).join(',')

  return (
    <div className={cn('w-full', className)}>
      <input
        ref={inputRef}
        type="file"
        accept={acceptStr}
        onChange={handleInputChange}
        className="hidden"
        disabled={disabled}
      />

      {/* 预览状态 */}
      {previewFile ? (
        <div className="rounded-xl border-2 border-dashed border-system-blue bg-system-blue/5 p-6">
          <div className="flex items-center gap-4">
            <div className="flex h-12 w-12 items-center justify-center rounded-lg bg-system-blue/10">
              <FileText className="h-6 w-6 text-system-blue" />
            </div>
            <div className="flex-1 min-w-0">
              <p className="font-medium text-label truncate">{previewFile.name}</p>
              <p className="text-sm text-secondary-label">
                {formatFileSize(previewFile.size)}
              </p>
            </div>
            <button
              onClick={handleClear}
              className="p-2 rounded-full hover:bg-secondary-background transition-colors"
              aria-label={t('common.cancel')}
            >
              <X className="h-5 w-5 text-secondary-label" />
            </button>
          </div>
          
          <div className="mt-4 flex gap-3">
            <button
              onClick={handleClear}
              className="flex-1 py-2 px-4 rounded-full border border-gray-300 text-label hover:bg-secondary-background transition-colors"
            >
              {t('upload.choose_another')}
            </button>
            <button
              onClick={handleConfirm}
              className="flex-1 py-2 px-4 rounded-full bg-system-blue text-white hover:opacity-90 transition-opacity"
            >
              {t('upload.start')}
            </button>
          </div>
        </div>
      ) : (
        /* 拖拽区域 */
        <div
          onClick={handleClick}
          onDragEnter={handleDragEnter}
          onDragLeave={handleDragLeave}
          onDragOver={handleDragOver}
          onDrop={handleDrop}
          className={cn(
            'rounded-xl border-2 border-dashed p-8 text-center cursor-pointer transition-all duration-fast',
            isDragOver
              ? 'border-system-blue bg-system-blue/5 scale-[1.02]'
              : 'border-gray-300 hover:border-system-blue hover:bg-secondary-background',
            disabled && 'opacity-50 cursor-not-allowed',
            error && 'border-system-red bg-system-red/5'
          )}
        >
          <div className={cn(
            'mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full transition-colors',
            isDragOver ? 'bg-system-blue/10' : 'bg-secondary-background'
          )}>
            <Upload className={cn(
              'h-8 w-8 transition-colors',
              isDragOver ? 'text-system-blue' : 'text-secondary-label'
            )} />
          </div>

          <p className="text-label font-medium mb-1">
            {isDragOver ? t('upload.drop_here') : t('upload.drag_or_click')}
          </p>
          <p className="text-sm text-secondary-label mb-3">
            {t('upload.supported_formats', { formats: accept.join(', ').toUpperCase() })}
          </p>
          <p className="text-xs text-tertiary-label">
            {t('upload.max_size', { size: formatFileSize(maxSize) })}
          </p>

          {error && (
            <p className="mt-3 text-sm text-system-red">{error}</p>
          )}
        </div>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/upload/UploadProgress.tsx
==================================================

/**
 * 上传进度组件
 * - 展示阶段、进度百分比与错误信息
 * - 支持取消、重试、关闭等交互
 */
import { useTranslation } from 'react-i18next'
import { X, CheckCircle, AlertCircle, Loader2 } from 'lucide-react'
import { cn } from '@/lib/utils'
import { UploadStage, UploadErrorCode } from '@/hooks/useBookUpload'

export interface UploadProgressProps {
  stage: UploadStage
  progress: number
  fileName: string
  errorCode?: UploadErrorCode | null
  onCancel?: () => void
  onRetry?: () => void
  onDismiss?: () => void
  className?: string
}

// 阶段配置
const STAGE_CONFIG: Record<UploadStage, { labelKey: string; color: string }> = {
  idle: { labelKey: 'upload.stage.idle', color: 'text-secondary-label' },
  hashing: { labelKey: 'upload.stage.hashing', color: 'text-system-blue' },
  initializing: { labelKey: 'upload.stage.initializing', color: 'text-system-blue' },
  uploading: { labelKey: 'upload.stage.uploading', color: 'text-system-blue' },
  completing: { labelKey: 'upload.stage.completing', color: 'text-system-blue' },
  done: { labelKey: 'upload.stage.done', color: 'text-system-green' },
  error: { labelKey: 'upload.stage.error', color: 'text-system-red' },
}

export default function UploadProgress({
  stage,
  progress,
  fileName,
  errorCode,
  onCancel,
  onRetry,
  onDismiss,
  className,
}: UploadProgressProps) {
  const { t } = useTranslation('common')

  const config = STAGE_CONFIG[stage]
  const isComplete = stage === 'done'
  const isError = stage === 'error'
  const isActive = !isComplete && !isError

  // 获取错误消息
  const getErrorMessage = () => {
    if (!errorCode) return t('upload.error.unknown')
    return t(`upload.error.${errorCode}`)
  }

  return (
    <div className={cn(
      'rounded-xl border p-4 transition-all duration-medium',
      isComplete && 'border-system-green/30 bg-system-green/5',
      isError && 'border-system-red/30 bg-system-red/5',
      isActive && 'border-system-blue/30 bg-system-blue/5',
      className
    )}>
      {/* 头部：文件名和操作按钮 */}
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-3 min-w-0">
          {/* 状态图标 */}
          <div className={cn(
            'flex h-8 w-8 items-center justify-center rounded-full shrink-0',
            isComplete && 'bg-system-green/10',
            isError && 'bg-system-red/10',
            isActive && 'bg-system-blue/10'
          )}>
            {isComplete && <CheckCircle className="h-5 w-5 text-system-green" />}
            {isError && <AlertCircle className="h-5 w-5 text-system-red" />}
            {isActive && <Loader2 className="h-5 w-5 text-system-blue animate-spin" />}
          </div>
          
          {/* 文件名 */}
          <span className="text-sm font-medium text-label truncate">
            {fileName}
          </span>
        </div>

        {/* 操作按钮 */}
        <div className="flex items-center gap-2 shrink-0">
          {isActive && onCancel && (
            <button
              onClick={onCancel}
              className="p-1.5 rounded-full hover:bg-secondary-background transition-colors"
              aria-label={t('common.cancel')}
            >
              <X className="h-4 w-4 text-secondary-label" />
            </button>
          )}
          {(isComplete || isError) && onDismiss && (
            <button
              onClick={onDismiss}
              className="p-1.5 rounded-full hover:bg-secondary-background transition-colors"
              aria-label={t('common.close')}
            >
              <X className="h-4 w-4 text-secondary-label" />
            </button>
          )}
        </div>
      </div>

      {/* 进度条 */}
      {isActive && (
        <div className="mb-2">
          <div className="h-1.5 w-full bg-gray-200 rounded-full overflow-hidden">
            <div
              className="h-full bg-system-blue rounded-full transition-all duration-medium ease-out"
              style={{ width: `${Math.min(100, Math.max(0, progress))}%` }}
            />
          </div>
        </div>
      )}

      {/* 状态文本 */}
      <div className="flex items-center justify-between text-sm">
        <span className={config.color}>
          {isError ? getErrorMessage() : t(config.labelKey)}
        </span>
        {isActive && (
          <span className="text-secondary-label">
            {progress}%
          </span>
        )}
      </div>

      {/* 错误状态下的重试按钮 */}
      {isError && onRetry && (
        <button
          onClick={onRetry}
          className="mt-3 w-full py-2 px-4 rounded-full border border-system-red text-system-red hover:bg-system-red/10 transition-colors text-sm font-medium"
        >
          {t('common.retry')}
        </button>
      )}
    </div>
  )
}


==================================================
FILE_PATH: web/src/components/upload/UploadManager.tsx
==================================================

/**
 * 上传管理组件
 *
 * 说明：
 * - 负责发起文件选择与上传流程（使用 `useBookUpload`）
 * - 监听后台处理状态（封面、元数据、OCR）并弹出确认对话框
 * - 上传完成后广播事件，供书库页面刷新
 */
import { useCallback, useState, useRef, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTranslation } from 'react-i18next'
import { Plus } from 'lucide-react'
import { useBookUpload, UploadResult, UploadErrorCode } from '@/hooks/useBookUpload'
import { useUploadPostProcessing } from '@/hooks/useUploadPostProcessing'
import { useAuthStore } from '@/stores/auth'
import UploadDropzone from './UploadDropzone'
import UploadProgress from './UploadProgress'
import { UploadPostProcessDialog } from '@/components/UploadPostProcessDialog'
import Modal from '@/components/ui/Modal'
import { cn } from '@/lib/utils'

export interface UploadManagerProps {
  /** 是否在上传完成后自动导航到书库 */
  navigateOnSuccess?: boolean
  /** 上传成功回调 */
  onSuccess?: (result: UploadResult) => void
  /** 上传错误回调 */
  onError?: (errorCode: UploadErrorCode) => void
  /** 自定义类名 */
  className?: string
  /** 按钮变体 */
  variant?: 'button' | 'icon' | 'inline'
}

export default function UploadManager({
  navigateOnSuccess = true,
  onSuccess,
  onError,
  className,
  variant = 'button',
}: UploadManagerProps) {
  const { t } = useTranslation('common')
  const navigate = useNavigate()
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [pendingFile, setPendingFile] = useState<File | null>(null)
  
  // 上传后处理状态
  const [postProcessOpen, setPostProcessOpen] = useState(false)
  const [postProcessData, setPostProcessData] = useState<{
    bookId: string
    bookTitle: string
    needsMetadataConfirm: boolean
    extractedTitle?: string
    extractedAuthor?: string
    isImageBasedPdf: boolean
    pageCount?: number
  } | null>(null)
  
  // 保存最近上传成功的书籍信息
  const lastUploadRef = useRef<{ id: string; title: string; author?: string; format?: string } | null>(null)
  // 标记对话框是否已显示，避免重复弹出
  const dialogShownRef = useRef(false)

  // 后处理监控 hook
  const { startMonitoring, stopMonitoring } = useUploadPostProcessing({
    pollInterval: 2000,
    maxPollCount: 60,  // 增加到 60 次（2分钟），给后端足够的处理时间
    onStatusUpdate: (status) => {
      console.log('[UploadManager] Processing status update:', {
        bookId: status.bookId,
        hasCover: status.hasCover,
        metadataExtracted: status.metadataExtracted,
        metadataConfirmed: status.metadataConfirmed,
        isImageBasedPdf: status.isImageBasedPdf,
        lastUploadRef: lastUploadRef.current?.id,
        dialogShown: dialogShownRef.current,
      })
      
      // 如果对话框已显示，只更新图片 PDF 状态
      if (dialogShownRef.current) {
        console.log('[UploadManager] Dialog already shown, skipping...')
        if (status.isImageBasedPdf && postProcessData && !postProcessData.isImageBasedPdf) {
          setPostProcessData(prev => prev ? {
            ...prev,
            isImageBasedPdf: true,
            pageCount: status.pageCount,
          } : null)
        }
        return
      }
      
      // 检查是否应该弹出对话框
      // 条件：1) 有封面或元数据已提取  2) 元数据未确认  3) 有上传记录
      const hasProcessingResult = status.metadataExtracted || status.hasCover
      const needsConfirmation = !status.metadataConfirmed
      const hasUploadRecord = !!lastUploadRef.current
      
      console.log('[UploadManager] Dialog conditions:', {
        hasProcessingResult,
        needsConfirmation,
        hasUploadRecord,
      })
      
      const shouldShowDialog = hasProcessingResult && needsConfirmation && hasUploadRecord
      
      if (shouldShowDialog) {
        console.log('[UploadManager] ✅ Showing metadata confirmation dialog!')
        dialogShownRef.current = true
        setPostProcessData({
          bookId: status.bookId,
          bookTitle: status.title || lastUploadRef.current!.title,
          needsMetadataConfirm: true,
          extractedTitle: status.extractedTitle,
          extractedAuthor: status.extractedAuthor,
          isImageBasedPdf: status.isImageBasedPdf,
          pageCount: status.pageCount,
        })
        setPostProcessOpen(true)
      }
    },
    onMetadataReady: (status) => {
      console.log('[UploadManager] Metadata ready callback:', status.metadataExtracted)
    },
    onImagePdfDetected: (status) => {
      console.log('[UploadManager] Image-based PDF detected:', status.isImageBasedPdf)
    },
    onCoverReady: (status) => {
      console.log('[UploadManager] Cover ready, broadcasting event:', status.bookId)
      // 广播封面就绪事件，通知 LibraryPage 刷新
      window.dispatchEvent(new CustomEvent('book_cover_ready', {
        detail: { bookId: status.bookId, coverUrl: status.coverUrl }
      }))
    },
  })
  
  // 用于追踪正在等待转换完成的书籍
  const convertingBookRef = useRef<{ id: string; title: string } | null>(null)
  const conversionPollRef = useRef<NodeJS.Timeout | null>(null)
  
  // 轮询检查转换状态
  const pollConversionStatus = useCallback(async (bookId: string, title: string) => {
    console.log(`[UploadManager] pollConversionStatus called for ${bookId}, lastUploadRef:`, lastUploadRef.current?.id)
    try {
      // 使用正确的 API 路径并添加认证
      const token = useAuthStore.getState().accessToken
      if (!token) {
        console.log('[UploadManager] No access token available')
        return
      }
      const res = await fetch(`/api/v1/books/${bookId}`, {
        headers: { Authorization: `Bearer ${token}` }
      })
      if (!res.ok) {
        console.log(`[UploadManager] Failed to fetch book status: ${res.status}`)
        return
      }
      const response = await res.json()
      const book = response.data  // API 返回 { status, data: {...} }
      console.log(`[UploadManager] Polling conversion status for ${bookId}:`, book?.conversion_status)
      
      if (book?.conversion_status === 'completed') {
        // 转换完成，停止轮询并开始监控元数据提取
        console.log(`[UploadManager] Conversion completed for ${bookId}, starting metadata monitoring`)
        if (conversionPollRef.current) {
          clearInterval(conversionPollRef.current)
          conversionPollRef.current = null
        }
        convertingBookRef.current = null
        
        // 广播转换完成事件，通知 LibraryPage 刷新
        window.dispatchEvent(new CustomEvent('book_conversion_complete', {
          detail: { bookId, title }
        }))
        
        // 开始监控元数据提取
        lastUploadRef.current = { id: bookId, title }
        dialogShownRef.current = false
        startMonitoring(bookId)
      } else if (book?.conversion_status === 'failed') {
        // 转换失败，停止轮询
        console.log(`[UploadManager] Conversion failed for ${bookId}`)
        if (conversionPollRef.current) {
          clearInterval(conversionPollRef.current)
          conversionPollRef.current = null
        }
        convertingBookRef.current = null
      }
      // pending/processing: 继续轮询
    } catch (err) {
      console.error('[UploadManager] Error polling conversion status:', err)
    }
  }, [startMonitoring])
  
  // 开始监控转换状态（用于非 EPUB/PDF 格式）
  const startConversionMonitoring = useCallback((bookId: string, title: string) => {
    console.log(`[UploadManager] Starting conversion monitoring for ${bookId} (${title})`)
    
    // 清理之前的轮询
    if (conversionPollRef.current) {
      clearInterval(conversionPollRef.current)
    }
    
    convertingBookRef.current = { id: bookId, title }
    
    // 立即检查一次
    pollConversionStatus(bookId, title)
    
    // 每 3 秒轮询一次，最多 5 分钟（100 次）
    let pollCount = 0
    const maxPolls = 100
    conversionPollRef.current = setInterval(() => {
      pollCount++
      if (pollCount >= maxPolls) {
        console.log(`[UploadManager] Conversion monitoring timeout for ${bookId}`)
        if (conversionPollRef.current) {
          clearInterval(conversionPollRef.current)
          conversionPollRef.current = null
        }
        convertingBookRef.current = null
        return
      }
      pollConversionStatus(bookId, title)
    }, 3000)
  }, [pollConversionStatus])
  
  // 组件卸载时清理轮询
  useEffect(() => {
    return () => {
      if (conversionPollRef.current) {
        clearInterval(conversionPollRef.current)
      }
    }
  }, [])

  const {
    stage,
    progress,
    fileName,
    errorCode,
    isUploading,
    start,
    cancel,
    reset,
  } = useBookUpload({
    onSuccess: (result) => {
      onSuccess?.(result)
      // 广播上传成功事件，供其他组件监听
      window.dispatchEvent(new CustomEvent('book_uploaded', { detail: result }))
      
      // 从 pendingFile 或 fileName 状态获取文件扩展名
      // 注意：result.title 是书名，不是文件名！
      const currentFileName = pendingFile?.name || fileName || ''
      const originalFormat = currentFileName.split('.').pop()?.toLowerCase() || ''
      const directFormats = ['epub', 'pdf']
      const needsConversion = originalFormat !== '' && !directFormats.includes(originalFormat)
      
      console.log(`[UploadManager] Upload success! bookId=${result.id}, fileName=${currentFileName}, format=${originalFormat}, needsConversion=${needsConversion}`)
      
      // 保存上传信息（包含格式信息）
      lastUploadRef.current = { id: result.id, title: result.title, format: originalFormat }
      dialogShownRef.current = false  // 重置对话框显示标记
      
      console.log(`[UploadManager] Set lastUploadRef to:`, lastUploadRef.current)
      
      // 【关键】只有 EPUB/PDF 格式才立即开始监控元数据提取
      // 其他格式（AZW3/MOBI等）需要先完成 Calibre 转换，转换完成后会自动触发元数据提取
      if (!needsConversion) {
        console.log(`[UploadManager] Starting immediate metadata monitoring for ${result.id}`)
        startMonitoring(result.id)
      } else {
        console.log(`[UploadManager] Format ${originalFormat} needs conversion, starting conversion monitoring`)
        // 开始监控转换状态，转换完成后自动开始元数据监控
        startConversionMonitoring(result.id, result.title)
      }
      
      // 延迟关闭上传 modal（但不立即导航，等待后处理完成）
      setTimeout(() => {
        setIsModalOpen(false)
        reset()
        
        // 对于需要转换的格式，直接导航到书库页面
        if (needsConversion && navigateOnSuccess) {
          navigate('/app/library')
        }
      }, 1500)
    },
    onError: (code) => {
      onError?.(code)
    },
  })

  // 后处理完成后的回调
  const handlePostProcessComplete = useCallback(() => {
    stopMonitoring()
    setPostProcessData(null)
    lastUploadRef.current = null
    dialogShownRef.current = false  // 重置对话框显示标记
    
    // 广播事件通知 LibraryPage 刷新数据，确保 isImageBased 等字段更新
    window.dispatchEvent(new CustomEvent('book_data_updated'))
    
    if (navigateOnSuccess) {
      navigate('/app/library')
    }
  }, [navigateOnSuccess, navigate, stopMonitoring])

  // 后处理对话框关闭
  const handlePostProcessClose = useCallback((open: boolean) => {
    setPostProcessOpen(open)
    if (!open) {
      // 用户关闭对话框，也执行导航
      handlePostProcessComplete()
    }
  }, [handlePostProcessComplete])

  // 处理文件选择
  const handleFileSelect = useCallback((file: File) => {
    setPendingFile(file)
    start(file)
  }, [start])

  // 处理取消
  const handleCancel = useCallback(() => {
    cancel()
    setPendingFile(null)
  }, [cancel])

  // 处理重试
  const handleRetry = useCallback(() => {
    if (pendingFile) {
      reset()
      start(pendingFile)
    }
  }, [pendingFile, reset, start])

  // 处理关闭 Modal
  const handleCloseModal = useCallback(() => {
    if (isUploading) {
      // 如果正在上传，先确认是否取消
      if (window.confirm(t('upload.confirm_cancel'))) {
        cancel()
        setIsModalOpen(false)
        setPendingFile(null)
        reset()
      }
    } else {
      setIsModalOpen(false)
      setPendingFile(null)
      reset()
    }
  }, [isUploading, cancel, reset, t])

  // 处理完成后关闭
  const handleDismiss = useCallback(() => {
    setIsModalOpen(false)
    setPendingFile(null)
    reset()
  }, [reset])

  // 渲染触发按钮
  const renderTrigger = () => {
    switch (variant) {
      case 'icon':
        return (
          <button
            onClick={() => setIsModalOpen(true)}
            className={cn(
              // 圆形按钮 - 白色背景 + 黑色加号 + 阴影
              'flex h-11 w-11 items-center justify-center rounded-full',
              'bg-white dark:bg-gray-800 shadow-lg border border-gray-200 dark:border-gray-700',
              'hover:shadow-xl hover:scale-105 active:scale-95 transition-all',
              className
            )}
            aria-label={t('upload.cta')}
          >
            <Plus className="h-6 w-6 text-gray-900 dark:text-white" strokeWidth={2.5} />
          </button>
        )
      case 'inline':
        return (
          <div className={cn('w-full', className)}>
            {stage === 'idle' ? (
              <UploadDropzone onFileSelect={handleFileSelect} />
            ) : (
              <UploadProgress
                stage={stage}
                progress={progress}
                fileName={fileName || ''}
                errorCode={errorCode}
                onCancel={handleCancel}
                onRetry={handleRetry}
                onDismiss={handleDismiss}
              />
            )}
          </div>
        )
      default:
        return (
          <button
            onClick={() => setIsModalOpen(true)}
            className={cn(
              // 主要按钮样式 - 确保在明亮模式下可见
              'inline-flex items-center gap-2 rounded-full px-5 py-2.5',
              'bg-system-blue text-white shadow-md',
              'hover:opacity-90 active:scale-95 transition-all',
              'text-sm font-medium',
              className
            )}
          >
            <Plus className="h-4 w-4" strokeWidth={2} />
            {t('upload.cta')}
          </button>
        )
    }
  }

  // inline 变体直接渲染，不需要 Modal
  if (variant === 'inline') {
    return (
      <>
        {renderTrigger()}
        {/* 后处理对话框 */}
        {postProcessData && (
          <UploadPostProcessDialog
            open={postProcessOpen}
            onOpenChange={handlePostProcessClose}
            bookId={postProcessData.bookId}
            bookTitle={postProcessData.bookTitle}
            needsMetadataConfirm={postProcessData.needsMetadataConfirm}
            extractedTitle={postProcessData.extractedTitle}
            extractedAuthor={postProcessData.extractedAuthor}
            isImageBasedPdf={postProcessData.isImageBasedPdf}
            pageCount={postProcessData.pageCount}
            onComplete={handlePostProcessComplete}
          />
        )}
      </>
    )
  }

  return (
    <>
      {renderTrigger()}

      {isModalOpen && (
        <Modal onClose={handleCloseModal}>
          <div className="w-full max-w-md">
            <h2 className="text-lg font-semibold text-label mb-4">
              {t('upload.title')}
            </h2>

            {stage === 'idle' ? (
              <UploadDropzone
                onFileSelect={handleFileSelect}
                disabled={isUploading}
              />
            ) : (
              <UploadProgress
                stage={stage}
                progress={progress}
                fileName={fileName || ''}
                errorCode={errorCode}
                onCancel={handleCancel}
                onRetry={handleRetry}
                onDismiss={stage === 'done' || stage === 'error' ? handleDismiss : undefined}
              />
            )}
          </div>
        </Modal>
      )}
      
      {/* 后处理对话框 */}
      {postProcessData && (
        <UploadPostProcessDialog
          open={postProcessOpen}
          onOpenChange={handlePostProcessClose}
          bookId={postProcessData.bookId}
          bookTitle={postProcessData.bookTitle}
          needsMetadataConfirm={postProcessData.needsMetadataConfirm}
          extractedTitle={postProcessData.extractedTitle}
          extractedAuthor={postProcessData.extractedAuthor}
          isImageBasedPdf={postProcessData.isImageBasedPdf}
          pageCount={postProcessData.pageCount}
          onComplete={handlePostProcessComplete}
        />
      )}
    </>
  )
}


==================================================
FILE_PATH: web/src/components/base/Button.tsx
==================================================

/**
 * 基础按钮组件
 * - 提供 `primary`/`secondary` 两种主题
 * - 仅封装样式，不包含业务逻辑
 */
type Props = React.ButtonHTMLAttributes<HTMLButtonElement> & { variant?: 'primary' | 'secondary' }
export default function Button({ children, onClick, variant = 'secondary', style, ...rest }: Props) {
  const base = {
    padding: 'var(--space-sm) var(--space-md)',
    borderRadius: variant === 'primary' ? 999 : 8,
    border: 'none',
    cursor: 'pointer',
    fontWeight: variant === 'primary' ? 600 : 'var(--font-weight-medium)'
  } as React.CSSProperties
  const theme = variant === 'primary'
    ? { background: 'var(--color-system-blue)', color: '#fff' }
    : { background: 'var(--color-system-fill)', color: 'var(--color-label)' }
  return (
    <button {...rest} onClick={onClick} style={{ ...base, ...theme, ...style }}>{children}</button>
  )
}


==================================================
FILE_PATH: web/src/components/base/Input.tsx
==================================================

/**
 * 基础输入组件
 * - 包装原生 `<input>` 并统一样式
 * - 支持占位符与类型设置
 */
type Props = { id?: string; ariaLabel?: string; value: string; onChange: (e: React.ChangeEvent<HTMLInputElement>) => void; placeholder?: string; style?: React.CSSProperties; type?: string }
export default function Input({ id, ariaLabel, value, onChange, placeholder, style, type = 'text' }: Props) {
  return (
    <input id={id} aria-label={ariaLabel} type={type} value={value} onChange={onChange} placeholder={placeholder} style={{
      width: '100%',
      padding: 'var(--space-sm)',
      border: '1px solid #ccc',
      borderRadius: 8,
      ...style
    }} />
  )
}


==================================================
FILE_PATH: web/src/components/base/Modal.tsx
==================================================

/**
 * 基础模态容器
 * - 居中弹层与遮罩
 * - 不含关闭逻辑，由父组件控制显示与关闭
 */
type Props = { children: React.ReactNode }
export default function Modal({ children }: Props) {
  return (
    <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.3)', display: 'grid', placeItems: 'center' }}>
      <div style={{ width: 440, background: 'var(--color-system-background)', border: '1px solid #eee', borderRadius: 12, padding: 'var(--space-lg)' }}>{children}</div>
    </div>
  )
}


==================================================
FILE_PATH: web/src/stores/auth.ts
==================================================

/**
 * 认证状态管理（Zustand 持久化）
 *
 * 内容：
 * - 保存 access/refresh token、过期时间与用户信息
 * - 支持并发安全的 Token 刷新（通过单例 `refreshPromise`）
 * - 本地持久化键：`athena-auth`
 *
 * 约定：
 * - 刷新失败后使用 `clear()` 清空并进入未登录态
 */
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

interface User {
  id: string
  email: string
  display_name?: string
}

interface AuthState {
  accessToken: string | null
  refreshToken: string | null
  expiresAt: number | null
  user: User | null
  isAuthenticated: boolean

  // Actions
  setTokens: (accessToken: string, refreshToken: string, expiresIn: number, user?: User) => void
  setUser: (user: User) => void
  refreshAccessToken: () => Promise<boolean>
  logout: () => void
  clear: () => void

  // Computed
  isTokenExpired: () => boolean
  isTokenExpiringSoon: () => boolean
}

let refreshPromise: Promise<boolean> | null = null

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      accessToken: null,
      refreshToken: null,
      expiresAt: null,
      user: null,
      isAuthenticated: false,

      setTokens: (accessToken, refreshToken, expiresIn, user) => {
        const expiresAt = Date.now() + expiresIn * 1000

        console.log('[Auth] Setting tokens:', {
          accessToken: accessToken.substring(0, 20) + '...',
          expiresIn,
          expiresAt: new Date(expiresAt).toISOString()
        })

        set({
          accessToken,
          refreshToken,
          expiresAt,
          user: user || get().user,
          isAuthenticated: true
        })
      },

      setUser: (user) => set({ user }),

      refreshAccessToken: async () => {
        // 防止并发刷新
        if (refreshPromise) {
          console.log('[Auth] Refresh already in progress, waiting...')
          return refreshPromise
        }

        const { refreshToken } = get()
        if (!refreshToken) {
          console.log('[Auth] No refresh token available')
          return false
        }

        console.log('[Auth] Starting token refresh...')

        refreshPromise = (async () => {
          try {
            const response = await fetch('/api/v1/auth/refresh', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ refresh_token: refreshToken })
            })

            if (!response.ok) {
              console.error('[Auth] Refresh request failed:', response.status)
              throw new Error('Refresh failed')
            }

            const data = await response.json()

            if (data.status === 'success' && data.data?.access_token) {
              const { access_token, expires_in } = data.data
              const expiresAt = Date.now() + expires_in * 1000

              console.log('[Auth] Token refreshed successfully')

              set({
                accessToken: access_token,
                expiresAt,
                isAuthenticated: true
              })

              return true
            }

            console.error('[Auth] Invalid refresh response:', data)
            return false
          } catch (error) {
            console.error('[Auth] Token refresh error:', error)
            get().clear()
            return false
          } finally {
            refreshPromise = null
          }
        })()

        return refreshPromise
      },

      isTokenExpired: () => {
        const { expiresAt } = get()
        if (!expiresAt) return true
        const expired = Date.now() >= expiresAt
        if (expired) {
          console.log('[Auth] Token is expired')
        }
        return expired
      },

      isTokenExpiringSoon: () => {
        const { expiresAt } = get()
        if (!expiresAt) return true
        // 5 分钟内过期视为即将过期
        const expiringSoon = Date.now() >= expiresAt - 5 * 60 * 1000
        if (expiringSoon) {
          console.log('[Auth] Token expiring soon')
        }
        return expiringSoon
      },

      logout: async () => {
        const { accessToken } = get()

        console.log('[Auth] Logging out...')

        // 调用后端登出接口
        if (accessToken) {
          try {
            await fetch('/api/v1/auth/logout', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
              },
              body: JSON.stringify({})
            })
          } catch (error) {
            console.error('[Auth] Logout error:', error)
          }
        }

        get().clear()
      },

      clear: () => {
        console.log('[Auth] Clearing auth state')
        set({
          accessToken: null,
          refreshToken: null,
          expiresAt: null,
          user: null,
          isAuthenticated: false
        })
      }
    }),
    {
      name: 'athena-auth',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        accessToken: state.accessToken,
        refreshToken: state.refreshToken,
        expiresAt: state.expiresAt,
        user: state.user,
        isAuthenticated: state.isAuthenticated
      }),
      onRehydrateStorage: () => (state) => {
        if (state) {
          console.log('[Auth] Rehydrated from storage:', {
            hasAccessToken: !!state.accessToken,
            hasRefreshToken: !!state.refreshToken,
            isAuthenticated: state.isAuthenticated,
            expiresAt: state.expiresAt ? new Date(state.expiresAt).toISOString() : null
          })
        }
      }
    }
  )
)


==================================================
FILE_PATH: scripts/test_alignment.py
==================================================

#!/usr/bin/env python3
"""
测试 PyMuPDF 文字嵌入与坐标对齐

这个测试创建一个带有已知位置文字的 PDF，然后验证嵌入的透明文字层是否对齐。
"""
import sys
sys.path.insert(0, '/app')

import fitz
import io

def test_coordinate_alignment():
    """测试坐标对齐"""
    print("=" * 60)
    print("测试 PyMuPDF 文字嵌入坐标对齐")
    print("=" * 60)
    
    # 模拟 OCR 结果
    # 假设 OCR 图片尺寸是 1000x1414（类似 A4 的比例）
    ocr_width = 1000
    ocr_height = 1414
    
    # 模拟 PaddleOCR 返回的区域
    # polygon 格式: [[左上x,左上y], [右上x,右上y], [右下x,右下y], [左下x,左下y]]
    mock_ocr_pages = [
        {
            "page_num": 1,
            "width": ocr_width,
            "height": ocr_height,
            "regions": [
                {
                    "text": "测试文字一",
                    "confidence": 0.99,
                    "polygon": [[100, 100], [300, 100], [300, 140], [100, 140]],
                },
                {
                    "text": "第二行文字",
                    "confidence": 0.98,
                    "polygon": [[100, 200], [350, 200], [350, 240], [100, 240]],
                },
                {
                    "text": "English Text",
                    "confidence": 0.97,
                    "polygon": [[100, 300], [400, 300], [400, 340], [100, 340]],
                },
                {
                    "text": "底部测试",
                    "confidence": 0.96,
                    "polygon": [[100, 1300], [280, 1300], [280, 1340], [100, 1340]],
                },
            ]
        }
    ]
    
    # 创建一个空白 PDF 页面
    doc = fitz.open()
    page = doc.new_page(width=595, height=842)  # A4 尺寸
    
    pdf_width = page.rect.width
    pdf_height = page.rect.height
    
    # 计算缩放比例
    scale_x = pdf_width / ocr_width
    scale_y = pdf_height / ocr_height
    
    print(f"\nPDF 尺寸: {pdf_width} x {pdf_height}")
    print(f"OCR 图片尺寸: {ocr_width} x {ocr_height}")
    print(f"缩放比例: scale_x={scale_x:.4f}, scale_y={scale_y:.4f}")
    
    # 遍历并嵌入文字
    for region in mock_ocr_pages[0]["regions"]:
        text = region["text"]
        polygon = region["polygon"]
        
        # 提取多边形顶点
        p0, p1, p2, p3 = polygon[0], polygon[1], polygon[2], polygon[3]
        
        # 缩放到 PDF 坐标（无需 Y 轴翻转）
        pdf_x0, pdf_y0 = p0[0] * scale_x, p0[1] * scale_y
        pdf_x1, pdf_y1 = p1[0] * scale_x, p1[1] * scale_y
        pdf_x2, pdf_y2 = p2[0] * scale_x, p2[1] * scale_y
        pdf_x3, pdf_y3 = p3[0] * scale_x, p3[1] * scale_y
        
        # 计算宽度和高度
        text_width = ((pdf_x1 - pdf_x0) ** 2 + (pdf_y1 - pdf_y0) ** 2) ** 0.5
        text_height = ((pdf_x3 - pdf_x0) ** 2 + (pdf_y3 - pdf_y0) ** 2) ** 0.5
        
        # 计算字体大小
        char_count = len(text)
        cjk_count = sum(1 for c in text if '\u4e00' <= c <= '\u9fff')
        eng_count = char_count - cjk_count
        avg_char_width_ratio = (cjk_count * 1.0 + eng_count * 0.5) / max(char_count, 1)
        
        font_size_by_height = text_height * 0.85
        font_size_by_width = text_width / (char_count * avg_char_width_ratio) if avg_char_width_ratio > 0 else font_size_by_height
        font_size = min(font_size_by_height, font_size_by_width)
        font_size = max(4, min(font_size, 72))
        
        # 插入点和基线
        insert_x = pdf_x0
        baseline_y = pdf_y0 + text_height * 0.80
        
        print(f"\n文字: '{text}'")
        print(f"  OCR polygon: {polygon}")
        print(f"  PDF 左上角: ({pdf_x0:.1f}, {pdf_y0:.1f})")
        print(f"  区域尺寸: {text_width:.1f} x {text_height:.1f}")
        print(f"  字体大小: {font_size:.1f}")
        print(f"  基线位置: ({insert_x:.1f}, {baseline_y:.1f})")
        
        # 先画一个矩形框来标记原始区域
        rect = fitz.Rect(pdf_x0, pdf_y0, pdf_x1, pdf_y2)
        page.draw_rect(rect, color=(1, 0, 0), width=0.5)  # 红色边框
        
        # 插入透明文字
        page.insert_text(
            (insert_x, baseline_y),
            text,
            fontsize=font_size,
            fontname="china-s",
            color=(0.2, 0.2, 0.8),  # 蓝色（用于可视化测试）
        )
    
    # 保存 PDF
    pdf_data = doc.tobytes()
    doc.close()
    
    # 保存到文件
    output_path = "/tmp/test_alignment.pdf"
    with open(output_path, "wb") as f:
        f.write(pdf_data)
    
    print(f"\n✅ 测试 PDF 已保存到: {output_path}")
    print("   红色框 = OCR 检测到的文字区域")
    print("   蓝色文字 = 嵌入的透明文字层")
    print("\n请使用 'docker cp athena-api-1:/tmp/test_alignment.pdf .' 复制到本地检查")
    
    # 验证文字可以被提取
    doc2 = fitz.open(stream=pdf_data, filetype="pdf")
    extracted_text = doc2[0].get_text()
    doc2.close()
    
    print(f"\n提取的文字:\n{extracted_text}")
    
    return True

if __name__ == "__main__":
    test_coordinate_alignment()


==================================================
FILE_PATH: scripts/calibre-convert.ps1
==================================================

param(
  [string]$BookId,
  [string]$ApiBase = "http://localhost:8000",
  [string]$Token
)

if (-not $Token) {
  Write-Error "Missing Token"
  exit 1
}

$headers = @{ Authorization = "Bearer $Token" }

# Download inside calibre container and convert
$id = [guid]::NewGuid().ToString()
$input = "/books/input-$id"
$output = "/books/output-$id.epub"
# Host download then copy into container
# Ask API for internal presign GET
$src = Invoke-RestMethod -Method Post -Uri "$ApiBase/api/v1/books/$BookId/presign_get_source" -Headers $headers -ContentType "application/json"
$getUrl = $src.data.get_url
# Download inside container and convert
docker compose exec -T calibre /bin/sh -lc "apk add --no-cache wget >/dev/null 2>&1 || true; wget -O $input '$getUrl' && ebook-convert $input $output"

# Ask API for presign put
$resp = Invoke-RestMethod -Method Post -Uri "$ApiBase/api/v1/books/$BookId/presign_put_converted" -Headers $headers -ContentType "application/json"
$put = $resp.data.put_url
$key = $resp.data.key

# Copy file to host and upload via presign PUT
docker compose cp calibre:$output ./tmp-output-$id.epub
Invoke-WebRequest -Method Put -Uri $put -InFile (Resolve-Path ./tmp-output-$id.epub)
Remove-Item -Force ./tmp-output-$id.epub

# Update book record
Invoke-RestMethod -Method Post -Uri "$ApiBase/api/v1/books/$BookId/set_converted" -Headers $headers -ContentType "application/json" -Body (@{ key=$key } | ConvertTo-Json)

Write-Output "Converted and uploaded: $key"

==================================================
FILE_PATH: scripts/es-bootstrap.ps1
==================================================

param(
  [string]$BaseUrl = "http://localhost:9200",
  [string]$NotesIndex = "notes",
  [string]$HighlightsIndex = "highlights",
  [string]$BooksIndex = "books"
)
$ErrorActionPreference = "Stop"
Invoke-RestMethod -Method Put -Uri "$BaseUrl/$NotesIndex" -ContentType 'application/json' -Body (@{
  settings = @{ number_of_shards = 1; number_of_replicas = 0 }
  mappings = @{ properties = @{ id=@{type='keyword'}; user_id=@{type='keyword'}; book_id=@{type='keyword'}; content=@{type='text'}; tag_ids=@{type='keyword'} } }
} | ConvertTo-Json -Depth 6) | Out-Null
Invoke-RestMethod -Method Put -Uri "$BaseUrl/$HighlightsIndex" -ContentType 'application/json' -Body (@{
  settings = @{ number_of_shards = 1; number_of_replicas = 0 }
  mappings = @{ properties = @{ id=@{type='keyword'}; user_id=@{type='keyword'}; book_id=@{type='keyword'}; text_content=@{type='text'}; color=@{type='keyword'}; tag_ids=@{type='keyword'} } }
} | ConvertTo-Json -Depth 6) | Out-Null
Invoke-RestMethod -Method Put -Uri "$BaseUrl/$BooksIndex" -ContentType 'application/json' -Body (@{
  settings = @{ number_of_shards = 1; number_of_replicas = 0 }
  mappings = @{ properties = @{ id=@{type='keyword'}; user_id=@{type='keyword'}; title=@{type='text'}; author=@{type='text'} } }
} | ConvertTo-Json -Depth 6) | Out-Null
Write-Output "ES indices ensured: $NotesIndex, $HighlightsIndex, $BooksIndex"

==================================================
FILE_PATH: scripts/test_pymupdf_coords.py
==================================================

#!/usr/bin/env python3
"""验证 PyMuPDF 坐标系"""
import fitz

# 创建一个测试PDF
doc = fitz.open()
page = doc.new_page(width=595, height=842)

print(f'Page rect: {page.rect}')
print(f'Page origin: ({page.rect.x0}, {page.rect.y0})')
print(f'Page dimensions: {page.rect.width} x {page.rect.height}')

# 在不同位置插入文字
page.insert_text((50, 50), 'Y=50 (top?)', fontsize=20, fontname='helv')
page.insert_text((50, 421), 'Y=421 (middle)', fontsize=20, fontname='helv')
page.insert_text((50, 800), 'Y=800 (bottom?)', fontsize=20, fontname='helv')

# 保存并查看
pdf_data = doc.tobytes()
doc.close()

# 重新打开获取文字位置
doc2 = fitz.open(stream=pdf_data, filetype='pdf')
page2 = doc2[0]

# 获取所有文字块
blocks = page2.get_text('dict')['blocks']
for block in blocks:
    if block.get('type') == 0:  # text block
        for line in block.get('lines', []):
            for span in line.get('spans', []):
                bbox = span['bbox']
                print(f"Text: '{span['text']}' at y={bbox[1]:.1f}")

doc2.close()

print('\n结论:')
print('  - PyMuPDF 坐标系原点在左上角')
print('  - Y=0 在页面顶部, Y 增加向下')
print('  - 这与 OCR 坐标系相同，不需要 Y 轴翻转!')


==================================================
FILE_PATH: scripts/calibre-convert-watcher.sh
==================================================

#!/bin/bash
# Calibre 转换监控器
# 监听 .request 文件并执行 ebook-convert 转换
# 支持将 MOBI, AZW3, FB2 等格式转换为 EPUB

WATCH_DIR="/books"
LOG_FILE="/books/convert.log"

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" >> "$LOG_FILE"
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1"
}

log "Calibre Convert Watcher started"

# 处理单个转换请求
process_request() {
    local request_file="$1"
    local job_id=$(basename "$request_file" .request)
    job_id="${job_id#convert-}"  # 移除 convert- 前缀
    
    log "Processing conversion request: $job_id"
    
    # 读取请求文件内容
    # 格式: 第一行是输入文件路径，第二行是输出文件路径
    local input_path=$(sed -n '1p' "$request_file")
    local output_path=$(sed -n '2p' "$request_file")
    local done_file="/books/convert-${job_id}.done"
    local error_file="/books/convert-${job_id}.error"
    
    log "Input: $input_path -> Output: $output_path"
    
    if [[ ! -f "$input_path" ]]; then
        log "ERROR: Input file not found: $input_path"
        echo "Input file not found: $input_path" > "$error_file"
        rm -f "$request_file"
        return
    fi
    
    # 执行 ebook-convert
    log "Starting conversion..."
    if ebook-convert "$input_path" "$output_path" >> "$LOG_FILE" 2>&1; then
        if [[ -f "$output_path" ]] && [[ -s "$output_path" ]]; then
            log "Conversion successful: $(stat -c%s "$output_path") bytes"
            touch "$done_file"
        else
            log "ERROR: Output file empty or not created"
            echo "Output file empty or not created" > "$error_file"
        fi
    else
        log "ERROR: ebook-convert failed"
        echo "ebook-convert command failed" > "$error_file"
    fi
    
    # 删除请求文件
    rm -f "$request_file"
    
    # 清理输入文件（转换完成后不再需要）
    rm -f "$input_path"
}

# 主循环：轮询监听请求
log "Watching for .request files in $WATCH_DIR"
while true; do
    for request_file in "$WATCH_DIR"/convert-*.request; do
        if [[ -f "$request_file" ]]; then
            process_request "$request_file"
        fi
    done
    sleep 2
done


==================================================
FILE_PATH: scripts/calibre-metadata-watcher.sh
==================================================

#!/bin/bash
# Calibre 元数据提取监控器
# 监听 metadata_requests 目录，使用 ebook-meta 提取元数据和封面
# 支持 MOBI, AZW3, FB2, LRF 等非 EPUB/PDF 格式

WATCH_DIR="/books"
LOG_FILE="/books/metadata.log"

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" >> "$LOG_FILE"
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1"
}

log "Calibre Metadata Watcher started"

# 确保目录存在
mkdir -p "$WATCH_DIR"

# 处理单个元数据请求
process_request() {
    local request_file="$1"
    local job_id=$(basename "$request_file" .metadata.request)
    
    log "Processing metadata request: $job_id"
    
    # 读取请求文件内容
    # 格式: 第一行是输入文件路径，第二行是封面输出路径
    local input_path=$(sed -n '1p' "$request_file")
    local cover_output=$(sed -n '2p' "$request_file")
    # job_id 已经包含 "metadata-" 前缀，所以直接使用
    local metadata_output="/books/${job_id}.txt"
    local done_file="/books/${job_id}.done"
    local error_file="/books/${job_id}.error"
    
    log "Input: $input_path, Cover: $cover_output"
    
    if [[ ! -f "$input_path" ]]; then
        log "ERROR: Input file not found: $input_path"
        echo "Input file not found" > "$error_file"
        rm -f "$request_file"
        return
    fi
    
    # 执行 ebook-meta 提取元数据
    if ebook-meta "$input_path" > "$metadata_output" 2>&1; then
        log "Metadata extracted successfully"
    else
        log "WARNING: Metadata extraction returned error, but continuing..."
    fi
    
    # 提取封面
    if [[ -n "$cover_output" ]]; then
        if ebook-meta "$input_path" --get-cover="$cover_output" 2>&1; then
            if [[ -f "$cover_output" ]] && [[ -s "$cover_output" ]]; then
                log "Cover extracted: $cover_output ($(stat -c%s "$cover_output") bytes)"
            else
                log "WARNING: Cover file empty or not created"
            fi
        else
            log "WARNING: Cover extraction failed"
        fi
    fi
    
    # 创建完成标志
    touch "$done_file"
    log "Done: $job_id"
    
    # 删除请求文件
    rm -f "$request_file"
}

# 主循环：轮询监听请求
while true; do
    for request_file in "$WATCH_DIR"/*.metadata.request; do
        if [[ -f "$request_file" ]]; then
            process_request "$request_file"
        fi
    done
    sleep 1
done


==================================================
FILE_PATH: scripts/infisical-inject.ps1
==================================================

param(
  [string]$EnvName = "dev",
  [string]$Output = ".env.infisical"
)
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"
if (Get-Command infisical -ErrorAction SilentlyContinue) {
  infisical export --env $EnvName --format dotenv --output $Output
} else {
  if (Test-Path ".env.local") {
    Copy-Item ".env.local" -Destination $Output -Force
  } else {
    New-Item -ItemType File -Path $Output -Force | Out-Null
  }
}
Write-Output "ENV_FILE=$Output"

==================================================
FILE_PATH: scripts/calibre-custom-init.sh
==================================================

#!/bin/bash
# Calibre 容器自定义初始化脚本
# 在后台启动格式转换监控器

echo "[custom-init] Starting Calibre convert watcher..."

# 确保脚本有执行权限
chmod +x /scripts/convert-watcher.sh

# 在后台运行 watcher
nohup /scripts/convert-watcher.sh > /config/logs/convert-watcher.log 2>&1 &

echo "[custom-init] Convert watcher started in background (PID: $!)"
echo "[custom-init] Log file: /config/logs/convert-watcher.log"


==================================================
FILE_PATH: scripts/test_ocrmypdf.ps1
==================================================

#!/usr/bin/env pwsh
# OCRmyPDF 集成自动化测试脚本

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "OCRmyPDF Integration Test Suite" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan

$ErrorCount = 0

# 1. 验证 Docker 容器运行状态
Write-Host "`n[1/5] Checking Docker Container Status..." -ForegroundColor Yellow
$containerStatus = docker-compose ps api --format json | ConvertFrom-Json
if ($containerStatus.State -ne "running") {
    Write-Host "✗ API container is not running: $($containerStatus.State)" -ForegroundColor Red
    Write-Host "  Starting API container..." -ForegroundColor Yellow
    docker-compose up -d api
    Start-Sleep -Seconds 10
} else {
    Write-Host "✓ API container is running" -ForegroundColor Green
}

# 2. 验证 OCRmyPDF 安装
Write-Host "`n[2/5] Verifying OCRmyPDF Installation..." -ForegroundColor Yellow
$ocrmypdfCheck = docker-compose exec -T api python -c "import ocrmypdf; print(ocrmypdf.__version__)" 2>&1
if ($LASTEXITCODE -eq 0) {
    Write-Host "✓ OCRmyPDF installed: $ocrmypdfCheck" -ForegroundColor Green
} else {
    Write-Host "✗ OCRmyPDF not installed" -ForegroundColor Red
    $ErrorCount++
}

# 3. 验证 Tesseract 安装和语言包
Write-Host "`n[3/5] Verifying Tesseract OCR..." -ForegroundColor Yellow
$tesseractVersion = docker-compose exec -T api tesseract --version 2>&1 | Select-Object -First 1
Write-Host "  Version: $tesseractVersion" -ForegroundColor Gray

$tesseractLangs = docker-compose exec -T api tesseract --list-langs 2>&1
if ($tesseractLangs -match "chi_sim" -and $tesseractLangs -match "eng") {
    Write-Host "✓ Tesseract installed with Chinese support" -ForegroundColor Green
} else {
    Write-Host "✗ Chinese language packs missing" -ForegroundColor Red
    $ErrorCount++
}

# 4. 运行 Python 集成测试
Write-Host "`n[4/5] Running Integration Tests..." -ForegroundColor Yellow
$testResult = docker-compose exec -T api pytest /app/tests/test_ocrmypdf_integration.py -v --tb=short 2>&1
Write-Host $testResult

if ($LASTEXITCODE -eq 0) {
    Write-Host "✓ All integration tests passed" -ForegroundColor Green
} else {
    Write-Host "✗ Some tests failed" -ForegroundColor Red
    $ErrorCount++
}

# 5. 验证 API 健康状态
Write-Host "`n[5/5] Checking API Health..." -ForegroundColor Yellow
try {
    $healthCheck = Invoke-WebRequest -Uri "http://localhost:8000/health" -TimeoutSec 5 -ErrorAction Stop
    if ($healthCheck.StatusCode -eq 200) {
        Write-Host "✓ API is healthy" -ForegroundColor Green
    } else {
        Write-Host "✗ API returned status $($healthCheck.StatusCode)" -ForegroundColor Red
        $ErrorCount++
    }
} catch {
    Write-Host "✗ API is not responding: $($_.Exception.Message)" -ForegroundColor Red
    $ErrorCount++
}

# 总结
Write-Host "`n========================================" -ForegroundColor Cyan
if ($ErrorCount -eq 0) {
    Write-Host "✅ All Tests Passed!" -ForegroundColor Green
    Write-Host "`nOCRmyPDF integration is ready for use." -ForegroundColor Green
    Write-Host "You can now upload PDFs and test the layered PDF generation." -ForegroundColor Gray
} else {
    Write-Host "❌ $ErrorCount Test(s) Failed" -ForegroundColor Red
    Write-Host "`nPlease check the error messages above." -ForegroundColor Yellow
}
Write-Host "========================================" -ForegroundColor Cyan

exit $ErrorCount


==================================================
FILE_PATH: scripts/init-data-dirs.sh
==================================================

#!/bin/bash
# =========================================================================
# Athena 数据目录初始化脚本
# =========================================================================
# 功能：
# 1. 创建 SSD 上的高性能数据目录
# 2. 创建 HDD (bcache) 上的大容量数据目录
# 3. 设置正确的权限
# =========================================================================

set -e

echo "=========================================="
echo "Athena 数据目录初始化"
echo "=========================================="

# 颜色定义
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# 检查是否在 Athena 项目根目录
if [ ! -f "docker-compose.yml" ]; then
    echo -e "${RED}错误: 请在 Athena 项目根目录运行此脚本${NC}"
    exit 1
fi

# 获取当前用户
CURRENT_USER=$(whoami)
CURRENT_UID=$(id -u)
CURRENT_GID=$(id -g)

echo -e "${YELLOW}当前用户: $CURRENT_USER (UID: $CURRENT_UID, GID: $CURRENT_GID)${NC}"
echo ""

# =========================================================================
# 1. 创建 SSD 上的高性能数据目录
# =========================================================================
echo -e "${GREEN}[1/3] 创建 SSD 数据目录...${NC}"

SSD_BASE="/home/vitiana/Athena/data_ssd"
SSD_DIRS=(
    "$SSD_BASE/postgres"
    "$SSD_BASE/valkey"
    "$SSD_BASE/opensearch"
    "$SSD_BASE/hf_cache"
)

for dir in "${SSD_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
        echo "  ✓ 创建: $dir"
    else
        echo "  - 已存在: $dir"
    fi
done

# 设置 SSD 目录权限
chown -R $CURRENT_USER:$CURRENT_USER "$SSD_BASE"
chmod -R 755 "$SSD_BASE"
echo -e "${GREEN}  ✓ SSD 目录权限设置完成${NC}"
echo ""

# =========================================================================
# 2. 创建 HDD (bcache) 上的大容量数据目录
# =========================================================================
echo -e "${GREEN}[2/3] 创建 HDD (bcache) 数据目录...${NC}"

HDD_BASE="/data/athena"
HDD_DIRS=(
    "$HDD_BASE/seaweed"
    "$HDD_BASE/calibre_books"
    "$HDD_BASE/calibre_config"
    "$HDD_BASE/tolgee"
    "$HDD_BASE/nginx_logs"
)

for dir in "${HDD_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        sudo mkdir -p "$dir"
        echo "  ✓ 创建: $dir"
    else
        echo "  - 已存在: $dir"
    fi
done

# 设置 HDD 目录权限
sudo chown -R $CURRENT_USER:$CURRENT_USER "$HDD_BASE"
sudo chmod -R 755 "$HDD_BASE"
echo -e "${GREEN}  ✓ HDD 目录权限设置完成${NC}"
echo ""

# =========================================================================
# 3. 显示磁盘空间信息
# =========================================================================
echo -e "${GREEN}[3/3] 磁盘空间信息${NC}"
echo ""
echo "SSD (系统盘):"
df -h / | tail -1
echo ""
echo "HDD (bcache):"
df -h /data | tail -1
echo ""

# =========================================================================
# 4. 显示目录结构
# =========================================================================
echo -e "${GREEN}数据目录结构:${NC}"
echo ""
echo "高性能存储 (SSD):"
tree -L 2 "$SSD_BASE" 2>/dev/null || ls -lh "$SSD_BASE"
echo ""
echo "大容量存储 (HDD bcache):"
tree -L 2 "$HDD_BASE" 2>/dev/null || ls -lh "$HDD_BASE"
echo ""

# =========================================================================
# 完成
# =========================================================================
echo -e "${GREEN}=========================================="
echo "✓ 数据目录初始化完成！"
echo "==========================================${NC}"
echo ""
echo -e "${YELLOW}存储策略说明:${NC}"
echo "  • SSD (932 MB/s, 11.2K IOPS):"
echo "    - PostgreSQL: 数据库事务日志"
echo "    - OpenSearch: 全文索引"
echo "    - Valkey: Redis 持久化"
echo "    - HF Cache: 模型缓存"
echo ""
echo "  • HDD bcache (575 MB/s, SSD 缓存加速):"
echo "    - SeaweedFS: 对象存储"
echo "    - Calibre: 电子书库"
echo "    - Tolgee: 翻译数据库"
echo "    - Nginx Logs: 日志文件"
echo ""
echo -e "${YELLOW}下一步:${NC}"
echo "  1. 检查配置: cat .env"
echo "  2. 启动服务: docker-compose up -d"
echo "  3. 查看日志: docker-compose logs -f"
echo ""


==================================================
FILE_PATH: scripts/register-book.ps1
==================================================

param(
  [string]$Email = 'webmaster@wxbooks.cn',
  [string]$ObjectUrl,
  [string]$Title = '测试书籍',
  [string]$Format = 'epub',
  [int]$Size = 0,
  [string]$BaseUrl = 'http://localhost:8000'
)
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
function Json($obj) { $obj | ConvertTo-Json -Depth 6 }

# 获取验证码并登录
Invoke-RestMethod -Uri "$BaseUrl/api/v1/auth/email/send_code" -Method POST -ContentType 'application/json' -Body (Json @{ email=$Email }) | Out-Null
$dev = Invoke-RestMethod -Uri "$BaseUrl/api/v1/auth/email/dev_code?email=$Email" -Method GET
$code = $dev.data.code
if (-not $code) { throw 'dev_code not available' }
$verify = Invoke-RestMethod -Uri "$BaseUrl/api/v1/auth/email/verify_code" -Method POST -ContentType 'application/json' -Body (Json @{ email=$Email; code=$code })
$token = $verify.data.tokens.access_token
if (-not $token) { throw 'no access token' }

# 注册书籍（使用已上传的对象URL）
if (-not $ObjectUrl) { throw 'ObjectUrl is required' }
$regBody = Json @{ object_url=$ObjectUrl; title=$Title; original_format=$Format; size=$Size }
$reg = Invoke-RestMethod -Uri "$BaseUrl/api/v1/books/register" -Method POST -ContentType 'application/json' -Headers @{ Authorization = "Bearer $token" } -Body $regBody
Write-Output ("REGISTERED=" + ($reg.data | ConvertTo-Json -Depth 6))

# 列出书籍
$books = Invoke-RestMethod -Uri "$BaseUrl/api/v1/books?limit=5" -Headers @{ Authorization = "Bearer $token" }
Write-Output ("BOOKS=" + (Json $books.data))

# 搜索书籍
$search = Invoke-WebRequest -Uri "$BaseUrl/api/v1/search?q=$Title&kind=book&limit=5" -Headers @{ Authorization = "Bearer $token" } -UseBasicParsing
Write-Output ("ENGINE=" + $search.Headers['X-Search-Engine'])
Write-Output ("SEARCH=" + $search.Content)
try {
  Invoke-RestMethod -Uri "$BaseUrl/api/v1/search/reindex_books" -Method POST -Headers @{ Authorization = "Bearer $token" } | Out-Null
} catch {}
Start-Sleep -Seconds 2
$search2 = Invoke-WebRequest -Uri "$BaseUrl/api/v1/search?q=$Title&kind=book&limit=5" -Headers @{ Authorization = "Bearer $token" } -UseBasicParsing
Write-Output ("ENGINE2=" + $search2.Headers['X-Search-Engine'])
Write-Output ("SEARCH2=" + $search2.Content)

==================================================
FILE_PATH: scripts/quality-gates.ps1
==================================================

param()
$ErrorActionPreference = 'Stop'
Write-Output '== Athena Quality Gates =='
$failed = $false

Write-Output 'Contracts: running redocly lint'
pushd ../web
npm run contracts:lint | Out-Host
if ($LASTEXITCODE -ne 0) { Write-Output 'Contracts: FAILED'; $failed = $true }
popd

Write-Output 'ESLint: running'
pushd ../web
npm run lint | Out-Host
if ($LASTEXITCODE -ne 0) { Write-Output 'ESLint: FAILED'; $failed = $true }
popd

Write-Output 'Vitest: unit & coverage'
pushd ../web
npx -y vitest run --coverage | Out-Host
if ($LASTEXITCODE -ne 0) {
  Write-Output 'Vitest coverage failed, fallback to unit only'
  npx -y vitest run | Out-Host
  if ($LASTEXITCODE -ne 0) { Write-Output 'Vitest: FAILED'; $failed = $true }
}
popd

Write-Output 'Cypress: axe and basic flows'
pushd ../web
npm run e2e:axe | Out-Host
if ($LASTEXITCODE -ne 0) { Write-Output 'Cypress axe: FAILED'; $failed = $true }
npm run e2e:flows | Out-Host
if ($LASTEXITCODE -ne 0) { Write-Output 'Cypress flows: FAILED'; $failed = $true }
popd

if ($failed) { Write-Output '== FAILED =='; exit 1 } else { Write-Output '== PASSED =='; exit 0 }

==================================================
FILE_PATH: scripts/reader-e2e.ps1
==================================================

param(
  [string]$Email = 'webmaster@wxbooks.cn',
  [string]$BaseUrl = 'http://localhost:8000'
)
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
function Json($obj) { $obj | ConvertTo-Json -Depth 6 }

Invoke-RestMethod -Uri "$BaseUrl/api/v1/auth/email/send_code" -Method POST -ContentType 'application/json' -Body (Json @{ email=$Email }) | Out-Null
$dev = Invoke-RestMethod -Uri "$BaseUrl/api/v1/auth/email/dev_code?email=$Email" -Method GET
$code = $dev.data.code
if (-not $code) { throw 'dev_code not available' }
$verify = Invoke-RestMethod -Uri "$BaseUrl/api/v1/auth/email/verify_code" -Method POST -ContentType 'application/json' -Body (Json @{ email=$Email; code=$code })
$token = $verify.data.tokens.access_token
if (-not $token) { throw 'no access token' }

$books = Invoke-RestMethod -Uri "$BaseUrl/api/v1/books?limit=1" -Headers @{ Authorization = "Bearer $token" }
$bookId = $books.data.items[0].id
if (-not $bookId) { throw 'no book found' }

$start = Invoke-RestMethod -Uri "$BaseUrl/api/v1/reader/start" -Method POST -ContentType 'application/json' -Headers @{ Authorization = "Bearer $token" } -Body (Json @{ book_id=$bookId; device_id='dev-1' })
$sid = $start.data.session_id
if (-not $sid) { throw 'no session id' }
Write-Output ("SESSION=" + $sid)

Invoke-RestMethod -Uri "$BaseUrl/api/v1/reader/heartbeat" -Method POST -ContentType 'application/json' -Headers @{ Authorization = "Bearer $token" } -Body (Json @{ session_id=$sid; delta_ms=1500; progress=0.33; last_location='epub://ch1#p10' }) | Out-Null
Invoke-RestMethod -Uri "$BaseUrl/api/v1/reader/heartbeat" -Method POST -ContentType 'application/json' -Headers @{ Authorization = "Bearer $token" } -Body (Json @{ session_id=$sid; delta_ms=1200; progress=0.40; last_location='epub://ch1#p12' }) | Out-Null

$progress = Invoke-RestMethod -Uri "$BaseUrl/api/v1/reader/progress" -Headers @{ Authorization = "Bearer $token" }
Write-Output ("PROGRESS=" + ($progress.data | ConvertTo-Json -Depth 6))

Invoke-RestMethod -Uri "$BaseUrl/api/v1/reader/stop" -Method POST -ContentType 'application/json' -Headers @{ Authorization = "Bearer $token" } -Body (Json @{ session_id=$sid }) | Out-Null
Write-Output 'STOPPED'

==================================================
FILE_PATH: api/Dockerfile
==================================================

FROM zukubq0aouv2k2.xuanyuan.run/python:3.11-slim

WORKDIR /app

# 环境变量配置
ENV HF_HOME=/app/.hf_cache
ENV TRANSFORMERS_CACHE=/app/.hf_cache
ENV HUGGINGFACE_HUB_CACHE=/app/.hf_cache

# pip 配置：使用国内镜像 + 增加超时 + 重试
ENV PIP_INDEX_URL=https://pypi.tuna.tsinghua.edu.cn/simple
ENV PIP_TRUSTED_HOST=pypi.tuna.tsinghua.edu.cn
ENV PIP_DEFAULT_TIMEOUT=300
ENV PIP_RETRIES=5

# OCR/Embedding GPU 配置
ENV FLAGS_fraction_of_gpu_memory_to_use=0.4
ENV OCR_GPU_MEM=3500
ENV OCR_CPU_THREADS=6

ARG SKIP_HEAVY=true

# 使用国内 Debian 镜像源加速
RUN sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list.d/debian.sources 2>/dev/null || \
    sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list 2>/dev/null || true

# 安装系统依赖（适配 Debian Trixie）
RUN apt-get update && \
    apt-get install -y --no-install-recommends --fix-missing \
    libgl1 \
    libglib2.0-0 \
    libgomp1 \
    curl \
    tesseract-ocr \
    tesseract-ocr-chi-sim \
    tesseract-ocr-chi-tra \
    tesseract-ocr-eng \
    ghostscript \
    unpaper \
    && rm -rf /var/lib/apt/lists/* || \
    (apt-get update && apt-get install -y --fix-missing \
    libgl1 libglib2.0-0 libgomp1 curl \
    tesseract-ocr tesseract-ocr-chi-sim tesseract-ocr-chi-tra tesseract-ocr-eng \
    ghostscript unpaper && rm -rf /var/lib/apt/lists/*)

# 升级 pip 并安装基础依赖
COPY requirements.txt /app/requirements.txt
RUN pip install --upgrade pip && \
    pip install --no-cache-dir -r /app/requirements.txt

# 安装重型 AI 依赖（OCR + Embedding + TTS）
# SKIP_HEAVY=false 时安装完整版本
RUN if [ "$SKIP_HEAVY" != "true" ]; then \
    # PaddlePaddle GPU 版本 (CUDA 11.8) - 支持 PP-OCRv5
    pip install --no-cache-dir paddlepaddle-gpu==3.0.0 -i https://www.paddlepaddle.org.cn/packages/stable/cu118/ --timeout 300 && \
    # PaddleOCR 3.x (支持 PP-OCRv5 mobile) - 3.3.2 修复与 PaddleX 3.3.10 的兼容性
    pip install --no-cache-dir paddleocr==3.3.2 --timeout 300 && \
    # BGE-M3 Embedding 模型
    pip install --no-cache-dir FlagEmbedding --timeout 300 && \
    # Edge TTS
    pip install --no-cache-dir edge-tts --timeout 300; \
    fi

COPY app /app/app
COPY alembic.ini /app/alembic.ini
COPY alembic /app/alembic

EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]


==================================================
FILE_PATH: api/alembic.ini
==================================================

[alembic]
script_location = alembic
sqlalchemy.url = %(DATABASE_URL)s



==================================================
FILE_PATH: api/requirements.txt
==================================================

fastapi==0.115.4
uvicorn[standard]==0.32.0
sqlalchemy==2.0.36
asyncpg==0.30.0
psycopg2-binary==2.9.10
redis==5.0.8
sentry-sdk==2.19.0
alembic==1.13.2
prometheus-fastapi-instrumentator==6.1.0
python-jose==3.3.0
boto3==1.35.59
python-multipart==0.0.9
jaeger-client==4.8.0
opentracing==2.4.0
reportlab==3.6.13
requests==2.32.3
celery==5.4.0
httpx==0.27.0
pytest-asyncio==0.23.8
y-py==0.6.2
ypy-websocket==0.8.4
pymupdf
Pillow>=10.0.0
psutil>=5.9.0
ocrmypdf>=16.0.0


==================================================
FILE_PATH: api/app/home.py
==================================================

"""
首页仪表盘与目标设置接口

职责：
- `/dashboard`：聚合用户的今日/周/年阅读统计与目标达成情况
- `/goals`：更新每日阅读分钟与年度书籍目标

说明：
- 仅新增注释，不改动聚合服务调用
"""
from fastapi import APIRouter, Body, Depends

from .auth import require_user
from .home_service import get_dashboard

router = APIRouter(prefix="/api/v1/home", tags=["home"])


@router.get("/dashboard")
async def dashboard(auth=Depends(require_user)):
    user_id, _ = auth
    data = await get_dashboard(user_id)
    return {"status": "success", "data": data.model_dump()}


@router.patch("/goals")
async def update_goals_endpoint(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    from .home_service import update_goals

    await update_goals(user_id, body.get("daily_minutes"), body.get("yearly_books"))
    return {"status": "success"}


==================================================
FILE_PATH: api/app/profile.py
==================================================

from fastapi import APIRouter, Body, Depends, Header, HTTPException
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/profile", tags=["profile"])


@router.get("/me")
async def get_me(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        try:
            res = await conn.execute(
                text(
                    "SELECT id::text, email, display_name, is_active, membership_tier, updated_at FROM users WHERE id = current_setting('app.user_id')::uuid"
                )
            )
            row = res.fetchone()
            if not row:
                return {
                    "status": "success",
                    "data": {
                        "id": user_id,
                        "email": "",
                        "display_name": "",
                        "is_active": True,
                        "membership_tier": "FREE",
                        "etag": 'W/"1"',
                    },
                }
            return {
                "status": "success",
                "data": {
                    "id": row[0],
                    "email": row[1] or "",
                    "display_name": row[2] or "",
                    "is_active": bool(row[3]),
                    "membership_tier": row[4] or "FREE",
                    "updated_at": str(row[5]),
                    "etag": 'W/"1"',
                },
            }
        except Exception:
            res = await conn.execute(
                text(
                    "SELECT id::text, email, display_name, is_active, updated_at FROM users WHERE id = current_setting('app.user_id')::uuid"
                )
            )
            row = res.fetchone()
            if not row:
                return {
                    "status": "success",
                    "data": {
                        "id": user_id,
                        "email": "",
                        "display_name": "",
                        "is_active": True,
                        "etag": 'W/"1"',
                    },
                }
        return {
            "status": "success",
            "data": {
                "id": row[0],
                "email": row[1] or "",
                "display_name": row[2] or "",
                "is_active": bool(row[3]),
                "updated_at": str(row[4]),
                "etag": 'W/"1"',
            },
        }


@router.patch("/me")
async def patch_me(
    body: dict = Body(...),
    if_match: str | None = Header(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    display_name = body.get("display_name")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE users SET display_name = COALESCE(:dn, display_name), updated_at = now() WHERE id = current_setting('app.user_id')::uuid"
            ),
            {"dn": display_name},
        )
    return {"status": "success"}


==================================================
FILE_PATH: api/app/dict.py
==================================================

import os
import uuid
from datetime import timedelta

import redis
from fastapi import APIRouter, Body, Depends, Header, HTTPException
from sqlalchemy import text

from .auth import require_user
from .db import engine
from .storage import make_object_key, presigned_put

packages_router = APIRouter(prefix="/api/v1/dict/packages", tags=["dict"])
dict_router = APIRouter(prefix="/api/v1/dict", tags=["dict"])

REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)


@packages_router.post("/upload_init")
async def upload_init(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    name = body.get("name")
    lang = body.get("lang")
    version = int(body.get("version") or 1)
    if not name or not lang:
        raise HTTPException(status_code=400, detail="invalid_payload")
    pid = str(uuid.uuid4())
    key = make_object_key(user_id, f"dict-{pid}.bin")
    put_url = presigned_put(os.getenv("MINIO_BUCKET", "athena"), key)
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO dictionary_packages(id, owner_id, name, lang, version, minio_key, status) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :n, :l, :v, :k, 'uploading')"
            ),
            {"id": pid, "n": name, "l": lang, "v": version, "k": key},
        )
    return {"status": "success", "data": {"id": pid, "put_url": put_url}}


@packages_router.post("/upload_complete")
async def upload_complete(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    pid = body.get("id")
    if not pid:
        raise HTTPException(status_code=400, detail="missing_id")
    if idempotency_key:
        v = r.get(f"idem:{idempotency_key}")
        if v:
            return {"status": "success"}
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "UPDATE dictionary_packages SET status = 'ready', updated_at = now() WHERE id = cast(:id as uuid) AND owner_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL"
            ),
            {"id": pid},
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=404, detail="not_found")
    if idempotency_key:
        r.setex(
            f"idem:{idempotency_key}", int(timedelta(hours=24).total_seconds()), pid
        )
    return {"status": "success"}


@packages_router.get("")
async def list_packages(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, name, lang, version, minio_key, status, updated_at FROM dictionary_packages WHERE owner_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL ORDER BY updated_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "name": r[1],
                    "lang": r[2],
                    "version": int(r[3]),
                    "minio_key": r[4],
                    "status": r[5],
                    "updated_at": str(r[6]),
                }
                for r in rows
            ],
        }


@dict_router.post("/lookup")
async def lookup(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    word = body.get("word")
    lang = body.get("lang") or "en"
    package_id = body.get("package_id")
    book_id = body.get("book_id")
    if not word:
        raise HTTPException(status_code=400, detail="missing_word")
    if idempotency_key:
        v = r.get(f"idem:{idempotency_key}")
        if v:
            return {"status": "success", "data": {"definition": v}}
    definition = None
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        did = str(uuid.uuid4())
        await conn.execute(
            text(
                "INSERT INTO dict_history(id, owner_id, word, lang, package_id, book_id, definition) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :w, :l, cast(:pid as uuid), cast(:bid as uuid), :d)"
            ),
            {
                "id": did,
                "w": word,
                "l": lang,
                "pid": package_id,
                "bid": book_id,
                "d": definition,
            },
        )
    if idempotency_key:
        r.setex(
            f"idem:{idempotency_key}",
            int(timedelta(hours=24).total_seconds()),
            definition or "",
        )
    return {"status": "success", "data": {"definition": definition}}


@dict_router.get("/history")
async def history(limit: int = 50, offset: int = 0, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, word, lang, definition, created_at FROM dict_history WHERE owner_id = current_setting('app.user_id')::uuid ORDER BY created_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "word": r[1],
                    "lang": r[2],
                    "definition": r[3],
                    "created_at": str(r[4]),
                }
                for r in rows
            ],
        }


==================================================
FILE_PATH: api/app/tts.py
==================================================

"""
TTS 文本转语音接口

职责：
- `/api/v1/tts`：根据定价规则扣费后生成示例 WAV（占位实现）并返回下载链接
- `/api/v1/tts/heartbeat`：累计本次合成时长（毫秒），用于计费统计

说明：
- 仅新增注释，不改动接口与业务逻辑
- 真正的在线合成由 services/tts 提供（Edge TTS），此处为占位 API
"""
import math
import os
import struct
import wave

from fastapi import APIRouter, Body, Depends, HTTPException

from .auth import require_user
from .db import engine
from .storage import make_object_key, presigned_get, upload_bytes

router = APIRouter(prefix="/api/v1/tts", tags=["tts"])


def _sine_wav(text: str) -> bytes:
    framerate = 8000
    duration = max(1.0, min(len(text) / 20.0, 10.0))
    freq = 440.0
    nframes = int(framerate * duration)
    buf = bytearray()
    for i in range(nframes):
        val = int(32767.0 * math.sin(2.0 * math.pi * freq * (i / framerate)))
        buf += struct.pack("<h", val)
    import io

    mem = io.BytesIO()
    w = wave.open(mem, "wb")
    w.setnchannels(1)
    w.setsampwidth(2)
    w.setframerate(framerate)
    w.writeframes(buf)
    w.close()
    return mem.getvalue()


@router.post("")
async def tts(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    input_text = body.get("text") or ""
    if not input_text:
        raise HTTPException(status_code=400, detail="invalid_text")
    async with engine.begin() as conn:
        await conn.exec_driver_sql(
            "SELECT set_config('app.user_id', '%s', true)" % user_id
        )
        res = await conn.exec_driver_sql(
            "SELECT price_amount, unit_size, currency FROM pricing_rules WHERE service_type = 'TTS' AND unit_type = 'CHARS' AND is_active = TRUE ORDER BY updated_at DESC LIMIT 1"
        )
        rule = res.fetchone()
        amt = 0
        cur = "CNY"
        if rule:
            units = max(1, int((len(input_text) + int(rule[1]) - 1) / int(rule[1])))
            amt = int(round(float(rule[0]) * 100)) * units
            cur = rule[2]
        if amt > 0:
            bal = await conn.exec_driver_sql(
                "SELECT balance FROM credit_accounts WHERE owner_id = current_setting('app.user_id')::uuid"
            )
            b = bal.fetchone()
            if not b or int(b[0]) < amt:
                raise HTTPException(status_code=400, detail="insufficient_balance")
            await conn.exec_driver_sql(
                "UPDATE credit_accounts SET balance = balance - %s, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                % amt
            )
            await conn.exec_driver_sql(
                "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (gen_random_uuid(), current_setting('app.user_id')::uuid, %s, '%s', 'tts', 'debit')"
                % (amt, cur)
            )
    wav = _sine_wav(input_text)
    key = make_object_key(user_id, "tts.wav")
    upload_bytes(os.getenv("MINIO_BUCKET", "athena"), key, wav, "audio/wav")
    req_id = None
    try:
        import uuid as _uuid

        req_id = str(_uuid.uuid4())
        async with engine.begin() as conn:
            await conn.exec_driver_sql(
                "INSERT INTO tts_requests(id, user_id, duration_ms) VALUES ('%s', '%s'::uuid, 0)"
                % (req_id, user_id)
            )
    except Exception:
        pass
    return {
        "status": "success",
        "data": {
            "download_url": presigned_get(os.getenv("MINIO_BUCKET", "athena"), key),
            "request_id": req_id,
        },
    }


@router.post("/heartbeat")
async def tts_heartbeat(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    req_id = body.get("request_id")
    delta_ms = int(body.get("delta_ms") or 0)
    if not req_id or delta_ms < 0:
        raise HTTPException(status_code=400, detail="invalid_request")
    async with engine.begin() as conn:
        await conn.exec_driver_sql(
            "SELECT set_config('app.user_id', '%s', true)" % user_id
        )
        res = await conn.exec_driver_sql(
            "UPDATE tts_requests SET duration_ms = COALESCE(duration_ms,0) + %s, updated_at = now() WHERE id = cast('%s' as uuid) AND user_id = current_setting('app.user_id')::uuid RETURNING duration_ms"
            % (delta_ms, req_id)
        )
        row = res.fetchone()
        if not row:
            try:
                await conn.exec_driver_sql(
                    "INSERT INTO tts_requests(id, user_id, duration_ms) VALUES ('%s', current_setting('app.user_id')::uuid, 0)"
                    % req_id
                )
                res2 = await conn.exec_driver_sql(
                    "UPDATE tts_requests SET duration_ms = COALESCE(duration_ms,0) + %s, updated_at = now() WHERE id = cast('%s' as uuid) AND user_id = current_setting('app.user_id')::uuid RETURNING duration_ms"
                    % (delta_ms, req_id)
                )
                row = res2.fetchone()
            except Exception:
                raise HTTPException(status_code=404, detail="request_not_found")
        return {"status": "success", "data": {"duration_ms": int(row[0])}}


==================================================
FILE_PATH: api/app/reader.py
==================================================

"""
阅读会话与进度同步接口

职责：
- `/start`：创建阅读会话，记录设备与初始状态
- `/heartbeat`：累计时长、更新每日阅读统计、保存书籍进度与最后位置、维护 streak
- `/sessions`：列出当前用户的阅读会话
- `/progress`：列出用户各书籍的阅读进度
- `/mark-finished`：标记/取消书籍读完状态
- `/stop`：结束阅读会话
- 兼容契约别名 `/api/v1/reading-sessions/*` 路由
"""
import uuid
from datetime import datetime, timezone

from fastapi import APIRouter, Body, Depends, Response
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/reader")
alias = APIRouter(prefix="/api/v1/reading-sessions")


async def _ensure_tables(conn):
    return


@router.post("/start")
async def start(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    book_id = body.get("book_id")
    device_id = body.get("device_id") or ""
    sid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )

        await conn.execute(
            text(
                "INSERT INTO reading_sessions(id, user_id, book_id, device_id, is_active, total_ms, last_heartbeat) VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:bid as uuid), :dev, TRUE, 0, now())"
            ),
            {"id": sid, "uid": user_id, "bid": book_id, "dev": device_id},
        )
    return {"status": "success", "data": {"session_id": sid}}






@router.get("/sessions")
async def list_sessions(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, book_id::text, device_id, total_ms, last_heartbeat FROM reading_sessions WHERE user_id = current_setting('app.user_id')::uuid ORDER BY last_heartbeat DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "book_id": r[1],
                    "device_id": r[2],
                    "total_ms": r[3],
                    "last_heartbeat": str(r[4]),
                }
                for r in rows
            ],
        }


@router.get("/progress")
async def get_progress(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT book_id::text, progress, updated_at, last_location, finished_at FROM reading_progress WHERE user_id = current_setting('app.user_id')::uuid ORDER BY updated_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "book_id": r[0],
                    "progress": float(r[1]),
                    "updated_at": str(r[2]),
                    "last_location": r[3],
                    "finished_at": str(r[4]) if r[4] else None,
                }
                for r in rows
            ],
        }


@router.post("/mark-finished")
async def mark_finished(body: dict = Body(...), auth=Depends(require_user)):
    """
    标记书籍为已读完或取消已读完。
    body: { book_id: str, finished: bool }
    """
    user_id, _ = auth
    book_id = body.get("book_id")
    finished = body.get("finished", True)
    
    if not book_id:
        from fastapi import HTTPException
        raise HTTPException(status_code=400, detail="book_id_required")
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        if finished:
            # 标记为已读完：设置 finished_at 为当前时间
            await conn.execute(
                text(
                    """INSERT INTO reading_progress(user_id, book_id, progress, finished_at, updated_at)
                       VALUES (current_setting('app.user_id')::uuid, cast(:bid as uuid), 1.0, now(), now())
                       ON CONFLICT (user_id, book_id) DO UPDATE SET finished_at = now(), updated_at = now()"""
                ),
                {"bid": book_id},
            )
        else:
            # 取消已读完：清空 finished_at
            await conn.execute(
                text(
                    """UPDATE reading_progress 
                       SET finished_at = NULL, updated_at = now() 
                       WHERE user_id = current_setting('app.user_id')::uuid 
                       AND book_id = cast(:bid as uuid)"""
                ),
                {"bid": book_id},
            )
    
    return {"status": "success", "data": {"finished": finished}}


@router.post("/stop")
async def stop(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    sid = body.get("session_id")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE reading_sessions SET is_active = FALSE WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": sid},
        )
    return {"status": "success"}


# 契约别名路由：/api/v1/reading-sessions/*
@alias.post("/start")
async def alias_start(body: dict = Body(...), auth=Depends(require_user)):
    return await start(body, auth)


@alias.get("/progress")
async def alias_progress(auth=Depends(require_user)):
    return await get_progress(auth)






@alias.post("/{session_id}/end")
async def alias_stop(session_id: str, auth=Depends(require_user)):
    await stop({"session_id": session_id}, auth)
    return Response(status_code=204)


==================================================
FILE_PATH: api/app/ocr.py
==================================================

"""
OCR 任务管理接口

职责：
- 创建 OCR 作业：根据书籍页数、会员与系统阈值计算扣费策略（免费额度或增购额度）
- 并发控制：通过 Redis 记录活跃任务数量，限制并发
- 任务入队：按优先级将作业推送到 Celery 队列
- 作业查询：按用户列出最近的 OCR 作业记录

说明：
- 仅新增注释，不改动接口与业务逻辑
- 真正的识别流程由 `tasks.process_book_ocr` 执行
"""
import json
import os
import uuid
from datetime import datetime

import redis
from fastapi import APIRouter, Body, Depends, HTTPException
from sqlalchemy import text

from .auth import require_user
from .celery_app import celery_app
from .db import engine

router = APIRouter(prefix="/api/v1/ocr", tags=["ocr"])

REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)


@router.post("/jobs")
async def init_job(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    book_id = body.get("book_id")
    if not book_id:
        raise HTTPException(status_code=400, detail="missing_book_id")

    async with engine.begin() as conn:
        # 1. Get Book Metadata (Page Count)
        bres = await conn.execute(
            text("SELECT meta, minio_key FROM books WHERE id = cast(:bid as uuid) AND user_id = cast(:uid as uuid)"),
            {"bid": book_id, "uid": user_id}
        )
        book_row = bres.fetchone()
        if not book_row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        meta = book_row[0] or {}
        source_key = book_row[1]
        page_count = meta.get("page_count", 0)
        if page_count <= 0:
             page_count = 1 

        # 2. Get User Membership & Quota
        ures = await conn.execute(
            text("SELECT membership_tier, free_ocr_usage, membership_expire_at FROM users WHERE id = cast(:uid as uuid)"),
            {"uid": user_id}
        )
        user_row = ures.fetchone()
        tier = user_row[0]
        free_used = user_row[1] or 0
        expire_at = user_row[2]
        
        is_pro = False
        if tier != "FREE" and expire_at and expire_at > datetime.now():
            is_pro = True

        # 3. Get System Settings
        sres = await conn.execute(text("SELECT key, value FROM system_settings WHERE key IN ('ocr_page_thresholds', 'ocr_monthly_quota', 'ocr_concurrency_limit')"))
        settings = {row[0]: row[1] for row in sres.fetchall()}
        
        thresholds = settings.get("ocr_page_thresholds", {"standard": 600, "double": 1000, "triple": 2000})
        monthly_quota = int(settings.get("ocr_monthly_quota", 3))
        concurrency_limit = int(settings.get("ocr_concurrency_limit", 1))

        # 4. Determine Cost & Strategy
        cost = 0
        strategy = "free_quota"
        
        if page_count <= thresholds.get("standard", 600):
            cost = 1
            if is_pro and free_used < monthly_quota:
                strategy = "free_quota"
            else:
                strategy = "addon_quota"
        elif page_count <= thresholds.get("double", 1000):
            cost = 2
            strategy = "addon_quota"
        elif page_count <= thresholds.get("triple", 2000):
            cost = 3
            strategy = "addon_quota"
        else:
            raise HTTPException(status_code=400, detail="book_too_large_for_ocr")

        # 5. Check Balance & Deduct
        if strategy == "free_quota":
             await conn.execute(
                 text("UPDATE users SET free_ocr_usage = free_ocr_usage + :c WHERE id = cast(:uid as uuid)"),
                 {"c": cost, "uid": user_id}
             )
        else:
             # Deduct Credits (Fallback for Addon: 1 Time = 100 Credits)
             required_credits = cost * 100 
             upd = await conn.execute(
                 text("UPDATE credit_accounts SET balance = balance - :c WHERE owner_id = cast(:uid as uuid) AND balance >= :c"),
                 {"c": required_credits, "uid": user_id}
             )
             if upd.rowcount == 0:
                 raise HTTPException(status_code=402, detail="insufficient_credits_for_ocr")
             
             # Add Ledger Entry
             lid = str(uuid.uuid4())
             await conn.execute(
                 text("INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, related_id, direction) VALUES (cast(:id as uuid), cast(:uid as uuid), :amt, 'CREDITS', 'ocr_deduction', cast(:bid as uuid), 'debit')"),
                 {"id": lid, "uid": user_id, "amt": required_credits, "bid": book_id}
             )

        # 6. Concurrency Check
        active_jobs = r.scard("ocr:active_jobs")
        if active_jobs >= concurrency_limit:
             raise HTTPException(status_code=503, detail="server_busy_try_later")

        # 7. Create Job
        job_id = str(uuid.uuid4())
        await conn.execute(
            text("INSERT INTO ocr_jobs (id, book_id, user_id, owner_id, source_key, status, page_count, deduction_strategy, deduction_amount) VALUES (cast(:jid as uuid), cast(:bid as uuid), cast(:uid as uuid), cast(:uid as uuid), :sk, 'pending', :pc, :ds, :da)"),
            {"jid": job_id, "bid": book_id, "uid": user_id, "sk": source_key, "pc": page_count, "ds": strategy, "da": cost}
        )
        
        # 8. Enqueue Task
        priority = 0
        if is_pro:
            priority = 9 if strategy == "addon_quota" else 7
        else:
            priority = 5 if strategy == "addon_quota" else 1
            
        celery_app.send_task("tasks.process_ocr_book", args=[job_id], priority=priority)
        r.sadd("ocr:active_jobs", job_id)

    return {"status": "success", "data": {"job_id": job_id}}

@router.get("/jobs")
async def list_jobs(limit: int = 20, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        res = await conn.execute(
            text("SELECT id, book_id, status, created_at, page_count, deduction_strategy FROM ocr_jobs WHERE user_id = cast(:uid as uuid) ORDER BY created_at DESC LIMIT :limit"),
            {"uid": user_id, "limit": limit}
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": str(r[0]),
                    "book_id": str(r[1]),
                    "status": r[2],
                    "created_at": str(r[3]),
                    "page_count": r[4],
                    "strategy": r[5]
                } for r in rows
            ]
        }


==================================================
FILE_PATH: api/app/dependencies.py
==================================================

from fastapi import HTTPException, Depends
from sqlalchemy import text
from .db import engine
from .auth import require_user

async def check_quota_status(auth=Depends(require_user)):
    user_id, _ = auth
    
    async with engine.begin() as conn:
        # Set RLS context
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 1. Get or create User Stats with defensive handling
        # First, ensure the row exists
        await conn.execute(
            text("""
                INSERT INTO user_stats (user_id, storage_used, book_count, extra_storage_quota, extra_book_quota)
                VALUES (cast(:uid as uuid), 0, 0, 0, 0)
                ON CONFLICT (user_id) DO NOTHING
            """),
            {"uid": user_id}
        )
        
        # Then fetch the stats
        res = await conn.execute(
            text("SELECT storage_used, book_count, extra_storage_quota, extra_book_quota FROM user_stats WHERE user_id = cast(:uid as uuid)"),
            {"uid": user_id}
        )
        stats = res.fetchone()
        storage_used = stats[0] if stats else 0
        book_count = stats[1] if stats else 0
        extra_storage = stats[2] if stats else 0
        extra_books = stats[3] if stats else 0
        
        # 2. Get System Settings
        sres = await conn.execute(text("SELECT key, value FROM system_settings WHERE key IN ('free_book_limit', 'free_storage_limit')"))
        settings = {row[0]: row[1] for row in sres.fetchall()}
        base_book_limit = int(settings.get("free_book_limit", 50))
        base_storage_limit = int(settings.get("free_storage_limit", 1073741824))
        
        # 3. Get Membership Status
        mres = await conn.execute(
            text("SELECT membership_tier, membership_expire_at FROM users WHERE id = cast(:uid as uuid)"),
            {"uid": user_id}
        )
        user_row = mres.fetchone()
        tier = user_row[0] if user_row else "FREE"
        expire_at = user_row[1] if user_row else None
        
        # Check if membership is active
        from datetime import datetime, timezone
        is_pro = False
        if tier != "FREE":
            if expire_at and expire_at > datetime.now(timezone.utc):
                is_pro = True
        
        # 4. Calculate Limits
        if is_pro:
            # Pro users have no effective limit (or very high)
            can_upload = True
            is_readonly = False
        else:
            total_book_limit = base_book_limit + extra_books
            total_storage_limit = base_storage_limit + extra_storage
            
            is_book_limit_reached = book_count >= total_book_limit
            is_storage_limit_reached = storage_used >= total_storage_limit
            
            # The Hook: Cannot upload if limit reached
            can_upload = not (is_book_limit_reached or is_storage_limit_reached)
            
            # The Trap: Readonly if limit reached (Soft Lock)
            is_readonly = is_book_limit_reached or is_storage_limit_reached
            
    return {
        "user_id": user_id,
        "is_pro": is_pro,
        "can_upload": can_upload,
        "is_readonly": is_readonly,
        "usage": {
            "books": book_count,
            "storage": storage_used
        },
        "limits": {
            "books": total_book_limit if not is_pro else -1,
            "storage": total_storage_limit if not is_pro else -1
        }
    }

def require_write_permission(quota=Depends(check_quota_status)):
    if quota["is_readonly"]:
        raise HTTPException(status_code=403, detail="readonly_mode_quota_exceeded")
    return quota

def require_upload_permission(quota=Depends(check_quota_status)):
    if not quota["can_upload"]:
        raise HTTPException(status_code=403, detail="upload_forbidden_quota_exceeded")
    return quota


==================================================
FILE_PATH: api/app/powersync.py
==================================================

"""
PowerSync 同步上传接口

职责：
- 接收客户端 PowerSync SDK 上传的本地变更
- 将变更应用到 PostgreSQL 数据库
- 支持批量操作 (INSERT/UPDATE/DELETE)
- RLS 安全校验

@see 09 - APP-FIRST架构改造计划.md - Phase 4
@version 1.0.0
"""
import hashlib
from datetime import datetime, timezone
from typing import List, Literal, Optional

from fastapi import APIRouter, Body, Depends
from pydantic import BaseModel
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/sync")


def _generate_version_hash(content: str) -> str:
    """
    生成版本指纹（用于冲突检测）
    
    Args:
        content: 要hash的内容
        
    Returns:
        格式: "sha256:xxxxx" (前16字符)
    """
    h = hashlib.sha256(content.encode('utf-8')).hexdigest()
    return f"sha256:{h[:16]}"


# ============ Pydantic 模型 ============

class SyncOperation(BaseModel):
    """单个同步操作"""
    table: str
    op: Literal["PUT", "PATCH", "DELETE"]
    id: str
    data: Optional[dict] = None


class SyncUploadRequest(BaseModel):
    """同步上传请求"""
    operations: List[SyncOperation]


class SyncUploadResponse(BaseModel):
    """同步上传响应"""
    status: str = "success"
    processed: int = 0
    errors: List[dict] = []


# ============ 允许同步的表 (白名单) ============
# 前端可以通过 PowerSync 写入这些表，变更会同步到 PostgreSQL
# @see 05 - API 契约与协议 - 3.C PowerSync 数据操作规范

ALLOWED_TABLES = {
    "books",              # 元数据修改、软删除（硬删除仍需 API）
    "reading_progress",
    "reading_sessions",
    "notes",
    "highlights",
    "bookmarks",
    "shelves",
    "shelf_books",
    "user_settings",
}

# 表字段映射 (前端字段 -> 后端字段)
# 定义每个表允许同步的字段，防止恶意写入敏感字段
TABLE_COLUMNS = {
    "books": {
        "id", "user_id", "title", "author",  # 元数据可修改
        "deleted_at", "updated_at",           # 软删除相关
        # 注意：以下字段前端不可修改，由服务器控制
        # minio_key, content_sha256, size, original_format, ocr_status 等
    },
    "reading_progress": {
        "id", "user_id", "book_id", "device_id", "progress",
        "last_position", "last_location", "updated_at"
    },
    "reading_sessions": {
        "id", "user_id", "book_id", "device_id", "is_active",
        "total_ms", "created_at", "updated_at"
    },
    "notes": {
        "id", "user_id", "book_id", "device_id", "content",
        "page_number", "position_cfi", "color", "is_deleted",
        "deleted_at", "created_at", "updated_at"
    },
    "highlights": {
        "id", "user_id", "book_id", "device_id", "text",
        "page_number", "position_start_cfi", "position_end_cfi",
        "color", "is_deleted", "deleted_at", "created_at", "updated_at"
    },
    "bookmarks": {
        "id", "user_id", "book_id", "device_id", "title",
        "page_number", "position_cfi", "is_deleted",
        "deleted_at", "created_at", "updated_at"
    },
    "shelves": {
        "id", "user_id", "name", "description", "cover_url",
        "sort_order", "is_deleted", "deleted_at", "created_at", "updated_at"
    },
    "shelf_books": {
        "id", "user_id", "shelf_id", "book_id", "sort_order", "added_at"
    },
    "user_settings": {
        "id", "user_id", "device_id", "settings_json", "updated_at"
    },
}


# ============ 路由 ============

@router.post("/upload", response_model=SyncUploadResponse)
async def sync_upload(
    body: SyncUploadRequest = Body(...),
    auth=Depends(require_user)
):
    """
    接收 PowerSync 客户端上传的本地变更
    
    安全措施：
    1. 只允许操作白名单中的表
    2. 强制注入 user_id (覆盖客户端传值)
    3. 使用 RLS 进行行级安全校验
    4. 过滤危险字段
    """
    user_id, _ = auth
    processed = 0
    errors = []

    import logging
    logger = logging.getLogger(__name__)
    logger.info(f"[PowerSync] Received {len(body.operations)} operations from user {user_id}")

    async with engine.begin() as conn:
        # 设置 RLS user_id
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"),
            {"v": user_id}
        )

        for op in body.operations:
            try:
                logger.info(f"[PowerSync] Processing: table={op.table}, op={op.op}, id={op.id}, data={op.data}")
                
                # 安全检查：只允许白名单表
                if op.table not in ALLOWED_TABLES:
                    errors.append({
                        "id": op.id,
                        "error": f"Table '{op.table}' is not allowed for sync"
                    })
                    continue

                # 根据操作类型处理
                if op.op == "DELETE":
                    await _handle_delete(conn, op, user_id)
                elif op.op in ("PUT", "PATCH"):
                    await _handle_upsert(conn, op, user_id)
                else:
                    errors.append({
                        "id": op.id,
                        "error": f"Unknown operation: {op.op}"
                    })
                    continue

                processed += 1
                logger.info(f"[PowerSync] Successfully processed op for {op.table}/{op.id}")

            except Exception as e:
                logger.error(f"[PowerSync] Error processing {op.table}/{op.id}: {e}")
                errors.append({
                    "id": op.id,
                    "error": str(e)
                })

    return SyncUploadResponse(
        status="success",
        processed=processed,
        errors=errors
    )


async def _handle_delete(conn, op: SyncOperation, user_id: str):
    """处理 DELETE 操作"""
    import logging
    logger = logging.getLogger(__name__)
    
    table = op.table
    record_id = op.id
    
    logger.info(f"[PowerSync DELETE] table={table}, id={record_id}, user_id={user_id}")

    # books 表只有 deleted_at，没有 is_deleted
    if table == "books":
        result = await conn.execute(
            text("""
                UPDATE books
                SET deleted_at = now()
                WHERE id = cast(:id as uuid)
                AND user_id = cast(:user_id as uuid)
                RETURNING id, deleted_at
            """),
            {"id": record_id, "user_id": user_id}
        )
        row = result.fetchone()
        logger.info(f"[PowerSync DELETE books] Result: {row}")
    # 其他表有 is_deleted + deleted_at
    elif table in {"notes", "highlights", "bookmarks", "shelves"}:
        await conn.execute(
            text(f"""
                UPDATE {table}
                SET is_deleted = TRUE, deleted_at = now()
                WHERE id = cast(:id as uuid)
                AND user_id = current_setting('app.user_id')::uuid
            """),
            {"id": record_id}
        )
    elif table == "shelf_books":
        # shelf_books 使用硬删除
        await conn.execute(
            text("""
                DELETE FROM shelf_books
                WHERE id = cast(:id as uuid)
                AND shelf_id IN (
                    SELECT id FROM shelves 
                    WHERE user_id = current_setting('app.user_id')::uuid
                )
            """),
            {"id": record_id}
        )
    else:
        # 其他表硬删除 (reading_progress, reading_sessions, user_settings)
        await conn.execute(
            text(f"""
                DELETE FROM {table}
                WHERE id = cast(:id as uuid)
                AND user_id = current_setting('app.user_id')::uuid
            """),
            {"id": record_id}
        )


async def _handle_books_update(conn, record_id: str, filtered_data: dict, user_id: str, logger):
    """
    专门处理 books 表的更新操作
    books 只能通过上传流程创建，PowerSync 只能修改元数据和软删除
    """
    from dateutil.parser import isoparse
    
    if not filtered_data:
        logger.info(f"[PowerSync books UPDATE] No data to update for {record_id}")
        return
    
    # 时间戳字段列表
    timestamp_columns = {"deleted_at", "updated_at"}
    
    # 构建 UPDATE SET 子句
    set_clauses = []
    params = {"id": record_id, "user_id": user_id}
    
    for k, v in filtered_data.items():
        if k in timestamp_columns and v is not None and isinstance(v, str):
            try:
                params[f"p_{k}"] = isoparse(v)
            except Exception:
                params[f"p_{k}"] = v
        else:
            params[f"p_{k}"] = v
        set_clauses.append(f"{k} = :p_{k}")
    
    sql = f"""
        UPDATE books 
        SET {', '.join(set_clauses)}
        WHERE id = cast(:id as uuid) 
        AND user_id = cast(:user_id as uuid)
    """
    
    logger.info(f"[PowerSync books UPDATE] SQL: {sql}")
    logger.info(f"[PowerSync books UPDATE] Params: {params}")
    
    result = await conn.execute(text(sql), params)
    logger.info(f"[PowerSync books UPDATE] Result rowcount: {result.rowcount}")


async def _handle_upsert(conn, op: SyncOperation, user_id: str):
    """处理 PUT/PATCH 操作 (UPSERT)"""
    import logging
    logger = logging.getLogger(__name__)
    
    table = op.table
    record_id = op.id
    data = op.data or {}
    
    logger.info(f"[PowerSync UPSERT] table={table}, id={record_id}, data={data}")

    # 获取允许的字段
    allowed_columns = TABLE_COLUMNS.get(table, set())
    logger.info(f"[PowerSync UPSERT] allowed_columns for {table}: {allowed_columns}")

    # 过滤数据，只保留允许的字段
    filtered_data = {
        k: v for k, v in data.items()
        if k in allowed_columns and k not in {"id", "user_id"}
    }

    # books 表特殊处理：只允许 UPDATE，不允许 INSERT
    # 因为书籍必须通过上传流程创建，PowerSync 只能修改元数据和软删除
    if table == "books":
        return await _handle_books_update(conn, record_id, filtered_data, user_id, logger)

    # 强制注入 user_id (安全措施)
    if "user_id" in allowed_columns:
        filtered_data["user_id"] = user_id

    # 确保有更新时间
    if "updated_at" in allowed_columns:
        filtered_data["updated_at"] = datetime.now(timezone.utc).isoformat()

    if not filtered_data:
        return

    # shelf_books 特殊处理：验证 shelf 属于当前用户
    if table == "shelf_books":
        shelf_id = filtered_data.get("shelf_id") or data.get("shelf_id")
        if shelf_id:
            # 验证书架属于当前用户
            result = await conn.execute(
                text("""
                    SELECT id FROM shelves 
                    WHERE id = cast(:shelf_id as uuid) 
                    AND user_id = current_setting('app.user_id')::uuid
                """),
                {"shelf_id": shelf_id}
            )
            if result.fetchone() is None:
                raise ValueError(f"Shelf {shelf_id} not found or access denied")

    # 构建 UPSERT SQL
    columns = ["id"] + list(filtered_data.keys())
    
    # 时间戳字段列表 - 需要转换 ISO 字符串为 datetime
    timestamp_columns = {"added_at", "created_at", "updated_at", "deleted_at"}
    
    placeholders = ["cast(:id as uuid)"] + [
        f"cast(:p_{k} as uuid)" if k in {"user_id", "book_id", "shelf_id", "device_id"}
        else f":p_{k}"
        for k in filtered_data.keys()
    ]
    update_clause = ", ".join([
        f"{k} = EXCLUDED.{k}"
        for k in filtered_data.keys()
    ])

    sql = f"""
        INSERT INTO {table} ({', '.join(columns)})
        VALUES ({', '.join(placeholders)})
        ON CONFLICT (id) DO UPDATE SET {update_clause}
    """

    # 构建参数 - 转换时间戳字符串为 datetime
    from dateutil.parser import isoparse
    
    params = {"id": record_id}
    for k, v in filtered_data.items():
        if k in timestamp_columns and v is not None and isinstance(v, str):
            try:
                params[f"p_{k}"] = isoparse(v)
            except Exception:
                params[f"p_{k}"] = v  # 转换失败则保留原值
        else:
            params[f"p_{k}"] = v

    logger.info(f"[PowerSync UPSERT] SQL: {sql}")
    logger.info(f"[PowerSync UPSERT] Params: {params}")
    
    result = await conn.execute(text(sql), params)
    logger.info(f"[PowerSync UPSERT] Result rowcount: {result.rowcount}")


==================================================
FILE_PATH: api/app/books.py
==================================================

"""
书籍模块

功能：
- 上传初始化/完成（含全局 SHA256 去重与软删除恢复）
- 秒传引用 `dedup_reference`（共享存储但独立计费与 OCR）
- 书籍详情/列表、封面与内容代理、转换作业管理
- OCR 结果查询、完整数据下载、配额评估与触发任务
- 书架 CRUD 与项目管理
- 删除策略：区分私人信息与公共信息，按引用计数与软删除清理

说明：
- MinIO 作为对象存储，`presigned_get/put` 提供外链
- OCR 报告兼容旧版与新版数据结构
"""
import os
import uuid

import redis
from fastapi import (
    APIRouter,
    Body,
    Depends,
    File,
    Header,
    HTTPException,
    Query,
    Response,
    UploadFile,
)
from sqlalchemy import text

from .auth import require_user
from .celery_app import celery_app
from .db import engine
from .dependencies import require_upload_permission, require_write_permission
from .search_sync import delete_book as delete_book_from_index
from .search_sync import index_book
from .storage import (
    delete_object,
    ensure_bucket,
    get_s3,
    make_object_key,
    presigned_get,
    presigned_put,
    read_head,
    read_full,
    stat_etag,
    upload_bytes,
)
from .services.book_service import get_upload_url as svc_get_upload_url, create_book as svc_create_book
from .ws import broadcast as ws_broadcast

BOOKS_BUCKET = os.getenv("MINIO_BUCKET", "athena")
REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)


router = APIRouter(prefix="/api/v1/books", tags=["books"])
shelves_router = APIRouter(prefix="/api/v1/shelves", tags=["shelves"])


async def _ensure_books_fields(conn):
    return


def _quick_confidence(bucket: str, key: str) -> tuple[bool, float]:
    """
    快速检测 PDF 是否为图片型。
    
    使用 PyMuPDF 检查前 6 页的文本内容，这比检查字节头更可靠。
    
    返回 (is_image_based, confidence):
    - is_image_based: 是否为图片型 PDF
    - confidence: 置信度，用于前端判断（confidence < 0.8 表示图片型）
    """
    try:
        import fitz  # PyMuPDF
        
        # 获取文件数据
        pdf_data = None
        if isinstance(key, str) and key.startswith("http"):
            import urllib.request
            try:
                with urllib.request.urlopen(key) as resp:
                    pdf_data = resp.read()
            except Exception:
                pdf_data = None
        else:
            pdf_data = read_full(bucket, key)
        
        if not pdf_data:
            return (False, 0.0)
        
        # 非 PDF 文件直接返回数字型
        if not key.lower().endswith('.pdf'):
            return (False, 1.0)  # 非 PDF 默认是数字型
        
        # 使用 PyMuPDF 提取前 6 页文本
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        total_pages = len(doc)
        pages_to_check = min(6, total_pages)
        
        total_chars = 0
        meaningful_chars = 0
        
        for i in range(pages_to_check):
            page = doc[i]
            text = page.get_text()
            
            if text:
                total_chars += len(text)
                # 统计有意义的字符（中文、英文字母）
                import re
                cjk = len(re.findall(r'[\u4e00-\u9fff]', text))
                latin = len(re.findall(r'[A-Za-z]', text))
                meaningful_chars += cjk + latin
        
        doc.close()
        
        # 计算比例
        if total_chars == 0:
            # 完全没有文本，是纯图片型
            return (True, 0.1)
        
        ratio = meaningful_chars / max(1, total_chars)
        
        # 判断标准：
        # - 如果有意义字符占比 < 5%，认为是图片型
        # - 每页平均文本少于 50 字符，也认为是图片型
        avg_chars_per_page = total_chars / pages_to_check
        
        is_image_based = ratio < 0.05 or avg_chars_per_page < 50
        
        # confidence 规则：
        # - 图片型：confidence < 0.8
        # - 数字型：confidence >= 0.8
        if is_image_based:
            conf = max(0.1, min(0.5, ratio * 5.0))  # 图片型 conf 最高 0.5
        else:
            conf = max(0.8, min(1.0, 0.8 + ratio * 0.2))  # 数字型 conf 最低 0.8
        
        print(f"[PDF Detection] {key}: {pages_to_check} pages, {total_chars} chars, ratio={ratio:.3f}, avg={avg_chars_per_page:.0f}, is_image={is_image_based}, conf={conf:.2f}")
        return (is_image_based, conf)
        
    except Exception as e:
        print(f"[PDF Detection] Error: {e}")
        return (False, 0.0)


@router.post("/upload_init")
async def upload_init(
    body: dict = Body(...),
    quota=Depends(require_upload_permission),
    auth=Depends(require_user),
):
    """
    初始化上传，支持全局 SHA256 去重。
    
    如果客户端提供了 content_sha256，服务端会检查是否已有相同文件：
    - 全局已存在：返回 dedup_available=true，客户端可跳过上传
    - 仅当前用户已有：返回现有 book_id
    """
    user_id, _ = auth
    filename = body.get("filename")
    if not filename:
        raise HTTPException(status_code=400, detail="missing_filename")
    content_type = body.get("content_type")
    content_sha256 = body.get("content_sha256")  # 客户端计算的 SHA256
    
    # 如果提供了 SHA256，检查全局去重
    if content_sha256 and len(content_sha256) == 64:
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            # 1. 先检查当前用户是否已有相同文件（排除软删除的）
            res = await conn.execute(
                text(
                    "SELECT id::text, title FROM books WHERE user_id = cast(:uid as uuid) AND content_sha256 = :sha AND deleted_at IS NULL"
                ),
                {"uid": user_id, "sha": content_sha256},
            )
            own_row = res.fetchone()
            if own_row:
                # 用户自己已有相同文件，返回现有记录
                return {
                    "status": "success",
                    "data": {
                        "dedup_hit": "own",
                        "existing_book_id": own_row[0],
                        "existing_title": own_row[1],
                        "message": "您已上传过该文件"
                    }
                }
            
            # 2. 检查全局是否有相同文件（任何用户上传过，包括软删除的）
            # 存储去重不排除软删除的书籍，因为文件仍然存在于 MinIO
            # 优先选择未删除的书作为 canonical，否则选择已删除的（文件仍在）
            res = await conn.execute(
                text(
                    """SELECT id::text, minio_key, cover_image_key, deleted_at
                       FROM books WHERE content_sha256 = :sha 
                       ORDER BY deleted_at IS NULL DESC, created_at ASC
                       LIMIT 1"""
                ),
                {"sha": content_sha256},
            )
            global_row = res.fetchone()
            if global_row:
                # 全局已存在，告知客户端可以秒传
                canonical_id = global_row[0]
                is_soft_deleted = global_row[3] is not None
                print(f"[Upload Init] Global dedup hit for SHA256 {content_sha256[:16]}..., canonical={canonical_id}, soft_deleted={is_soft_deleted}")
                return {
                    "status": "success",
                    "data": {
                        "dedup_hit": "global",
                        "dedup_available": True,
                        "canonical_book_id": canonical_id,
                        "canonical_minio_key": global_row[1],
                        "canonical_cover_key": global_row[2],
                        "message": "文件已存在，可快速添加到书库"
                    }
                }
    
    # 没有去重命中，返回上传 URL
    print(f"[Upload Init] No dedup hit, creating new upload for {filename}")
    data = await svc_get_upload_url(user_id, filename, content_type)
    data["dedup_hit"] = None
    return {"status": "success", "data": data}


@router.post("/upload_complete")
async def upload_complete(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    key = body.get("key")
    if not key:
        raise HTTPException(status_code=400, detail="missing_key")
    title = body.get("title") or "Untitled"
    author = body.get("author") or ""
    language = body.get("language") or ""
    original_format = body.get("original_format") or ""
    size = body.get("size") or None
    content_sha256 = body.get("content_sha256")  # 客户端计算的 SHA256
    
    # 【关键】如果客户端没有提供 SHA256（移动端浏览器可能不支持），服务器自己计算
    if not content_sha256 or len(content_sha256) != 64:
        print(f"[Upload] Client did not provide SHA256, computing server-side for {key}...")
        try:
            import hashlib
            file_data = read_full(BOOKS_BUCKET, key)  # 读取完整文件
            if file_data:
                content_sha256 = hashlib.sha256(file_data).hexdigest()
                print(f"[Upload] Server computed SHA256: {content_sha256[:16]}...")
            else:
                print(f"[Upload] Warning: Could not read file for SHA256 computation")
                content_sha256 = None
        except Exception as e:
            print(f"[Upload] Warning: Server-side SHA256 computation failed: {e}")
            content_sha256 = None
    
    if idempotency_key:
        idem_key = f"idem:books:upload_complete:{user_id}:{idempotency_key}"
        cached = r.get(idem_key)
        if cached:
            return {"status": "success", "data": eval(cached)}
    book_id = str(uuid.uuid4())
    etag = stat_etag(BOOKS_BUCKET, key)
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )

        if etag:
            res = await conn.execute(
                text(
                    "SELECT id::text, deleted_at FROM books WHERE user_id = current_setting('app.user_id')::uuid AND source_etag = :e"
                ),
                {"e": etag},
            )
            row = res.fetchone()
            if row:
                existing_book_id = row[0]
                was_deleted = row[1] is not None
                
                # 如果书籍之前被软删除，需要恢复它
                if was_deleted:
                    await conn.execute(
                        text("UPDATE books SET deleted_at = NULL, updated_at = now() WHERE id = cast(:id as uuid)"),
                        {"id": existing_book_id},
                    )
                    print(f"[Upload] Restored soft-deleted book {existing_book_id} with same etag")
                
                download_url = presigned_get(BOOKS_BUCKET, key)
                index_book(existing_book_id, user_id, title, author)
                data = {"id": existing_book_id, "download_url": download_url}
                if idempotency_key:
                    r.setex(idem_key, 24 * 3600, str(data))
                try:
                    celery_app.send_task(
                        "tasks.analyze_book_type", args=[existing_book_id, user_id]
                    )
                    celery_app.send_task(
                        "tasks.deep_analyze_book", args=[existing_book_id, user_id]
                    )
                except Exception:
                    pass
                return {"status": "success", "data": data}
    img_based, conf = _quick_confidence(BOOKS_BUCKET, key)
    
    # 对于非 EPUB/PDF 格式，需要设置 conversion_status='pending'
    fmt_lower = (original_format or '').lower()
    needs_conversion = fmt_lower not in ('epub', 'pdf')
    conversion_status = 'pending' if needs_conversion else None
    
    async with engine.begin() as conn:
        await conn.execute(
            text(
                """
        INSERT INTO books(id, user_id, title, author, language, original_format, minio_key, size, is_digitalized, initial_digitalization_confidence, source_etag, content_sha256, storage_ref_count, conversion_status)
        VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt, :key, :size, :dig, :conf, :etag, :sha256, 1, :conv_status)
        """
            ),
            {
                "id": book_id,
                "uid": user_id,
                "title": title,
                "author": author,
                "language": language,
                "fmt": original_format,
                "key": key,
                "size": size,
                "dig": (conf >= 0.8),
                "conf": conf,
                "etag": etag,
                "sha256": content_sha256,
                "conv_status": conversion_status,
            },
        )
        # 初始化 meta.page_count 为占位，后台任务将补齐
        await conn.execute(
            text(
                "UPDATE books SET meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', 1, 'needs_manual', true) WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
    
    # 记录上传完成日志
    sha_log = content_sha256[:16] if content_sha256 else 'None'
    print(f"[Upload] Created book {book_id} for user {user_id}, SHA256={sha_log}..., title={title}")
    
    download_url = presigned_get(BOOKS_BUCKET, key)
    index_book(book_id, user_id, title, author)
    data = {"id": book_id, "download_url": download_url}
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, str(data))
    
    # 【统一架构】所有格式均使用 Calibre 提取元数据
    # Calibre ebook-meta 支持 PDF, EPUB, MOBI, AZW3, FB2 等 20+ 种格式
    # 对于 PDF 还会检测是否为图片型（需要 OCR）
    try:
        print(f"[Upload] Using Calibre for metadata extraction (format: {fmt_lower})...")
        celery_app.send_task("tasks.extract_ebook_metadata_calibre", args=[book_id, user_id])
        
        # 非 EPUB/PDF 格式：额外启动转换任务，供阅读器使用
        if fmt_lower not in ('epub', 'pdf'):
            print(f"[Upload] Non-EPUB/PDF format, also starting conversion to EPUB...")
            celery_app.send_task("tasks.convert_to_epub", args=[book_id, user_id])
            
    except Exception as e:
        print(f"[Upload] Failed to queue background tasks: {e}")
        
    return {"status": "success", "data": data}


@router.post("/dedup_reference")
async def dedup_reference(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_upload_permission),
    auth=Depends(require_user),
):
    """
    全局去重秒传：当 upload_init 返回 dedup_available=true 时调用。
    不需要实际上传文件，直接创建指向已有存储的书籍记录。
    """
    user_id, _ = auth
    content_sha256 = body.get("content_sha256")
    canonical_book_id = body.get("canonical_book_id")
    title = body.get("title") or "Untitled"
    author = body.get("author") or ""
    language = body.get("language") or ""
    original_format = body.get("original_format") or ""
    
    if not content_sha256 or not canonical_book_id:
        raise HTTPException(status_code=400, detail="missing_content_sha256_or_canonical_book_id")
    
    if idempotency_key:
        idem_key = f"idem:books:dedup_reference:{user_id}:{idempotency_key}"
        cached = r.get(idem_key)
        if cached:
            return {"status": "success", "data": eval(cached)}
    
    book_id = str(uuid.uuid4())
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 获取原始书籍信息（包括 OCR 状态和结果）
        # 存储去重不排除软删除的书籍，因为文件仍然存在于 MinIO
        res = await conn.execute(
            text(
                """
                SELECT minio_key, cover_image_key, size, original_format, is_digitalized, 
                       initial_digitalization_confidence, meta, ocr_status, ocr_result_key
                FROM books WHERE id = cast(:cid as uuid) AND content_sha256 = :sha
                """
            ),
            {"cid": canonical_book_id, "sha": content_sha256},
        )
        canonical = res.fetchone()
        if not canonical:
            raise HTTPException(status_code=404, detail="canonical_book_not_found")
        
        (c_minio_key, c_cover_key, c_size, c_fmt, c_dig, c_conf, c_meta,
         c_ocr_status, c_ocr_result_key) = canonical
        
        # 增加原始存储的引用计数
        await conn.execute(
            text(
                "UPDATE books SET storage_ref_count = COALESCE(storage_ref_count, 1) + 1 WHERE id = cast(:cid as uuid)"
            ),
            {"cid": canonical_book_id},
        )
        
        # 创建新的书籍记录，共享存储但【不复制 OCR 状态】
        # 商业逻辑：每个用户都需要单独为 OCR 付费，不能"白嫖"其他用户的 OCR
        # 用户点击 OCR 按钮时，会检查 canonical_book_id 对应的原书是否已 OCR，
        # 如果已 OCR 则扣费后直接复制数据（假 OCR）
        
        # 关键：如果原书已经完成 OCR，说明它原本是图片型 PDF
        # 新用户的书籍应该标记为 is_image_based=True，以便显示 OCR 按钮
        # is_image_based 判断逻辑：(is_digitalized AND confidence < 0.8) OR ocr_status == 'completed'
        canonical_has_ocr = c_ocr_status == 'completed' and c_ocr_result_key is not None
        if canonical_has_ocr:
            # 原书已 OCR：新书设为"图片型 PDF 但未 OCR"，等待用户付费 OCR
            # 设置 is_digitalized=True + 低 confidence，使 is_image_based=True
            new_is_digitalized = True
            new_confidence = c_conf if c_conf and c_conf < 0.5 else 0.1  # 低置信度表示图片型
        else:
            # 原书未 OCR：继承原书状态
            new_is_digitalized = c_dig
            new_confidence = c_conf
        
        import json
        await conn.execute(
            text(
                """
                INSERT INTO books(id, user_id, title, author, language, original_format, 
                                  minio_key, cover_image_key, size, is_digitalized, initial_digitalization_confidence,
                                  content_sha256, canonical_book_id, storage_ref_count, meta)
                VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt,
                        :key, :cover, :size, :dig, :conf, :sha256, cast(:cid as uuid), 0, cast(:meta as jsonb))
                """
            ),
            {
                "id": book_id,
                "uid": user_id,
                "title": title,
                "author": author,
                "language": language,
                "fmt": c_fmt if not original_format else original_format,
                "key": c_minio_key,
                "cover": c_cover_key,
                "size": c_size,
                "dig": new_is_digitalized,
                "conf": new_confidence,
                "sha256": content_sha256,
                "cid": canonical_book_id,
                "meta": json.dumps(c_meta) if c_meta else None,
            },
        )
    
    print(f"[Dedup Reference] Created book {book_id} for user {user_id}, canonical={canonical_book_id}, has_ocr={canonical_has_ocr}")
    
    download_url = presigned_get(BOOKS_BUCKET, c_minio_key)
    index_book(book_id, user_id, title, author)
    
    data = {
        "id": book_id,
        "download_url": download_url,
        "dedup_hit": "global",
        "canonical_has_ocr": canonical_has_ocr,  # 原书是否已 OCR（仅供参考，不影响用户付费）
    }
    
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, str(data))
    
    return {"status": "success", "data": data}


async def _deep_analyze_and_standardize(book_id: str, user_id: str):
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        res = await conn.execute(
            text(
                "SELECT minio_key, is_digitalized, original_format FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            return
        key = row[0]
        fmt = (row[2] or "").lower()
        img_based, conf = _quick_confidence(BOOKS_BUCKET, key)
        rep_key = make_object_key(user_id, f"digitalize-report-{book_id}.json")
        import json

        upload_bytes(
            BOOKS_BUCKET,
            rep_key,
            json.dumps({"is_image_based": img_based, "confidence": conf}).encode(
                "utf-8"
            ),
            "application/json",
        )
        await conn.execute(
            text(
                "UPDATE books SET is_digitalized = :dig, initial_digitalization_confidence = :conf, digitalize_report_key = :rk, updated_at = now() WHERE id = cast(:id as uuid)"
            ),
            {
                "dig": (not img_based and conf >= 0.8),
                "conf": conf,
                "rk": rep_key,
                "id": book_id,
            },
        )
    try:
        await ws_broadcast(
            f"book:{book_id}",
            json.dumps(
                {
                    "event": "DEEP_ANALYZED",
                    "digitalized": (not img_based and conf >= 0.8),
                    "confidence": conf,
                }
            ),
        )
    except Exception:
        pass
    if fmt != "pdf":
        std_key = make_object_key(user_id, f"converted/{book_id}.epub")
        upload_bytes(
            BOOKS_BUCKET, std_key, b"standardized-epub", "application/epub+zip"
        )
        async with engine.begin() as conn:
            await conn.execute(
                text(
                    "UPDATE books SET converted_epub_key = :k, updated_at = now() WHERE id = cast(:id as uuid)"
                ),
                {"k": std_key, "id": book_id},
            )
        try:
            await ws_broadcast(
                f"book:{book_id}",
                json.dumps({"event": "STANDARDIZED", "epub_key": std_key}),
            )
        except Exception:
            pass


# ─────────────────────────────────────────────────────────────────────────────
# 获取书籍所属的书架列表（放在 /{book_id} 通配路由之前）
# ─────────────────────────────────────────────────────────────────────────────

@router.get("/{book_id}/shelves")
async def get_book_shelves(book_id: str, auth=Depends(require_user)):
    """查询某本书所属的所有书架"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            SELECT s.id::text, s.name, s.description, s.updated_at
            FROM shelf_items si
            JOIN shelves s ON s.id = si.shelf_id
            WHERE si.book_id = cast(:bid as uuid)
              AND s.user_id = current_setting('app.user_id')::uuid
            ORDER BY s.name
            """
            ),
            {"bid": book_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": {
                "items": [
                    {
                        "id": r[0],
                        "name": r[1],
                        "description": r[2],
                        "updated_at": str(r[3]),
                    }
                    for r in rows
                ]
            },
        }


@router.get("/{book_id}/cover")
async def get_book_cover(
    book_id: str,
    token: str = Query(None),
    authorization: str = Header(None),
):
    """
    获取书籍封面图片（通过 API 代理）
    解决移动端无法直接访问 localhost 存储的问题
    支持两种认证方式：
    1. Authorization header: Bearer <token>
    2. Query param: ?token=<token>
    """
    from fastapi.responses import Response as FastAPIResponse
    from jose import jwt
    
    AUTH_SECRET = os.getenv("AUTH_SECRET", "dev_secret")
    
    # 解析 token
    auth_token = None
    if authorization and authorization.startswith("Bearer "):
        auth_token = authorization.split(" ", 1)[1]
    elif token:
        auth_token = token
    
    if not auth_token:
        raise HTTPException(status_code=401, detail="unauthorized")
    
    try:
        # 【重要】verify_aud=False 因为 token 包含 aud: authenticated (PowerSync 要求)
        payload = jwt.decode(auth_token, AUTH_SECRET, algorithms=["HS256"], options={"verify_aud": False})
        user_id = payload["sub"]
    except Exception as e:
        raise HTTPException(status_code=401, detail=f"invalid_token: {str(e)}")
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT cover_image_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="cover_not_found")
        
        cover_key = row[0]
        
        # 从存储读取封面
        try:
            client = get_s3()
            ensure_bucket(client, BOOKS_BUCKET)
            resp = client.get_object(Bucket=BOOKS_BUCKET, Key=cover_key)
            cover_data = resp["Body"].read()
            content_type = resp.get("ContentType", "image/webp")
            
            return FastAPIResponse(
                content=cover_data,
                media_type=content_type,
                headers={
                    "Cache-Control": "public, max-age=86400",  # 缓存 24 小时
                    "Content-Disposition": "inline",
                    "Access-Control-Allow-Origin": "*",  # 允许 canvas 跨域读取
                }
            )
        except Exception as e:
            raise HTTPException(status_code=404, detail=f"cover_fetch_error: {str(e)}")


@router.get("/{book_id}/content")
async def get_book_content(
    book_id: str,
    token: str = Query(None),
    authorization: str = Header(None),
):
    """
    获取书籍内容（通过 API 代理）
    支持 HTTP Range 请求以实现流式加载
    解决 CORS 问题，使 epub.js 和 react-pdf 可以正确加载书籍
    """
    from fastapi.responses import Response as FastAPIResponse, StreamingResponse
    from fastapi import Request
    from jose import jwt
    
    AUTH_SECRET = os.getenv("AUTH_SECRET", "dev_secret")
    
    # 解析 token
    auth_token = None
    if authorization and authorization.startswith("Bearer "):
        auth_token = authorization.split(" ", 1)[1]
    elif token:
        auth_token = token
    
    if not auth_token:
        raise HTTPException(status_code=401, detail="unauthorized")
    
    try:
        # 【重要】verify_aud=False 因为 token 包含 aud: authenticated (PowerSync 要求)
        payload = jwt.decode(auth_token, AUTH_SECRET, algorithms=["HS256"], options={"verify_aud": False})
        user_id = payload["sub"]
    except Exception as e:
        raise HTTPException(status_code=401, detail=f"invalid_token: {str(e)}")
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT minio_key, original_format, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        minio_key, original_format, converted_epub_key = row[0], row[1], row[2]
        
        # 优先使用转换后的 EPUB（非 EPUB/PDF 格式会被转换为 EPUB）
        if converted_epub_key:
            minio_key = converted_epub_key
            original_format = "epub"
        
        # 确定 content type（只支持 EPUB 和 PDF）
        content_type_map = {
            "epub": "application/epub+zip",
            "pdf": "application/pdf",
        }
        content_type = content_type_map.get(original_format, "application/epub+zip")
        
        # 从存储读取书籍
        try:
            client = get_s3()
            ensure_bucket(client, BOOKS_BUCKET)
            resp = client.get_object(Bucket=BOOKS_BUCKET, Key=minio_key)
            book_data = resp["Body"].read()
            content_length = len(book_data)
            
            return FastAPIResponse(
                content=book_data,
                media_type=content_type,
                headers={
                    "Content-Length": str(content_length),
                    "Accept-Ranges": "bytes",
                    "Cache-Control": "private, max-age=3600",
                    "Content-Disposition": f"inline; filename=\"book.{original_format}\"",
                }
            )
        except Exception as e:
            raise HTTPException(status_code=404, detail=f"book_fetch_error: {str(e)}")


@router.get("/{book_id}/processing/status")
async def processing_status(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT status FROM conversion_jobs WHERE owner_id = current_setting('app.user_id')::uuid AND book_id = cast(:bid as uuid) ORDER BY created_at DESC LIMIT 1"
            ),
            {"bid": book_id},
        )
        row = res.fetchone()
        if not row:
            return {"status": "success", "data": {"status": "ACTIVE"}}
        st = row[0]
        mapped = (
            "ACTIVE"
            if st in ("succeeded", "active")
            else ("FAILED" if st == "failed" else "PENDING")
        )
        return {"status": "success", "data": {"status": mapped}}


@router.get("/{book_id}/convert/output")
async def presign_convert_output(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT output_key FROM conversion_jobs WHERE owner_id = current_setting('app.user_id')::uuid AND book_id = cast(:bid as uuid) AND status = 'completed' ORDER BY updated_at DESC LIMIT 1"
            ),
            {"bid": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="not_found")
        return {
            "status": "success",
            "data": {"download_url": presigned_get(BOOKS_BUCKET, row[0])},
        }


@router.get("/{book_id}/ocr")
async def get_book_ocr(book_id: str, auth=Depends(require_user)):
    """
    获取书籍的 OCR 识别结果
    返回按页组织的文本内容，用于前端显示和搜索
    
    支持两种数据源：
    1. ocr_result_key - 新版 OCR 结果（含每页尺寸）
    2. digitalize_report_key - 旧版数字化报告
    """
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT digitalize_report_key, ocr_result_key, is_digitalized, ocr_status FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        
        old_report_key, new_ocr_key, is_digitalized, ocr_status = row
        
        # 优先使用新版 OCR 结果
        report_key = new_ocr_key or old_report_key
        
        if not report_key:
            return {
                "status": "success",
                "data": {
                    "available": False,
                    "is_digitalized": bool(is_digitalized),
                    "ocr_status": ocr_status,
                    "pages": {},
                    "total_pages": 0,
                    "total_chars": 0,
                }
            }
        
        # 读取 OCR 报告
        try:
            from .storage import read_full
            report_data = read_full(BOOKS_BUCKET, report_key)
            if not report_data:
                raise Exception("Report not found")
            
            import json
            report = json.loads(report_data)
            
            # 判断是新版还是旧版格式
            if "pages" in report and isinstance(report["pages"], list):
                # 新版格式: {"pages": [{page_num, width, height, regions, text}, ...]}
                ocr_pages = report.get("pages", [])
                pages_formatted = {}
                total_chars = 0
                
                for page_data in ocr_pages:
                    page_num = page_data.get("page_num", 1)
                    page_text = page_data.get("text", "")
                    if page_text:
                        pages_formatted[str(page_num)] = page_text
                        total_chars += len(page_text)
                
                return {
                    "status": "success",
                    "data": {
                        "available": True,
                        "is_digitalized": bool(is_digitalized),
                        "ocr_status": ocr_status,
                        "is_image_based": True,  # 新版 OCR 结果肯定是图片型
                        "confidence": 1.0,
                        "pages": pages_formatted,
                        "total_pages": report.get("total_pages", len(pages_formatted)),
                        "total_chars": total_chars,
                    }
                }
            else:
                # 旧版格式: {"ocr": {"pages": [...], "regions": [...]}}
                ocr_result = report.get("ocr", {})
                ocr_pages = ocr_result.get("pages", [])
                
                # 按页组织文本
                pages_dict = {}
                for item in ocr_pages:
                    page_num = item.get("page", 1)
                    item_text = item.get("text", "")
                    if item_text:
                        if page_num not in pages_dict:
                            pages_dict[page_num] = []
                        pages_dict[page_num].append(item_text)
                
                # 转换为前端友好格式
                pages_formatted = {}
                total_chars = 0
                for page_num, texts in pages_dict.items():
                    page_text = "\n".join(texts)
                    pages_formatted[str(page_num)] = page_text
                    total_chars += len(page_text)
                
                return {
                    "status": "success",
                    "data": {
                        "available": True,
                        "is_digitalized": bool(is_digitalized),
                        "ocr_status": ocr_status,
                        "is_image_based": report.get("is_image_based", False),
                        "confidence": report.get("confidence", 0),
                        "pages": pages_formatted,
                        "total_pages": len(pages_formatted),
                        "total_chars": total_chars,
                    }
                }
        except Exception as e:
            print(f"[OCR] Failed to read report: {e}")
            return {
                "status": "success",
                "data": {
                    "available": False,
                    "is_digitalized": bool(is_digitalized),
                    "ocr_status": ocr_status,
                    "pages": {},
                    "total_pages": 0,
                    "total_chars": 0,
                    "error": str(e),
                }
            }


@router.get("/{book_id}/ocr/full")
async def get_book_ocr_full(
    book_id: str,
    auth=Depends(require_user)
):
    """
    获取书籍完整的 OCR 识别结果（含所有页面坐标信息）
    用于前端一次性下载并缓存到 IndexedDB
    
    注意：PDF 每一页的尺寸可能不同，page_sizes 字典包含每页的实际尺寸
    
    支持两种数据源：
    1. ocr_result_key - 新版 OCR 结果（含每页尺寸）
    2. digitalize_report_key - 旧版数字化报告
    
    返回格式（支持 gzip 压缩）:
    {
        "is_image_based": true,
        "confidence": 0.95,
        "total_pages": 603,
        "total_chars": 606993,
        "total_regions": 22784,
        "page_sizes": {           // 每页的实际尺寸（页码为字符串 key）
            "1": {"width": 1240, "height": 1754},
            "2": {"width": 1240, "height": 1600},
            ...
        },
        "regions": [
            {
                "text": "识别的文字",
                "confidence": 0.99,
                "bbox": [x1, y1, x2, y2],
                "polygon": [[x1,y1], ...],
                "page": 1
            },
            ...
        ]
    }
    """
    import gzip
    import json
    
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT digitalize_report_key, ocr_result_key, is_digitalized FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        old_report_key, new_ocr_key, is_digitalized = row
        
        # 优先使用新版 OCR 结果
        report_key = new_ocr_key or old_report_key
        
        if not report_key:
            raise HTTPException(status_code=404, detail="ocr_not_available")
        
        try:
            from .storage import read_full
            report_data = read_full(BOOKS_BUCKET, report_key)
            if not report_data:
                raise Exception("Report not found")
            
            report = json.loads(report_data)
            
            # 判断是新版还是旧版格式
            if "pages" in report and isinstance(report["pages"], list):
                # 新版格式: {"pages": [{page_num, width, height, regions, text}, ...]}
                ocr_pages = report.get("pages", [])
                
                # 构建 page_sizes 和 regions
                page_sizes = {}
                all_regions = []
                total_chars = 0
                
                for page_data in ocr_pages:
                    page_num = page_data.get("page_num", 1)
                    
                    # 记录每页尺寸
                    page_sizes[str(page_num)] = {
                        "width": page_data.get("width", 0),
                        "height": page_data.get("height", 0),
                        "pdf_width": page_data.get("pdf_width", 0),
                        "pdf_height": page_data.get("pdf_height", 0),
                        "dpi": page_data.get("dpi", 150),
                    }
                    
                    # 收集 regions，添加 page 信息
                    for region in page_data.get("regions", []):
                        region_with_page = region.copy()
                        region_with_page["page"] = page_num
                        all_regions.append(region_with_page)
                    
                    total_chars += len(page_data.get("text", ""))
                
                response_data = {
                    "is_image_based": True,
                    "confidence": 1.0,
                    "total_pages": report.get("total_pages", len(ocr_pages)),
                    "total_chars": total_chars,
                    "total_regions": len(all_regions),
                    "page_sizes": page_sizes,
                    "regions": all_regions,
                }
            else:
                # 旧版格式: {"ocr": {"pages": [...], "regions": [...]}}
                ocr_result = report.get("ocr", {})
                all_regions = ocr_result.get("regions", [])
                
                # 计算统计信息
                total_chars = sum(len(r.get("text", "")) for r in all_regions)
                page_numbers = set(r.get("page", 1) for r in all_regions)
                total_pages = max(page_numbers) if page_numbers else 0
                
                # 获取每页的尺寸信息
                page_sizes = report.get("page_sizes", {})
                
                # 如果报告中没有 page_sizes，则从每页的 region 坐标推断
                if not page_sizes:
                    page_sizes = {}
                    page_regions_map = {}
                    for r in all_regions:
                        p = r.get("page", 1)
                        if p not in page_regions_map:
                            page_regions_map[p] = []
                        page_regions_map[p].append(r)
                    
                    for page_num, regions in page_regions_map.items():
                        max_x, max_y = 0.0, 0.0
                        for r in regions:
                            bbox = r.get("bbox", [])
                            if len(bbox) >= 4:
                                max_x = max(max_x, bbox[2])
                                max_y = max(max_y, bbox[3])
                        
                        if max_x > 0 and max_y > 0:
                            page_sizes[str(page_num)] = {
                                "width": int(max_x * 1.08),
                                "height": int(max_y * 1.08)
                            }
                
                response_data = {
                    "is_image_based": report.get("is_image_based", False),
                    "confidence": report.get("confidence", 0),
                    "total_pages": total_pages,
                    "total_chars": total_chars,
                    "total_regions": len(all_regions),
                    "page_sizes": page_sizes,
                    "regions": all_regions,
                }
            
            # 使用 gzip 压缩
            json_bytes = json.dumps(response_data, ensure_ascii=False).encode("utf-8")
            compressed = gzip.compress(json_bytes, compresslevel=6)
            
            return Response(
                content=compressed,
                media_type="application/json",
                headers={
                    "Content-Encoding": "gzip",
                    "Content-Length": str(len(compressed)),
                    "X-Original-Size": str(len(json_bytes)),
                    "X-Compressed-Size": str(len(compressed)),
                }
            )
        except Exception as e:
            print(f"[OCR] Failed to read full OCR data: {e}")
            import traceback
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(e))


@router.get("/{book_id}/ocr/quota")
async def get_ocr_quota_info(book_id: str, auth=Depends(require_user)):
    """
    获取 OCR 配额信息，用于前端显示。
    
    返回:
    - pageCount: 书籍页数
    - tier: 阶梯 (1, 2, 3)
    - cost: 所需配额单位
    - canTrigger: 是否可以触发 OCR
    - reason: 不能触发的原因
    - freeRemaining: 免费剩余额度
    - proRemaining: Pro 赠送剩余额度
    - addonRemaining: 加油包剩余额度
    - isPro: 是否是 Pro 用户
    - maxPages: 最大支持页数
    """
    from datetime import datetime, timezone
    
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 获取书籍信息
        res = await conn.execute(
            text("""
                SELECT id, is_digitalized, initial_digitalization_confidence, ocr_status,
                       COALESCE((meta->>'page_count')::int, 0) as page_count
                FROM books 
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        _, is_digitalized, confidence, ocr_status, page_count = row
        
        # 获取系统配置
        settings_res = await conn.execute(
            text("""
                SELECT key, value FROM system_settings 
                WHERE key IN (
                    'ocr_page_thresholds', 'ocr_max_pages', 'ocr_monthly_free_quota',
                    'monthly_gift_ocr_count'
                )
            """)
        )
        settings = {r[0]: r[1] for r in settings_res.fetchall()}
        
        thresholds = settings.get("ocr_page_thresholds", {"standard": 600, "double": 1000, "triple": 2000})
        max_pages = int(settings.get("ocr_max_pages", 2000))
        free_quota = int(settings.get("ocr_monthly_free_quota", 3))
        gift_quota = int(settings.get("monthly_gift_ocr_count", 3))
        
        # 获取用户信息
        user_res = await conn.execute(
            text("""
                SELECT membership_tier, membership_expire_at, free_ocr_usage,
                       COALESCE(ocr_addon_balance, 0) as addon_balance
                FROM users WHERE id = cast(:uid as uuid)
            """),
            {"uid": user_id},
        )
        user_row = user_res.fetchone()
        if not user_row:
            raise HTTPException(status_code=401, detail="user_not_found")
        
        tier, membership_expire_at, free_ocr_used, addon_balance = user_row
        
        # Pro 会员检查
        is_pro = False
        if tier and tier != "FREE" and membership_expire_at:
            if membership_expire_at > datetime.now(timezone.utc):
                is_pro = True
        
        # 计算阶梯和所需单位
        if page_count <= thresholds["standard"]:
            tier_level = 1
            units_needed = 1
        elif page_count <= thresholds["double"]:
            tier_level = 2
            units_needed = 2
        elif page_count <= thresholds["triple"]:
            tier_level = 3
            units_needed = 3
        else:
            tier_level = 3
            units_needed = 3
        
        # 计算剩余配额
        free_remaining = max(0, free_quota - (free_ocr_used or 0))
        pro_remaining = max(0, gift_quota - (free_ocr_used or 0)) if is_pro else 0
        
        # 判断是否可以触发
        can_trigger = True
        reason = None
        
        # 检查是否已是数字型（confidence >= 0.8 表示有足够可提取文字，不需要 OCR）
        # 注意：is_digitalized 表示"已检测"，不是"已数字化"
        # 真正的判断依据是 confidence：低于 0.8 表示图片型，需要 OCR
        is_already_digital = is_digitalized and (confidence is not None and confidence >= 0.8)
        
        if is_already_digital:
            can_trigger = False
            reason = "书籍已是文字型，无需 OCR"
        elif ocr_status in ('pending', 'processing'):
            can_trigger = False
            reason = "OCR 任务正在处理中"
        elif ocr_status == 'completed':
            can_trigger = False
            reason = "书籍已完成 OCR"
        elif not page_count or page_count == 0:
            can_trigger = False
            reason = "无法获取书籍页数"
        elif page_count > max_pages:
            can_trigger = False
            reason = f"页数超过上限 (最大 {max_pages} 页)"
        elif not is_pro:
            # 免费用户检查
            if tier_level > 1:
                can_trigger = False
                reason = "免费用户仅支持 ≤600 页的书籍"
            elif free_remaining < 1:
                can_trigger = False
                reason = "本月免费配额已用尽"
        else:
            # Pro 用户检查
            if tier_level == 1 and pro_remaining >= 1:
                pass  # 可以使用月度赠送
            elif addon_balance < units_needed:
                can_trigger = False
                reason = "配额不足，请购买加油包"
        
        return {
            "status": "success",
            "data": {
                "pageCount": page_count if page_count > 0 else None,
                "tier": tier_level,
                "cost": units_needed,
                "canTrigger": can_trigger,
                "reason": reason,
                "freeRemaining": free_remaining if not is_pro else 0,
                "proRemaining": pro_remaining,
                "addonRemaining": addon_balance,
                "isPro": is_pro,
                "maxPages": max_pages,
            }
        }


@router.post("/{book_id}/ocr")
async def trigger_book_ocr(book_id: str, auth=Depends(require_user)):
    """
    用户主动请求对图片型 PDF 进行 OCR 处理。
    
    检查:
    1. 书籍是否存在且属于用户
    2. 书籍是否已是文字型 (confidence >= 0.8 表示数字型，不需要 OCR)
    3. 是否已有 OCR 任务在处理中
    4. 用户 OCR 配额是否充足
    5. 【新增】如果是去重引用书籍且原书已完成 OCR，直接复用并"假装处理"
    
    成功后更新 books.ocr_status='pending', ocr_requested_at=now()
    并分发 Celery 任务进行 OCR 处理
    """
    from datetime import datetime, timezone
    
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 1. 获取书籍信息（包括 canonical_book_id、ocr_result_key 和 content_sha256）
        res = await conn.execute(
            text("""
                SELECT id, is_digitalized, initial_digitalization_confidence, 
                       ocr_status, ocr_requested_at, minio_key, 
                       COALESCE((meta->>'page_count')::int, 0) as page_count,
                       canonical_book_id, ocr_result_key, content_sha256
                FROM books 
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        (book_id_db, is_digitalized, confidence, ocr_status, ocr_requested_at, 
         minio_key, page_count, canonical_book_id, current_ocr_result_key, content_sha256) = row
        
        # 【重要】检查是否可以复用已有 OCR 数据（假 OCR）
        # 通过 content_sha256 查找任何一本已完成 OCR 的书籍
        # 这比只检查 canonical_book_id 更可靠，因为原书可能被删除
        can_instant_complete = False
        reusable_ocr_result_key = None
        
        if content_sha256:
            # 查找同一 SHA256 的任何已完成 OCR 的书籍（包括软删除的）
            ocr_res = await conn.execute(
                text("""
                    SELECT ocr_result_key 
                    FROM books 
                    WHERE content_sha256 = :sha 
                      AND ocr_status = 'completed' 
                      AND ocr_result_key IS NOT NULL
                      AND id != cast(:book_id as uuid)
                    ORDER BY deleted_at IS NULL DESC, ocr_requested_at DESC
                    LIMIT 1
                """),
                {"sha": content_sha256, "book_id": book_id},
            )
            ocr_row = ocr_res.fetchone()
            if ocr_row:
                can_instant_complete = True
                reusable_ocr_result_key = ocr_row[0]
                print(f"[OCR] Found reusable OCR for {book_id} via SHA256 {content_sha256[:16]}...")
        
        # 2. 检查是否已是数字型（confidence >= 0.8 表示有足够可提取文字，不需要 OCR）
        # 注意：is_digitalized 表示"已检测"，不是"已数字化"
        # 真正的判断依据是 confidence：低于 0.8 表示图片型，需要 OCR
        if is_digitalized and (confidence is not None and confidence >= 0.8):
            raise HTTPException(status_code=400, detail="already_digitalized")
        
        # 3. 检查是否已有 OCR 任务在处理中
        if ocr_status in ('pending', 'processing'):
            # 计算队列位置
            queue_res = await conn.execute(
                text("""
                    SELECT COUNT(*) FROM books 
                    WHERE ocr_status IN ('pending', 'processing') 
                    AND ocr_requested_at < :req_at
                """),
                {"req_at": ocr_requested_at or datetime.now(timezone.utc)},
            )
            queue_pos = (queue_res.fetchone()[0] or 0) + 1
            
            raise HTTPException(
                status_code=409,
                detail={
                    "code": "ocr_in_progress",
                    "queuePosition": queue_pos
                }
            )
        
        # 4. 页数风控检查
        if not page_count or page_count == 0:
            raise HTTPException(
                status_code=400,
                detail={
                    "code": "OCR_NEEDS_MANUAL_CHECK",
                    "message": "无法获取书籍页数信息，请联系客服"
                }
            )
        
        # 获取系统配置
        settings_res = await conn.execute(
            text("""
                SELECT key, value FROM system_settings 
                WHERE key IN (
                    'ocr_page_thresholds', 'ocr_max_pages', 'ocr_monthly_free_quota',
                    'monthly_gift_ocr_count', 'ocr_minutes_per_book'
                )
            """)
        )
        settings = {r[0]: r[1] for r in settings_res.fetchall()}
        
        # 解析配置（value 是 JSONB，已经是 Python 对象）
        thresholds = settings.get("ocr_page_thresholds", {"standard": 600, "double": 1000, "triple": 2000})
        max_pages = int(settings.get("ocr_max_pages", 2000))
        free_quota = int(settings.get("ocr_monthly_free_quota", 3))
        gift_quota = int(settings.get("monthly_gift_ocr_count", 3))
        minutes_per_book = int(settings.get("ocr_minutes_per_book", 5))
        
        # 检查页数上限
        if page_count > max_pages:
            raise HTTPException(
                status_code=400,
                detail={
                    "code": "OCR_MAX_PAGES_EXCEEDED",
                    "pages": page_count,
                    "limit": max_pages
                }
            )
        
        # 计算所需单位数（按阶梯）
        if page_count <= thresholds["standard"]:
            units_needed = 1
        elif page_count <= thresholds["double"]:
            units_needed = 2
        elif page_count <= thresholds["triple"]:
            units_needed = 3
        else:
            units_needed = 3  # fallback
        
        # 5. 检查用户配额
        user_res = await conn.execute(
            text("""
                SELECT membership_tier, membership_expire_at, free_ocr_usage,
                       COALESCE(monthly_gift_reset_at, '1970-01-01'::timestamptz) as gift_reset_at
                FROM users WHERE id = cast(:uid as uuid)
            """),
            {"uid": user_id},
        )
        user_row = user_res.fetchone()
        if not user_row:
            raise HTTPException(status_code=401, detail="user_not_found")
        
        tier, membership_expire_at, free_ocr_used, gift_reset_at = user_row
        
        # Pro 会员检查
        is_pro = False
        if tier and tier != "FREE" and membership_expire_at:
            if membership_expire_at > datetime.now(timezone.utc):
                is_pro = True
        
        # 检查月度赠送是否需要重置
        now_utc = datetime.now(timezone.utc)
        if is_pro and gift_reset_at < now_utc.replace(day=1, hour=0, minute=0, second=0, microsecond=0):
            # 重置月度赠送
            await conn.execute(
                text("UPDATE users SET free_ocr_usage = 0, monthly_gift_reset_at = now() WHERE id = cast(:uid as uuid)"),
                {"uid": user_id}
            )
            free_ocr_used = 0
        
        # 配额检查逻辑（按商业模型 V9.0）
        can_use_free = units_needed == 1  # 仅 ≤600 页可用免费额度
        
        if is_pro:
            # Pro 会员：优先用月度赠送
            if can_use_free and free_ocr_used < gift_quota:
                # 使用月度赠送额度
                quota_type = "monthly_gift"
            else:
                # 需要检查加油包余额
                addon_res = await conn.execute(
                    text("SELECT ocr_addon_balance FROM users WHERE id = cast(:uid as uuid)"),
                    {"uid": user_id}
                )
                addon_balance = (addon_res.fetchone() or (0,))[0] or 0
                if addon_balance < units_needed:
                    raise HTTPException(
                        status_code=403,
                        detail={
                            "code": "ocr_quota_exceeded",
                            "quota": {
                                "giftUsed": free_ocr_used,
                                "giftLimit": gift_quota,
                                "addonBalance": addon_balance,
                                "unitsNeeded": units_needed,
                                "pageCount": page_count
                            }
                        }
                    )
                quota_type = "addon"
        else:
            # 免费用户：仅能用月度免费配额（仅 ≤600 页）
            if not can_use_free:
                raise HTTPException(
                    status_code=403,
                    detail={
                        "code": "OCR_MAX_PAGES_EXCEEDED",
                        "message": "免费用户仅支持 600 页以内的书籍 OCR"
                    }
                )
            if free_ocr_used >= free_quota:
                raise HTTPException(
                    status_code=403,
                    detail={
                        "code": "ocr_quota_exceeded",
                        "quota": {
                            "used": free_ocr_used,
                            "limit": free_quota
                        }
                    }
                )
            quota_type = "free"
        
        # 6. 扣除配额（在同一事务内）
        if quota_type == "monthly_gift":
            await conn.execute(
                text("UPDATE users SET free_ocr_usage = free_ocr_usage + 1 WHERE id = cast(:uid as uuid)"),
                {"uid": user_id}
            )
        elif quota_type == "addon":
            await conn.execute(
                text("UPDATE users SET ocr_addon_balance = ocr_addon_balance - :units WHERE id = cast(:uid as uuid)"),
                {"uid": user_id, "units": units_needed}
            )
        elif quota_type == "free":
            await conn.execute(
                text("UPDATE users SET free_ocr_usage = free_ocr_usage + 1 WHERE id = cast(:uid as uuid)"),
                {"uid": user_id}
            )
        
        # 7. 【重要】如果可以秒完成（复用已有 OCR），直接更新状态为 completed
        if can_instant_complete and reusable_ocr_result_key:
            # 直接复用已有的 OCR 结果，标记为 completed
            await conn.execute(
                text("""
                    UPDATE books 
                    SET ocr_status = 'completed', 
                        ocr_requested_at = now(),
                        ocr_result_key = :ocr_key,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {"id": book_id, "ocr_key": reusable_ocr_result_key}
            )
            
            print(f"[OCR] Instant completed for {book_id} using reusable OCR result")
            
            # 计算"假装处理"的时间：页数 × 0.5 秒，最少 3 秒，最多 60 秒
            fake_processing_seconds = min(60, max(3, (page_count or 10) * 0.5))
            
            return {
                "status": "instant_completed",
                "estimatedSeconds": fake_processing_seconds,
                "pageCount": page_count,
                "message": "OCR data inherited from shared source"
            }
        
        # 8. 正常流程：更新书籍 OCR 状态为 pending
        await conn.execute(
            text("""
                UPDATE books 
                SET ocr_status = 'pending', 
                    ocr_requested_at = now(),
                    updated_at = now()
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id}
        )
        
        # 9. 计算队列位置
        queue_res = await conn.execute(
            text("""
                SELECT COUNT(*) FROM books 
                WHERE ocr_status IN ('pending', 'processing') 
                AND ocr_requested_at < now()
            """)
        )
        queue_position = (queue_res.fetchone()[0] or 0) + 1
        estimated_minutes = max(minutes_per_book, queue_position * minutes_per_book + (page_count or 100) // 50)
        
        # 10. 分发 Celery 任务
        try:
            celery_app.send_task(
                "tasks.process_book_ocr",
                args=[book_id, user_id],
                priority=7 if is_pro else 3
            )
        except Exception as e:
            print(f"[OCR] Failed to dispatch Celery task: {e}")
            # 任务分发失败，回滚状态
            await conn.execute(
                text("UPDATE books SET ocr_status = NULL, ocr_requested_at = NULL WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            raise HTTPException(status_code=503, detail="ocr_service_unavailable")
    
    return {
        "status": "queued",
        "queuePosition": queue_position,
        "estimatedMinutes": estimated_minutes
    }


@router.get("/{book_id}/ocr/status")
async def get_book_ocr_status(book_id: str, auth=Depends(require_user)):
    """
    查询书籍的 OCR 处理状态。
    
    返回:
    - isDigitalized: 是否已是文字型
    - ocrStatus: pending | processing | completed | failed | null
    - queuePosition: 仅当 status=pending 时返回
    - estimatedMinutes: 预计处理时间
    - completedAt: 仅当 status=completed 时返回
    - errorMessage: 仅当 status=failed 时返回
    """
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        res = await conn.execute(
            text("""
                SELECT id, is_digitalized, ocr_status, ocr_requested_at, 
                       vector_indexed_at, COALESCE((meta->>'page_count')::int, 0) as page_count,
                       meta->>'ocr_error' as ocr_error
                FROM books 
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        book_id_db, is_digitalized, ocr_status, ocr_requested_at, vector_indexed_at, page_count, ocr_error = row
        
        result = {
            "bookId": str(book_id_db),
            "isDigitalized": bool(is_digitalized),
            "ocrStatus": ocr_status,
        }
        
        if ocr_status == 'pending':
            # 计算队列位置
            queue_res = await conn.execute(
                text("""
                    SELECT COUNT(*) FROM books 
                    WHERE ocr_status IN ('pending', 'processing') 
                    AND ocr_requested_at < :req_at
                """),
                {"req_at": ocr_requested_at},
            )
            queue_pos = (queue_res.fetchone()[0] or 0) + 1
            result["queuePosition"] = queue_pos
            # 从 system_settings 获取配置
            settings_row = await conn.execute(
                text("SELECT value FROM system_settings WHERE key = 'ocr_minutes_per_book'")
            )
            mins_per_book = int((settings_row.fetchone() or (5,))[0])
            result["estimatedMinutes"] = max(mins_per_book, queue_pos * mins_per_book + (page_count or 100) // 50)
        
        elif ocr_status == 'processing':
            settings_row = await conn.execute(
                text("SELECT value FROM system_settings WHERE key = 'ocr_minutes_per_book'")
            )
            mins_per_book = int((settings_row.fetchone() or (5,))[0])
            result["estimatedMinutes"] = max(mins_per_book, (page_count or 100) // 50)
        
        elif ocr_status == 'completed':
            result["completedAt"] = str(vector_indexed_at) if vector_indexed_at else None
        
        elif ocr_status == 'failed':
            result["errorCode"] = "ocr_failed"
            if ocr_error:
                result["errorMessage"] = ocr_error
        
        return result


@router.get("/{book_id}/ocr/page/{page}")
async def get_book_ocr_page(
    book_id: str, 
    page: int,
    auth=Depends(require_user)
):
    """
    获取书籍单页的 OCR 识别结果（含坐标信息）
    用于前端渲染 OCR 文字叠加层，实现文字选择和高亮功能
    
    注意：PDF 每一页的尺寸可能不同，image_width 和 image_height 是该页的实际尺寸
    
    返回格式:
    {
        "regions": [
            {
                "text": "识别的文字",
                "confidence": 0.99,
                "bbox": [x1, y1, x2, y2],  # 边界框坐标
                "polygon": [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]  # 4点多边形
            },
            ...
        ],
        "page": 1,
        "image_width": 1240,  # 该页的原始图片宽度（用于坐标映射）
        "image_height": 1754  # 该页的原始图片高度
    }
    """
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT digitalize_report_key FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="ocr_not_available")
        
        report_key = row[0]
        
        try:
            from .storage import read_full
            report_data = read_full(BOOKS_BUCKET, report_key)
            if not report_data:
                raise Exception("Report not found")
            
            import json
            report = json.loads(report_data)
            ocr_result = report.get("ocr", {})
            all_regions = ocr_result.get("regions", [])
            
            # 筛选指定页的 regions
            page_regions = [
                {
                    "text": r.get("text", ""),
                    "confidence": r.get("confidence", 0),
                    "bbox": r.get("bbox"),
                    "polygon": r.get("polygon"),
                }
                for r in all_regions
                if r.get("page") == page
            ]
            
            # 获取该页的图片尺寸
            # PDF 每一页的尺寸可能不同，需要从报告中读取每页的实际尺寸
            page_sizes = report.get("page_sizes", {})  # {"1": {"width": 1240, "height": 1754}, ...}
            page_size = page_sizes.get(str(page), {})
            
            if page_size:
                image_width = page_size.get("width", 0)
                image_height = page_size.get("height", 0)
            else:
                # 如果报告中没有该页尺寸，从该页的 region 坐标推断
                max_x, max_y = 0.0, 0.0
                for r in page_regions:
                    bbox = r.get("bbox", [])
                    if bbox and len(bbox) >= 4:
                        max_x = max(max_x, bbox[2])  # x2
                        max_y = max(max_y, bbox[3])  # y2
                
                if max_x > 0 and max_y > 0:
                    # 添加约 8% 边距估算完整页面尺寸
                    image_width = int(max_x * 1.08)
                    image_height = int(max_y * 1.08)
                else:
                    # 无法推断时返回 0 表示未知
                    image_width = 0
                    image_height = 0
            
            return {
                "status": "success",
                "data": {
                    "regions": page_regions,
                    "page": page,
                    "image_width": image_width,
                    "image_height": image_height,
                    "total_regions": len(page_regions),
                }
            }
        except Exception as e:
            print(f"[OCR] Failed to read page {page} OCR: {e}")
            raise HTTPException(status_code=500, detail=str(e))


@router.get("/{book_id}/ocr/search")
async def search_book_ocr(
    book_id: str, 
    q: str = Query(..., min_length=1, description="搜索关键词"),
    auth=Depends(require_user)
):
    """
    在书籍 OCR 内容中搜索
    使用 OpenSearch 进行全文搜索
    """
    import requests
    
    user_id, _ = auth
    ES_URL = os.getenv("ES_URL", "http://opensearch:9200")
    
    if not ES_URL:
        raise HTTPException(status_code=503, detail="search_unavailable")
    
    try:
        query = {
            "query": {
                "bool": {
                    "must": [
                        {"match": {"content": q}},
                        {"term": {"book_id": book_id}},
                        {"term": {"user_id": user_id}},
                    ]
                }
            },
            "size": 50,
            "sort": [{"page": "asc"}],
            "_source": ["page", "content"],
            "highlight": {
                "fields": {"content": {}},
                "pre_tags": ["<mark>"],
                "post_tags": ["</mark>"],
            }
        }
        
        resp = requests.post(f"{ES_URL}/book_content/_search", json=query, timeout=10)
        resp.raise_for_status()
        result = resp.json()
        
        hits = []
        for hit in result.get("hits", {}).get("hits", []):
            src = hit.get("_source", {})
            highlight = hit.get("highlight", {}).get("content", [])
            hits.append({
                "page": src.get("page"),
                "content": src.get("content", "")[:200],
                "highlight": highlight[0] if highlight else None,
                "score": hit.get("_score", 0),
            })
        
        return {
            "status": "success",
            "data": {
                "query": q,
                "total": result.get("hits", {}).get("total", {}).get("value", 0),
                "hits": hits,
            }
        }
    except Exception as e:
        print(f"[Search] Failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{book_id}/presign_put_converted")
async def presign_put_converted(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    key = make_object_key(user_id, f"converted/{book_id}.epub")
    url = presigned_put(BOOKS_BUCKET, key)
    return {"status": "success", "data": {"put_url": url, "key": key}}


@router.post("/{book_id}/presign_get_source")
async def presign_get_source(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT minio_key, original_format FROM books WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        key, fmt = row[0], (row[1] or "").lower()
        if isinstance(key, str) and key.startswith("http"):
            try:
                from urllib.parse import urlparse, urlunparse

                u = urlparse(key)
                if u.hostname in ("127.0.0.1", "localhost"):
                    # 重写为主机网关域名，容器可达
                    host = "host.docker.internal" + (f":{u.port}" if u.port else "")
                    key = urlunparse(
                        (u.scheme, host, u.path, u.params, u.query, u.fragment)
                    )
                else:
                    # 直接外链下载并写入MinIO，保障后续内部访问
                    import urllib.request

                    with urllib.request.urlopen(key) as resp:
                        data = resp.read()
                    ext = ("." + fmt) if fmt else ""
                    new_key = make_object_key(user_id, f"ingested-{book_id}{ext}")
                    upload_bytes(
                        BOOKS_BUCKET, new_key, data, "application/octet-stream"
                    )
                    await conn.execute(
                        text(
                            "UPDATE books SET minio_key = :k, updated_at = now() WHERE id = cast(:id as uuid)"
                        ),
                        {"k": new_key, "id": book_id},
                    )
                    key = new_key
            except Exception:
                raise HTTPException(status_code=400, detail="ingest_failed")
        if isinstance(key, str) and key.startswith("http"):
            from urllib.parse import urlparse

            u = urlparse(key)
            # 解析 bucket 与 object key 并返回内部 presign GET，保证可访问
            path = u.path.lstrip("/")
            parts = path.split("/", 1)
            if len(parts) == 2:
                bkt, obj = parts[0], parts[1]
                url = presigned_get(bkt, obj)
                return {"status": "success", "data": {"get_url": url}}
            return {"status": "success", "data": {"get_url": key}}
        url = presigned_get(BOOKS_BUCKET, key)
    return {"status": "success", "data": {"get_url": url}}


@router.post("/{book_id}/set_converted")
async def set_converted(
    book_id: str, body: dict = Body(...), auth=Depends(require_user)
):
    user_id, _ = auth
    key = body.get("key")
    if not key:
        raise HTTPException(status_code=400, detail="missing_key")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        await conn.execute(
            text(
                "UPDATE books SET converted_epub_key = :k, updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"k": key, "id": book_id},
        )
    try:
        import json as _j

        await ws_broadcast(
            f"book:{book_id}", _j.dumps({"event": "STANDARDIZED", "epub_key": key})
        )
    except Exception:
        pass
    return {"status": "success"}


@router.get("")
async def list_books(
    limit: int = Query(20, ge=1, le=100),
    cursor: str | None = Query(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        # 排除已软删除的书籍
        cond = "WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL"
        order = "ORDER BY updated_at DESC, id DESC"
        params = {"limit": limit + 1}
        if cursor:
            try:
                ts_str, last_id = cursor.split("|", 1)
                cond += " AND (updated_at < cast(:ts as timestamptz) OR (updated_at = cast(:ts as timestamptz) AND id < cast(:id as uuid)))"
                params.update({"ts": ts_str, "id": last_id})
            except Exception:
                pass
        q = text(
            """
            SELECT b.id::text, b.title, b.author, b.language, b.original_format, b.minio_key, b.size, b.created_at, b.updated_at, b.version, COALESCE(b.is_digitalized,false), COALESCE(b.initial_digitalization_confidence,0), b.cover_image_key,
                   COALESCE(rp.progress, 0) as progress, rp.finished_at, b.converted_epub_key, b.ocr_status, b.conversion_status
            FROM books b
            LEFT JOIN reading_progress rp ON rp.book_id = b.id AND rp.user_id = current_setting('app.user_id')::uuid
            """
            + cond.replace("WHERE", "WHERE b.")
            + "\n"
            + order.replace("updated_at", "b.updated_at").replace("id", "b.id")
            + "\n"
            + "LIMIT :limit"
        )
        res = await conn.execute(q, params)
        rows = res.fetchall()
        take = rows[:limit]
        items = []

        def _hint(key: str, lang: str, size: int | None):
            try:
                head = read_head(BOOKS_BUCKET, key, 65536)
                if not head:
                    return None
                txt = None
                for enc in ("utf-8", "gb18030", "latin1"):
                    try:
                        txt = head.decode(enc, errors="ignore")
                        break
                    except Exception:
                        continue
                if not txt:
                    return None
                import re

                cjk = len(re.findall(r"[\u4e00-\u9fff]", txt))
                latin_words = len(re.findall(r"[A-Za-z]+", txt))
                if lang and lang.lower().startswith("zh"):
                    ratio = cjk / max(1, len(txt))
                    bpc = 2.0
                    est = int((ratio) * (size or 0) / bpc) if size else cjk
                    return f"约{est/10000.0:.1f}万字"
                else:
                    # 近似估算词数
                    return f"约{latin_words}词"
            except Exception:
                return None

        for r in take:
            # 优先使用转换后的 EPUB，否则使用原始 minio_key
            key_for_download = r[15] if r[15] else r[5]  # r[15] = converted_epub_key, r[5] = minio_key
            download = key_for_download
            if not (isinstance(download, str) and download.startswith("http")):
                download = presigned_get(BOOKS_BUCKET, key_for_download)
            hint = _hint(key_for_download, r[3] or "", r[6])
            # 生成封面 URL
            cover_url = None
            if r[12]:  # cover_image_key
                cover_url = presigned_get(BOOKS_BUCKET, r[12])
            
            # 判断是否为图片型 PDF
            # 方式1: is_digitalized=true 且 confidence < 0.8
            # 方式2: 有完成的 OCR 结果（ocr_status='completed'）也表示是图片型
            is_image_based = (bool(r[10]) and float(r[11]) < 0.8) or r[16] == 'completed'
            
            items.append(
                {
                    "id": r[0],
                    "title": r[1],
                    "author": r[2],
                    "language": r[3],
                    "original_format": r[4],
                    "size": r[6],
                    "created_at": str(r[7]),
                    "updated_at": str(r[8]),
                    "etag": f'W/"{int(r[9])}"',
                    "download_url": download,
                    "cover_url": cover_url,
                    "text_hint": hint,
                    "is_digitalized": bool(r[10]),
                    "initial_digitalization_confidence": float(r[11]),
                    "progress": float(r[13]) if r[13] else 0,  # 添加阅读进度
                    "finished_at": str(r[14]) if r[14] else None,  # 已读完时间
                    "ocr_status": r[16],  # OCR 状态: pending/processing/completed/failed/null
                    "is_image_based": is_image_based,
                    "conversion_status": r[17],  # 格式转换状态: pending/processing/completed/failed/null
                }
            )
        next_cursor = None
        if len(rows) > limit:
            last = take[-1]
            next_cursor = f"{last[8]}|{last[0]}"
        return {
            "status": "success",
            "data": {
                "items": items,
                "next_cursor": next_cursor,
                "has_more": len(rows) > limit,
            },
        }


@router.get("/{book_id}")
async def get_book(book_id: str, auth=Depends(require_user), response: Response = None):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        res = await conn.execute(
            text(
                """
            SELECT id::text, title, author, language, original_format, minio_key, size, created_at, updated_at, version,
                   COALESCE(is_digitalized,false), COALESCE(initial_digitalization_confidence,0), converted_epub_key, digitalize_report_key, cover_image_key,
                   COALESCE(metadata_confirmed, false), ocr_status, meta, deleted_at, user_id, conversion_status
            FROM books WHERE id = cast(:id as uuid)
            """
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        
        # 检查软删除状态：如果书籍已软删除且不属于当前用户，返回 404
        deleted_at = row[18]
        book_user_id = str(row[19])
        if deleted_at is not None and book_user_id != user_id:
            raise HTTPException(status_code=404, detail="not_found")
        
        if response is not None:
            response.headers["ETag"] = f'W/"{int(row[9])}"'
        # 优先使用转换后的 EPUB，否则使用原始 minio_key
        key_for_download = row[12] if row[12] else row[5]  # row[12] = converted_epub_key, row[5] = minio_key
        download = key_for_download
        if not (isinstance(download, str) and download.startswith("http")):
            download = presigned_get(BOOKS_BUCKET, key_for_download)
        hint = None
        try:
            head = read_head(BOOKS_BUCKET, key_for_download, 65536)
            if head:
                for enc in ("utf-8", "gb18030", "latin1"):
                    try:
                        txt = head.decode(enc, errors="ignore")
                        break
                    except Exception:
                        txt = None
                if txt:
                    import re

                    cjk = len(re.findall(r"[\u4e00-\u9fff]", txt))
                    latin_words = len(re.findall(r"[A-Za-z]+", txt))
                    if (row[3] or "").lower().startswith("zh"):
                        hint = f"约{cjk/10000.0:.1f}万字"
                    else:
                        hint = f"约{latin_words}词"
        except Exception:
            hint = None
        # 生成封面 URL
        cover_url = None
        if row[14]:  # cover_image_key
            cover_url = presigned_get(BOOKS_BUCKET, row[14])
        
        # 解析 meta 获取 page_count 和 metadata_extracted
        meta = row[17] or {}
        page_count = meta.get("page_count") if isinstance(meta, dict) else None
        metadata_extracted = meta.get("metadata_extracted", False) if isinstance(meta, dict) else False
        
        # 判断是否是图片型 PDF
        # 方式1: is_digitalized=true 且 confidence < 0.8
        # 方式2: 有完成的 OCR 结果（ocr_status='completed'）也表示是图片型
        is_image_based = (bool(row[10]) and float(row[11]) < 0.8) or row[16] == 'completed'
        
        return {
            "status": "success",
            "data": {
                "id": row[0],
                "title": row[1],
                "author": row[2],
                "language": row[3],
                "original_format": row[4],
                "size": row[6],
                "created_at": str(row[7]),
                "updated_at": str(row[8]),
                "etag": f'W/"{int(row[9])}"',
                "download_url": download,
                "cover_url": cover_url,
                "cover_image_key": row[14],
                "text_hint": hint,
                "is_digitalized": bool(row[10]),
                "initial_digitalization_confidence": float(row[11]),
                "converted_epub_key": row[12],
                "digitalize_report_key": row[13],
                "metadata_confirmed": bool(row[15]),
                "metadata_extracted": bool(metadata_extracted),
                "ocr_status": row[16],
                "page_count": page_count,
                "is_image_based": is_image_based,
                "conversion_status": row[20],  # 格式转换状态: pending/processing/completed/failed/null
            },
        }

@router.post("/register")
async def register_book(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    object_url = body.get("object_url")
    if not object_url or not isinstance(object_url, str):
        raise HTTPException(status_code=400, detail="invalid_object_url")
    title = body.get("title") or "Untitled"
    author = body.get("author") or ""
    language = body.get("language") or ""
    original_format = (body.get("original_format") or "").lower()
    size = body.get("size") or None
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        res = await conn.execute(
            text(
                "SELECT id::text FROM books WHERE user_id = current_setting('app.user_id')::uuid AND minio_key = :key"
            ),
            {"key": object_url},
        )
        row = res.fetchone()
        if row:
            return {
                "status": "success",
                "data": {"id": row[0], "download_url": object_url},
            }
        book_id = str(uuid.uuid4())
        img_based, conf = _quick_confidence(BOOKS_BUCKET, object_url)
        await conn.execute(
            text(
                """
            INSERT INTO books(id, user_id, title, author, language, original_format, minio_key, size, is_digitalized, initial_digitalization_confidence)
            VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt, :key, :size, :dig, :conf)
            """
            ),
            {
                "id": book_id,
                "uid": user_id,
                "title": title,
                "author": author,
                "language": language,
                "fmt": original_format,
                "key": object_url,
                "size": size,
                "dig": (conf >= 0.8),
                "conf": conf,
            },
        )
    index_book(book_id, user_id, title, author)
    return {"status": "success", "data": {"id": book_id, "download_url": object_url}}


@router.post("/{book_id}/deep_analyze")
async def deep_analyze(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        res = await conn.execute(
            text(
                "SELECT minio_key FROM books WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        key = row[0]
        img_based, conf = _quick_confidence(BOOKS_BUCKET, key)
        report = {"is_image_based": img_based, "confidence": conf}
        rep_key = make_object_key(user_id, f"digitalize-report-{book_id}.json")
        import json

        upload_bytes(
            BOOKS_BUCKET,
            rep_key,
            json.dumps(report).encode("utf-8"),
            "application/json",
        )
        await conn.execute(
            text(
                "UPDATE books SET is_digitalized = :dig, initial_digitalization_confidence = :conf, digitalize_report_key = :rk, updated_at = now() WHERE id = cast(:id as uuid)"
            ),
            {
                "dig": (not img_based and conf >= 0.8),
                "conf": conf,
                "rk": rep_key,
                "id": book_id,
            },
        )
        # 若未设置页数则补充占位
        await conn.execute(
            text(
                "UPDATE books SET meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', 1) WHERE id = cast(:id as uuid) AND (meta->>'page_count') IS NULL"
            ),
            {"id": book_id},
        )
    return {
        "status": "success",
        "data": {"is_digitalized": (not img_based and conf >= 0.8), "confidence": conf},
    }


@router.delete("/{book_id}")
async def delete_book(book_id: str, quota=Depends(require_write_permission), auth=Depends(require_user)):
    """
    删除书籍 - 分离公共信息和私人信息
    
    【私人信息】- 用户删除时立即物理删除：
    - 笔记 (notes) 和笔记标签 (note_tags)
    - 高亮 (highlights) 和高亮标签 (highlight_tags)
    - AI 对话 (ai_conversations, ai_messages, ai_conversation_contexts)
    - 阅读进度 (reading_progress)
    - 阅读会话 (reading_sessions)
    - 书架关联 (shelf_items)
    - 转换任务 (conversion_jobs)
    - OCR 任务 (ocr_jobs)
    
    【公共信息】- 只有最后一位用户删除时才物理删除：
    - 书籍文件 (MinIO)
    - 封面图片 (MinIO)
    - OCR 结果 (MinIO)
    - 数字化报告 (MinIO)
    - 向量索引 (OpenSearch)
    - 书籍记录 (books 表)
    
    删除策略：
    1. 如果是去重引用书籍：删除私人信息 + 删除书籍记录 + 减少原书引用计数
    2. 如果是原书且有引用：删除私人信息 + 软删除书籍记录（保留公共信息）
    3. 如果是原书无引用/最后一位用户：删除私人信息 + 物理删除所有公共信息
    """
    user_id, _ = auth
    try:
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            
            # 获取书籍信息
            res = await conn.execute(
                text("""
                    SELECT id, minio_key, cover_image_key, canonical_book_id, storage_ref_count,
                           ocr_result_key, digitalize_report_key, content_sha256
                    FROM books 
                    WHERE id = cast(:id as uuid) AND user_id = cast(:uid as uuid)
                """),
                {"id": book_id, "uid": user_id},
            )
            book = res.fetchone()
            if not book:
                raise HTTPException(status_code=404, detail="not_found")
            
            (_, minio_key, cover_key, canonical_book_id, storage_ref_count,
             ocr_result_key, digitalize_report_key, content_sha256) = book
            
            # 判断删除策略
            is_dedup_reference = canonical_book_id is not None
            # storage_ref_count 初始值为 1（代表原书自身），> 1 才表示有其他引用
            has_references = (storage_ref_count or 0) > 1
            
            # ========================================
            # 第一步：删除所有【私人信息】（任何情况都要删除）
            # ========================================
            
            # 1.1 删除书架关联
            await conn.execute(
                text("DELETE FROM shelf_items WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.2 删除笔记标签关联，然后删除笔记
            await conn.execute(
                text("DELETE FROM note_tags WHERE note_id IN (SELECT id FROM notes WHERE book_id = cast(:id as uuid))"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM notes WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.3 删除高亮标签关联，然后删除高亮
            await conn.execute(
                text("DELETE FROM highlight_tags WHERE highlight_id IN (SELECT id FROM highlights WHERE book_id = cast(:id as uuid))"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM highlights WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.4 删除 AI 对话上下文和消息
            await conn.execute(
                text("""
                    DELETE FROM ai_conversation_contexts 
                    WHERE book_ids @> to_jsonb(ARRAY[cast(:id as text)])::jsonb
                """),
                {"id": book_id},
            )
            await conn.execute(
                text("""
                    DELETE FROM ai_messages 
                    WHERE conversation_id NOT IN (SELECT conversation_id FROM ai_conversation_contexts)
                """),
            )
            await conn.execute(
                text("""
                    DELETE FROM ai_conversations 
                    WHERE id NOT IN (SELECT conversation_id FROM ai_conversation_contexts)
                """),
            )
            
            # 1.5 删除阅读进度和会话
            await conn.execute(
                text("DELETE FROM reading_progress WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM reading_sessions WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.6 删除转换任务和 OCR 任务
            await conn.execute(
                text("DELETE FROM conversion_jobs WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM ocr_jobs WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            print(f"[Delete Book] Deleted private data for {book_id}")
            
            # ========================================
            # 第二步：处理书籍记录和【公共信息】
            # ========================================
            
            if is_dedup_reference:
                # 情况1：这是一个去重引用
                # - 删除当前书籍记录
                # - 减少原书的引用计数
                # - 检查原书是否需要清理（软删除且无引用）
                
                # 获取原书信息
                res = await conn.execute(
                    text("""
                        SELECT storage_ref_count, deleted_at, minio_key, cover_image_key, 
                               ocr_result_key, digitalize_report_key, content_sha256
                        FROM books WHERE id = cast(:cid as uuid)
                    """),
                    {"cid": canonical_book_id},
                )
                canonical_info = res.fetchone()
                
                # 减少引用计数
                await conn.execute(
                    text("""
                        UPDATE books 
                        SET storage_ref_count = GREATEST(COALESCE(storage_ref_count, 1) - 1, 0)
                        WHERE id = cast(:cid as uuid)
                    """),
                    {"cid": canonical_book_id},
                )
                
                # 删除当前书籍记录
                await conn.execute(
                    text("DELETE FROM books WHERE id = cast(:id as uuid)"),
                    {"id": book_id},
                )
                print(f"[Delete Book] Deleted dedup reference {book_id}, decremented ref count of {canonical_book_id}")
                
                # 检查原书是否需要清理
                if canonical_info:
                    c_ref_count, c_deleted_at, c_minio_key, c_cover_key, c_ocr_key, c_report_key, c_sha256 = canonical_info
                    # 计算减少后的引用计数（原值 - 1，但不低于 0）
                    new_ref_count = max((c_ref_count or 1) - 1, 0)
                    
                    # 只有当原书已软删除且没有其他引用时才清理
                    # new_ref_count <= 1 表示只剩原书自己（或完全没有引用）
                    if c_deleted_at and new_ref_count <= 1:
                        # 原书已软删除且没有其他引用了，检查是否是最后一个使用此 SHA256 的书籍
                        other_count = 0
                        if c_sha256:
                            res = await conn.execute(
                                text("""
                                    SELECT COUNT(*) FROM books 
                                    WHERE content_sha256 = :sha AND id != cast(:cid as uuid)
                                """),
                                {"sha": c_sha256, "cid": canonical_book_id},
                            )
                            other_count = res.scalar() or 0
                        
                        if other_count == 0:
                            # 真正的最后一个引用，物理删除原书和所有公共信息
                            await conn.execute(
                                text("DELETE FROM books WHERE id = cast(:cid as uuid)"),
                                {"cid": canonical_book_id},
                            )
                            
                            # 删除 MinIO 文件
                            files_to_delete = [f for f in [c_minio_key, c_cover_key, c_ocr_key, c_report_key] if f]
                            for file_key in files_to_delete:
                                try:
                                    delete_object(BOOKS_BUCKET, file_key)
                                    print(f"[Delete Book] Cleaned up canonical MinIO file: {file_key}")
                                except Exception as e:
                                    print(f"[Delete Book] Failed to delete canonical file {file_key}: {e}")
                            
                            # 删除向量索引
                            delete_book_from_index(canonical_book_id)
                            print(f"[Delete Book] Cleaned up soft-deleted canonical {canonical_book_id} (no more references)")
                
            elif has_references:
                # 情况2：这是原书，但有其他用户引用
                # - 软删除书籍记录（设置 deleted_at）
                # - 不删除公共信息（MinIO 文件、向量索引）
                await conn.execute(
                    text("""
                        UPDATE books 
                        SET deleted_at = NOW(), updated_at = NOW()
                        WHERE id = cast(:id as uuid)
                    """),
                    {"id": book_id},
                )
                print(f"[Delete Book] Soft deleted {book_id} (has {storage_ref_count} references, public data preserved)")
                # 不删除向量索引，因为其他用户还在使用
                
            else:
                # 情况3：没有引用（最后一位用户删除）
                # - 检查是否有其他具有相同 SHA256 的书籍
                # - 如果没有，物理删除所有公共信息
                
                # 检查是否还有其他书籍使用相同的存储
                other_books_count = 0
                if content_sha256:
                    res = await conn.execute(
                        text("""
                            SELECT COUNT(*) FROM books 
                            WHERE content_sha256 = :sha AND id != cast(:id as uuid)
                        """),
                        {"sha": content_sha256, "id": book_id},
                    )
                    other_books_count = res.scalar() or 0
                
                # 删除书籍记录
                await conn.execute(
                    text("DELETE FROM books WHERE id = cast(:id as uuid)"),
                    {"id": book_id},
                )
                
                if other_books_count == 0:
                    # 真正的最后一位用户，物理删除所有公共信息
                    
                    # 删除 MinIO 文件
                    files_to_delete = [f for f in [minio_key, cover_key, ocr_result_key, digitalize_report_key] if f]
                    for file_key in files_to_delete:
                        try:
                            delete_object(BOOKS_BUCKET, file_key)
                            print(f"[Delete Book] Deleted MinIO file: {file_key}")
                        except Exception as e:
                            print(f"[Delete Book] Failed to delete MinIO file {file_key}: {e}")
                    
                    # 删除向量索引
                    delete_book_from_index(book_id)
                    print(f"[Delete Book] Fully deleted {book_id} (last user, all public data removed)")
                else:
                    print(f"[Delete Book] Deleted {book_id} but preserved public data ({other_books_count} other books share same SHA256)")
        
        return {"status": "success"}
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print(f"[Delete Book] Error: {e}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"delete_failed: {str(e)}")


@router.patch("/{book_id}/metadata")
async def update_book_metadata(
    book_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    auth=Depends(require_user),
):
    """
    用户确认或修改书籍的元数据（书名、作者）。
    
    Request Body:
    {
        "title"?: string,       // 书籍名称
        "author"?: string,      // 作者
        "confirmed": boolean    // 是否标记为已确认（即使不修改也可确认）
    }
    
    支持乐观锁（If-Match 头），防止并发冲突。
    更新成功后设置 metadata_confirmed=true, metadata_confirmed_at=now()
    """
    import hashlib
    
    user_id, _ = auth
    title = body.get("title")
    author = body.get("author")
    confirmed = body.get("confirmed", True)
    
    # 乐观锁检查（可选）
    current_version = None
    if if_match and if_match.startswith('W/"'):
        try:
            current_version = int(if_match.split('"')[1])
        except Exception:
            raise HTTPException(status_code=400, detail="invalid_if_match")
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 获取当前书籍信息
        res = await conn.execute(
            text("""
                SELECT id, title, author, version, metadata_confirmed
                FROM books WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        book_id_db, old_title, old_author, version, already_confirmed = row
        
        # 乐观锁版本检查
        if current_version is not None and version != current_version:
            raise HTTPException(
                status_code=409,
                detail={
                    "error": "version_conflict",
                    "message": "书籍信息已被其他设备修改，请刷新后重试",
                    "currentVersion": version
                }
            )
        
        # 计算新的元数据
        new_title = title if title is not None else old_title
        new_author = author if author is not None else old_author
        
        # 生成元数据版本指纹 (sha256 的前 16 位)
        metadata_str = f"{new_title}|{new_author or ''}"
        metadata_hash = hashlib.sha256(metadata_str.encode('utf-8')).hexdigest()[:16]
        metadata_version = f"sha256:{metadata_hash}"
        
        # 更新数据库
        if confirmed:
            update_res = await conn.execute(
                text("""
                    UPDATE books SET
                        title = COALESCE(:title, title),
                        author = COALESCE(:author, author),
                        metadata_confirmed = TRUE,
                        metadata_confirmed_at = now(),
                        version = version + 1,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                    RETURNING version
                """),
                {"title": title, "author": author, "id": book_id},
            )
        else:
            update_res = await conn.execute(
                text("""
                    UPDATE books SET
                        title = COALESCE(:title, title),
                        author = COALESCE(:author, author),
                        version = version + 1,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                    RETURNING version
                """),
                {"title": title, "author": author, "id": book_id},
            )
        
        new_version_row = update_res.fetchone()
        new_version = new_version_row[0] if new_version_row else version + 1
        
        # 获取更新后的完整信息
        final_res = await conn.execute(
            text("""
                SELECT id, title, author, metadata_confirmed, metadata_confirmed_at, version
                FROM books WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        final_row = final_res.fetchone()
    
    return {
        "id": str(final_row[0]),
        "title": final_row[1],
        "author": final_row[2],
        "metadataConfirmed": bool(final_row[3]),
        "metadataConfirmedAt": str(final_row[4]) if final_row[4] else None,
        "metadataVersion": metadata_version,
        "version": final_row[5]
    }


@router.patch("/{book_id}")
async def update_book(
    book_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    title = body.get("title")
    author = body.get("author")
    language = body.get("language")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            UPDATE books SET
              title = COALESCE(:title, title),
              author = COALESCE(:author, author),
              language = COALESCE(:language, language),
              version = version + 1,
              updated_at = now()
            WHERE id = cast(:id as uuid) AND version = :ver
            """
            ),
            {
                "title": title,
                "author": author,
                "language": language,
                "id": book_id,
                "ver": current_version,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


@router.get("/{book_id}/presign")
async def presign_book_download(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        return {
            "status": "success",
            "data": {"download_url": presigned_get(BOOKS_BUCKET, row[0])},
        }


@router.post("/{book_id}/convert")
async def request_convert(
    book_id: str, body: dict = Body(...), auth=Depends(require_user)
):
    user_id, _ = auth
    target_format = (body.get("target_format") or "epub").lower()
    job_id = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        source_key = row[0]
        await conn.execute(
            text(
                """
            INSERT INTO conversion_jobs(id, user_id, book_id, source_key, target_format, status)
            VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:bid as uuid), :src, :fmt, 'pending')
            """
            ),
            {
                "id": job_id,
                "uid": user_id,
                "bid": book_id,
                "src": source_key,
                "fmt": target_format,
            },
        )
    return {"status": "success", "data": {"job_id": job_id, "status": "pending"}}


@router.get("/jobs/list")
async def list_jobs(status: str | None = Query(None), auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        if status:
            res = await conn.execute(
                text(
                    "SELECT id::text, book_id::text, target_format, status, created_at FROM conversion_jobs WHERE user_id = current_setting('app.user_id')::uuid AND status = :st ORDER BY created_at DESC"
                ),
                {"st": status},
            )
        else:
            res = await conn.execute(
                text(
                    "SELECT id::text, book_id::text, target_format, status, created_at FROM conversion_jobs WHERE user_id = current_setting('app.user_id')::uuid ORDER BY created_at DESC"
                )
            )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "book_id": r[1],
                    "target_format": r[2],
                    "status": r[3],
                    "created_at": str(r[4]),
                }
                for r in rows
            ],
        }


@router.post("/jobs/{job_id}/complete")
async def complete_job(
    job_id: str, body: dict = Body(None), auth=Depends(require_user)
):
    user_id, _ = auth
    output_key = (body or {}).get("output_key") or ""
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE conversion_jobs SET status='completed', output_key = COALESCE(:out, output_key), updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id, "out": output_key},
        )
    return {"status": "success"}


@router.post("/jobs/{job_id}/fail")
async def fail_job(job_id: str, body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    message = body.get("error") or ""
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE conversion_jobs SET status='failed', error = :msg, updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id, "msg": message},
        )
    return {"status": "success"}


@router.post("/jobs/{job_id}/simulate")
async def simulate_job(job_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT book_id::text FROM conversion_jobs WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        book_id = row[0]
        out_key = f"converted/{book_id}.epub"
        upload_bytes(
            BOOKS_BUCKET, out_key, b"converted content", "application/epub+zip"
        )
        res2 = await conn.execute(
            text(
                "SELECT price_amount, unit_size, currency FROM pricing_rules WHERE service_type = 'VECTORIZE' AND unit_type = 'CHARS' AND is_active = TRUE ORDER BY updated_at DESC LIMIT 1"
            )
        )
        rule = res2.fetchone()
        if rule:
            import math

            qty = 100000
            max(1, math.ceil(qty / int(rule[1])))
            sres = await conn.execute(
                text("SELECT key, value FROM system_settings WHERE key LIKE 'free_%'")
            )
            settings = {r[0]: r[1] for r in sres.fetchall()}
            mtres = await conn.execute(
                text(
                    "SELECT membership_tier FROM users WHERE id = current_setting('app.user_id')::uuid"
                )
            )
            mtrow = mtres.fetchone()
            tier = (mtrow and mtrow[0]) or "FREE"
            tres = await conn.execute(
                text("SELECT value FROM system_settings WHERE key = 'membership_tiers'")
            )
            trow = tres.fetchone()
            mconf = trow and trow[0]
            free_chars = None
            if isinstance(mconf, dict) and tier in mconf:
                try:
                    free_chars = int((mconf[tier] or {}).get("free_vector_chars") or 0)
                except Exception:
                    free_chars = 0
            if free_chars is None:
                free_chars = int(settings.get("free_vector_chars", 0))

            ures = await conn.execute(
                text(
                    "SELECT used_units FROM free_quota_usage WHERE owner_id = current_setting('app.user_id')::uuid AND service_type = 'VECTORIZE' AND period_start = current_date"
                )
            )
            urow = ures.fetchone()
            used = int(urow[0]) if urow else 0
            remain = max(0, free_chars - used)
            payable_chars = max(0, qty - remain)
            if remain > 0:
                await conn.execute(
                    text(
                        "INSERT INTO free_quota_usage(owner_id, service_type, used_units) VALUES (current_setting('app.user_id')::uuid, 'VECTORIZE', :u) ON CONFLICT (owner_id, service_type, period_start) DO UPDATE SET used_units = free_quota_usage.used_units + EXCLUDED.used_units"
                    ),
                    {"u": min(qty, remain)},
                )
            if payable_chars > 0:
                units_pay = max(1, math.ceil(payable_chars / int(rule[1])))
                amt = int(round(float(rule[0]) * 100)) * units_pay
                await conn.execute(
                    text(
                        "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
                    )
                )
                bal = await conn.execute(
                    text(
                        "SELECT balance FROM credit_accounts WHERE owner_id = current_setting('app.user_id')::uuid"
                    )
                )
                b = bal.fetchone()
                if not b or int(b[0]) < amt:
                    await conn.execute(
                        text(
                            "UPDATE conversion_jobs SET status='failed', updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
                        ),
                        {"id": job_id},
                    )
                    raise HTTPException(status_code=400, detail="insufficient_balance")
                await conn.execute(
                    text(
                        "UPDATE credit_accounts SET balance = balance - :amt, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                    ),
                    {"amt": amt},
                )
                lid = str(uuid.uuid4())
                await conn.execute(
                    text(
                        "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, related_id, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, :cur, 'vectorize', cast(:rid as uuid), 'debit')"
                    ),
                    {"id": lid, "amt": amt, "cur": rule[2], "rid": job_id},
                )
        await conn.execute(
            text(
                "UPDATE conversion_jobs SET status='completed', output_key = :out, updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id, "out": out_key},
        )
    return {"status": "success", "data": {"output_key": out_key}}


@shelves_router.post("")
async def create_shelf(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    name = body.get("name")
    if not name:
        raise HTTPException(status_code=400, detail="missing_name")
    description = body.get("description") or ""
    if idempotency_key:
        idem_key = f"idem:shelves:create:{user_id}:{idempotency_key}"
        cached = r.get(idem_key)
        if cached:
            return {"status": "success", "data": {"id": cached}}
    shelf_id = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO shelves(id, user_id, name, description) VALUES (cast(:id as uuid), cast(:uid as uuid), :name, :desc)"
            ),
            {"id": shelf_id, "uid": user_id, "name": name, "desc": description},
        )
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, shelf_id)
    return {"status": "success", "data": {"id": shelf_id}}


@shelves_router.get("")
async def list_shelves(
    limit: int = Query(20, ge=1, le=100),
    cursor: str | None = Query(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        cond = "WHERE user_id = current_setting('app.user_id')::uuid"
        order = "ORDER BY updated_at DESC, id DESC"
        params = {"limit": limit + 1}
        if cursor:
            try:
                ts_str, last_id = cursor.split("|", 1)
                cond += " AND (updated_at < cast(:ts as timestamptz) OR (updated_at = cast(:ts as timestamptz) AND id < cast(:id as uuid)))"
                params.update({"ts": ts_str, "id": last_id})
            except Exception:
                pass
        q = text(
            """
            SELECT id::text, name, description, updated_at, version
            FROM shelves
            """
            + cond
            + "\n"
            + order
            + "\n"
            + "LIMIT :limit"
        )
        res = await conn.execute(q, params)
        rows = res.fetchall()
        take = rows[:limit]
        items = [
            {
                "id": r[0],
                "name": r[1],
                "description": r[2],
                "updated_at": str(r[3]),
                "etag": f'W/"{int(r[4])}"',
            }
            for r in take
        ]
        next_cursor = None
        if len(rows) > limit:
            last = take[-1]
            next_cursor = f"{last[3]}|{last[0]}"
        return {
            "status": "success",
            "data": {
                "items": items,
                "next_cursor": next_cursor,
                "has_more": len(rows) > limit,
            },
        }


@shelves_router.patch("/{shelf_id}")
async def update_shelf(
    shelf_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    name = body.get("name")
    description = body.get("description")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            UPDATE shelves SET
              name = COALESCE(:name, name),
              description = COALESCE(:desc, description),
              version = version + 1,
              updated_at = now()
            WHERE id = cast(:id as uuid) AND version = :ver
            """
            ),
            {"name": name, "desc": description, "id": shelf_id, "ver": current_version},
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


@shelves_router.delete("/{shelf_id}")
async def delete_shelf(
    shelf_id: str,
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    """删除书架（同时删除书架内的关联关系）"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        # 先删除书架内的书籍关联
        await conn.execute(
            text(
                """
            DELETE FROM shelf_items 
            WHERE shelf_id = cast(:sid as uuid)
              AND shelf_id IN (SELECT id FROM shelves WHERE user_id = current_setting('app.user_id')::uuid)
            """
            ),
            {"sid": shelf_id},
        )
        # 再删除书架本身
        res = await conn.execute(
            text(
                """
            DELETE FROM shelves 
            WHERE id = cast(:sid as uuid) 
              AND user_id = current_setting('app.user_id')::uuid
            """
            ),
            {"sid": shelf_id},
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=404, detail="shelf_not_found")
    return {"status": "success"}


@shelves_router.post("/{shelf_id}/items")
async def add_item(
    shelf_id: str,
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    book_id = body.get("book_id")
    if not book_id:
        raise HTTPException(status_code=400, detail="missing_book_id")
    if idempotency_key:
        idem_key = (
            f"idem:shelves:add_item:{user_id}:{shelf_id}:{book_id}:{idempotency_key}"
        )
        if r.get(idem_key):
            return {"status": "success"}
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO shelf_items(shelf_id, book_id) VALUES (cast(:sid as uuid), cast(:bid as uuid)) ON CONFLICT DO NOTHING"
            ),
            {"sid": shelf_id, "bid": book_id},
        )
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, "1")
    return {"status": "success"}


@shelves_router.get("/{shelf_id}/items")
async def list_items(shelf_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            SELECT b.id::text, b.title, b.author, b.language, b.minio_key
            FROM shelf_items si
            JOIN books b ON b.id = si.book_id
            WHERE si.shelf_id = cast(:sid as uuid)
            ORDER BY b.updated_at DESC
            """
            ),
            {"sid": shelf_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "title": r[1],
                    "author": r[2],
                    "language": r[3],
                    "download_url": presigned_get(BOOKS_BUCKET, r[4]),
                }
                for r in rows
            ],
        }


@shelves_router.delete("/{shelf_id}/items/{book_id}")
async def remove_item(
    shelf_id: str,
    book_id: str,
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if idempotency_key:
        idem_key = (
            f"idem:shelves:remove_item:{user_id}:{shelf_id}:{book_id}:{idempotency_key}"
        )
        if r.get(idem_key):
            return {"status": "success"}
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "DELETE FROM shelf_items WHERE shelf_id = cast(:sid as uuid) AND book_id = cast(:bid as uuid)"
            ),
            {"sid": shelf_id, "bid": book_id},
        )
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, "1")
    return {"status": "success"}


@router.post("/upload_proxy")
async def upload_proxy(
    title: str | None = None,
    file: UploadFile = File(...),
    quota=Depends(require_upload_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    name = file.filename or "upload.bin"
    fmt = (name.split(".")[-1] or "bin").lower()
    key = make_object_key(user_id, name)
    content = await file.read()
    from .storage import upload_bytes

    upload_bytes(
        os.getenv("MINIO_BUCKET", "athena"),
        key,
        content,
        file.content_type or "application/octet-stream",
    )
    # 轻量置信度
    img_based, conf = _quick_confidence(os.getenv("MINIO_BUCKET", "athena"), key)
    etag = stat_etag(os.getenv("MINIO_BUCKET", "athena"), key)
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await _ensure_books_fields(conn)
        if etag:
            res = await conn.execute(
                text(
                    "SELECT id::text FROM books WHERE user_id = current_setting('app.user_id')::uuid AND source_etag = :e"
                ),
                {"e": etag},
            )
            row = res.fetchone()
            if row:
                download_url = presigned_get(os.getenv("MINIO_BUCKET", "athena"), key)
                return {
                    "status": "success",
                    "data": {"id": row[0], "download_url": download_url},
                }
        book_id = str(uuid.uuid4())
        await conn.execute(
            text(
                """
            INSERT INTO books(id, user_id, title, original_format, minio_key, is_digitalized, initial_digitalization_confidence, source_etag)
            VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :t, :f, :k, :dig, :conf, :etag)
            """
            ),
            {
                "id": book_id,
                "t": title or name.replace(f".{fmt}", ""),
                "k": key,
                "f": fmt,
                "dig": (conf >= 0.8),
                "conf": conf,
                "etag": etag,
            },
        )
    download_url = presigned_get(os.getenv("MINIO_BUCKET", "athena"), key)
    return {"status": "success", "data": {"id": book_id, "download_url": download_url}}


==================================================
FILE_PATH: api/app/tracing.py
==================================================

import os
import time

from fastapi import Request
from jaeger_client import Config
from opentracing import Tracer

_tracer: Tracer | None = None


def init_tracer():
    global _tracer
    if _tracer is not None:
        return
    host = os.getenv("JAEGER_HOST", "jaeger")
    service = os.getenv("SERVICE_NAME", "athena-api")
    cfg = Config(
        config={
            "sampler": {"type": "const", "param": 1},
            "local_agent": {"reporting_host": host, "reporting_port": 6831},
            "logging": False,
        },
        service_name=service,
    )
    _tracer = cfg.initialize_tracer()


async def tracer_middleware(request: Request, call_next):
    if _tracer is None:
        return await call_next(request)
    name = f"HTTP {request.method} {request.url.path}"
    span = _tracer.start_span(name)
    span.set_tag("http.method", request.method)
    span.set_tag("http.url", str(request.url))
    start = time.time()
    try:
        response = await call_next(request)
        span.set_tag("http.status_code", response.status_code)
        return response
    finally:
        span.log_kv({"duration_ms": int((time.time() - start) * 1000)})
        span.finish()


==================================================
FILE_PATH: api/app/pricing.py
==================================================

"""
定价规则与管理员接口

职责：
- `/pricing/rules`：按服务类型/区域过滤返回有效定价规则与备注模板渲染结果
- 管理员 `/admin/pricing/*`：列出/创建/更新/禁用定价规则（支持平台与 SKU 字段）

说明：
- 仅新增注释，不改动查询与更新逻辑
"""
import os
import uuid

from fastapi import APIRouter, Body, Depends, Query
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/pricing", tags=["pricing"])


async def _ensure(conn):
    return


@router.get("/rules")
async def list_rules(
    service_type: str | None = Query(None), region: str | None = Query(None)
):
    async with engine.begin() as conn:
        await _ensure(conn)
        base = "SELECT id::text, service_type, unit_type, unit_size, price_amount, currency, region, remark_template FROM pricing_rules WHERE is_active = TRUE"
        params = {}
        if service_type:
            base += " AND service_type = :st"
            params["st"] = service_type
        if region:
            base += " AND (region IS NULL OR region = :rg)"
            params["rg"] = region
        base += " ORDER BY updated_at DESC"
        res = await conn.execute(text(base), params)
        rows = res.fetchall()
        data = []
        for r in rows:
            approx_tokens = int((r[3] or 0) * 1.5)
            remark = (
                (r[7] or "")
                .replace("{unit_size}", str(r[3]))
                .replace("{price_amount}", str(r[4]))
                .replace("{currency}", r[5])
                .replace("{approx_tokens}", str(approx_tokens))
            )
            data.append(
                {
                    "id": r[0],
                    "service_type": r[1],
                    "unit_type": r[2],
                    "unit_size": r[3],
                    "price_amount": float(r[4]),
                    "currency": r[5],
                    "region": r[6],
                    "remark": remark,
                }
            )
        return {"status": "success", "data": data}


admin = APIRouter(prefix="/api/v1/admin/pricing", tags=["admin-pricing"])


def _require_admin(user_id: str):
    aid = os.getenv("ADMIN_USER_ID", "")
    if not aid or aid != user_id:
        from fastapi import HTTPException

        raise HTTPException(status_code=403, detail="forbidden")


@admin.get("/rules")
async def admin_list(auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text(
                "SELECT id::text, service_type, unit_type, unit_size, price_amount, currency, region, remark_template, platform, sku_id, is_active, version, updated_at FROM pricing_rules ORDER BY updated_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "service_type": r[1],
                    "unit_type": r[2],
                    "unit_size": r[3],
                    "price_amount": float(r[4]),
                    "currency": r[5],
                    "region": r[6],
                    "remark_template": r[7],
                    "platform": r[8],
                    "sku_id": r[9],
                    "is_active": bool(r[10]),
                    "version": int(r[11]),
                    "updated_at": str(r[12]),
                }
                for r in rows
            ],
        }


@admin.post("/rules")
async def admin_create(body: dict = Body(...), auth=Depends(require_user)):
    _require_admin(auth[0])
    rid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await _ensure(conn)
        await conn.execute(
            text(
                "INSERT INTO pricing_rules(id, service_type, unit_type, unit_size, price_amount, currency, region, remark_template, platform, sku_id, is_active) VALUES (cast(:id as uuid), :st, :ut, :us, :pa, :cur, :rg, :rt, COALESCE(:pf, 'web'), :sku, COALESCE(:ia, TRUE))"
            ),
            {
                "id": rid,
                "st": body.get("service_type"),
                "ut": body.get("unit_type"),
                "us": int(body.get("unit_size")),
                "pa": float(body.get("price_amount")),
                "cur": body.get("currency"),
                "rg": body.get("region"),
                "rt": body.get("remark_template"),
                "pf": body.get("platform"),
                "sku": body.get("sku_id"),
                "ia": body.get("is_active"),
            },
        )
    return {"status": "success", "data": {"id": rid}}


@admin.patch("/rules/{rule_id}")
async def admin_update(
    rule_id: str,
    body: dict = Body(...),
    if_match: str | None = Query(None),
    auth=Depends(require_user),
):
    _require_admin(auth[0])
    sets = []
    params = {"id": rule_id}
    ver = None
    if if_match and if_match.startswith('W/"') and if_match.endswith('"'):
        try:
            ver = int(if_match[3:-1])
        except Exception:
            ver = None
    for k in [
        "service_type",
        "unit_type",
        "unit_size",
        "price_amount",
        "currency",
        "region",
        "remark_template",
        "platform",
        "sku_id",
        "is_active",
    ]:
        if k in body:
            sets.append(f"{k} = :{k}")
            params[k] = body[k]
    if not sets:
        return {"status": "success"}
    async with engine.begin() as conn:
        await _ensure(conn)
        if ver is not None:
            res = await conn.execute(
                text("SELECT version FROM pricing_rules WHERE id = cast(:id as uuid)"),
                {"id": rule_id},
            )
            row = res.fetchone()
            if not row or int(row[0]) != ver:
                from fastapi import HTTPException

                raise HTTPException(status_code=412, detail="etag_mismatch")
        q = (
            "UPDATE pricing_rules SET "
            + ", ".join(sets)
            + ", version = version + 1, updated_at = now() WHERE id = cast(:id as uuid)"
        )
        await conn.execute(text(q), params)
    return {"status": "success"}


@admin.delete("/rules/{rule_id}")
async def admin_delete(rule_id: str, auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        await conn.execute(
            text(
                "UPDATE pricing_rules SET is_active = FALSE, updated_at = now() WHERE id = cast(:id as uuid)"
            ),
            {"id": rule_id},
        )
    return {"status": "success"}


==================================================
FILE_PATH: api/app/tasks.py
==================================================

import json
import os
import io
import tempfile
import zipfile

from celery import shared_task
from sqlalchemy import text
from sqlalchemy import text as _text

from .db import engine
from .services import get_ocr
from .storage import make_object_key, read_head, read_full, upload_bytes, get_s3, ensure_bucket, presigned_get
from .ws import broadcast as ws_broadcast

BUCKET = os.getenv("MINIO_BUCKET", "athena")


def _quick_confidence(key: str) -> tuple[bool, float]:
    """Quick heuristic to guess whether a file is image based."""
    try:
        head = None
        if isinstance(key, str) and key.startswith("http"):
            import urllib.request

            with urllib.request.urlopen(key) as resp:
                head = resp.read(65536)
        else:
            head = read_head(BUCKET, key, 65536)
        if not head:
            return (False, 0.0)
        txt = None
        for enc in ("utf-8", "gb18030", "latin1"):
            try:
                txt = head.decode(enc, errors="ignore")
                break
            except Exception:
                continue
        if not txt:
            return (False, 0.0)
        import re

        cjk = len(re.findall(r"[\u4e00-\u9fff]", txt))
        latin = len(re.findall(r"[A-Za-z]", txt))
        total = max(1, len(txt))
        ratio = (cjk + latin) / total
        is_image_based = ratio < 0.02
        conf = max(0.0, min(1.0, ratio * 5.0))
        return (is_image_based, conf)
    except Exception:
        return (False, 0.0)


def _optimize_cover_image(image_data: bytes, max_width: int = 400, quality: int = 80) -> tuple[bytes, str]:
    """Convert a cover image to a normalized WebP rendition."""
    try:
        from PIL import Image

        img = Image.open(io.BytesIO(image_data))

        if img.mode in ("RGBA", "LA", "P"):
            img = img.convert("RGBA")
        elif img.mode != "RGB":
            img = img.convert("RGB")

        target_width = max_width
        target_height = int(max_width * 1.5)  # 2:3 ratio
        img_ratio = img.width / img.height
        target_ratio = target_width / target_height

        if img_ratio > target_ratio:
            new_width = int(img.height * target_ratio)
            left = (img.width - new_width) // 2
            img = img.crop((left, 0, left + new_width, img.height))
        elif img_ratio < target_ratio:
            new_height = int(img.width / target_ratio)
            top = (img.height - new_height) // 2
            img = img.crop((0, top, img.width, top + new_height))

        resample = getattr(Image, "Resampling", Image).LANCZOS
        img = img.resize((target_width, target_height), resample)

        output = io.BytesIO()
        img.save(output, format="WEBP", quality=quality, lossless=False)
        webp_data = output.getvalue()
        print(f"[Cover] Optimized: {len(image_data)} -> {len(webp_data)} bytes (400x600 WebP)")
        return webp_data, "image/webp"
    except Exception as e:
        print(f"[Cover] Failed to optimize image, using original: {e}")
        if image_data[:8].startswith(b"\x89PNG"):
            return image_data, "image/png"
        return image_data, "image/jpeg"


def _extract_epub_metadata(epub_data: bytes) -> dict:
    """Extract title/author information from an EPUB file."""
    metadata = {"title": None, "author": None}
    try:
        with zipfile.ZipFile(io.BytesIO(epub_data)) as zf:
            opf_path = None
            for name in zf.namelist():
                if name.endswith(".opf"):
                    opf_path = name
                    break

            if opf_path:
                import re

                opf_content = zf.read(opf_path).decode("utf-8", errors="ignore")
                title_match = re.search(r"<dc:title[^>]*>([^<]+)</dc:title>", opf_content, re.IGNORECASE)
                if title_match:
                    metadata["title"] = title_match.group(1).strip()

                author_match = re.search(r"<dc:creator[^>]*>([^<]+)</dc:creator>", opf_content, re.IGNORECASE)
                if author_match:
                    metadata["author"] = author_match.group(1).strip()

                print(f"[Metadata] EPUB metadata extracted: title={metadata['title']}, author={metadata['author']}")
    except Exception as e:
        print(f"[Metadata] Failed to extract EPUB metadata: {e}")
    return metadata


def _extract_pdf_metadata(pdf_data: bytes) -> dict:
    """Extract metadata (title, author, page count) and a quick digitalization score."""
    metadata = {"title": None, "author": None, "page_count": None, "is_image_based": False, "digitalization_confidence": 1.0}
    try:
        import fitz  # PyMuPDF

        doc = fitz.open(stream=pdf_data, filetype="pdf")
        pdf_meta = doc.metadata
        if pdf_meta:
            if pdf_meta.get("title"):
                metadata["title"] = pdf_meta["title"].strip()
            if pdf_meta.get("author"):
                metadata["author"] = pdf_meta["author"].strip()

        page_count = len(doc)
        metadata["page_count"] = page_count

        sample_pages = min(5, page_count)
        total_text_chars = 0
        total_cjk_chars = 0

        import re

        for i in range(sample_pages):
            page = doc[i]
            text = page.get_text("text")
            if text:
                clean_text = text.strip()
                total_text_chars += len(clean_text)
                total_cjk_chars += len(re.findall(r"[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]", clean_text))

        avg_chars_per_page = total_text_chars / sample_pages if sample_pages > 0 else 0

        if avg_chars_per_page < 50:
            metadata["is_image_based"] = True
            metadata["digitalization_confidence"] = 0.1
            print(f"[Metadata] PDF detected as IMAGE-BASED: avg {avg_chars_per_page:.1f} chars/page (threshold: 50)")
        elif avg_chars_per_page < 200:
            metadata["is_image_based"] = True
            metadata["digitalization_confidence"] = 0.3
            print(f"[Metadata] PDF detected as PARTIALLY IMAGE-BASED: avg {avg_chars_per_page:.1f} chars/page")
        else:
            metadata["is_image_based"] = False
            metadata["digitalization_confidence"] = min(1.0, avg_chars_per_page / 500)
            print(f"[Metadata] PDF detected as DIGITAL: avg {avg_chars_per_page:.1f} chars/page")

        doc.close()
        print(
            f"[Metadata] PDF metadata extracted: title={metadata['title']}, author={metadata['author']}, pages={page_count}, is_image_based={metadata['is_image_based']}"
        )
    except Exception as e:
        print(f"[Metadata] Failed to extract PDF metadata: {e}")
    return metadata


def _extract_epub_cover(epub_data: bytes) -> bytes | None:
    """从 EPUB 文件中提取封面图片"""
    try:
        with zipfile.ZipFile(io.BytesIO(epub_data)) as zf:
            # 尝试从 OPF 文件中找到封面
            opf_path = None
            for name in zf.namelist():
                if name.endswith('.opf'):
                    opf_path = name
                    break
            
            if opf_path:
                opf_content = zf.read(opf_path).decode('utf-8', errors='ignore')
                
                # 查找封面图片引用
                import re
                # 查找 cover-image 或 cover 的引用
                cover_patterns = [
                    r'<item[^>]*id\s*=\s*["\']cover["\'][^>]*href\s*=\s*["\']([^"\']+)["\']',
                    r'<item[^>]*href\s*=\s*["\']([^"\']+)["\'][^>]*id\s*=\s*["\']cover["\']',
                    r'<item[^>]*properties\s*=\s*["\']cover-image["\'][^>]*href\s*=\s*["\']([^"\']+)["\']',
                    r'<item[^>]*href\s*=\s*["\']([^"\']+)["\'][^>]*properties\s*=\s*["\']cover-image["\']',
                ]
                
                for pattern in cover_patterns:
                    match = re.search(pattern, opf_content, re.IGNORECASE)
                    if match:
                        cover_href = match.group(1)
                        # 构建完整路径
                        opf_dir = os.path.dirname(opf_path)
                        if opf_dir:
                            cover_path = f"{opf_dir}/{cover_href}"
                        else:
                            cover_path = cover_href
                        
                        # 尝试读取封面
                        for name in zf.namelist():
                            if name.endswith(cover_href) or name == cover_path:
                                return zf.read(name)
            
            # 后备方案：查找常见的封面文件名
            cover_names = ['cover.jpg', 'cover.jpeg', 'cover.png', 'Cover.jpg', 'Cover.jpeg', 'Cover.png']
            for name in zf.namelist():
                for cover_name in cover_names:
                    if name.endswith(cover_name):
                        return zf.read(name)
            
            # 最后方案：找第一个图片文件
            for name in zf.namelist():
                lower = name.lower()
                if lower.endswith(('.jpg', '.jpeg', '.png')) and 'cover' in lower:
                    return zf.read(name)
                    
    except Exception as e:
        print(f"[Cover] Failed to extract EPUB cover: {e}")
    return None


def _extract_pdf_cover(pdf_data: bytes) -> bytes | None:
    """从 PDF 文件中提取第一页作为封面"""
    try:
        import fitz  # PyMuPDF
        
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        if len(doc) > 0:
            page = doc[0]
            # 渲染第一页为图片
            pix = page.get_pixmap(matrix=fitz.Matrix(2, 2))  # 2x 缩放以获得更好的质量
            img_data = pix.tobytes("jpeg")
            doc.close()
            return img_data
    except Exception as e:
        print(f"[Cover] Failed to extract PDF cover: {e}")
    return None


# Calibre 容器地址（Docker 内部网络）
CALIBRE_HOST = os.getenv("CALIBRE_HOST", "calibre")
CALIBRE_BOOKS_DIR = os.getenv("CALIBRE_CONVERT_DIR", "/calibre_books")


@shared_task(name="tasks.extract_ebook_metadata_calibre")
def extract_ebook_metadata_calibre(book_id: str, user_id: str):
    """
    使用 Calibre ebook-meta 命令即时提取电子书的元数据和封面。
    
    支持所有格式：PDF, EPUB, MOBI, AZW3, FB2 等 20+ 格式。
    
    对于 PDF：
    - 提取元数据和封面
    - 额外检测是否为图片型 PDF（需要 OCR）
    
    通过共享卷与 calibre-metadata 容器交互：
    1. Worker 将电子书写入共享卷
    2. Worker 创建 .metadata.request 请求文件
    3. calibre-metadata 容器执行 ebook-meta
    4. Worker 轮询等待 .done 文件
    """
    import asyncio
    import time
    import re
    import uuid as _uuid
    
    async def _run():
        # 获取书籍信息
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, author FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[CalibreMeta] Book not found: {book_id}")
                return
            
            minio_key, original_format, current_title, current_author = row[0], row[1], row[2], row[3]
            fmt_lower = (original_format or '').lower()
            
            print(f"[CalibreMeta] Extracting metadata for {book_id} (format: {fmt_lower})")
        
        # 下载文件到共享卷
        job_id = str(_uuid.uuid4())[:8]
        input_filename = f"meta-{job_id}.{fmt_lower}"
        cover_filename = f"cover-{job_id}.jpg"
        
        # Worker 容器中的路径 (/calibre_books) 和 Calibre 容器中的路径 (/books) 不同
        worker_input_path = os.path.join(CALIBRE_BOOKS_DIR, input_filename)
        worker_cover_path = os.path.join(CALIBRE_BOOKS_DIR, cover_filename)
        worker_metadata_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.txt")
        worker_request_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.metadata.request")
        worker_done_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.done")
        worker_error_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.error")
        
        # Calibre 容器中的路径
        calibre_input_path = f"/books/{input_filename}"
        calibre_cover_path = f"/books/{cover_filename}"
        
        # 用于存储下载的文件数据（PDF 需要额外分析）
        book_data = None
        
        try:
            # 从 S3 下载文件
            client = get_s3()
            ensure_bucket(client, BUCKET)
            resp = client.get_object(Bucket=BUCKET, Key=minio_key)
            book_data = resp["Body"].read()
            
            os.makedirs(CALIBRE_BOOKS_DIR, exist_ok=True)
            with open(worker_input_path, 'wb') as f:
                f.write(book_data)
            print(f"[CalibreMeta] Downloaded {len(book_data)} bytes to {worker_input_path}")
            
            # 创建元数据提取请求文件
            with open(worker_request_path, 'w') as f:
                f.write(f"{calibre_input_path}\n{calibre_cover_path}\n")
            print(f"[CalibreMeta] Created request file: {worker_request_path}")
            
            # 轮询等待完成（最多等待 60 秒，PDF 可能较慢）
            max_wait = 60
            wait_interval = 0.5
            waited = 0
            
            while waited < max_wait:
                if os.path.exists(worker_done_path):
                    print(f"[CalibreMeta] Metadata extraction completed!")
                    break
                if os.path.exists(worker_error_path):
                    with open(worker_error_path, 'r') as f:
                        error_msg = f.read()
                    print(f"[CalibreMeta] Extraction failed: {error_msg}")
                    # 清理文件
                    for p in [worker_request_path, worker_error_path, worker_input_path]:
                        try:
                            if os.path.exists(p):
                                os.remove(p)
                        except:
                            pass
                    return
                
                time.sleep(wait_interval)
                waited += wait_interval
            
            if waited >= max_wait:
                print(f"[CalibreMeta] Timeout waiting for metadata extraction")
                # 继续处理，可能部分成功
            
            # 解析元数据输出
            metadata = {"title": None, "author": None, "page_count": None}
            if os.path.exists(worker_metadata_path):
                with open(worker_metadata_path, 'r', encoding='utf-8', errors='ignore') as f:
                    output = f.read()
                print(f"[CalibreMeta] ebook-meta output:\n{output}")
                
                # 解析元数据
                title_match = re.search(r'^Title\s*:\s*(.+)$', output, re.MULTILINE)
                if title_match:
                    metadata["title"] = title_match.group(1).strip()
                
                author_match = re.search(r'^Author\(s\)\s*:\s*(.+)$', output, re.MULTILINE)
                if author_match:
                    author_str = author_match.group(1).strip()
                    # 移除排序名称部分 [xxx]
                    author_str = re.sub(r'\s*\[.*?\]', '', author_str)
                    metadata["author"] = author_str.strip()
                
                # 尝试提取页数
                pages_match = re.search(r'^Pages?\s*:\s*(\d+)', output, re.MULTILINE | re.IGNORECASE)
                if pages_match:
                    metadata["page_count"] = int(pages_match.group(1))
            
            # 读取封面
            cover_key = None
            if os.path.exists(worker_cover_path):
                with open(worker_cover_path, 'rb') as f:
                    cover_data = f.read()
                
                if cover_data and len(cover_data) > 1000:  # 至少 1KB
                    # 优化封面
                    optimized_data, content_type = _optimize_cover_image(cover_data, max_width=400, quality=80)
                    cover_key = make_object_key(user_id, f"covers/{book_id}.webp")
                    upload_bytes(BUCKET, cover_key, optimized_data, content_type)
                    print(f"[CalibreMeta] Uploaded cover: {cover_key} ({len(optimized_data)} bytes)")
                else:
                    print(f"[CalibreMeta] Cover too small or empty, skipping")
            else:
                print(f"[CalibreMeta] No cover file found")
            
            # 【PDF 特殊处理】检测是否为图片型 PDF（需要 OCR）
            is_image_based = False
            digitalization_confidence = 1.0
            
            if fmt_lower == 'pdf' and book_data:
                print(f"[CalibreMeta] Analyzing PDF for OCR requirement...")
                pdf_analysis = _extract_pdf_metadata(book_data)
                is_image_based = pdf_analysis.get("is_image_based", False)
                digitalization_confidence = pdf_analysis.get("digitalization_confidence", 1.0)
                if pdf_analysis.get("page_count"):
                    metadata["page_count"] = pdf_analysis["page_count"]
                print(f"[CalibreMeta] PDF analysis: is_image_based={is_image_based}, confidence={digitalization_confidence:.2f}")
            
            # 更新数据库
            updates = []
            params = {"id": book_id}
            
            if cover_key:
                updates.append("cover_image_key = :cover_key")
                params["cover_key"] = cover_key
            
            # 更新作者（如果当前为空）
            if metadata.get("author") and (not current_author or current_author.strip() == ""):
                updates.append("author = :author")
                params["author"] = metadata["author"]
                print(f"[CalibreMeta] Will update author to: {metadata['author']}")
            
            # 更新标题（如果需要）
            if metadata.get("title"):
                extracted_title = metadata["title"].strip()
                should_update = (
                    not current_title or 
                    current_title.strip() == "" or 
                    "_" in current_title or 
                    current_title.endswith(('.epub', '.pdf', '.mobi', '.azw3')) or
                    ("-" in (current_title or "") and "-" not in extracted_title and len(extracted_title) < len(current_title or ""))
                )
                if should_update:
                    updates.append("title = :title")
                    params["title"] = extracted_title
                    print(f"[CalibreMeta] Will update title to: '{extracted_title}'")
            
            # 更新页数
            meta_updates = []
            if metadata.get("page_count"):
                meta_updates.append(f"'page_count', {metadata['page_count']}::int")
            
            # PDF 特殊：更新图片型检测结果
            if fmt_lower == 'pdf':
                updates.append("is_digitalized = true")
                updates.append("initial_digitalization_confidence = :confidence")
                params["confidence"] = digitalization_confidence
            
            # 标记元数据已提取（合并所有 meta 更新，使用 JSON 字面量避免类型推断问题）
            meta_updates.append("'metadata_extracted', true::boolean")
            meta_updates.append("'extraction_method', 'calibre'::text")
            updates.append(f"meta = COALESCE(meta, '{{}}'::jsonb) || jsonb_build_object({', '.join(meta_updates)})")
            
            if updates:
                updates.append("updated_at = now()")
                update_sql = f"UPDATE books SET {', '.join(updates)} WHERE id = cast(:id as uuid)"
                async with engine.begin() as conn:
                    await conn.execute(
                        text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                    )
                    await conn.execute(text(update_sql), params)
                    print(f"[CalibreMeta] Updated book: {book_id}")
            
            # 广播更新事件
            try:
                event_data = {
                    "event": "METADATA_EXTRACTED",
                    "cover_key": cover_key,
                    "title": metadata.get("title"),
                    "author": metadata.get("author"),
                    "extraction_method": "calibre",
                    "format": fmt_lower,
                }
                # PDF 特殊：包含 OCR 检测信息
                if fmt_lower == 'pdf':
                    event_data["is_image_based"] = is_image_based
                    event_data["digitalization_confidence"] = digitalization_confidence
                    event_data["needs_ocr"] = is_image_based and digitalization_confidence < 0.8
                
                await ws_broadcast(f"book:{book_id}", json.dumps(event_data))
                print(f"[CalibreMeta] WebSocket event broadcasted")
            except Exception as e:
                print(f"[CalibreMeta] Failed to broadcast: {e}")
            
        except Exception as e:
            print(f"[CalibreMeta] Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # 清理临时文件
            for path in [worker_input_path, worker_cover_path, worker_metadata_path, 
                         worker_request_path, worker_done_path, worker_error_path]:
                try:
                    if os.path.exists(path):
                        os.remove(path)
                except:
                    pass
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.convert_to_epub")
def convert_to_epub(book_id: str, user_id: str):
    """
    使用 Calibre 容器将非 EPUB/PDF 格式的书籍转换为 EPUB
    通过共享卷与 Calibre 容器交互，然后轮询等待转换完成
    
    状态流转：pending -> processing -> completed/failed
    
    【重要】每个数据库操作使用独立事务，避免长事务问题
    """
    import asyncio
    import uuid as _uuid
    import os
    import time
    from .celery_app import celery_app
    
    CALIBRE_BOOKS_DIR = os.environ.get("CALIBRE_CONVERT_DIR", "/calibre_books")
    
    async def _update_status(status: str, extra_sql: str = "", extra_params: dict = None):
        """独立事务更新状态"""
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            params = {"id": book_id, **(extra_params or {})}
            if extra_sql:
                sql = f"UPDATE books SET conversion_status = '{status}', {extra_sql}, updated_at = now() WHERE id = cast(:id as uuid)"
            else:
                sql = f"UPDATE books SET conversion_status = '{status}', updated_at = now() WHERE id = cast(:id as uuid)"
            await conn.execute(text(sql), params)
            print(f"[Convert] Status updated to '{status}' for book: {book_id}")
    
    async def _get_book_info():
        """独立事务获取书籍信息"""
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            return res.fetchone()
    
    async def _update_converted_epub(epub_key: str):
        """独立事务更新转换后的 EPUB 信息"""
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            await conn.execute(
                text("UPDATE books SET minio_key = :key, converted_epub_key = :key, conversion_status = 'completed', updated_at = now() WHERE id = cast(:id as uuid)"),
                {"key": epub_key, "id": book_id},
            )
            print(f"[Convert] Updated book with converted EPUB, status='completed': {book_id}")
    
    async def _run():
        # 步骤1：更新状态为 processing
        await _update_status('processing')
        
        # 步骤2：获取书籍信息
        row = await _get_book_info()
        if not row:
            print(f"[Convert] Book not found: {book_id}")
            return
        
        minio_key, original_format, title, existing_epub = row[0], row[1], row[2], row[3]
        fmt_lower = (original_format or '').lower()
        
        # 如果已经是 EPUB 或已有转换后的 EPUB，跳过
        if fmt_lower == 'epub':
            print(f"[Convert] Book is already EPUB, skipping: {book_id}")
            await _update_status('completed')
            return
        if existing_epub:
            print(f"[Convert] Book already has converted EPUB, skipping: {book_id}")
            await _update_status('completed')
            return
        
        # PDF 不需要转换
        if fmt_lower == 'pdf':
            print(f"[Convert] PDF format does not need conversion: {book_id}")
            await _update_status('completed')
            return
        
        print(f"[Convert] Converting {fmt_lower} to EPUB: {title}")
        
        job_id = str(_uuid.uuid4())[:8]
        input_filename = f"input-{job_id}.{fmt_lower}"
        output_filename = f"output-{job_id}.epub"
        
        # Calibre 容器中的路径是 /books，Worker 容器中的路径是 /calibre_books
        worker_input_path = os.path.join(CALIBRE_BOOKS_DIR, input_filename)
        worker_output_path = os.path.join(CALIBRE_BOOKS_DIR, output_filename)
        calibre_input_path = f"/books/{input_filename}"
        calibre_output_path = f"/books/{output_filename}"
        
        try:
            # 从存储下载源文件
            client = get_s3()
            ensure_bucket(client, BUCKET)
            resp = client.get_object(Bucket=BUCKET, Key=minio_key)
            book_data = resp["Body"].read()
            
            # 写入共享卷
            os.makedirs(CALIBRE_BOOKS_DIR, exist_ok=True)
            with open(worker_input_path, 'wb') as f:
                f.write(book_data)
            print(f"[Convert] Wrote source file: {worker_input_path} ({len(book_data)} bytes)")
            
            # 创建转换请求文件（Calibre 容器中的监控脚本会读取并执行）
            request_file = os.path.join(CALIBRE_BOOKS_DIR, f"convert-{job_id}.request")
            with open(request_file, 'w') as f:
                f.write(f"{calibre_input_path}\n{calibre_output_path}\n")
            print(f"[Convert] Created conversion request: {request_file}")
            
            # 轮询等待转换完成（最多等待 5 分钟）
            done_file = os.path.join(CALIBRE_BOOKS_DIR, f"convert-{job_id}.done")
            error_file = os.path.join(CALIBRE_BOOKS_DIR, f"convert-{job_id}.error")
            
            max_wait = 300  # 5 分钟
            wait_interval = 2  # 每 2 秒检查一次
            waited = 0
            
            while waited < max_wait:
                if os.path.exists(done_file):
                    print(f"[Convert] Conversion completed!")
                    break
                if os.path.exists(error_file):
                    with open(error_file, 'r') as f:
                        error_msg = f.read()
                    print(f"[Convert] Conversion failed: {error_msg}")
                    # 清理
                    try:
                        os.remove(request_file)
                        os.remove(error_file)
                        os.remove(worker_input_path)
                    except:
                        pass
                    # 标记转换失败
                    await _update_status('failed', 
                        "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('conversion_error', :err)",
                        {"err": error_msg[:500]})
                    return
                
                time.sleep(wait_interval)
                waited += wait_interval
                if waited % 30 == 0:
                    print(f"[Convert] Still waiting... ({waited}s)")
            
            if waited >= max_wait:
                print(f"[Convert] Conversion timed out after {max_wait}s")
                # 标记为转换失败（超时）
                await _update_status('failed',
                    "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('needs_manual_conversion', true, 'conversion_error', 'timeout')")
                return
            
            # 读取转换后的文件
            if not os.path.exists(worker_output_path):
                print(f"[Convert] Output file not found: {worker_output_path}")
                await _update_status('failed',
                    "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('conversion_error', 'output_not_found')")
                return
            
            with open(worker_output_path, 'rb') as f:
                epub_data = f.read()
            print(f"[Convert] Read converted EPUB: {len(epub_data)} bytes")
            
            # 上传到存储
            epub_key = make_object_key(user_id, f"converted/{book_id}.epub")
            upload_bytes(BUCKET, epub_key, epub_data, "application/epub+zip")
            print(f"[Convert] Uploaded converted EPUB: {epub_key}")
            
            # 删除 S3 中的原始非 EPUB/PDF 文件（节省存储空间）
            try:
                client.delete_object(Bucket=BUCKET, Key=minio_key)
                print(f"[Convert] Deleted original file from S3: {minio_key}")
            except Exception as del_e:
                print(f"[Convert] Warning: Failed to delete original file: {del_e}")
            
            # 【关键】使用独立事务更新数据库
            await _update_converted_epub(epub_key)
            
            # 清理临时文件
            for f in [worker_input_path, worker_output_path, request_file, done_file]:
                try:
                    os.remove(f)
                except:
                    pass
            
            # 广播转换完成事件
            try:
                import json as _j
                asyncio.create_task(
                    ws_broadcast(
                        f"book:{book_id}",
                        _j.dumps({"event": "CONVERTED_TO_EPUB", "epub_key": epub_key}),
                    )
                )
            except Exception:
                pass
            
        except Exception as e:
            print(f"[Convert] Conversion error: {e}")
            import traceback
            traceback.print_exc()
            # 标记为失败
            try:
                await _update_status('failed',
                    "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('conversion_error', :err)",
                    {"err": str(e)[:500]})
            except:
                pass
            return
        
        # 【架构变更】转换完成后，检查是否已有封面
        # extract_ebook_metadata_calibre 任务已经并行提取了元数据和封面
        # 只有在封面不存在时才触发补充提取
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT cover_image_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            has_cover = row and row[0]
        
        if not has_cover:
            # 封面还没有，使用转换后的 EPUB 提取封面
            print(f"[Convert] No cover found, triggering EPUB cover extraction for: {book_id}")
            celery_app.send_task("tasks.extract_book_cover_and_metadata", args=[book_id, user_id])
        else:
            print(f"[Convert] Cover already exists, skipping extraction for: {book_id}")
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.extract_book_cover")
def extract_book_cover(book_id: str, user_id: str):
    """
    提取书籍封面并保存到存储
    仅支持 EPUB 和 PDF 格式，其他格式需先通过 Calibre 转换为 EPUB
    """
    import asyncio
    
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[Cover] Book not found: {book_id}")
                return
            
            minio_key, original_format, title, converted_epub_key = row[0], row[1], row[2], row[3]
            fmt_lower = (original_format or '').lower()
            
            # 对于非 EPUB/PDF 格式，优先使用转换后的 EPUB
            if fmt_lower not in ('epub', 'pdf'):
                if converted_epub_key:
                    print(f"[Cover] Using converted EPUB for: {title}")
                    minio_key = converted_epub_key
                    fmt_lower = 'epub'
                else:
                    print(f"[Cover] Non-EPUB/PDF format ({fmt_lower}) needs conversion first: {book_id}")
                    return
            
            if not minio_key:
                print(f"[Cover] No minio_key for book: {book_id}")
                return
            
            print(f"[Cover] Extracting cover for: {title} ({fmt_lower})")
            
            # 下载书籍文件
            try:
                client = get_s3()
                ensure_bucket(client, BUCKET)
                resp = client.get_object(Bucket=BUCKET, Key=minio_key)
                book_data = resp["Body"].read()
            except Exception as e:
                print(f"[Cover] Failed to download book: {e}")
                return
            
            # 根据格式提取封面（只支持 EPUB 和 PDF）
            cover_data = None
            if fmt_lower == 'epub':
                cover_data = _extract_epub_cover(book_data)
            elif fmt_lower == 'pdf':
                cover_data = _extract_pdf_cover(book_data)
            
            if not cover_data:
                print(f"[Cover] No cover found for: {book_id}")
                return
            
            # 优化封面图片：转换为 WebP 并压缩
            optimized_data, content_type = _optimize_cover_image(cover_data, max_width=400, quality=80)
            
            # 上传封面到存储
            cover_key = make_object_key(user_id, f"covers/{book_id}.webp")
            
            try:
                upload_bytes(BUCKET, cover_key, optimized_data, content_type)
                print(f"[Cover] Uploaded cover: {cover_key} ({len(optimized_data)} bytes)")
            except Exception as e:
                print(f"[Cover] Failed to upload cover: {e}")
                return
            
            # 更新数据库
            await conn.execute(
                text("UPDATE books SET cover_image_key = :key, updated_at = now() WHERE id = cast(:id as uuid)"),
                {"key": cover_key, "id": book_id},
            )
            print(f"[Cover] Updated book with cover: {book_id}")
            
            # 广播更新事件
            try:
                import json as _j
                asyncio.create_task(
                    ws_broadcast(
                        f"book:{book_id}",
                        _j.dumps({"event": "COVER_EXTRACTED", "cover_key": cover_key}),
                    )
                )
            except Exception:
                pass
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.extract_book_metadata")
def extract_book_metadata(book_id: str, user_id: str):
    """
    从书籍文件中提取元数据 (title, author, page_count) 并更新数据库
    仅支持 EPUB 和 PDF 格式，其他格式需先通过 Calibre 转换为 EPUB
    """
    import asyncio
    
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, author, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[Metadata] Book not found: {book_id}")
                return
            
            minio_key, original_format, current_title, current_author, converted_epub_key = row[0], row[1], row[2], row[3], row[4]
            fmt_lower = (original_format or '').lower()
            
            # 对于非 EPUB/PDF 格式，优先使用转换后的 EPUB
            if fmt_lower not in ('epub', 'pdf'):
                if converted_epub_key:
                    print(f"[Metadata] Using converted EPUB for metadata extraction")
                    minio_key = converted_epub_key
                    fmt_lower = 'epub'
                else:
                    print(f"[Metadata] Non-EPUB/PDF format ({fmt_lower}) needs conversion first: {book_id}")
                    return
            
            if not minio_key:
                print(f"[Metadata] No minio_key for book: {book_id}")
                return
            
            print(f"[Metadata] Extracting metadata for book: {book_id} (format: {fmt_lower})")
            
            # 下载书籍文件
            try:
                client = get_s3()
                ensure_bucket(client, BUCKET)
                resp = client.get_object(Bucket=BUCKET, Key=minio_key)
                book_data = resp["Body"].read()
            except Exception as e:
                print(f"[Metadata] Failed to download book: {e}")
                return
            
            # 根据格式提取元数据（只支持 EPUB 和 PDF）
            metadata = {"title": None, "author": None, "page_count": None}
            
            if fmt_lower == 'epub':
                metadata = _extract_epub_metadata(book_data)
            elif fmt_lower == 'pdf':
                metadata = _extract_pdf_metadata(book_data)
            
            # 构建更新语句
            updates = []
            params = {"id": book_id}
            
            # 只有在当前 author 为空且提取到了 author 时才更新
            if metadata.get("author") and (not current_author or current_author.strip() == ""):
                updates.append("author = :author")
                params["author"] = metadata["author"]
                print(f"[Metadata] Will update author to: {metadata['author']}")
            
            # 只有在当前 title 是文件名格式（或为空）且提取到了更好的 title 时才更新
            if metadata.get("title"):
                extracted_title = metadata["title"].strip()
                # 检查是否需要更新标题
                # 1. 当前标题为空
                # 2. 当前标题包含文件名特征（下划线、连字符分隔作者名、扩展名后缀）
                # 3. 当前标题与提取的标题不同，且提取的标题更短（可能是去除了作者名后缀）
                should_update = (
                    not current_title or 
                    current_title.strip() == "" or 
                    "_" in current_title or 
                    current_title.endswith(('.epub', '.pdf', '.mobi', '.azw3')) or
                    # 文件名格式通常是 "书名-作者名"，如果提取的标题不包含连字符且当前标题包含，说明需要更新
                    ("-" in (current_title or "") and "-" not in extracted_title and len(extracted_title) < len(current_title or ""))
                )
                if should_update:
                    updates.append("title = :title")
                    params["title"] = extracted_title
                    print(f"[Metadata] Will update title from '{current_title}' to: '{extracted_title}'")
                else:
                    print(f"[Metadata] Title not updated, current: '{current_title}', extracted: '{extracted_title}'")
            
            # 更新 meta 字段：page_count 和 metadata_extracted
            # 合并成一个语句避免 "multiple assignments to same column" 错误
            if metadata.get("page_count"):
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', cast(:page_count as integer), 'needs_manual', false, 'metadata_extracted', true)")
                params["page_count"] = int(metadata["page_count"])
                print(f"[Metadata] Will update page_count to: {metadata['page_count']}")
            else:
                # 无论是否提取到有效数据，都标记元数据提取任务已完成
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || '{\"metadata_extracted\": true}'::jsonb")
            
            if updates:
                updates.append("updated_at = now()")
                update_sql = f"UPDATE books SET {', '.join(updates)} WHERE id = cast(:id as uuid)"
                await conn.execute(text(update_sql), params)
                print(f"[Metadata] Updated book metadata for: {book_id}, metadata_extracted=true")
                
                # 广播更新事件
                try:
                    import json as _j
                    event_data = {
                        "event": "METADATA_EXTRACTED",
                        "title": metadata.get("title"),
                        "author": metadata.get("author"),
                        "page_count": metadata.get("page_count"),
                        "metadata_extracted": True,  # 标记任务完成
                    }
                    asyncio.create_task(
                        ws_broadcast(
                            f"book:{book_id}",
                            _j.dumps(event_data),
                        )
                    )
                except Exception:
                    pass
            else:
                # 即使没有其他更新，也要标记 metadata_extracted
                await conn.execute(
                    text("UPDATE books SET meta = COALESCE(meta, '{}'::jsonb) || '{\"metadata_extracted\": true}'::jsonb, updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id},
                )
                print(f"[Metadata] No metadata updates, but marked metadata_extracted=true for: {book_id}")
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.extract_book_cover_and_metadata")
def extract_book_cover_and_metadata(book_id: str, user_id: str):
    """
    合并的封面+元数据提取任务
    只下载一次文件，同时提取封面和元数据，提高 PDF 处理效率
    """
    import asyncio
    
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, author, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[CoverMeta] Book not found: {book_id}")
                return
            
            minio_key, original_format, current_title, current_author, converted_epub_key = row[0], row[1], row[2], row[3], row[4]
            fmt_lower = (original_format or '').lower()
            
            # 对于非 EPUB/PDF 格式，优先使用转换后的 EPUB
            if fmt_lower not in ('epub', 'pdf'):
                if converted_epub_key:
                    print(f"[CoverMeta] Using converted EPUB")
                    minio_key = converted_epub_key
                    fmt_lower = 'epub'
                else:
                    print(f"[CoverMeta] Non-EPUB/PDF format ({fmt_lower}) needs conversion first: {book_id}")
                    return
            
            if not minio_key:
                print(f"[CoverMeta] No minio_key for book: {book_id}")
                return
            
            print(f"[CoverMeta] Extracting cover and metadata for: {book_id} (format: {fmt_lower})")
            
            # 下载书籍文件（只下载一次）
            try:
                client = get_s3()
                ensure_bucket(client, BUCKET)
                resp = client.get_object(Bucket=BUCKET, Key=minio_key)
                book_data = resp["Body"].read()
                print(f"[CoverMeta] Downloaded {len(book_data)} bytes")
            except Exception as e:
                print(f"[CoverMeta] Failed to download book: {e}")
                return
            
            # ============ 提取封面 ============
            cover_data = None
            if fmt_lower == 'epub':
                cover_data = _extract_epub_cover(book_data)
            elif fmt_lower == 'pdf':
                cover_data = _extract_pdf_cover(book_data)
            
            cover_key = None
            if cover_data:
                # 优化封面图片
                optimized_data, content_type = _optimize_cover_image(cover_data, max_width=400, quality=80)
                cover_key = make_object_key(user_id, f"covers/{book_id}.webp")
                try:
                    upload_bytes(BUCKET, cover_key, optimized_data, content_type)
                    print(f"[CoverMeta] Uploaded cover: {cover_key} ({len(optimized_data)} bytes)")
                except Exception as e:
                    print(f"[CoverMeta] Failed to upload cover: {e}")
                    cover_key = None
            else:
                print(f"[CoverMeta] No cover found for: {book_id}")
            
            # ============ 提取元数据 ============
            metadata = {"title": None, "author": None, "page_count": None}
            if fmt_lower == 'epub':
                metadata = _extract_epub_metadata(book_data)
            elif fmt_lower == 'pdf':
                metadata = _extract_pdf_metadata(book_data)
            
            # ============ 构建数据库更新 ============
            updates = []
            params = {"id": book_id}
            
            # 更新封面
            if cover_key:
                updates.append("cover_image_key = :cover_key")
                params["cover_key"] = cover_key
            
            # 更新作者（如果当前为空且提取到了）
            if metadata.get("author") and (not current_author or current_author.strip() == ""):
                updates.append("author = :author")
                params["author"] = metadata["author"]
                print(f"[CoverMeta] Will update author to: {metadata['author']}")
            
            # 更新标题（如果需要）
            if metadata.get("title"):
                extracted_title = metadata["title"].strip()
                should_update = (
                    not current_title or 
                    current_title.strip() == "" or 
                    "_" in current_title or 
                    current_title.endswith(('.epub', '.pdf', '.mobi', '.azw3')) or
                    ("-" in (current_title or "") and "-" not in extracted_title and len(extracted_title) < len(current_title or ""))
                )
                if should_update:
                    updates.append("title = :title")
                    params["title"] = extracted_title
                    print(f"[CoverMeta] Will update title to: '{extracted_title}'")
            
            # 更新 meta 字段：page_count + metadata_extracted
            if metadata.get("page_count"):
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', cast(:page_count as integer), 'needs_manual', false, 'metadata_extracted', true)")
                params["page_count"] = int(metadata["page_count"])
                print(f"[CoverMeta] Will update page_count to: {metadata['page_count']}")
            else:
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || '{\"metadata_extracted\": true}'::jsonb")
            
            # ============ 更新图片型 PDF 检测结果（仅对 PDF 格式）============
            if fmt_lower == 'pdf' and 'is_image_based' in metadata:
                is_image_based = metadata.get("is_image_based", False)
                confidence = metadata.get("digitalization_confidence", 1.0)
                # is_digitalized = true 表示"已检测"，confidence < 0.8 表示是图片型
                updates.append("is_digitalized = true")
                updates.append("initial_digitalization_confidence = :confidence")
                params["confidence"] = confidence
                print(f"[CoverMeta] PDF type detection: is_image_based={is_image_based}, confidence={confidence}")
            
            # 执行更新
            if updates:
                updates.append("updated_at = now()")
                update_sql = f"UPDATE books SET {', '.join(updates)} WHERE id = cast(:id as uuid)"
                await conn.execute(text(update_sql), params)
                print(f"[CoverMeta] Updated book: {book_id}")
            
            # 广播更新事件
            try:
                import json as _j
                event_data = {
                    "event": "COVER_AND_METADATA_EXTRACTED",
                    "cover_key": cover_key,
                    "title": metadata.get("title"),
                    "author": metadata.get("author"),
                    "page_count": metadata.get("page_count"),
                    "metadata_extracted": True,
                    "is_image_based": metadata.get("is_image_based", False),
                    "digitalization_confidence": metadata.get("digitalization_confidence", 1.0),
                }
                # 【关键修复】使用 await 而不是 create_task，确保广播消息立即发送
                await ws_broadcast(
                    f"book:{book_id}",
                    _j.dumps(event_data),
                )
                print(f"[CoverMeta] WebSocket event broadcasted: COVER_AND_METADATA_EXTRACTED")
            except Exception as e:
                print(f"[CoverMeta] Failed to broadcast WebSocket event: {e}")
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.analyze_book_type")
def analyze_book_type(book_id: str, user_id: str):
    """
    【已废弃】此任务已被 extract_book_cover_and_metadata 取代
    
    保留此函数仅为向后兼容，实际 PDF 类型检测已整合到元数据提取流程中。
    如果仍被调用，使用 _quick_confidence 快速检测并设置 is_digitalized 标志。
    """
    import asyncio

    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                return
            key = row[0]
            is_image_based, conf = _quick_confidence(key)
            
            # 【关键修复】设置 is_digitalized = true 以标记检测完成
            await conn.execute(
                text(
                    "UPDATE books SET is_digitalized = true, initial_digitalization_confidence = :c, updated_at = now() WHERE id = cast(:id as uuid)"
                ),
                {"c": conf, "id": book_id},
            )
            print(f"[AnalyzeBookType] Book {book_id}: is_image_based={is_image_based}, confidence={conf:.2f}")
        
        try:
            import json as _j

            # 【关键修复】WebSocket 事件包含完整检测信息，使用 await 确保发送
            await ws_broadcast(
                f"book:{book_id}",
                _j.dumps({
                    "event": "ANALYZED",
                    "confidence": conf,
                    "is_image_based": is_image_based,
                    "is_digitalized": True,
                }),
            )
            print(f"[AnalyzeBookType] WebSocket event broadcasted: ANALYZED")
        except Exception as e:
            print(f"[AnalyzeBookType] Failed to broadcast WebSocket event: {e}")
        try:
            async with engine.begin() as conn2:
                await conn2.execute(
                    _text(
                        "INSERT INTO audit_logs(id, owner_id, action, details) VALUES (gen_random_uuid(), cast(:uid as uuid), :act, cast(:det as jsonb))"
                    ),
                    {
                        "uid": user_id,
                        "act": "task_analyze_book_type",
                        "det": _j.dumps({"book_id": book_id, "confidence": conf, "is_image_based": is_image_based}),
                    },
                )
        except Exception:
            pass

    asyncio.get_event_loop().run_until_complete(_run())


def _pdf_to_images_with_sizes(pdf_data: bytes, max_pages: int = 0, dpi: int = 150) -> list:
    """
    将 PDF 转换为图片列表，用于 OCR
    **每页单独记录尺寸**，因为 PDF 每页尺寸可能不同
    
    Args:
        pdf_data: PDF 文件二进制数据
        max_pages: 最大处理页数，0 表示处理所有页面
        dpi: 渲染分辨率
    Returns:
        list of dict: [
            {
                "page_num": 1,
                "image_bytes": bytes,
                "width": 1200,   # 该页渲染后的像素宽度
                "height": 1600,  # 该页渲染后的像素高度
                "pdf_width": 595.0,   # PDF 原始宽度 (points, 72 DPI)
                "pdf_height": 842.0,  # PDF 原始高度 (points)
            },
            ...
        ]
    """
    import fitz  # PyMuPDF
    
    pages = []
    try:
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        total_pages = len(doc)
        pages_to_process = total_pages if max_pages <= 0 else min(total_pages, max_pages)
        
        print(f"[OCR] PDF has {total_pages} pages, will process {pages_to_process} pages")
        
        for page_num in range(pages_to_process):
            page = doc[page_num]
            
            # 获取 PDF 原始页面尺寸 (points, 1 point = 1/72 inch)
            pdf_rect = page.rect
            pdf_width = pdf_rect.width
            pdf_height = pdf_rect.height
            
            # 渲染为像素图
            mat = fitz.Matrix(dpi / 72, dpi / 72)
            pix = page.get_pixmap(matrix=mat)
            
            # 渲染后的像素尺寸
            pixel_width = pix.width
            pixel_height = pix.height
            
            if page_num == 0:
                print(f"[OCR] First page: PDF size {pdf_width:.1f}x{pdf_height:.1f} pt -> {pixel_width}x{pixel_height} px at {dpi} DPI")
            
            # 转换为 PNG 格式
            img_data = pix.tobytes("png")
            
            pages.append({
                "page_num": page_num + 1,
                "total_pages": total_pages,
                "image_bytes": img_data,
                "width": pixel_width,
                "height": pixel_height,
                "pdf_width": pdf_width,
                "pdf_height": pdf_height,
                "dpi": dpi,
            })
        
        doc.close()
    except Exception as e:
        print(f"[OCR] Failed to convert PDF to images: {e}")
    
    return pages


def _pdf_page_to_image(doc, page_num: int, total_pages: int, dpi: int = 150) -> dict:
    """
    将单个 PDF 页面转换为图片（供流水线模式使用）
    """
    page = doc[page_num]
    
    # 获取 PDF 原始页面尺寸
    pdf_rect = page.rect
    pdf_width = pdf_rect.width
    pdf_height = pdf_rect.height
    
    # 渲染为像素图
    import fitz
    mat = fitz.Matrix(dpi / 72, dpi / 72)
    pix = page.get_pixmap(matrix=mat)
    
    # 转换为 PNG 格式
    img_data = pix.tobytes("png")
    
    return {
        "page_num": page_num + 1,
        "total_pages": total_pages,
        "image_bytes": img_data,
        "width": pix.width,
        "height": pix.height,
        "pdf_width": pdf_width,
        "pdf_height": pdf_height,
        "dpi": dpi,
    }


def _get_optimal_workers(reserved_cores: int = 2, max_workers: int = 8) -> int:
    """
    动态计算最优工作线程数
    
    考虑因素：
    1. 系统总 CPU 核心数
    2. 当前 CPU 使用率
    3. 预留核心给其他任务（API、其他 Celery 任务）
    4. 最大工作线程数限制（避免内存过高）
    
    Args:
        reserved_cores: 预留给其他任务的核心数，默认 2
        max_workers: 最大工作线程数，默认 8
    
    Returns:
        int: 推荐的工作线程数
    """
    import os
    import psutil
    
    # 获取 CPU 核心数
    cpu_count = os.cpu_count() or 4
    
    # 获取当前 CPU 使用率
    try:
        cpu_percent = psutil.cpu_percent(interval=0.1)
        # 估算空闲核心数
        idle_cores = int(cpu_count * (100 - cpu_percent) / 100)
    except Exception:
        # 如果 psutil 不可用，假设 50% 空闲
        idle_cores = cpu_count // 2
    
    # 计算可用核心数：空闲核心 - 预留核心
    available_cores = max(1, idle_cores - reserved_cores)
    
    # 取 available_cores 和 max_workers 的较小值
    workers = min(available_cores, max_workers)
    
    # 至少 1 个 worker
    return max(1, workers)


def _pipeline_ocr_process(
    pdf_data: bytes,
    ocr_instance,
    max_pages: int = 0,
    dpi: int = 150,
    batch_size: int = 20,
    progress_callback=None,
) -> tuple:
    """
    流水线模式处理 PDF OCR
    
    使用生产者-消费者模式，CPU 图片转换和 OCR 识别并行执行：
    - 生产者：将 PDF 页面转换为图片（CPU 密集）
    - 消费者：对图片执行 OCR（CPU/GPU 密集）
    
    优化策略：
    1. 动态计算工作线程数，预留核心给其他任务
    2. 批量处理，控制内存占用
    3. 使用队列实现流水线，减少等待时间
    
    Args:
        pdf_data: PDF 文件二进制数据
        ocr_instance: PaddleOCR 实例
        max_pages: 最大处理页数，0 表示所有
        dpi: 渲染 DPI
        batch_size: 每批处理的页数
        progress_callback: 进度回调函数 (processed, total) -> None
    
    Returns:
        tuple: (ocr_pages, full_text, total_pages, processed_pages)
    """
    import fitz
    import tempfile
    import os as _os
    from queue import Queue
    from threading import Thread, Event
    from concurrent.futures import ThreadPoolExecutor
    
    # 打开 PDF
    doc = fitz.open(stream=pdf_data, filetype="pdf")
    total_pages = len(doc)
    pages_to_process = total_pages if max_pages <= 0 else min(total_pages, max_pages)
    
    print(f"[OCR Pipeline] PDF has {total_pages} pages, will process {pages_to_process} pages")
    
    # 获取最优工作线程数
    image_workers = _get_optimal_workers(reserved_cores=2, max_workers=6)
    print(f"[OCR Pipeline] Using {image_workers} workers for image conversion")
    
    # 结果存储
    ocr_pages = [None] * pages_to_process  # 预分配，保持页面顺序
    all_text_parts = []
    processed_count = 0
    
    # 队列：图片转换结果
    image_queue = Queue(maxsize=batch_size * 2)  # 限制队列大小，控制内存
    
    # 完成信号
    conversion_done = Event()
    
    def convert_page(page_num: int) -> dict:
        """转换单个页面为图片"""
        try:
            page = doc[page_num]
            pdf_rect = page.rect
            pdf_width = pdf_rect.width
            pdf_height = pdf_rect.height
            
            mat = fitz.Matrix(dpi / 72, dpi / 72)
            pix = page.get_pixmap(matrix=mat)
            img_data = pix.tobytes("png")
            
            return {
                "page_num": page_num + 1,
                "image_bytes": img_data,
                "width": pix.width,
                "height": pix.height,
                "pdf_width": pdf_width,
                "pdf_height": pdf_height,
                "dpi": dpi,
                "error": None,
            }
        except Exception as e:
            return {
                "page_num": page_num + 1,
                "image_bytes": None,
                "width": 0,
                "height": 0,
                "pdf_width": 0,
                "pdf_height": 0,
                "dpi": dpi,
                "error": str(e),
            }
    
    def image_producer():
        """生产者：批量转换 PDF 页面为图片"""
        
        with ThreadPoolExecutor(max_workers=image_workers) as executor:
            # 分批提交任务
            for batch_start in range(0, pages_to_process, batch_size):
                batch_end = min(batch_start + batch_size, pages_to_process)
                batch_pages = range(batch_start, batch_end)
                
                # 并行转换这一批页面
                futures = {executor.submit(convert_page, p): p for p in batch_pages}
                
                # 收集结果并放入队列
                for future in futures:
                    try:
                        result = future.result(timeout=60)
                        image_queue.put(result)
                    except Exception as e:
                        page_num = futures[future]
                        image_queue.put({
                            "page_num": page_num + 1,
                            "image_bytes": None,
                            "error": str(e),
                        })
        
        conversion_done.set()
        print(f"[OCR Pipeline] Image conversion completed for {pages_to_process} pages")
    
    def ocr_consumer():
        """消费者：对图片执行 OCR"""
        nonlocal processed_count
        
        while True:
            # 检查是否所有图片都已处理完
            if conversion_done.is_set() and image_queue.empty():
                break
            
            try:
                # 从队列获取图片（带超时，避免死锁）
                page_info = image_queue.get(timeout=1)
            except Exception:
                continue
            
            page_num = page_info["page_num"]
            page_idx = page_num - 1
            
            # 如果图片转换失败，记录错误
            if page_info.get("error") or not page_info.get("image_bytes"):
                ocr_pages[page_idx] = {
                    "page_num": page_num,
                    "width": page_info.get("width", 0),
                    "height": page_info.get("height", 0),
                    "pdf_width": page_info.get("pdf_width", 0),
                    "pdf_height": page_info.get("pdf_height", 0),
                    "dpi": page_info.get("dpi", dpi),
                    "regions": [],
                    "text": "",
                    "error": page_info.get("error", "Unknown error"),
                }
                processed_count += 1
                image_queue.task_done()
                continue
            
            # 保存临时文件并执行 OCR
            fd, temp_path = tempfile.mkstemp(suffix='.png')
            try:
                _os.write(fd, page_info["image_bytes"])
                _os.close(fd)
                
                # 执行 OCR
                page_result = ocr_instance.recognize("", temp_path)
                
                # 构建页面结果
                page_data = {
                    "page_num": page_num,
                    "width": page_info["width"],
                    "height": page_info["height"],
                    "pdf_width": page_info["pdf_width"],
                    "pdf_height": page_info["pdf_height"],
                    "dpi": page_info["dpi"],
                    "regions": page_result.get("regions", []),
                    "text": page_result.get("text", ""),
                }
                ocr_pages[page_idx] = page_data
                
                if page_result.get("text"):
                    all_text_parts.append((page_num, page_result["text"]))
                
                processed_count += 1
                
                # 进度回调
                if progress_callback:
                    progress_callback(processed_count, pages_to_process)
                
                # 日志（每 10 页输出一次）
                if processed_count % 10 == 0 or processed_count == pages_to_process:
                    print(f"[OCR Pipeline] Progress: {processed_count}/{pages_to_process} pages ({processed_count * 100 // pages_to_process}%)")
                
            except Exception as e:
                ocr_pages[page_idx] = {
                    "page_num": page_num,
                    "width": page_info["width"],
                    "height": page_info["height"],
                    "pdf_width": page_info["pdf_width"],
                    "pdf_height": page_info["pdf_height"],
                    "dpi": page_info["dpi"],
                    "regions": [],
                    "text": "",
                    "error": str(e),
                }
                processed_count += 1
            finally:
                try:
                    _os.remove(temp_path)
                except Exception:
                    pass
                image_queue.task_done()
    
    # 启动生产者和消费者线程
    producer_thread = Thread(target=image_producer, name="OCR-ImageProducer")
    consumer_thread = Thread(target=ocr_consumer, name="OCR-Consumer")
    
    print(f"[OCR Pipeline] Starting pipeline processing...")
    start_time = __import__('time').time()
    
    producer_thread.start()
    consumer_thread.start()
    
    # 等待完成
    producer_thread.join()
    consumer_thread.join()
    
    # 关闭 PDF 文档
    doc.close()
    
    elapsed = __import__('time').time() - start_time
    print(f"[OCR Pipeline] Completed in {elapsed:.1f}s, avg {elapsed / pages_to_process:.2f}s per page")
    
    # 整理文本（按页码排序）
    all_text_parts.sort(key=lambda x: x[0])
    full_text_parts = []
    for page_num, text in all_text_parts:
        full_text_parts.append(f"--- Page {page_num} ---")
        full_text_parts.append(text)
    
    # 过滤掉 None（理论上不应该有）
    ocr_pages = [p for p in ocr_pages if p is not None]
    
    return ocr_pages, "\n".join(full_text_parts), total_pages, len(ocr_pages)


def _pdf_to_images(pdf_data: bytes, max_pages: int = 0, dpi: int = 150) -> tuple:
    """
    将 PDF 转换为图片列表，用于 OCR（兼容旧接口）
    Args:
        pdf_data: PDF 文件二进制数据
        max_pages: 最大处理页数，0 表示处理所有页面
        dpi: 渲染分辨率
    Returns:
        (images, image_width, image_height)
        images: [(page_num, image_bytes, total_pages), ...]
        image_width, image_height: 第一页的渲染尺寸（像素）
    """
    pages = _pdf_to_images_with_sizes(pdf_data, max_pages, dpi)
    if not pages:
        return [], 0, 0
    
    images = [(p["page_num"], p["image_bytes"], p["total_pages"]) for p in pages]
    return images, pages[0]["width"], pages[0]["height"]


@shared_task(name="tasks.process_book_ocr")
def process_book_ocr(book_id: str, user_id: str):
    """
    处理书籍 OCR 任务（双层 PDF 生成模式）
    
    **架构重构说明**：
    - 旧方案：生成 JSON，前端渲染透明 DOM（存在文字对齐问题）
    - 新方案：后端生成双层 PDF (Invisible Text Layer)，前端直接使用 react-pdf 渲染
    
    优化策略：
    1. 使用生产者-消费者模式：CPU 图片转换和 OCR 识别并行执行
    2. 动态计算工作线程数，预留核心给其他任务
    3. 借助 OCRmyPDF-PaddleOCR 插件生成透明文字层（pikepdf + ContentStreamBuilder）
    4. 生成的双层 PDF 替换原文件，前端无需额外处理
    
    流程:
    1. 更新状态为 processing
    2. 下载原始 PDF 文件
    3. 流水线处理：图片转换 → OCR（并行）
    4. OCRmyPDF 插件写入透明文字层，保持 PaddleOCR 原始坐标
    5. 上传新的双层 PDF 到 MinIO (layered/{book_id}.pdf)
    6. 更新数据库：minio_key 指向新文件，备份原始 key
    7. 触发搜索索引
    8. WebSocket 通知前端清理旧缓存
    
    双层 PDF 优势：
    - 文字位置由 PDF 引擎精确控制，完美对齐
    - 前端无需维护 OCR 层组件
    - 支持所有 PDF 阅读器的标准文字选择
    """
    import asyncio
    
    print(f"[OCR] Starting OCR task for book {book_id} (Layered PDF Mode)")

    def _embed_ocr_text_to_pdf_with_paddle_plugin(pdf_data: bytes, ocr_pages: list) -> bytes:
        """
        使用 OCRmyPDF-PaddleOCR 插件将 PaddleOCR 识别的文字嵌入 PDF 作为透明文字层
        
        核心优势（完全参照 OCRmyPDF-EasyOCR 实现）：
        1. 使用 pikepdf + ContentStreamBuilder 精确控制 PDF 文本流
        2. 使用 PaddleOCR 的精确多边形坐标（polygon）
        3. 支持旋转文本（使用 Tm 文本矩阵）
        4. 透明文字层（Rendering Mode 3）完美覆盖原图
        5. 行业验证的坐标映射算法（从 OCRmyPDF-EasyOCR）
        
        Args:
            pdf_data: 原始 PDF 二进制数据
            ocr_pages: OCR 结果列表（PaddleOCR格式，包含精确坐标）
        
        Returns:
            bytes: 嵌入文字层后的 PDF 二进制数据
        """
        import tempfile
        import time as _time
        from pathlib import Path
        from app.services.ocrmypdf_paddle import create_layered_pdf_with_paddle
        
        start_time = _time.time()
        print(f"[PaddleOCR Plugin] Starting to embed text layer using OCRmyPDF-PaddleOCR plugin...")
        
        try:
            # 保存原始 PDF 到临时文件
            with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_in:
                temp_in.write(pdf_data)
                temp_in_path = temp_in.name
            
            # 输出文件路径
            with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_out:
                temp_out_path = temp_out.name
            
            # 使用 PaddleOCR 插件生成双层 PDF
            success = create_layered_pdf_with_paddle(
                pdf_path=temp_in_path,
                output_path=temp_out_path,
                ocr_pages=ocr_pages
            )
            
            if not success:
                raise Exception("Failed to create layered PDF with PaddleOCR plugin")
            
            # 读取结果
            with open(temp_out_path, 'rb') as f:
                result_data = f.read()
            
            # 清理临时文件
            import os
            try:
                os.remove(temp_in_path)
                os.remove(temp_out_path)
            except Exception:
                pass
            
            elapsed = _time.time() - start_time
            total_regions = sum(len(p.get('regions', [])) for p in ocr_pages)
            print(f"[PaddleOCR Plugin] Successfully embedded {total_regions} text regions in {elapsed:.1f}s")
            
            return result_data
            
        except Exception as e:
            import traceback
            print(f"[PaddleOCR Plugin] Failed to embed text layer: {e}")
            traceback.print_exc()
            raise Exception(f"PaddleOCR Plugin text embedding failed: {e}")

    async def _run():
        # 【关键修复】先获取书籍信息并更新状态为 processing，立即提交
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            
            # 获取书籍信息
            res = await conn.execute(
                text("SELECT minio_key, title FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[OCR] Book not found: {book_id}")
                return
            
            minio_key, book_title = row
            
            # 更新状态为 processing（此事务结束后立即提交）
            await conn.execute(
                text("""
                    UPDATE books 
                    SET ocr_status = 'processing', updated_at = now() 
                    WHERE id = cast(:id as uuid)
                """),
                {"id": book_id}
            )
        # 事务已提交，状态更新对前端可见
        
        original_minio_key = minio_key  # 保存原始 key 用于备份
        print(f"[OCR] Processing: {book_title} ({minio_key})")
        
        # 【关键优化】下载和 OCR 处理在事务外进行，避免长事务
        # 3. 下载 PDF
        pdf_data = read_full(BUCKET, minio_key)
        if not pdf_data:
            print(f"[OCR] Failed to download PDF: {minio_key}")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        print(f"[OCR] Downloaded PDF: {len(pdf_data)} bytes")
        
        # 4. 使用流水线模式处理 OCR
        ocr = get_ocr()
        
        try:
            ocr_pages, full_text, total_pages, processed_pages = _pipeline_ocr_process(
                pdf_data=pdf_data,
                ocr_instance=ocr,
                max_pages=0,  # 处理所有页面
                dpi=150,
                batch_size=20,  # 每批 20 页
                progress_callback=None,  # 可以后续添加进度回调
            )
        except Exception as e:
            print(f"[OCR] Pipeline processing failed: {e}")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        if not ocr_pages:
            print(f"[OCR] No pages processed")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        print(f"[OCR] Pipeline completed: {processed_pages}/{total_pages} pages")
        
        # 5. 【核心】生成双层 PDF（使用 OCRmyPDF-PaddleOCR 插件）
        print(f"[OCR] Generating layered PDF with PaddleOCR Plugin (OCRmyPDF-EasyOCR style)...")
        try:
            layered_pdf_data = _embed_ocr_text_to_pdf_with_paddle_plugin(pdf_data, ocr_pages)
            print(f"[OCR] Layered PDF generated: {len(layered_pdf_data)} bytes")
        except Exception as e:
            print(f"[OCR] Failed to generate layered PDF: {e}")
            import traceback
            traceback.print_exc()
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        # 6. 上传双层 PDF 到 MinIO
        layered_pdf_key = f"users/{user_id}/layered/{book_id}.pdf"
        try:
            upload_bytes(BUCKET, layered_pdf_key, layered_pdf_data, "application/pdf")
            print(f"[OCR] Uploaded layered PDF: {layered_pdf_key}")
        except Exception as e:
            print(f"[OCR] Failed to upload layered PDF: {e}")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        # 7. 备份原始 PDF 文件
        backup_key = f"users/{user_id}/backups/{book_id}_original.pdf"
        try:
            # 先备份原始文件，然后更新 minio_key 指向双层 PDF
            from .storage import copy_object
            
            # 备份原文件（如果还没备份过）
            try:
                read_head(BUCKET, backup_key)
                print(f"[OCR] Backup already exists: {backup_key}")
            except Exception:
                # 备份不存在，创建备份
                upload_bytes(BUCKET, backup_key, pdf_data, "application/pdf")
                print(f"[OCR] Created backup: {backup_key}")
        except Exception as e:
            print(f"[OCR] Warning: Failed to create backup: {e}")
            # 备份失败不影响后续流程
        
        # 8. 更新数据库记录
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            
            # 更新书籍记录：指向双层PDF，并标记OCR完成
            await conn.execute(
                text("""
                    UPDATE books 
                    SET 
                        minio_key = :layered_key,
                        ocr_status = 'completed',
                        ocr_text = :ocr_text,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {
                    "id": book_id,
                    "layered_key": layered_pdf_key,
                    "ocr_text": full_text[:50000] if full_text else "",  # 限制大小
                }
            )
            
            print(f"[OCR] Successfully completed OCR for book {book_id}")
            print(f"[OCR]   Original: {original_minio_key}")
            print(f"[OCR]   Backup: {backup_key}")
            print(f"[OCR]   Layered PDF: {layered_pdf_key}")
        
        # 9. 触发搜索索引（关键！使书籍内容可搜索）
        try:
            from .search_sync import index_book_content
            # 将 OCR 结果转换为搜索索引需要的格式
            # ocr_pages 格式: [{"page_num": 1, "regions": [{"text": "...", "page": 1}, ...], ...}]
            search_regions = []
            for page_info in ocr_pages:
                page_num = page_info.get("page_num", 1)
                for region in page_info.get("regions", []):
                    search_regions.append({
                        "text": region.get("text", ""),
                        "page": page_num
                    })
            index_book_content(book_id, user_id, search_regions)
            print(f"[OCR] Triggered search indexing for book {book_id} with {len(search_regions)} regions")
        except Exception as e:
            print(f"[OCR] Warning: Failed to index book content for search: {e}")
            # 搜索索引失败不影响整体流程
        
        # 10. 通过 WebSocket 通知前端
        try:
            await ws_broadcast(
                f"book:{book_id}",
                json.dumps({
                    "event": "OCR_COMPLETED",
                    "book_id": book_id,
                    "ocr_status": "completed",
                    "layered_pdf_key": layered_pdf_key,
                    "message": "OCR processing completed successfully"
                })
            )
        except Exception as e:
            print(f"[OCR] Warning: Failed to broadcast WebSocket message: {e}")
            # WebSocket 失败不影响整体流程
        
    
    # 调用异步运行函数
    try:
        asyncio.get_event_loop().run_until_complete(_run())
    except Exception as e:
        print(f"[OCR] Task failed with error: {e}")
        import traceback
        traceback.print_exc()
        # 更新状态为失败
        async def _mark_failed():
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
        asyncio.get_event_loop().run_until_complete(_mark_failed())
@shared_task(name="tasks.deep_analyze_book")
def deep_analyze_book(book_id: str, user_id: str):
    import asyncio
    import tempfile
    import os as _os

    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                return
            key = row[0]
            img, conf = _quick_confidence(key)
            
            ocr = get_ocr()
            ocr_res = {"regions": [], "text": ""}
            
            # 判断文件类型
            is_pdf = key.lower().endswith('.pdf')
            
            # 图片尺寸变量（用于存入报告）
            ocr_image_width = 0
            ocr_image_height = 0
            
            if is_pdf:
                # PDF 文件：先转换为图片再 OCR（处理所有页面）
                print(f"[OCR] Processing PDF: {key}")
                pdf_data = read_full(BUCKET, key)
                if pdf_data:
                    # max_pages=0 表示处理所有页面
                    page_images, ocr_image_width, ocr_image_height = _pdf_to_images(pdf_data, max_pages=0, dpi=150)
                    all_text = []
                    all_regions = []
                    total_pages = page_images[0][2] if page_images else 0
                    
                    for page_num, img_bytes, _ in page_images:
                        # 将图片保存到临时文件
                        fd, temp_path = tempfile.mkstemp(suffix='.png')
                        try:
                            _os.write(fd, img_bytes)
                            _os.close(fd)
                            
                            # 对单页进行 OCR
                            page_result = ocr.recognize("", temp_path)  # 直接传本地路径
                            if page_result.get("text"):
                                all_text.append(f"--- Page {page_num} ---")
                                all_text.append(page_result["text"])
                                # 使用 regions（包含坐标信息）
                                for r in page_result.get("regions", []):
                                    r["page"] = page_num
                                    all_regions.append(r)
                            print(f"[OCR] Page {page_num}/{total_pages}: {len(page_result.get('text', ''))} chars, {len(page_result.get('regions', []))} regions")
                        except Exception as e:
                            print(f"[OCR] Page {page_num}/{total_pages} failed: {e}")
                        finally:
                            try:
                                _os.remove(temp_path)
                            except Exception:
                                pass
                    
                    print(f"[OCR] Completed: {len(all_regions)} text regions, {len(''.join(all_text))} total chars")
                    ocr_res = {"regions": all_regions, "text": "\n".join(all_text)}
                    
                    # 触发向量索引任务
                    from .search_sync import index_book_content
                    index_book_content(book_id, user_id, all_regions)
                    print(f"[OCR] Triggered search indexing for book {book_id}")
            else:
                # 图片文件：直接 OCR
                ocr_res = ocr.recognize(BUCKET, key)
            
            rep_key = make_object_key(user_id, f"digitalize-report-{book_id}.json")
            report_data = {
                "is_image_based": img, 
                "confidence": conf, 
                "ocr": ocr_res,
            }
            # 如果有图片尺寸信息，添加到报告中
            if ocr_image_width > 0 and ocr_image_height > 0:
                report_data["image_width"] = ocr_image_width
                report_data["image_height"] = ocr_image_height
            upload_bytes(
                BUCKET,
                rep_key,
                json.dumps(report_data).encode("utf-8"),
                "application/json",
            )
            await conn.execute(
                text(
                    "UPDATE books SET is_digitalized = :dig, digitalize_report_key = :rk, updated_at = now() WHERE id = cast(:id as uuid)"
                ),
                {"dig": (not img and conf >= 0.8), "rk": rep_key, "id": book_id},
            )
        try:
            import json as _j

            asyncio.create_task(
                ws_broadcast(
                    f"book:{book_id}",
                    _j.dumps(
                        {
                            "event": "DEEP_ANALYZED",
                            "digitalized": (not img and conf >= 0.8),
                            "confidence": conf,
                        }
                    ),
                )
            )
        except Exception:
            pass
        try:
            async with engine.begin() as conn2:
                await conn2.execute(
                    _text(
                        "INSERT INTO audit_logs(id, owner_id, action, details) VALUES (gen_random_uuid(), cast(:uid as uuid), :act, cast(:det as jsonb))"
                    ),
                    {
                        "uid": user_id,
                        "act": "task_deep_analyze_book",
                        "det": json.dumps(
                            {
                                "book_id": book_id,
                                "digitalized": (not img and conf >= 0.8),
                                "confidence": conf,
                            }
                        ),
                    },
                )
        except Exception:
            pass

    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.generate_srs_card")
def generate_srs_card(highlight_id: str):
    import asyncio

    async def _run():
        async with engine.begin() as conn:
            res = await conn.execute(
                text(
                    "SELECT user_id::text, comment FROM highlights WHERE id = cast(:id as uuid)"
                ),
                {"id": highlight_id},
            )
            row = res.fetchone()
            if not row:
                return
            user_id = row[0]
            comment = row[1] or ""
            if len(comment) <= 20:
                return
            question = "这段高亮主要表达了什么？"
            answer = comment.strip()
            import uuid as _uuid

            card_id = str(_uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO srs_cards(id, owner_id, highlight_id, question, answer) VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:hid as uuid), :q, :a) ON CONFLICT (highlight_id) DO NOTHING"
                ),
                {
                    "id": card_id,
                    "uid": user_id,
                    "hid": highlight_id,
                    "q": question,
                    "a": answer,
                },
            )
            try:
                import json as _j

                asyncio.create_task(
                    ws_broadcast(
                        f"highlight:{highlight_id}",
                        _j.dumps({"event": "SRS_CARD_CREATED", "card_id": card_id}),
                    )
                )
            except Exception:
                pass

    asyncio.get_event_loop().run_until_complete(_run())


==================================================
FILE_PATH: api/app/billing.py
==================================================

import hashlib
import hmac
import logging
import os
import uuid

from fastapi import APIRouter, Body, Depends, Header, HTTPException, Request
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/billing", tags=["billing"])


def _sig_ok(secret: str, body: bytes, sig: str | None) -> bool:
    if not secret or not sig:
        return False
    mac = hmac.new(secret.encode(), body, hashlib.sha256).hexdigest()
    return hmac.compare_digest(mac, sig)


@router.get("/balance")
async def get_balance(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
            )
        )
        res = await conn.execute(
            text(
                "SELECT owner_id::text, balance, currency, wallet_amount, wallet_currency, updated_at FROM credit_accounts WHERE owner_id = current_setting('app.user_id')::uuid"
            )
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=500, detail="account_missing")
        return {
            "status": "success",
            "data": {
                "owner_id": row[0],
                "balance": int(row[1]),
                "currency": row[2],
                "wallet_amount": float(row[3] or 0),
                "wallet_currency": row[4],
                "updated_at": str(row[5]),
            },
        }


@router.get("/ledger")
async def list_ledger(limit: int = 50, offset: int = 0, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, amount, currency, reason, related_id::text, direction, created_at FROM credit_ledger WHERE owner_id = current_setting('app.user_id')::uuid ORDER BY created_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "amount": int(r[1]),
                    "currency": r[2],
                    "reason": r[3],
                    "related_id": r[4],
                    "direction": r[5],
                    "created_at": str(r[6]),
                }
                for r in rows
            ],
        }


@router.get("/products")
async def list_products(limit: int = 50, offset: int = 0, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, code, name, credits, amount_minor, currency, updated_at FROM credit_products ORDER BY updated_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "code": r[1],
                    "name": r[2],
                    "credits": int(r[3]),
                    "amount_minor": int(r[4]),
                    "currency": r[5],
                    "updated_at": str(r[6]),
                }
                for r in rows
            ],
        }


@router.post("/sessions")
async def create_session(payload: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    gateway = payload.get("gateway")
    amount = payload.get("amount")
    currency = payload.get("currency") or "CNY"
    if not gateway or not isinstance(amount, int) or amount <= 0:
        raise HTTPException(status_code=400, detail="invalid_request")
    sid = str(uuid.uuid4())
    ret_url = payload.get("return_url") or os.getenv(
        "PAY_RETURN_URL", "https://localhost/return"
    )
    cancel_url = payload.get("cancel_url") or os.getenv(
        "PAY_CANCEL_URL", "https://localhost/cancel"
    )
    meta = payload.get("metadata")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO payment_sessions(id, owner_id, gateway, amount, currency, status, return_url, cancel_url, metadata) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :g, :a, :c, 'pending', :r, :x, cast(:m as jsonb))"
            ),
            {
                "id": sid,
                "g": gateway,
                "a": amount,
                "c": currency,
                "r": ret_url,
                "x": cancel_url,
                "m": meta,
            },
        )
    pay_url = f"https://pay.local/{gateway}/{sid}"
    return {"status": "success", "data": {"id": sid, "payment_url": pay_url}}


@router.post("/webhook/{gateway}")
async def webhook(
    gateway: str, request: Request, x_signature: str | None = Header(None)
):
    # 统一签名读取与校验
    secret = os.getenv(f"PAY_{gateway.upper()}_WEBHOOK_SECRET", "")
    body = await request.body()
    x_sig = (
        request.headers.get("x-signature")
        or request.headers.get("x_signature")
        or x_signature
    )
    if not _sig_ok(secret, body, x_sig):
        raise HTTPException(status_code=401, detail="bad_signature")

    try:
        payload = await request.json()
        logging.info(f"[WEBHOOK] gateway={gateway} payload={payload}")
        event_id = str(payload.get("event_id") or uuid.uuid4())
        session_id = payload.get("session_id")
        amount = payload.get("amount")
        status = payload.get("status")
        external_id = str(payload.get("external_id") or "")
        async with engine.begin() as conn:
            await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
            logging.info("[WEBHOOK] ensure tables & set role=admin")
            logging.info(f"[WEBHOOK] UPSERT event id={event_id}")
            import json as _json

            await conn.execute(
                text(
                    "INSERT INTO payment_webhook_events(id, gateway, session_id, payload, processed) VALUES (:id, :gw, cast(:sid as uuid), cast(:p as jsonb), FALSE) ON CONFLICT (id) DO NOTHING"
                ),
                {
                    "id": event_id,
                    "gw": gateway,
                    "sid": session_id,
                    "p": _json.dumps(payload),
                },
            )
            logging.info(f"[WEBHOOK] Query session owner sid={session_id}")
            res = await conn.execute(
                text(
                    "SELECT owner_id FROM payment_sessions WHERE id = cast(:sid as uuid)"
                ),
                {"sid": session_id},
            )
            row = res.fetchone()
            if not row:
                logging.error(f"[WEBHOOK] session_not_found sid={session_id}")
                raise HTTPException(status_code=404, detail="session_not_found")
            owner_id = str(row[0])
            logging.info(
                f"[WEBHOOK] Update session status={status} external_id={external_id}"
            )
            await conn.execute(
                text(
                    "UPDATE payment_sessions SET status = :st, external_id = :ext, updated_at = now() WHERE id = cast(:sid as uuid)"
                ),
                {"st": status, "ext": external_id, "sid": session_id},
            )
            if status == "succeeded" and isinstance(amount, int) and amount > 0:
                logging.info(
                    f"[WEBHOOK] Credit account owner={owner_id} amount={amount}"
                )
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": owner_id}
                )
                await conn.execute(
                    text(
                        "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
                    )
                )
                await conn.execute(
                    text(
                        "UPDATE credit_accounts SET balance = balance + :amt, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                    ),
                    {"amt": amount},
                )
                lid = str(uuid.uuid4())
                await conn.execute(
                    text(
                        "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, related_id, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CNY', 'payment', cast(:rid as uuid), 'credit')"
                    ),
                    {"id": lid, "amt": amount, "rid": session_id},
                )
            logging.info(f"[WEBHOOK] Mark event processed id={event_id}")
            await conn.execute(
                text(
                    "UPDATE payment_webhook_events SET processed = TRUE, updated_at = now() WHERE id = :id"
                ),
                {"id": event_id},
            )
        return {"status": "success"}
    except Exception as e:
        logging.exception(f"[WEBHOOK] Unexpected error: {e}")
        raise


@router.post("/consume")
async def consume_credit(payload: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    amount = payload.get("amount")
    reason = payload.get("reason") or "consume"
    if not isinstance(amount, int) or amount <= 0:
        raise HTTPException(status_code=400, detail="invalid_amount")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
            )
        )
        dec = await conn.execute(
            text(
                "UPDATE credit_accounts SET balance = balance - :amt, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid AND balance >= :amt RETURNING balance"
            ),
            {"amt": amount},
        )
        row = dec.fetchone()
        if not row:
            raise HTTPException(status_code=400, detail="insufficient_balance")
        lid = str(uuid.uuid4())
        await conn.execute(
            text(
                "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CNY', :r, 'debit')"
            ),
            {"id": lid, "amt": amount, "r": reason},
        )
    return {"status": "success"}


@router.post("/exchange")
async def exchange(payload: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    direction = payload.get("direction")  # wallet_to_credits | credits_to_wallet
    amount = payload.get("amount")
    if (
        direction not in ("wallet_to_credits", "credits_to_wallet")
        or not isinstance(amount, (int, float))
        or amount <= 0
    ):
        raise HTTPException(status_code=400, detail="invalid_request")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
            )
        )
        sres = await conn.execute(
            text("SELECT value FROM system_settings WHERE key = 'wallet_exchange_rate'")
        )
        srow = sres.fetchone()
        val = srow and srow[0]
        rate = None
        if isinstance(val, (int, float, str)):
            try:
                rate = float(val)
            except Exception:
                rate = None
        if rate is None:
            curres = await conn.execute(
                text(
                    "SELECT wallet_currency FROM credit_accounts WHERE owner_id = current_setting('app.user_id')::uuid"
                )
            )
            currow = curres.fetchone()
            wc = (currow and currow[0]) or "CNY"
            try:
                rate = float((val or {}).get(wc) or (val or {}).get("default") or 100.0)
            except Exception:
                rate = 100.0
        if direction == "wallet_to_credits":
            credits = int(round(amount * rate))
            upd = await conn.execute(
                text(
                    "UPDATE credit_accounts SET wallet_amount = wallet_amount - :amt, balance = balance + :cr, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid AND wallet_amount >= :amt RETURNING wallet_amount, balance"
                ),
                {"amt": amount, "cr": credits},
            )
            if not upd.fetchone():
                raise HTTPException(status_code=400, detail="insufficient_wallet")
            lid1 = str(uuid.uuid4())
            lid2 = str(uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CNY', 'exchange_wallet_to_credits', 'debit')"
                ),
                {"id": lid1, "amt": int(round(amount * 100))},
            )
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CREDITS', 'exchange_wallet_to_credits', 'credit')"
                ),
                {"id": lid2, "amt": credits},
            )
        else:
            credits = int(amount)
            money = float(round(credits / rate, 2))
            upd = await conn.execute(
                text(
                    "UPDATE credit_accounts SET balance = balance - :cr, wallet_amount = wallet_amount + :amt, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid AND balance >= :cr RETURNING balance, wallet_amount"
                ),
                {"cr": credits, "amt": money},
            )
            if not upd.fetchone():
                raise HTTPException(status_code=400, detail="insufficient_credits")
            lid1 = str(uuid.uuid4())
            lid2 = str(uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CREDITS', 'exchange_credits_to_wallet', 'debit')"
                ),
                {"id": lid1, "amt": credits},
            )
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CNY', 'exchange_credits_to_wallet', 'credit')"
                ),
                {"id": lid2, "amt": int(round(money * 100))},
            )
    return {"status": "success"}


@router.post("/debug/grant-credits")
async def grant_credits(payload: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    if os.getenv("DEV_MODE", "false").lower() != "true":
        raise HTTPException(status_code=403, detail="forbidden")
    kind = (payload.get("kind") or "credits").lower()
    amount = payload.get("amount")
    if not isinstance(amount, (int, float)) or amount <= 0:
        raise HTTPException(status_code=400, detail="invalid_amount")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
            )
        )
        if kind == "wallet":
            money = float(amount)
            await conn.execute(
                text(
                    "UPDATE credit_accounts SET wallet_amount = wallet_amount + :m, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                ),
                {"m": money},
            )
            lid = str(uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CNY', 'debug_grant_wallet', 'credit')"
                ),
                {"id": lid, "amt": int(round(money * 100))},
            )
        else:
            credits = int(amount)
            await conn.execute(
                text(
                    "UPDATE credit_accounts SET balance = balance + :cr, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                ),
                {"cr": credits},
            )
            lid = str(uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, 'CREDITS', 'debug_grant_credits', 'credit')"
                ),
                {"id": lid, "amt": credits},
            )
    return {"status": "success"}


@router.post("/iap/verify")
async def verify_iap(payload: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    receipt = payload.get("receipt")
    platform = payload.get("platform")  # apple | google
    if not receipt or not platform:
        raise HTTPException(status_code=400, detail="missing_receipt_or_platform")
    
    # 待办：与苹果/谷歌官方接口进行真实凭据校验
    # 目前：仅记录日志，若为沙盒凭据则返回成功（占位实现）
    logging.info(f"[IAP] Verify {platform} receipt for user {user_id}")
    
    valid = False
    # Mock validation logic
    if platform == "apple" and len(receipt) > 10:
        valid = True
    elif platform == "google" and len(receipt) > 10:
        valid = True
        
    if not valid:
         raise HTTPException(status_code=400, detail="invalid_receipt")
         
    return {"status": "success", "data": {"valid": True}}


==================================================
FILE_PATH: api/app/search_sync.py
==================================================

import os
import time

import requests
from celery import shared_task

ES_URL = os.getenv("ES_URL", "http://opensearch:9200")
NOTES_INDEX = os.getenv("ES_INDEX_NOTES", "notes")
HIGHLIGHTS_INDEX = os.getenv("ES_INDEX_HIGHLIGHTS", "highlights")
BOOKS_INDEX = os.getenv("ES_INDEX_BOOKS", "books")
BOOK_CONTENT_INDEX = os.getenv("ES_INDEX_BOOK_CONTENT", "book_content")


def _put(url: str, payload: dict):
    try:
        resp = requests.put(url, json=payload, timeout=5)
        resp.raise_for_status()
    except Exception:
        raise


def _delete(url: str):
    try:
        resp = requests.delete(url, timeout=5)
        resp.raise_for_status()
    except Exception:
        raise


def _bulk(index: str, docs: list[dict]):
    """批量索引文档"""
    if not docs:
        return
    try:
        lines = []
        for doc in docs:
            doc_id = doc.get("id")
            lines.append(f'{{"index": {{"_index": "{index}", "_id": "{doc_id}"}}}}')
            lines.append(requests.compat.json.dumps(doc, ensure_ascii=False))
        body = "\n".join(lines) + "\n"
        resp = requests.post(
            f"{ES_URL}/_bulk",
            data=body.encode("utf-8"),
            headers={"Content-Type": "application/x-ndjson"},
            timeout=30,
        )
        resp.raise_for_status()
        result = resp.json()
        if result.get("errors"):
            print(f"[Search] Bulk index had errors: {result}")
    except Exception as e:
        print(f"[Search] Bulk index failed: {e}")
        raise


@shared_task(
    bind=True,
    name="search.index_note",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 8},
)
def task_index_note(
    self, id: str, user_id: str, book_id: str, content: str, tags: list[str] | None
):
    if not ES_URL:
        return
    doc = {
        "id": id,
        "user_id": user_id,
        "book_id": book_id,
        "content": content,
        "tag_ids": tags or [],
        "updated_at": int(time.time() * 1000),
    }
    url = f"{ES_URL}/{NOTES_INDEX}/_doc/{id}"
    _put(url, doc)


@shared_task(
    bind=True,
    name="search.delete_note",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 8},
)
def task_delete_note(self, id: str):
    if not ES_URL:
        return
    url = f"{ES_URL}/{NOTES_INDEX}/_doc/{id}"
    _delete(url)


@shared_task(
    bind=True,
    name="search.index_highlight",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 8},
)
def task_index_highlight(
    self,
    id: str,
    user_id: str,
    book_id: str,
    comment: str,
    color: str,
    tags: list[str] | None,
):
    if not ES_URL:
        return
    doc = {
        "id": id,
        "user_id": user_id,
        "book_id": book_id,
        "text_content": comment or "",
        "color": color or "",
        "tag_ids": tags or [],
        "updated_at": int(time.time() * 1000),
    }
    url = f"{ES_URL}/{HIGHLIGHTS_INDEX}/_doc/{id}"
    _put(url, doc)


@shared_task(
    bind=True,
    name="search.delete_highlight",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 8},
)
def task_delete_highlight(self, id: str):
    if not ES_URL:
        return
    url = f"{ES_URL}/{HIGHLIGHTS_INDEX}/_doc/{id}"
    _delete(url)


@shared_task(
    bind=True,
    name="search.index_book",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 8},
)
def task_index_book(self, id: str, user_id: str, title: str, author: str):
    if not ES_URL:
        return
    doc = {
        "id": id,
        "user_id": user_id,
        "title": title or "",
        "author": author or "",
        "updated_at": int(time.time() * 1000),
    }
    url = f"{ES_URL}/{BOOKS_INDEX}/_doc/{id}"
    _put(url, doc)


@shared_task(
    bind=True,
    name="search.delete_book",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 8},
)
def task_delete_book(self, id: str):
    if not ES_URL:
        return
    url = f"{ES_URL}/{BOOKS_INDEX}/_doc/{id}"
    _delete(url)


@shared_task(
    bind=True,
    name="search.index_book_content",
    autoretry_for=(Exception,),
    retry_backoff=True,
    retry_kwargs={"max_retries": 5},
)
def task_index_book_content(self, book_id: str, user_id: str, ocr_pages: list[dict]):
    """
    索引书籍 OCR 内容，按页分段存储
    每页作为一个文档，支持全文搜索
    """
    if not ES_URL:
        return
    
    # 确保索引存在
    try:
        mapping = {
            "mappings": {
                "properties": {
                    "book_id": {"type": "keyword"},
                    "user_id": {"type": "keyword"},
                    "page": {"type": "integer"},
                    "content": {
                        "type": "text",
                        "analyzer": "ik_max_word",
                        "search_analyzer": "ik_smart"
                    },
                    "updated_at": {"type": "date", "format": "epoch_millis"}
                }
            }
        }
        requests.put(f"{ES_URL}/{BOOK_CONTENT_INDEX}", json=mapping, timeout=10)
    except Exception:
        pass  # 索引可能已存在
    
    # 按页分组内容
    page_docs = {}
    for item in ocr_pages:
        page_num = item.get("page", 1)
        text = item.get("text", "")
        if text:
            if page_num not in page_docs:
                page_docs[page_num] = []
            page_docs[page_num].append(text)
    
    # 创建批量索引文档
    docs = []
    now = int(time.time() * 1000)
    for page_num, texts in page_docs.items():
        doc_id = f"{book_id}_p{page_num}"
        docs.append({
            "id": doc_id,
            "book_id": book_id,
            "user_id": user_id,
            "page": page_num,
            "content": "\n".join(texts),
            "updated_at": now,
        })
    
    # 分批索引（每批 100 个文档）
    batch_size = 100
    for i in range(0, len(docs), batch_size):
        batch = docs[i:i + batch_size]
        _bulk(BOOK_CONTENT_INDEX, batch)
    
    print(f"[Search] Indexed {len(docs)} pages for book {book_id}")


def index_note(
    id: str, user_id: str, book_id: str, content: str, tags: list[str] | None
):
    if not ES_URL:
        return
    try:
        task_index_note.delay(id, user_id, book_id, content, tags)
    except Exception:
        pass


def delete_note(id: str):
    if not ES_URL:
        return
    try:
        task_delete_note.delay(id)
    except Exception:
        pass


def index_highlight(
    id: str,
    user_id: str,
    book_id: str,
    comment: str,
    color: str,
    tags: list[str] | None,
):
    if not ES_URL:
        return
    try:
        task_index_highlight.delay(id, user_id, book_id, comment, color, tags)
    except Exception:
        pass


def delete_highlight(id: str):
    if not ES_URL:
        return
    try:
        task_delete_highlight.delay(id)
    except Exception:
        pass


def index_book(id: str, user_id: str, title: str, author: str):
    if not ES_URL:
        return
    try:
        task_index_book.delay(id, user_id, title, author)
    except Exception:
        pass


def delete_book(id: str):
    if not ES_URL:
        return
    try:
        task_delete_book.delay(id)
    except Exception:
        pass


def index_book_content(book_id: str, user_id: str, ocr_pages: list[dict]):
    """索引书籍 OCR 内容"""
    if not ES_URL:
        return
    try:
        task_index_book_content.delay(book_id, user_id, ocr_pages)
    except Exception:
        pass


==================================================
FILE_PATH: api/app/mailer.py
==================================================

import os
import smtplib
from email.mime.text import MIMEText


def send_email(to_addr: str, subject: str, body: str):
    host = os.getenv("SMTP_HOST", "")
    port = int(os.getenv("SMTP_PORT", "0") or "0")
    user = os.getenv("SMTP_USER", "")
    password = os.getenv("SMTP_PASSWORD", "")
    from_addr = os.getenv("SMTP_FROM_EMAIL", user or "")
    use_ssl = os.getenv("SMTP_USE_SSL", "false").lower() == "true"
    if not host or not port or not user or not password or not from_addr:
        if os.getenv("DEV_MODE", "false").lower() == "true":
            return
        raise RuntimeError("smtp_not_configured")
    msg = MIMEText(body, "plain", "utf-8")
    msg["Subject"] = subject
    msg["From"] = from_addr
    msg["To"] = to_addr
    if use_ssl:
        server = smtplib.SMTP_SSL(host, port or 465)
    else:
        server = smtplib.SMTP(host, port or 587)
        server.ehlo()
        try:
            server.starttls()
        except Exception:
            pass
    server.login(user, password)
    server.sendmail(from_addr, [to_addr], msg.as_string())
    server.quit()


==================================================
FILE_PATH: api/app/notes.py
==================================================

"""
笔记、标签与高亮接口

职责：
- Tags：创建/列表/更新/删除（ETag 并发控制，幂等键支持）
- Notes：创建/列表/获取/更新/删除（全文索引同步）
- Highlights：创建/列表/更新/删除（全文索引同步）
- 冲突处理：列出冲突、基于用户选择进行解决并更新索引

说明：
- 仅新增注释，不改动业务逻辑与存储结构
"""
import base64
import os
import uuid
from datetime import timedelta

import redis
from fastapi import APIRouter, Body, Depends, Header, HTTPException, Query, Response
from sqlalchemy import text

from .auth import require_user
from .celery_app import celery_app
from .db import engine
from .dependencies import require_write_permission
from .search_sync import delete_highlight as delete_highlight_from_index
from .search_sync import delete_note as delete_note_from_index
from .search_sync import index_highlight, index_note

REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)


notes_router = APIRouter(prefix="/api/v1/notes", tags=["notes"])
tags_router = APIRouter(prefix="/api/v1/tags", tags=["tags"])
highlights_router = APIRouter(prefix="/api/v1/highlights", tags=["highlights"])


def encode_cursor(ts: str, id_: str) -> str:
    return base64.urlsafe_b64encode(f"{ts}|{id_}".encode()).decode()


def decode_cursor(cur: str) -> tuple[str, str]:
    s = base64.urlsafe_b64decode(cur.encode()).decode()
    a, b = s.split("|", 1)
    return a, b


@tags_router.post("")
async def create_tag(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    name = body.get("name")
    if not name:
        raise HTTPException(status_code=400, detail="missing_name")
    if idempotency_key:
        v = r.get(f"idem:{idempotency_key}")
        if v:
            return {"status": "success", "data": {"id": v}}
    tag_id = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO tags(id, user_id, name) VALUES (cast(:id as uuid), cast(:uid as uuid), :name) ON CONFLICT (user_id, name) WHERE deleted_at IS NULL DO NOTHING"
            ),
            {"id": tag_id, "uid": user_id, "name": name},
        )
    if idempotency_key:
        r.setex(
            f"idem:{idempotency_key}", int(timedelta(hours=24).total_seconds()), tag_id
        )
    return {"status": "success", "data": {"id": tag_id}}


@tags_router.get("")
async def list_tags(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, name, updated_at, version FROM tags WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL ORDER BY updated_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "name": r[1],
                    "updated_at": str(r[2]),
                    "etag": f'W/"{int(r[3])}"',
                }
                for r in rows
            ],
        }


@tags_router.patch("/{tag_id}")
async def update_tag(
    tag_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    name = body.get("name")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "UPDATE tags SET name = COALESCE(:name, name), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND deleted_at IS NULL AND version = :ver"
            ),
            {"name": name, "id": tag_id, "ver": current_version},
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


@tags_router.delete("/{tag_id}")
async def delete_tag(tag_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE tags SET deleted_at = now(), updated_at = now(), version = version + 1 WHERE id = cast(:id as uuid) AND deleted_at IS NULL"
            ),
            {"id": tag_id},
        )
    return {"status": "success"}


@notes_router.post("")
async def create_note(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    book_id = body.get("book_id")
    content = body.get("content")
    tags = body.get("tags") or []
    if not book_id or not content:
        raise HTTPException(status_code=400, detail="invalid_payload")
    if idempotency_key:
        v = r.get(f"idem:{idempotency_key}")
        if v:
            return {"status": "success", "data": {"id": v}}
    note_id = str(uuid.uuid4())
    chapter = body.get("chapter")
    location = body.get("location")
    offset = body.get("offset")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO notes(id, user_id, book_id, content, chapter, location, pos_offset, tsv) VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:bid as uuid), :content, :chapter, :location, :offset, to_tsvector('simple', coalesce(:content,'') || ' ' || coalesce(:chapter,'')))"
            ),
            {
                "id": note_id,
                "uid": user_id,
                "bid": book_id,
                "content": content,
                "chapter": chapter,
                "location": location,
                "offset": offset,
            },
        )
        if tags:
            for t in tags:
                await conn.execute(
                    text(
                        "INSERT INTO note_tags(note_id, tag_id) VALUES (cast(:nid as uuid), cast(:tid as uuid)) ON CONFLICT DO NOTHING"
                    ),
                    {"nid": note_id, "tid": t},
                )
    if idempotency_key:
        r.setex(
            f"idem:{idempotency_key}", int(timedelta(hours=24).total_seconds()), note_id
        )
    index_note(note_id, user_id, book_id, content, tags)
    return {"status": "success", "data": {"id": note_id}}


@notes_router.get("")
async def list_notes(
    limit: int = Query(20, ge=1, le=100),
    cursor: str | None = Query(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        if cursor:
            ts, nid = decode_cursor(cursor)
            res = await conn.execute(
                text(
                    "SELECT id::text, content, book_id::text, chapter, location, pos_offset, updated_at, version FROM notes WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL AND (updated_at, id) < (cast(:ts as timestamptz), cast(:id as uuid)) ORDER BY updated_at DESC, id DESC LIMIT :limit"
                ),
                {"ts": ts, "id": nid, "limit": limit},
            )
        else:
            res = await conn.execute(
                text(
                    "SELECT id::text, content, book_id::text, chapter, location, pos_offset, updated_at, version FROM notes WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL ORDER BY updated_at DESC, id DESC LIMIT :limit"
                ),
                {"limit": limit},
            )
        rows = res.fetchall()
        data = []
        next_cursor = None
        for r in rows:
            data.append(
                {
                    "id": r[0],
                    "content": r[1],
                    "book_id": r[2],
                    "chapter": r[3],
                    "location": r[4],
                    "offset": r[5],
                    "updated_at": str(r[6]),
                    "etag": f'W/"{int(r[7])}"',
                }
            )
        if rows:
            last = rows[-1]
            next_cursor = encode_cursor(str(last[6]), str(last[0]))
        return {"status": "success", "data": data, "next_cursor": next_cursor}


@notes_router.get("/{note_id}")
async def get_note(note_id: str, auth=Depends(require_user), response: Response = None):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, content, book_id::text, chapter, location, pos_offset, updated_at, version FROM notes WHERE id = cast(:id as uuid) AND deleted_at IS NULL"
            ),
            {"id": note_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        if response is not None:
            response.headers["ETag"] = f'W/"{int(row[7])}"'
        return {
            "status": "success",
            "data": {
                "id": row[0],
                "content": row[1],
                "book_id": row[2],
                "chapter": row[3],
                "location": row[4],
                "offset": row[5],
                "updated_at": str(row[6]),
                "etag": f'W/"{int(row[7])}"',
            },
        }


@notes_router.patch("/{note_id}")
async def update_note(
    note_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    content = body.get("content")
    chapter = body.get("chapter")
    location = body.get("location")
    offset = body.get("offset")
    tags = body.get("tags")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "UPDATE notes SET content = COALESCE(:content, content), chapter = COALESCE(:chapter, chapter), location = COALESCE(:location, location), pos_offset = COALESCE(:offset, pos_offset), tsv = to_tsvector('simple', coalesce(COALESCE(:content, content),'') || ' ' || coalesce(COALESCE(:chapter, chapter),'')), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND deleted_at IS NULL AND version = :ver"
            ),
            {
                "content": content,
                "chapter": chapter,
                "location": location,
                "offset": offset,
                "id": note_id,
                "ver": current_version,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
        if isinstance(tags, list):
            await conn.execute(
                text("DELETE FROM note_tags WHERE note_id = cast(:nid as uuid)"),
                {"nid": note_id},
            )
            for t in tags:
                await conn.execute(
                    text(
                        "INSERT INTO note_tags(note_id, tag_id) VALUES (cast(:nid as uuid), cast(:tid as uuid)) ON CONFLICT DO NOTHING"
                    ),
                    {"nid": note_id, "tid": t},
                )
    index_note(
        note_id,
        user_id,
        None or "",
        content or "",
        tags if isinstance(tags, list) else None,
    )
    return {"status": "success"}


@notes_router.delete("/{note_id}")
async def delete_note(note_id: str, quota=Depends(require_write_permission), auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE notes SET deleted_at = now(), updated_at = now(), version = version + 1 WHERE id = cast(:id as uuid) AND deleted_at IS NULL"
            ),
            {"id": note_id},
        )
    delete_note_from_index(note_id)
    return {"status": "success"}


@highlights_router.post("")
async def create_highlight(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    book_id = body.get("book_id")
    start_location = body.get("start_location")
    end_location = body.get("end_location")
    color = body.get("color")
    comment = body.get("comment")
    tags = body.get("tags") or []
    if not book_id or start_location is None or end_location is None:
        raise HTTPException(status_code=400, detail="invalid_payload")
    if idempotency_key:
        v = r.get(f"idem:{idempotency_key}")
        if v:
            return {"status": "success", "data": {"id": v}}
    hid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO highlights(id, user_id, book_id, start_location, end_location, color, comment, tsv) VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:bid as uuid), :s, :e, :c, :m, to_tsvector('simple', coalesce(:c,'') || ' ' || coalesce(:m,'')))"
            ),
            {
                "id": hid,
                "uid": user_id,
                "bid": book_id,
                "s": start_location,
                "e": end_location,
                "c": color,
                "m": comment,
            },
        )
        for t in tags:
            await conn.execute(
                text(
                    "INSERT INTO highlight_tags(highlight_id, tag_id) VALUES (cast(:hid as uuid), cast(:tid as uuid)) ON CONFLICT DO NOTHING"
                ),
                {"hid": hid, "tid": t},
            )
    if idempotency_key:
        r.setex(
            f"idem:{idempotency_key}", int(timedelta(hours=24).total_seconds()), hid
        )
    index_highlight(hid, user_id, book_id, comment or "", color or "", tags)
    try:
        celery_app.send_task("tasks.generate_srs_card", args=[hid])
    except Exception:
        pass
    return {"status": "success", "data": {"id": hid}}


@highlights_router.get("")
async def list_highlights(
    book_id: str | None = Query(None),
    limit: int = Query(20, ge=1, le=100),
    cursor: str | None = Query(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        base = "SELECT id::text, book_id::text, start_location, end_location, color, comment, updated_at, version FROM highlights WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL"
        params = {}
        if book_id:
            base += " AND book_id = cast(:bid as uuid)"
            params["bid"] = book_id
        if cursor:
            ts, hid = decode_cursor(cursor)
            base += (
                " AND (updated_at, id) < (cast(:ts as timestamptz), cast(:id as uuid))"
            )
            params["ts"] = ts
            params["id"] = hid
        base += " ORDER BY updated_at DESC, id DESC LIMIT :limit"
        params["limit"] = limit
        res = await conn.execute(text(base), params)
        rows = res.fetchall()
        data = []
        next_cursor = None
        for r in rows:
            data.append(
                {
                    "id": r[0],
                    "book_id": r[1],
                    "start_location": r[2],
                    "end_location": r[3],
                    "color": r[4],
                    "comment": r[5],
                    "updated_at": str(r[6]),
                    "etag": f'W/"{int(r[7])}"',
                }
            )
        if rows:
            last = rows[-1]
            next_cursor = encode_cursor(str(last[6]), str(last[0]))
        return {"status": "success", "data": data, "next_cursor": next_cursor}


@highlights_router.patch("/{highlight_id}")
async def update_highlight(
    highlight_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    color = body.get("color")
    comment = body.get("comment")
    tags = body.get("tags")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "UPDATE highlights SET color = COALESCE(:color, color), comment = COALESCE(:comment, comment), tsv = to_tsvector('simple', coalesce(COALESCE(:color, color),'') || ' ' || coalesce(COALESCE(:comment, comment),'')), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND deleted_at IS NULL AND version = :ver"
            ),
            {
                "color": color,
                "comment": comment,
                "id": highlight_id,
                "ver": current_version,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
        if isinstance(tags, list):
            await conn.execute(
                text(
                    "DELETE FROM highlight_tags WHERE highlight_id = cast(:hid as uuid)"
                ),
                {"hid": highlight_id},
            )
            for t in tags:
                await conn.execute(
                    text(
                        "INSERT INTO highlight_tags(highlight_id, tag_id) VALUES (cast(:hid as uuid), cast(:tid as uuid)) ON CONFLICT DO NOTHING"
                    ),
                    {"hid": highlight_id, "tid": t},
                )
    index_highlight(
        highlight_id,
        user_id,
        None or "",
        comment or "",
        color or "",
        tags if isinstance(tags, list) else None,
    )
    return {"status": "success"}


@highlights_router.delete("/{highlight_id}")
async def delete_highlight(highlight_id: str, quota=Depends(require_write_permission), auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE highlights SET deleted_at = now(), updated_at = now(), version = version + 1 WHERE id = cast(:id as uuid) AND deleted_at IS NULL"
            ),
            {"id": highlight_id},
        )
    delete_highlight_from_index(highlight_id)
    return {"status": "success"}


# =============================================
# 笔记冲突处理 API (ADR-006)
# =============================================

@notes_router.get("/conflicts")
async def list_note_conflicts(auth=Depends(require_user)):
    """
    获取当前用户所有存在冲突的笔记。
    
    冲突笔记是指 conflict_of IS NOT NULL 的记录，表示该笔记是某个原始笔记的冲突副本。
    返回原始笔记和冲突副本的配对信息，供用户在 UI 上选择保留哪个版本。
    """
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 查询所有冲突副本及其原始笔记
        res = await conn.execute(
            text("""
                SELECT 
                    orig.id::text as original_id,
                    orig.content as original_content,
                    orig.updated_at as original_updated_at,
                    orig.device_id as original_device_id,
                    conflict.id::text as conflict_copy_id,
                    conflict.content as conflict_content,
                    conflict.updated_at as conflict_updated_at,
                    conflict.device_id as conflict_device_id,
                    orig.book_id::text as book_id,
                    b.title as book_title
                FROM notes conflict
                JOIN notes orig ON conflict.conflict_of = orig.id
                JOIN books b ON orig.book_id = b.id
                WHERE conflict.user_id = current_setting('app.user_id')::uuid
                  AND conflict.conflict_of IS NOT NULL
                  AND conflict.deleted_at IS NULL
                  AND orig.deleted_at IS NULL
                ORDER BY conflict.updated_at DESC
            """)
        )
        rows = res.fetchall()
        
        conflicts = []
        for r in rows:
            conflicts.append({
                "originalId": r[0],
                "originalContent": r[1],
                "originalUpdatedAt": str(r[2]) if r[2] else None,
                "originalDeviceId": r[3],
                "conflictCopyId": r[4],
                "conflictContent": r[5],
                "conflictUpdatedAt": str(r[6]) if r[6] else None,
                "conflictDeviceId": r[7],
                "bookId": r[8],
                "bookTitle": r[9]
            })
        
        return {"conflicts": conflicts}


@notes_router.post("/{note_id}/resolve-conflict")
async def resolve_note_conflict(
    note_id: str,
    body: dict = Body(...),
    auth=Depends(require_user),
):
    """
    解决笔记冲突。用户选择保留哪个版本或手动合并。
    
    Request Body:
    {
        "resolution": "keep_original" | "keep_conflict" | "merge",
        "mergedContent"?: string  // 仅当 resolution=merge 时需要
    }
    
    处理逻辑:
    - keep_original: 删除冲突副本，保留原始笔记
    - keep_conflict: 用冲突副本内容更新原始笔记，然后删除冲突副本
    - merge: 用 mergedContent 更新原始笔记，然后删除冲突副本
    """
    user_id, _ = auth
    resolution = body.get("resolution")
    merged_content = body.get("mergedContent")
    
    if resolution not in ("keep_original", "keep_conflict", "merge"):
        raise HTTPException(status_code=400, detail="invalid_resolution")
    
    if resolution == "merge" and not merged_content:
        raise HTTPException(status_code=400, detail="merged_content_required")
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 检查 note_id 是否是冲突副本
        res = await conn.execute(
            text("""
                SELECT id, conflict_of, content
                FROM notes
                WHERE id = cast(:id as uuid)
                  AND user_id = current_setting('app.user_id')::uuid
                  AND deleted_at IS NULL
            """),
            {"id": note_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="note_not_found")
        
        note_id_db, conflict_of, conflict_content = row
        
        if not conflict_of:
            raise HTTPException(status_code=400, detail="not_a_conflict_copy")
        
        original_id = str(conflict_of)
        
        if resolution == "keep_original":
            # 删除冲突副本，保留原始笔记
            await conn.execute(
                text("""
                    UPDATE notes SET deleted_at = now(), updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {"id": note_id},
            )
            final_content = None  # 保留原始内容，不需要获取
            
        elif resolution == "keep_conflict":
            # 用冲突副本内容更新原始笔记
            await conn.execute(
                text("""
                    UPDATE notes SET 
                        content = :content,
                        tsv = to_tsvector('simple', coalesce(:content, '')),
                        version = version + 1,
                        updated_at = now()
                    WHERE id = cast(:orig_id as uuid)
                """),
                {"content": conflict_content, "orig_id": original_id},
            )
            # 删除冲突副本
            await conn.execute(
                text("""
                    UPDATE notes SET deleted_at = now(), updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {"id": note_id},
            )
            final_content = conflict_content
            
        else:  # merge
            # 用合并内容更新原始笔记
            await conn.execute(
                text("""
                    UPDATE notes SET 
                        content = :content,
                        tsv = to_tsvector('simple', coalesce(:content, '')),
                        version = version + 1,
                        updated_at = now()
                    WHERE id = cast(:orig_id as uuid)
                """),
                {"content": merged_content, "orig_id": original_id},
            )
            # 删除冲突副本
            await conn.execute(
                text("""
                    UPDATE notes SET deleted_at = now(), updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {"id": note_id},
            )
            final_content = merged_content
        
        # 获取最终的笔记内容
        if final_content is None:
            final_res = await conn.execute(
                text("SELECT content FROM notes WHERE id = cast(:id as uuid)"),
                {"id": original_id},
            )
            final_row = final_res.fetchone()
            final_content = final_row[0] if final_row else ""
    
    # 删除冲突副本的搜索索引
    delete_note_from_index(note_id)
    
    return {
        "noteId": original_id,
        "content": final_content,
        "resolved": True
    }


==================================================
FILE_PATH: api/app/ai.py
==================================================

import asyncio
import hashlib
import json
import os
import time

import redis
from fastapi import APIRouter, Body, Depends, Header, HTTPException, Query
from fastapi.responses import StreamingResponse
from prometheus_client import Counter, Histogram
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/ai", tags=["ai"])


def _sse(data: str) -> bytes:
    return ("data: " + data + "\n\n").encode()


def _auth_from_qs(token: str | None) -> tuple[str | None, str | None]:
    return (None, None) if not token else ("", "")


REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)

AI_SSE_LATENCY = Histogram("ai_sse_latency_ms", "AI SSE latency (ms)")
AI_SSE_CACHE_HIT = Counter("ai_sse_cache_hit_total", "AI SSE cache hits")
AI_SSE_CACHE_MISS = Counter("ai_sse_cache_miss_total", "AI SSE cache misses")


@router.get("/stream")
async def stream(
    prompt: str = Query(""),
    conversation_id: str | None = Query(None),
    access_token: str | None = Query(None),
    authorization: str | None = Header(None),
):
    if access_token:
        authorization = "Bearer " + access_token
    try:
        user_id, _ = require_user(authorization)
    except Exception:
        raise HTTPException(status_code=401, detail="unauthorized")

    text = prompt or "Hello"
    qh = hashlib.sha256((text).encode()).hexdigest()
    key = f"ai_cache:{user_id}:{qh}"

    async def gen():
        yield _sse("BEGIN")
        cached = r.get(key)
        start = time.time()
        conv_id = conversation_id
        if not conv_id:
            import uuid as _uuid

            conv_id = str(_uuid.uuid4())
            async with engine.begin() as conn:
                await conn.execute(
                    text(
                        "INSERT INTO ai_conversations(id, owner_id, title) VALUES (cast(:id as uuid), cast(:uid as uuid), :t)"
                    ),
                    {"id": conv_id, "uid": user_id, "t": text[:32]},
                )
        async with engine.begin() as conn:
            import uuid as _uuid

            await conn.execute(
                text(
                    "INSERT INTO ai_messages(id, conversation_id, owner_id, role, content) VALUES (cast(:id as uuid), cast(:cid as uuid), cast(:uid as uuid), 'user', :c)"
                ),
                {"id": str(_uuid.uuid4()), "cid": conv_id, "uid": user_id, "c": text},
            )
        cache_hit = bool(cached)
        if cache_hit:
            for i in range(0, len(cached), 16):
                await asyncio.sleep(0.02)
                yield _sse(cached[i : i + 16])
        else:
            out = ""
            for i in range(0, len(text), 4):
                await asyncio.sleep(0.1)
                chunk = text[i : i + 4]
                out += chunk
                yield _sse(chunk)
            r.setex(key, 600, out)
            cached = out
        async with engine.begin() as conn:
            import uuid as _uuid

            await conn.execute(
                text(
                    "INSERT INTO ai_messages(id, conversation_id, owner_id, role, content) VALUES (cast(:id as uuid), cast(:cid as uuid), cast(:uid as uuid), 'assistant', :c)"
                ),
                {
                    "id": str(_uuid.uuid4()),
                    "cid": conv_id,
                    "uid": user_id,
                    "c": cached or text,
                },
            )
            # upsert cache record
            await conn.execute(
                text(
                    "INSERT INTO ai_query_cache(owner_id, conversation_id, query_hash, prompt, response) VALUES (cast(:uid as uuid), cast(:cid as uuid), :qh, :p, :r) ON CONFLICT (owner_id, query_hash) DO UPDATE SET response = EXCLUDED.response, conversation_id = EXCLUDED.conversation_id"
                ),
                {
                    "uid": user_id,
                    "cid": conv_id,
                    "qh": qh,
                    "p": text,
                    "r": cached or text,
                },
            )
        dur = int((time.time() - start) * 1000)
        if cache_hit:
            AI_SSE_CACHE_HIT.inc()
        else:
            AI_SSE_CACHE_MISS.inc()
        AI_SSE_LATENCY.observe(dur)
        yield _sse(f"LATENCY={dur}ms")
        yield _sse("END")

    headers = {"X-Cache-Hit": "true" if r.ttl(key) > 0 and r.get(key) else "false"}
    return StreamingResponse(gen(), media_type="text/event-stream", headers=headers)


@router.get("/conversations")
async def list_conversations(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "SELECT id::text, title, created_at FROM ai_conversations WHERE owner_id = cast(:uid as uuid) ORDER BY created_at DESC"
            ),
            {"uid": user_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {"id": r[0], "title": r[1], "created_at": str(r[2])} for r in rows
            ],
        }


@router.post("/conversations")
async def create_conversation(body: dict = Body({}), auth=Depends(require_user)):
    user_id, _ = auth
    import uuid as _uuid

    cid = str(_uuid.uuid4())
    title = (body or {}).get("title") or ""
    mode = (body or {}).get("mode") or "default"
    book_ids = (body or {}).get("book_ids") or []
    async with engine.begin() as conn:
        await conn.execute(
            text(
                "INSERT INTO ai_conversations(id, owner_id, title) VALUES (cast(:id as uuid), cast(:uid as uuid), :t)"
            ),
            {"id": cid, "uid": user_id, "t": title},
        )
        await conn.execute(
            text(
                "INSERT INTO ai_conversation_contexts(conversation_id, owner_id, mode, book_ids) VALUES (cast(:cid as uuid), cast(:uid as uuid), :m, cast(:ids as jsonb)) ON CONFLICT (conversation_id) DO UPDATE SET mode = EXCLUDED.mode, book_ids = EXCLUDED.book_ids, updated_at = now()"
            ),
            {"cid": cid, "uid": user_id, "m": mode, "ids": json.dumps(book_ids)},
        )
    return {"status": "success", "data": {"id": cid}}


@router.get("/messages")
async def list_messages(conversation_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "SELECT role, content, created_at FROM ai_messages WHERE owner_id = cast(:uid as uuid) AND conversation_id = cast(:cid as uuid) ORDER BY created_at ASC"
            ),
            {"uid": user_id, "cid": conversation_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {"role": r[0], "content": r[1], "created_at": str(r[2])} for r in rows
            ],
        }


==================================================
FILE_PATH: api/app/admin_panel.py
==================================================

import json
import os
import uuid

from fastapi import APIRouter, Body, Depends, Header, HTTPException
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/admin", tags=["admin"])


def _require_admin(user_id: str):
    aid = os.getenv("ADMIN_USER_ID", "")
    if not aid or aid != user_id:
        raise HTTPException(status_code=403, detail="forbidden")


async def _ensure(conn):
    return


async def _audit(conn, owner_id: str, action: str, details: dict):
    import json as _json

    aid = str(uuid.uuid4())
    await conn.execute(
        text(
            "INSERT INTO audit_logs(id, owner_id, action, details) VALUES (cast(:id as uuid), cast(:uid as uuid), :act, cast(:det as jsonb))"
        ),
        {"id": aid, "uid": owner_id, "act": action, "det": _json.dumps(details)},
    )


@router.get("/system/settings")
async def get_settings(auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text("SELECT key, value, updated_at FROM system_settings ORDER BY key")
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {"key": r[0], "value": r[1], "updated_at": str(r[2])} for r in rows
            ],
        }


@router.put("/system/settings")
async def put_settings(body: dict = Body(...), auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        for k, v in (body or {}).items():
            sid = str(uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO system_settings(id, key, value) VALUES (cast(:id as uuid), :k, cast(:v as jsonb)) ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value, updated_at = now()"
                ),
                {"id": sid, "k": k, "v": json.dumps(v)},
            )
        await _audit(conn, auth[0], "update_system_settings", body or {})
    return {"status": "success"}


@router.get("/providers")
async def list_providers(service_type: str | None = None, auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        base = "SELECT id::text, service_type, name, endpoint, config, is_active, priority, version, updated_at FROM service_providers"
        params = {}
        if service_type:
            base += " WHERE service_type = :st"
            params["st"] = service_type
        base += " ORDER BY service_type, priority DESC, updated_at DESC"
        res = await conn.execute(text(base), params)
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "service_type": r[1],
                    "name": r[2],
                    "endpoint": r[3],
                    "config": r[4],
                    "is_active": bool(r[5]),
                    "priority": int(r[6]),
                    "etag": f'W/"{int(r[7])}"',
                    "updated_at": str(r[8]),
                }
                for r in rows
            ],
        }


@router.post("/providers")
async def upsert_provider(body: dict = Body(...), auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        service_type = body.get("service_type")
        name = body.get("name")
        endpoint = body.get("endpoint")
        config = body.get("config")
        is_active = body.get("is_active")
        priority = body.get("priority")
        pid = str(uuid.uuid4())
        await conn.execute(
            text(
                "INSERT INTO service_providers(id, service_type, name, endpoint, config, is_active, priority) VALUES (cast(:id as uuid), :st, :nm, :ep, cast(:cfg as jsonb), COALESCE(:act, TRUE), COALESCE(:pr, 0)) ON CONFLICT (service_type, name) DO UPDATE SET endpoint = EXCLUDED.endpoint, config = EXCLUDED.config, is_active = EXCLUDED.is_active, priority = EXCLUDED.priority, version = service_providers.version + 1, updated_at = now()"
            ),
            {
                "id": pid,
                "st": service_type,
                "nm": name,
                "ep": endpoint,
                "cfg": json.dumps(config) if config is not None else None,
                "act": is_active,
                "pr": priority,
            },
        )
        await _audit(conn, auth[0], "upsert_provider", body or {})
    return {"status": "success"}


@router.patch("/providers/{provider_id}")
async def update_provider(
    provider_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    auth=Depends(require_user),
):
    _require_admin(auth[0])
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        ver = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    endpoint = body.get("endpoint")
    config = body.get("config")
    is_active = body.get("is_active")
    priority = body.get("priority")
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text(
                "UPDATE service_providers SET endpoint = COALESCE(:ep, endpoint), config = COALESCE(cast(:cfg as jsonb), config), is_active = COALESCE(:act, is_active), priority = COALESCE(:pr, priority), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND version = :v"
            ),
            {
                "ep": endpoint,
                "cfg": json.dumps(config) if config is not None else None,
                "act": is_active,
                "pr": priority,
                "id": provider_id,
                "v": ver,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
        await _audit(conn, auth[0], "update_provider", body or {})
    return {"status": "success"}


@router.get("/feature/flags")
async def get_flags(auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text("SELECT key, is_enabled, updated_at FROM feature_flags ORDER BY key")
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {"key": r[0], "is_enabled": bool(r[1]), "updated_at": str(r[2])}
                for r in rows
            ],
        }


@router.put("/feature/flags")
async def put_flags(body: dict = Body(...), auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        for k, v in (body or {}).items():
            await conn.execute(
                text(
                    "INSERT INTO feature_flags(id, key, is_enabled) VALUES (gen_random_uuid(), :k, :e) ON CONFLICT (key) DO UPDATE SET is_enabled = EXCLUDED.is_enabled, updated_at = now()"
                ),
                {"k": k, "e": bool(v)},
            )
        await _audit(conn, auth[0], "update_feature_flags", body or {})
    return {"status": "success"}


@router.get("/prompts")
async def list_prompts(auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text(
                "SELECT id::text, name, content, updated_at FROM prompt_templates ORDER BY updated_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {"id": r[0], "name": r[1], "content": r[2], "updated_at": str(r[3])}
                for r in rows
            ],
        }


@router.post("/prompts")
async def create_prompt(body: dict = Body(...), auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        tid = str(uuid.uuid4())
        await conn.execute(
            text(
                "INSERT INTO prompt_templates(id, name, content) VALUES (cast(:id as uuid), :n, :c) ON CONFLICT (name) DO UPDATE SET content = EXCLUDED.content, updated_at = now()"
            ),
            {"id": tid, "n": body.get("name"), "c": body.get("content")},
        )
        await _audit(conn, auth[0], "upsert_prompt", body or {})
    return {"status": "success"}


@router.get("/models")
async def list_models(auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text(
                "SELECT id::text, provider, model_id, display_name, active, updated_at FROM ai_models ORDER BY updated_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "provider": r[1],
                    "model_id": r[2],
                    "display_name": r[3],
                    "active": bool(r[4]),
                    "updated_at": str(r[5]),
                }
                for r in rows
            ],
        }


@router.post("/models")
async def upsert_model(body: dict = Body(...), auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        mid = str(uuid.uuid4())
        await conn.execute(
            text(
                "INSERT INTO ai_models(id, provider, model_id, display_name, active) VALUES (cast(:id as uuid), :p, :m, :d, COALESCE(:a, TRUE)) ON CONFLICT (model_id) DO UPDATE SET provider = EXCLUDED.provider, display_name = EXCLUDED.display_name, active = EXCLUDED.active, updated_at = now()"
            ),
            {
                "id": mid,
                "p": body.get("provider"),
                "m": body.get("model_id"),
                "d": body.get("display_name"),
                "a": body.get("active"),
            },
        )
        await _audit(conn, auth[0], "upsert_model", body or {})
    return {"status": "success"}


@router.get("/audit")
async def list_audit(limit: int = 50, offset: int = 0, auth=Depends(require_user)):
    _require_admin(auth[0])
    async with engine.begin() as conn:
        await _ensure(conn)
        res = await conn.execute(
            text(
                "SELECT id::text, owner_id::text, action, details, created_at FROM audit_logs ORDER BY created_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "owner_id": r[1],
                    "action": r[2],
                    "details": r[3],
                    "created_at": str(r[4]),
                }
                for r in rows
            ],
        }


==================================================
FILE_PATH: api/app/srs.py
==================================================

import uuid
from datetime import datetime, timedelta, timezone

from fastapi import APIRouter, Body, Depends, HTTPException
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/srs", tags=["srs"])


def _now_utc() -> datetime:
    """获取当前 UTC 时间（带时区信息）"""
    return datetime.now(timezone.utc)


def _schedule(ease: float, reps: int, interval: int, grade: int):
    if grade < 3:
        reps = 0
        interval = 1
    else:
        ease = max(1.3, ease + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)))
        if reps == 0:
            interval = 1
        elif reps == 1:
            interval = 6
        else:
            interval = int(round(interval * ease))
        reps += 1
    return ease, reps, interval


@router.post("/cards")
async def create_card(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    front = body.get("front")
    back = body.get("back")
    deck = body.get("deck_name")
    if not front or not back:
        raise HTTPException(status_code=400, detail="invalid_payload")
    rid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        next_at = _now_utc() + timedelta(days=1)
        await conn.execute(
            text(
                "INSERT INTO srs_reviews(id, owner_id, front, back, deck_name, next_review_at) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :f, :b, :d, :n)"
            ),
            {"id": rid, "f": front, "b": back, "d": deck, "n": next_at},
        )
    return {"status": "success", "data": {"id": rid}}


@router.get("/due")
async def list_due(limit: int = 50, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, front, back, deck_name, ease_factor, interval_days, repetitions, next_review_at FROM srs_reviews WHERE owner_id = current_setting('app.user_id')::uuid AND (next_review_at IS NULL OR next_review_at <= now()) ORDER BY next_review_at ASC NULLS FIRST LIMIT :l"
            ),
            {"l": limit},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "front": r[1],
                    "back": r[2],
                    "deck_name": r[3],
                    "ease_factor": float(r[4]),
                    "interval_days": int(r[5]),
                    "repetitions": int(r[6]),
                    "next_review_at": str(r[7]) if r[7] else None,
                }
                for r in rows
            ],
        }


@router.post("/reviews/{id}/answer")
async def answer(id: str, body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    grade = int(body.get("grade") or -1)
    if grade < 0 or grade > 5:
        raise HTTPException(status_code=400, detail="invalid_grade")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT ease_factor, repetitions, interval_days FROM srs_reviews WHERE id = cast(:id as uuid) AND owner_id = current_setting('app.user_id')::uuid"
            ),
            {"id": id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        ease, reps, interval = _schedule(float(row[0]), int(row[1]), int(row[2]), grade)
        next_at = _now_utc() + timedelta(days=interval)
        await conn.execute(
            text(
                "UPDATE srs_reviews SET ease_factor = :e, repetitions = :r, interval_days = :i, last_grade = :g, next_review_at = :n, updated_at = now() WHERE id = cast(:id as uuid)"
            ),
            {"e": ease, "r": reps, "i": interval, "g": grade, "n": next_at, "id": id},
        )
    return {"status": "success"}


@router.get("/history")
async def history(limit: int = 50, offset: int = 0, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, front, back, deck_name, last_grade, repetitions, interval_days, next_review_at, updated_at FROM srs_reviews WHERE owner_id = current_setting('app.user_id')::uuid ORDER BY updated_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "front": r[1],
                    "back": r[2],
                    "deck_name": r[3],
                    "last_grade": r[4],
                    "repetitions": int(r[5]),
                    "interval_days": int(r[6]),
                    "next_review_at": str(r[7]) if r[7] else None,
                    "updated_at": str(r[8]),
                }
                for r in rows
            ],
        }


==================================================
FILE_PATH: api/app/celery_app.py
==================================================

import os

from celery import Celery

broker = os.getenv("CELERY_BROKER_URL", "redis://redis:6379/0")
backend = os.getenv("CELERY_BACKEND_URL", "redis://redis:6379/1")

celery_app = Celery("athena", broker=broker, backend=backend)

# 显式导入任务模块以确保任务被注册
# 任务模块已拆分为子模块:
# - app.tasks.cover_tasks
# - app.tasks.metadata_tasks
# - app.tasks.convert_tasks
# - app.tasks.ocr_tasks
# - app.tasks.analysis_tasks
celery_app.conf.update(
    imports=[
        "app.tasks",  # 主包会导入所有子模块
        "app.tasks.cover_tasks",
        "app.tasks.metadata_tasks",
        "app.tasks.convert_tasks",
        "app.tasks.ocr_tasks",
        "app.tasks.analysis_tasks",
        "app.search_sync",
    ],
)


==================================================
FILE_PATH: api/app/home_service.py
==================================================

"""
首页仪表盘服务模型与计算

职责：
- 定义 Dashboard/Goals/Streak/Today/Weekly/YearlyFinished 模型
- 计算今日、周、年阅读统计与 streak，生成仪表盘数据
- 提供更新用户目标的服务方法

说明：
- 仅新增注释，不改动统计与查询逻辑
- 使用带时区的 datetime，避免使用已废弃的 datetime.utcnow()
"""
import uuid
from datetime import date, datetime, timezone
from typing import Literal

from pydantic import BaseModel
from sqlalchemy import text

from .db import engine


class Goals(BaseModel):
    daily_minutes: int
    yearly_books: int


class Streak(BaseModel):
    current_streak: int
    longest_streak: int
    last_read_date: date | None
    active: bool


class Today(BaseModel):
    seconds: int
    minutes: int
    target_minutes: int
    percent: int


class WeeklyDay(BaseModel):
    date: date
    minutes: int
    status: Literal["FUTURE", "MISSED", "REACHED", "PARTIAL"]


class YearlyFinished(BaseModel):
    count: int
    recent_covers: list[str]


class Dashboard(BaseModel):
    goals: Goals
    streak: Streak
    today: Today
    weekly: list[WeeklyDay]
    yearly_finished: YearlyFinished


async def _ensure_defaults(conn, user_id: str):
    await conn.execute(
        text(
            "INSERT INTO user_reading_goals(user_id, daily_minutes, yearly_books)\n             SELECT cast(:uid as uuid), 30, 10\n             WHERE NOT EXISTS (SELECT 1 FROM user_reading_goals WHERE user_id = cast(:uid as uuid))"
        ),
        {"uid": user_id},
    )
    await conn.execute(
        text(
            "INSERT INTO user_streaks(user_id, current_streak, longest_streak)\n             SELECT cast(:uid as uuid), 0, 0\n             WHERE NOT EXISTS (SELECT 1 FROM user_streaks WHERE user_id = cast(:uid as uuid))"
        ),
        {"uid": user_id},
    )


def _tz_now(tz_name: str | None) -> datetime:
    """
    获取指定时区的当前时间
    
    注意: 不再使用已废弃的 datetime.utcnow()
    回退时使用带时区信息的 UTC 时间
    """
    try:
        from zoneinfo import ZoneInfo

        return datetime.now(ZoneInfo(tz_name or "UTC"))
    except Exception:
        # 回退到 UTC（带时区信息）
        return datetime.now(timezone.utc)


def _week_range(d: date) -> tuple[date, date]:
    start = d
    while start.weekday() != 0:
        start = date.fromordinal(start.toordinal() - 1)
    end = date.fromordinal(start.toordinal() + 6)
    return start, end


async def get_dashboard(user_id: str) -> Dashboard:
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id})
        await _ensure_defaults(conn, user_id)

        tz_res = await conn.execute(text("SELECT timezone FROM users WHERE id = current_setting('app.user_id')::uuid"))
        tz_row = tz_res.fetchone()
        tz_name = (tz_row[0] if tz_row else None) or "UTC"
        now_local = _tz_now(tz_name)
        today_local = now_local.date()
        try:
            from zoneinfo import ZoneInfo

            year_start_dt = datetime(today_local.year, 1, 1, tzinfo=ZoneInfo(tz_name))
        except Exception:
            year_start_dt = datetime(today_local.year, 1, 1)
        week_start, week_end = _week_range(today_local)

        g_res = await conn.execute(text("SELECT daily_minutes, yearly_books FROM user_reading_goals WHERE user_id = current_setting('app.user_id')::uuid"))
        g = g_res.fetchone()
        goals = Goals(daily_minutes=int(g[0]), yearly_books=int(g[1])) if g else Goals(daily_minutes=30, yearly_books=10)

        s_res = await conn.execute(text("SELECT current_streak, longest_streak, last_read_date FROM user_streaks WHERE user_id = current_setting('app.user_id')::uuid"))
        s = s_res.fetchone()
        last = s[2] if s else None
        active = False
        try:
            if last and isinstance(last, date):
                active = (date.fromordinal(today_local.toordinal() - 1) == last)
        except Exception:
            active = False
        streak = Streak(current_streak=int(s[0]) if s else 0, longest_streak=int(s[1]) if s else 0, last_read_date=last, active=active)

        td_res = await conn.execute(text("SELECT total_ms FROM reading_daily WHERE user_id = current_setting('app.user_id')::uuid AND day = :d"), {"d": today_local})
        td = td_res.fetchone()
        seconds = int((int(td[0]) if td else 0) / 1000)
        minutes = int(round(seconds / 60))
        percent = max(0, min(100, int(round(100.0 * minutes / max(1, goals.daily_minutes)))))
        today_obj = Today(seconds=seconds, minutes=minutes, target_minutes=goals.daily_minutes, percent=percent)

        wk_res = await conn.execute(text("SELECT day, total_ms FROM reading_daily WHERE user_id = current_setting('app.user_id')::uuid AND day BETWEEN :s AND :e"), {"s": week_start, "e": week_end})
        wk_rows = {str(r[0]): int(r[1]) for r in wk_res.fetchall()}
        weekly: list[WeeklyDay] = []
        for i in range(7):
            d = date.fromordinal(week_start.toordinal() + i)
            ms = wk_rows.get(str(d), 0)
            m = int(round(int(ms) / 1000 / 60))
            status: Literal["FUTURE", "MISSED", "REACHED", "PARTIAL"]
            if d > today_local:
                status = "FUTURE"
            elif m == 0:
                status = "MISSED"
            elif m >= goals.daily_minutes:
                status = "REACHED"
            else:
                status = "PARTIAL"
            weekly.append(WeeklyDay(date=d, minutes=m, status=status))

        y_cnt_res = await conn.execute(text("SELECT COUNT(1) FROM reading_progress WHERE user_id = current_setting('app.user_id')::uuid AND finished_at IS NOT NULL AND finished_at >= :y"), {"y": year_start_dt})
        y_count_row = y_cnt_res.fetchone()
        y_count = int(y_count_row[0]) if y_count_row else 0
        # 返回 book_id 而不是 cover_image_key，前端将使用 API 代理获取封面
        covers_res = await conn.execute(text("SELECT b.id::text FROM reading_progress rp JOIN books b ON b.id = rp.book_id WHERE rp.user_id = current_setting('app.user_id')::uuid AND rp.finished_at IS NOT NULL AND rp.finished_at >= :y ORDER BY rp.finished_at DESC LIMIT 5"), {"y": year_start_dt})
        book_ids = [r[0] for r in covers_res.fetchall() if r and r[0]]
        yearly = YearlyFinished(count=y_count, recent_covers=book_ids)

        return Dashboard(goals=goals, streak=streak, today=today_obj, weekly=weekly, yearly_finished=yearly)


async def update_goals(user_id: str, daily_minutes: int | None = None, yearly_books: int | None = None):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id})
        await _ensure_defaults(conn, user_id)
        if daily_minutes is not None:
            await conn.execute(
                text("UPDATE user_reading_goals SET daily_minutes = :m, updated_at = now() WHERE user_id = current_setting('app.user_id')::uuid"),
                {"m": daily_minutes},
            )
        if yearly_books is not None:
            await conn.execute(
                text("UPDATE user_reading_goals SET yearly_books = :b, updated_at = now() WHERE user_id = current_setting('app.user_id')::uuid"),
                {"b": yearly_books},
            )


==================================================
FILE_PATH: api/app/ws.py
==================================================

from fastapi import WebSocket

channels: dict[str, set[WebSocket]] = {}
server = None


async def broadcast(doc_id: str, message: str):
    for ws in list(channels.get(doc_id, set())):
        try:
            await ws.send_text(message)
        except Exception:
            pass


async def websocket_endpoint(websocket: WebSocket, doc_id: str):
    await websocket.accept()
    channels.setdefault(doc_id, set()).add(websocket)
    try:
        global server
        if server is None:
            from ypy_websocket.websocket_server import WebsocketServer

            server = WebsocketServer()
        await server.serve(websocket, doc_id)
    finally:
        try:
            channels.get(doc_id, set()).discard(websocket)
        except Exception:
            pass


==================================================
FILE_PATH: api/app/auth.py
==================================================

"""
认证模块

功能：
- 邮箱验证码登录/注册（发送与校验）
- 颁发/刷新/注销 Token（JWT + Redis refresh）
- 会话列表、当前用户信息获取

说明：
- `issue_tokens` 生成 HS256 JWT 与 refresh token；refresh 存储于 Redis
- `require_user` 解析 `Authorization: Bearer <token>` 获取用户信息
"""
import os
import threading
import time
import uuid

import redis
from fastapi import APIRouter, Body, Depends, Header, HTTPException
from jose import jwt
from sqlalchemy import text

from .db import engine
from .mailer import send_email

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])

AUTH_SECRET = os.getenv("AUTH_SECRET", "dev_secret")
DEV_MODE = os.getenv("DEV_MODE", "true").lower() == "true"
ACCESS_EXPIRE = int(os.getenv("ACCESS_EXPIRE", "3600"))
REFRESH_EXPIRE = int(os.getenv("REFRESH_EXPIRE", "2592000"))
_ru = os.getenv("REDIS_URL")
if _ru and "://" in _ru:
    try:
        from urllib.parse import urlparse

        _p = urlparse(_ru)
        REDIS_HOST = _p.hostname or "redis"
        REDIS_PORT = _p.port or 6379
    except Exception:
        REDIS_HOST = os.getenv("REDIS_HOST", "redis")
        REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
else:
    REDIS_HOST = os.getenv("REDIS_HOST", "redis")
    REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)
_mem = {}


def issue_tokens(user_id: str, session_id: str):
    now = int(time.time())
    access = jwt.encode(
        {
            "sub": user_id,
            "sid": session_id,
            "iat": now,
            "exp": now + ACCESS_EXPIRE,
            "aud": "authenticated",  # PowerSync 要求的 aud 声明
        },
        AUTH_SECRET,
        algorithm="HS256",
    )
    refresh = str(uuid.uuid4())
    r.setex(f"refresh:{refresh}", REFRESH_EXPIRE, f"{user_id}:{session_id}")
    r.setex(f"refresh_session:{session_id}", REFRESH_EXPIRE, refresh)
    return {
        "access_token": access,
        "refresh_token": refresh,
        "expires_in": ACCESS_EXPIRE,
    }


def require_user(authorization: str = Header(None)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="unauthorized")
    token = authorization.split(" ", 1)[1]
    try:
        # 支持带 aud 字段的新 token 和不带 aud 字段的旧 token
        # 使用 options 跳过 aud 验证，因为 API 接受所有来源的请求
        payload = jwt.decode(token, AUTH_SECRET, options={"verify_aud": False})
        return payload["sub"], payload.get("sid")
    except Exception:
        raise HTTPException(status_code=401, detail="invalid_token")


@router.post("/email/send_code")
@router.post("/email/send-code")
def send_email_code(
    email: dict = Body(...),
    idempotency_key: str | None = Header(None),
    x_client_request_id: str | None = Header(None),
):
    addr = email.get("email", "").lower().strip()
    if not addr:
        raise HTTPException(status_code=400, detail="invalid_email")
    try:
        if r.get(f"email_rate:{addr}"):
            raise HTTPException(status_code=429, detail="rate_limited")
    except Exception:
        pass
    code = str(uuid.uuid4().int)[-6:]
    print(code)
    try:
        r.setex(f"email_code:{addr}", 600, code)
    except Exception:
        _mem[f"email_code:{addr}"] = code
    threading.Thread(
        target=send_email,
        args=(addr, "Your Athena Code", f"Your code is: {code}"),
        daemon=True,
    ).start()
    try:
        r.setex(f"email_rate:{addr}", 60, "1")
    except Exception:
        _mem[f"email_rate:{addr}"] = "1"
    data = {"request_id": str(uuid.uuid4()), "message": "sent"}
    if DEV_MODE:
        data["dev_code"] = code
    return {"status": "success", "data": data}


@router.get("/email/dev_code")
def get_dev_code(email: str):
    if not (os.getenv("DEV_MODE", "true").lower() == "true"):
        raise HTTPException(status_code=403, detail="forbidden")
    if not email:
        raise HTTPException(status_code=400, detail="invalid_email")
    try:
        code = r.get(f"email_code:{email}")
    except Exception:
        code = _mem.get(f"email_code:{email}")
    if not code:
        raise HTTPException(status_code=404, detail="not_found")
    return {"status": "success", "data": {"email": email, "code": code}}


@router.post("/email/verify_code")
@router.post("/email/verify-code")
async def verify_email_code(payload: dict = Body(...)):
    addr = payload.get("email", "").lower().strip()
    code = payload.get("code")
    if not addr or not code:
        raise HTTPException(status_code=400, detail="invalid_payload")
    try:
        saved = r.get(f"email_code:{addr}")
    except Exception:
        saved = _mem.get(f"email_code:{addr}")
    if not saved or saved != code:
        raise HTTPException(status_code=401, detail="invalid_code")
    user_id = str(uuid.uuid4())
    session_id = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        # 查或建用户（幂等）
        res = await conn.execute(
            text("SELECT id::text FROM users WHERE email = :email"), {"email": addr}
        )
        row = res.fetchone()
        if not row:
            await conn.execute(
                text(
                    "INSERT INTO users(id, email, display_name, is_active, language, timezone, updated_at) VALUES (cast(:uid as uuid), :email, '', TRUE, 'zh-CN', 'Asia/Shanghai', now()) ON CONFLICT (email) DO NOTHING"
                ),
                {"uid": user_id, "email": addr},
            )
            res = await conn.execute(
                text("SELECT id::text FROM users WHERE email = :email"), {"email": addr}
            )
            row = res.fetchone()
        user_id = row[0]
        await conn.execute(
            text(
                "INSERT INTO user_sessions(id, user_id) VALUES (cast(:id as uuid), cast(:uid as uuid))"
            ),
            {"id": session_id, "uid": user_id},
        )
    tokens = issue_tokens(user_id, session_id)
    return {
        "status": "success",
        "data": {
            "user": {
                "id": user_id,
                "email": addr,
                "display_name": "",
                "is_active": True,
            },
            "tokens": tokens,
            "session": {"id": session_id},
        },
    }


@router.post("/refresh")
def refresh_tokens(body: dict = Body(...)):
    rt = body.get("refresh_token")
    if not rt:
        raise HTTPException(status_code=400, detail="missing_refresh_token")
    v = r.get(f"refresh:{rt}")
    if not v:
        raise HTTPException(status_code=401, detail="invalid_refresh")
    user_id, session_id = v.split(":")
    tokens = issue_tokens(user_id, session_id)
    return {"status": "success", "data": tokens}


@router.post("/logout")
async def logout(body: dict = Body(...), auth=Depends(require_user)):
    user_id, sid = auth
    session_id = body.get("session_id") or sid
    if not session_id:
        raise HTTPException(status_code=400, detail="missing_session")
    r.delete(f"refresh_session:{session_id}")
    async with engine.begin() as conn:
        await conn.execute(
            text(
                "UPDATE user_sessions SET revoked = TRUE WHERE id = cast(:id as uuid) AND user_id = cast(:uid as uuid)"
            ),
            {"id": session_id, "uid": user_id},
        )
    return {"status": "success"}


@router.get("/sessions")
async def list_sessions(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text, revoked, created_at FROM user_sessions WHERE user_id = current_setting('app.user_id')::uuid ORDER BY created_at DESC"
            )
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {"id": r[0], "is_active": not bool(r[1]), "created_at": str(r[2])}
                for r in rows
            ],
        }


@router.get("/me")
async def get_me(auth=Depends(require_user)):
    user_id, _ = auth
    return {
        "status": "success",
        "data": {"id": user_id, "email": "", "display_name": "", "is_active": True},
    }


==================================================
FILE_PATH: api/app/translate.py
==================================================

"""
翻译接口（OpenRouter 优先，Mock 回退）

职责：
- `/api/v1/translate`：扣费后调用 OpenRouter 模型进行翻译，若不可用则返回本地 Mock 结果

说明：
- 仅新增注释，不改动计费与存储逻辑
"""
import os
import uuid

import requests
from fastapi import APIRouter, Body, Depends, HTTPException
from sqlalchemy import text

from .auth import require_user
from .db import engine
from .storage import make_object_key, presigned_get, upload_bytes

router = APIRouter(prefix="/api/v1/translate", tags=["translate"])


def _mock_translate(text: str, target_lang: str) -> str:
    return f"[{target_lang}] " + text[::-1]


def _openrouter_translate(text: str, target_lang: str) -> str | None:
    key = os.getenv("OPENROUTER_API_KEY", "").strip()
    model = os.getenv("OPENROUTER_MODEL", "openrouter/auto")
    if not key:
        return None
    try:
        resp = requests.post(
            "https://api.openrouter.ai/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {key}",
                "Content-Type": "application/json",
            },
            json={
                "model": model,
                "messages": [
                    {"role": "system", "content": "You are a translation engine."},
                    {"role": "user", "content": f"Translate to {target_lang}: {text}"},
                ],
            },
            timeout=10,
        )
        j = resp.json()
        return j.get("choices", [{}])[0].get("message", {}).get("content")
    except Exception:
        return None


@router.post("")
async def translate(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    text_in = body.get("text") or ""
    target = body.get("target_lang") or "zh"
    if not text_in:
        raise HTTPException(status_code=400, detail="invalid_text")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT price_amount, unit_size, currency FROM pricing_rules WHERE service_type = 'AI_CALL' AND unit_type IN ('CHARS','TOKENS') AND is_active = TRUE ORDER BY updated_at DESC LIMIT 1"
            )
        )
        rule = res.fetchone()
        amt = 0
        cur = "CNY"
        if rule:
            units = max(1, int((len(text_in) + int(rule[1]) - 1) / int(rule[1])))
            amt = int(round(float(rule[0]) * 100)) * units
            cur = rule[2]
        if amt > 0:
            bal = await conn.execute(
                text(
                    "SELECT balance FROM credit_accounts WHERE owner_id = current_setting('app.user_id')::uuid"
                )
            )
            b = bal.fetchone()
            if not b or int(b[0]) < amt:
                raise HTTPException(status_code=400, detail="insufficient_balance")
            await conn.execute(
                text(
                    "UPDATE credit_accounts SET balance = balance - :amt, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                ),
                {"amt": amt},
            )
            lid = str(uuid.uuid4())
            await conn.execute(
                text(
                    "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, :cur, 'ai_translate', 'debit')"
                ),
                {"id": lid, "amt": amt, "cur": cur},
            )
    out = _openrouter_translate(text_in, target) or _mock_translate(text_in, target)
    key = make_object_key(user_id, "translation.txt")
    upload_bytes(
        os.getenv("MINIO_BUCKET", "athena"), key, out.encode("utf-8"), "text/plain"
    )
    return {
        "status": "success",
        "data": {
            "text": out,
            "download_url": presigned_get(os.getenv("MINIO_BUCKET", "athena"), key),
        },
    }


==================================================
FILE_PATH: api/app/export.py
==================================================

import io
import uuid

from fastapi import APIRouter, Depends, HTTPException, Query
from reportlab.pdfgen import canvas
from sqlalchemy import text

from .auth import require_user
from .db import engine
from .storage import make_object_key, presigned_get, upload_bytes

router = APIRouter(prefix="/api/v1/export", tags=["export"])


def _to_pdf(text: str) -> bytes:
    buf = io.BytesIO()
    c = canvas.Canvas(buf)
    y = 800
    for line in text.splitlines():
        c.drawString(40, y, line[:120])
        y -= 16
        if y < 40:
            c.showPage()
            y = 800
    c.save()
    return buf.getvalue()


@router.get("/ocr/{job_id}")
async def export_ocr(
    job_id: str, format: str = Query("txt"), auth=Depends(require_user)
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT result_text FROM ocr_jobs WHERE id = cast(:id as uuid) AND owner_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="not_found")
        text_content = row[0]
    bucket = "athena"
    key = make_object_key(user_id, f"ocr-export-{job_id}.{format}")
    if format == "txt":
        upload_bytes(bucket, key, text_content.encode("utf-8"), "text/plain")
    elif format in ("md", "markdown"):
        md = f"# OCR Export\n\n{text_content}"
        upload_bytes(bucket, key, md.encode("utf-8"), "text/markdown")
    elif format == "pdf":
        pdf = _to_pdf(text_content)
        upload_bytes(bucket, key, pdf, "application/pdf")
    else:
        raise HTTPException(status_code=400, detail="unsupported_format")
    return {"status": "success", "data": {"download_url": presigned_get(bucket, key)}}


@router.get("/notes")
async def export_notes(format: str = Query("md"), auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT content, book_id::text, created_at FROM notes WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL ORDER BY created_at DESC LIMIT 500"
            )
        )
        rows = res.fetchall()
    lines = []
    if format == "txt":
        for r in rows:
            lines.append(r[0])
        data = ("\n\n".join(lines)).encode("utf-8")
        ct = "text/plain"
    elif format in ("md", "markdown"):
        for r in rows:
            lines.append(f"- {r[0]}")
        md = "# Notes Export\n\n" + "\n".join(lines)
        data = md.encode("utf-8")
        ct = "text/markdown"
    elif format == "pdf":
        text_content = "\n".join([r[0] for r in rows])
        data = _to_pdf(text_content)
        ct = "application/pdf"
    else:
        raise HTTPException(status_code=400, detail="unsupported_format")
    bucket = "athena"
    key = make_object_key(user_id, f"notes-export-{uuid.uuid4()}.{format}")
    upload_bytes(bucket, key, data, ct)
    return {"status": "success", "data": {"download_url": presigned_get(bucket, key)}}


@router.get("/ai/{conversation_id}")
async def export_ai(
    conversation_id: str, format: str = Query("md"), auth=Depends(require_user)
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT role, content, created_at FROM ai_messages WHERE owner_id = current_setting('app.user_id')::uuid AND conversation_id = cast(:cid as uuid) ORDER BY created_at ASC"
            ),
            {"cid": conversation_id},
        )
        rows = res.fetchall()
    lines = []
    for r in rows:
        ts = r[2]
        try:
            ts_str = ts.strftime("%Y-%m-%d %H:%M:%S")
        except Exception:
            ts_str = str(ts)
        lines.append("[" + r[0] + "] " + ts_str + "\n" + r[1])
    text_content = "\n\n".join(lines)
    bucket = "athena"
    key = make_object_key(user_id, f"ai-export-{conversation_id}.{format}")
    if format == "txt":
        upload_bytes(bucket, key, text_content.encode("utf-8"), "text/plain")
    elif format in ("md", "markdown"):
        md = "# AI Conversation\n\n" + "\n\n".join(
            [
                "## " + line.split("\n", 1)[0] + "\n" + line.split("\n", 1)[1]
                for line in lines
            ]
        )
        upload_bytes(bucket, key, md.encode("utf-8"), "text/markdown")
    elif format == "pdf":
        pdf = _to_pdf(text_content)
        upload_bytes(bucket, key, pdf, "application/pdf")
    else:
        raise HTTPException(status_code=400, detail="unsupported_format")
    return {"status": "success", "data": {"download_url": presigned_get(bucket, key)}}


==================================================
FILE_PATH: api/app/docs.py
==================================================

"""
文档快照与冲突管理接口

职责：
- 获取最新快照：返回快照内容与时间戳
- 列出冲突：返回版本冲突记录（base/actual 版本）
- 草稿恢复：恢复未解决的草稿并标记为已解决

说明：
- 仅新增注释，不改动查询逻辑
"""
from fastapi import APIRouter, Depends
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/docs", tags=["docs"])


@router.get("/{doc_id}/snapshots/latest")
async def latest_snapshot(doc_id: str, auth=Depends(require_user)):
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "SELECT snapshot, created_at FROM doc_snapshots WHERE doc_id = :d ORDER BY created_at DESC LIMIT 1"
            ),
            {"d": doc_id},
        )
        row = res.fetchone()
        if not row:
            return {"status": "success", "data": None}
        return {
            "status": "success",
            "data": {"snapshot": row[0], "created_at": str(row[1])},
        }


@router.get("/{doc_id}/conflicts")
async def list_conflicts(doc_id: str, auth=Depends(require_user)):
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "SELECT id::text, base_version, actual_version, created_at FROM doc_conflicts WHERE doc_id = :d ORDER BY created_at DESC"
            ),
            {"d": doc_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "base_version": int(r[1]),
                    "actual_version": int(r[2]),
                    "created_at": str(r[3]),
                }
                for r in rows
            ],
        }


@router.post("/{doc_id}/draft/recover")
async def recover_draft(doc_id: str, auth=Depends(require_user)):
    async with engine.begin() as conn:
        res = await conn.execute(
            text(
                "SELECT id::text, snapshot FROM doc_drafts WHERE doc_id = :d AND resolved = FALSE ORDER BY created_at DESC LIMIT 1"
            ),
            {"d": doc_id},
        )
        row = res.fetchone()
        if not row:
            return {"status": "success", "data": None}
        await conn.execute(
            text("UPDATE doc_drafts SET resolved = TRUE WHERE id = cast(:id as uuid)"),
            {"id": row[0]},
        )
        return {"status": "success", "data": {"draft_id": row[0], "snapshot": row[1]}}


==================================================
FILE_PATH: api/app/storage.py
==================================================

"""
对象存储封装（MinIO/S3）

功能：
- 生成预签名上传/下载 URL
- 读写对象（全量/头部）、查询 ETag、删除对象
- 公网域名重写，兼容前端访问与代理
"""
import os
import uuid
from datetime import timedelta
from urllib.parse import urlparse, urlunparse

import boto3


def get_s3():
    endpoint = os.getenv("MINIO_ENDPOINT", "seaweed:8333")
    access = os.getenv("MINIO_ACCESS_KEY")
    secret = os.getenv("MINIO_SECRET_KEY")
    secure = os.getenv("MINIO_SECURE", "false").lower() == "true"
    scheme = "https" if secure else "http"
    endpoint_url = endpoint if endpoint.startswith("http") else f"{scheme}://{endpoint}"
    return boto3.client(
        "s3",
        endpoint_url=endpoint_url,
        aws_access_key_id=access,
        aws_secret_access_key=secret,
    )


def ensure_bucket(client, bucket: str):
    try:
        client.head_bucket(Bucket=bucket)
    except Exception:
        try:
            client.create_bucket(Bucket=bucket)
        except Exception:
            pass


def make_object_key(user_id: str, filename: str) -> str:
    return f"users/{user_id}/{uuid.uuid4()}/{filename}"


def presigned_put(bucket: str, key: str, expires_hours: int = 1, content_type: str | None = None) -> str:
    client = get_s3()
    ensure_bucket(client, bucket)
    url = client.generate_presigned_url(
        "put_object",
        Params={"Bucket": bucket, "Key": key, **({"ContentType": content_type} if content_type else {})},
        ExpiresIn=int(timedelta(hours=expires_hours).total_seconds()),
    )
    return _rewrite_public(url)


def presigned_get(bucket: str, key: str, expires_hours: int = 24) -> str:
    client = get_s3()
    ensure_bucket(client, bucket)
    url = client.generate_presigned_url(
        "get_object",
        Params={"Bucket": bucket, "Key": key},
        ExpiresIn=int(timedelta(hours=expires_hours).total_seconds()),
    )
    return _rewrite_public(url)


def upload_bytes(
    bucket: str, key: str, data: bytes, content_type: str = "application/octet-stream"
) -> None:
    client = get_s3()
    ensure_bucket(client, bucket)
    client.put_object(Bucket=bucket, Key=key, Body=data, ContentType=content_type)


def read_head(bucket: str, key: str, length: int = 65536) -> bytes | None:
    try:
        client = get_s3()
        ensure_bucket(client, bucket)
        resp = client.get_object(Bucket=bucket, Key=key)
        body = resp.get("Body")
        if not body:
            return None
        data = body.read(length)
        return data
    except Exception:
        return None


def read_full(bucket: str, key: str) -> bytes | None:
    """读取完整文件内容"""
    try:
        client = get_s3()
        ensure_bucket(client, bucket)
        resp = client.get_object(Bucket=bucket, Key=key)
        body = resp.get("Body")
        if not body:
            return None
        data = body.read()
        return data
    except Exception:
        return None


def stat_etag(bucket: str, key: str) -> str | None:
    try:
        client = get_s3()
        ensure_bucket(client, bucket)
        head = client.head_object(Bucket=bucket, Key=key)
        etag = head.get("ETag")
        if isinstance(etag, str):
            return etag.strip('"')
        return None
    except Exception:
        return None


def delete_object(bucket: str, key: str) -> bool:
    """删除 MinIO 对象，返回是否成功"""
    try:
        client = get_s3()
        client.delete_object(Bucket=bucket, Key=key)
        return True
    except Exception as e:
        print(f"[Storage] Failed to delete {bucket}/{key}: {e}")
        return False


def _rewrite_public(url: str) -> str:
    pub = os.getenv("MINIO_PUBLIC_ENDPOINT", "").strip()
    if not pub:
        return url
    try:
        u = urlparse(url)
        p = urlparse(pub if pub.startswith("http") else f"http://{pub}")
        return urlunparse(
            (
                p.scheme or u.scheme,
                p.netloc or u.netloc,
                u.path,
                u.params,
                u.query,
                u.fragment,
            )
        )
    except Exception:
        return url


==================================================
FILE_PATH: api/app/invites.py
==================================================

import uuid
import random
import string
from datetime import datetime
from fastapi import APIRouter, Body, Depends, HTTPException
from sqlalchemy import text
from .db import engine
from .auth import require_user

router = APIRouter(prefix="/api/v1/invites", tags=["invites"])

def generate_invite_code():
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))

@router.post("/generate")
async def generate_code(auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        # Check if user already has a code
        res = await conn.execute(
            text("SELECT invite_code FROM invites WHERE inviter_id = cast(:uid as uuid) LIMIT 1"),
            {"uid": user_id}
        )
        row = res.fetchone()
        if row:
            return {"status": "success", "data": {"code": row[0]}}
        
        # Generate new code
        code = generate_invite_code()
        # Simple retry logic for collision
        for _ in range(3):
            try:
                await conn.execute(
                    text("INSERT INTO invites (id, inviter_id, invite_code, status) VALUES (gen_random_uuid(), cast(:uid as uuid), :code, 'pending')"),
                    {"uid": user_id, "code": code}
                )
                break
            except Exception:
                code = generate_invite_code()
        else:
            raise HTTPException(status_code=500, detail="failed_to_generate_code")
            
        return {"status": "success", "data": {"code": code}}

@router.post("/redeem")
async def redeem_code(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    code = body.get("code")
    if not code:
        raise HTTPException(status_code=400, detail="missing_code")
        
    async with engine.begin() as conn:
        # Find invite
        res = await conn.execute(
            text("SELECT id, inviter_id FROM invites WHERE invite_code = :code AND status = 'pending'"),
            {"code": code}
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="invalid_code")
        
        invite_id, inviter_id = row
        
        if str(inviter_id) == str(user_id):
            raise HTTPException(status_code=400, detail="cannot_invite_self")
            
        # Check if user already redeemed
        res = await conn.execute(
            text("SELECT 1 FROM invites WHERE invitee_id = cast(:uid as uuid)"),
            {"uid": user_id}
        )
        if res.fetchone():
            raise HTTPException(status_code=400, detail="already_redeemed")

        # Update invite status
        await conn.execute(
            text("UPDATE invites SET invitee_id = cast(:uid as uuid), status = 'completed', completed_at = now() WHERE id = cast(:iid as uuid)"),
            {"uid": user_id, "iid": invite_id}
        )
        
        # Grant rewards (read from settings first)
        sres = await conn.execute(text("SELECT key, value FROM system_settings WHERE key IN ('invite_bonus_storage', 'invite_bonus_books')"))
        settings = {row[0]: row[1] for row in sres.fetchall()}
        bonus_storage = int(settings.get("invite_bonus_storage", 524288000))
        bonus_books = int(settings.get("invite_bonus_books", 5))
        
        # Update inviter stats
        await conn.execute(
            text("""
                INSERT INTO user_stats (user_id, invite_count, extra_storage_quota, extra_book_quota)
                VALUES (cast(:inviter as uuid), 1, :bs, :bb)
                ON CONFLICT (user_id) DO UPDATE SET
                invite_count = user_stats.invite_count + 1,
                extra_storage_quota = user_stats.extra_storage_quota + :bs,
                extra_book_quota = user_stats.extra_book_quota + :bb,
                updated_at = now()
            """),
            {"inviter": inviter_id, "bs": bonus_storage, "bb": bonus_books}
        )
        
        # Update invitee stats (also gets reward)
        await conn.execute(
            text("""
                INSERT INTO user_stats (user_id, extra_storage_quota, extra_book_quota)
                VALUES (cast(:invitee as uuid), :bs, :bb)
                ON CONFLICT (user_id) DO UPDATE SET
                extra_storage_quota = user_stats.extra_storage_quota + :bs,
                extra_book_quota = user_stats.extra_book_quota + :bb,
                updated_at = now()
            """),
            {"invitee": user_id, "bs": bonus_storage, "bb": bonus_books}
        )
        
    return {"status": "success"}


==================================================
FILE_PATH: api/app/db.py
==================================================

"""
数据库引擎与会话变量

职责：
- 初始化全局异步数据库引擎与会话工厂
- 提供 `set_session_vars` 设置本地会话变量：`app.user_id` 与 `app.role`

说明：
- 仅新增注释，不改动连接与配置
"""
import os

from sqlalchemy import text
from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine

DATABASE_URL = os.getenv(
    "DATABASE_URL", "postgresql+asyncpg://athena:athena_dev@postgres:5432/athena"
)
engine = create_async_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = async_sessionmaker(engine, expire_on_commit=False)


async def set_session_vars(session, user_id: str | None, role: str | None):
    if user_id:
        await session.execute(text("SET LOCAL app.user_id = :v"), {"v": user_id})
    if role:
        await session.execute(text("SET LOCAL app.role = :v"), {"v": role})


==================================================
FILE_PATH: api/app/main.py
==================================================

"""
Athena API 入口

说明：
- 注册各业务子路由（认证、书籍、阅读、OCR、AI、搜索、定价、账单等）
- 接入 Sentry、Prometheus 指标与链路追踪中间件
- 全局异常处理：返回统一结构的 JSON 错误
- 提供健康检查与 RLS 测试端点
"""
import os

import sentry_sdk
from fastapi import FastAPI, Header, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from prometheus_fastapi_instrumentator import Instrumentator
from sqlalchemy import text

from .admin import router as admin_router
from .admin_panel import router as admin_panel_router
from .ai import router as ai_router
from .auth import router as auth_router
from .billing import router as billing_router
from .books import router as books_router
from .books import shelves_router
from .db import engine
from .dict import dict_router
from .dict import packages_router as dict_packages_router
from .docs import router as docs_router
from .export import router as export_router
from .notes import highlights_router, notes_router, tags_router
from .invites import router as invites_router
from .ocr import router as ocr_router
from .pricing import admin as pricing_admin_router
from .pricing import router as pricing_router
from .profile import router as profile_router
from .reader import alias as reader_alias_router
from .reader import router as reader_router
from .realtime import router as realtime_router
from .search import router as search_router
from .srs import router as srs_router
from .tracing import init_tracer, tracer_middleware
from .translate import router as translate_router
from .tts import router as tts_router
from .home import router as home_router
from .powersync import router as powersync_router

sentry_dsn = os.getenv("SENTRY_DSN", "")
if sentry_dsn:
    sentry_sdk.init(dsn=sentry_dsn)

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
    allow_credentials=False,
)
init_tracer()
app.middleware("http")(tracer_middleware)
Instrumentator().instrument(app).expose(app)
app.include_router(auth_router)
app.include_router(books_router)
app.include_router(shelves_router)
app.include_router(reader_router)
app.include_router(reader_alias_router)
app.include_router(docs_router)
app.include_router(notes_router)
app.include_router(tags_router)
app.include_router(highlights_router)
app.include_router(search_router)
app.include_router(billing_router)
app.include_router(tts_router)
app.include_router(dict_packages_router)
app.include_router(dict_router)
app.include_router(translate_router)
app.include_router(admin_router)
app.include_router(realtime_router)
app.include_router(pricing_router)
app.include_router(ai_router)
app.include_router(pricing_admin_router)
app.include_router(export_router)
app.include_router(admin_panel_router)
app.include_router(home_router)
app.include_router(powersync_router)


@app.websocket("/ws/docs/{doc_id}")
async def ws_docs(websocket, doc_id: str):
    from .ws import websocket_endpoint as _ep

    return await _ep(websocket, doc_id)


@app.exception_handler(HTTPException)
async def http_exc_handler(request: Request, exc: HTTPException):
    code = str(exc.detail) if isinstance(exc.detail, str) else "http_error"
    return JSONResponse(
        status_code=exc.status_code,
        content={"status": "error", "error": {"code": code, "message": code}},
    )


@app.exception_handler(Exception)
async def generic_exc_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={
            "status": "error",
            "error": {"code": "internal_error", "message": "internal_error"},
        },
    )


app.include_router(ocr_router)
app.include_router(srs_router)
app.include_router(profile_router)
app.include_router(invites_router)


@app.get("/health")
def health():
    return {"status": "ok"}


@app.get("/")
def root():
    return {"status": "ok", "service": "athena-api"}


@app.post("/rls/echo")
async def rls_echo(x_user_id: str = Header(None), x_role: str = Header(None)):
    async with engine.begin() as conn:
        if x_user_id:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": x_user_id}
            )
        if x_role:
            await conn.execute(
                text("SELECT set_config('app.role', :v, true)"), {"v": x_role}
            )
        res = await conn.execute(
            text(
                "SELECT current_setting('app.user_id', true), current_setting('app.role', true)"
            )
        )
        row = res.fetchone()
        return {"user_id": row[0], "role": row[1]}


@app.post("/rls/progress")
async def rls_progress(
    x_user_id: str = Header(None), book_id: str = "00000000-0000-0000-0000-000000000001"
):
    async with engine.begin() as conn:
        if x_user_id:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": x_user_id}
            )
        await conn.execute(
            text(
                "INSERT INTO reading_progress(user_id, book_id, progress) VALUES (cast(:u as uuid), cast(:b as uuid), 0.5) ON CONFLICT (user_id, book_id) DO UPDATE SET progress=EXCLUDED.progress, updated_at=now()"
            ),
            {"u": x_user_id, "b": book_id},
        )
        res = await conn.execute(
            text(
                "SELECT user_id, book_id, progress FROM reading_progress WHERE user_id = current_setting('app.user_id')::uuid"
            )
        )
        rows = res.fetchall()
        return [
            {"user_id": str(r[0]), "book_id": str(r[1]), "progress": float(r[2])}
            for r in rows
        ]


@app.get("/error")
def error():
    raise RuntimeError("intentional")


==================================================
FILE_PATH: api/app/search.py
==================================================

"""
搜索接口（ES 优先，回退 PostgreSQL）

职责：
- `/search`：按 kind（note/highlight/book）与标签筛选进行全文搜索，优先调用 Elasticsearch，失败回退到数据库模糊查询
- `/reindex`：按用户重建 notes/highlights 索引
- `/reindex_all`：管理员范围重建全量索引
- `/reindex_books`：重建书籍基本信息索引

说明：
- 仅新增注释，不改动查询与回退逻辑
"""
import json
import os
from urllib import request

from fastapi import APIRouter, Depends, Query, Response
from sqlalchemy import text

from .auth import require_user
from .db import engine
from .search_sync import index_book, index_highlight, index_note

router = APIRouter(prefix="/api/v1/search", tags=["search"])


@router.get("/")
async def search(
    q: str | None = Query(None),
    kind: str | None = Query(None),
    tag_ids: list[str] | None = Query(None),
    sort_by: str | None = Query(None),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    auth=Depends(require_user),
    response: Response = None,
):
    user_id, _ = auth
    items = []
    used_es = False
    es_url = os.getenv("ES_URL", "http://elasticsearch:9200")
    if es_url:
        queries = []
        if kind in (None, "note"):
            qnote = {
                "query": {
                    "bool": {
                        "must": (
                            [{"match": {"content": q}}] if q else [{"match_all": {}}]
                        ),
                        "filter": [{"match": {"user_id": user_id}}]
                        + ([{"terms": {"tag_ids": tag_ids}}] if tag_ids else []),
                    }
                },
                "highlight": {"fields": {"content": {}}},
                "from": offset,
                "size": limit,
            }
            if sort_by == "updated_at":
                qnote["sort"] = [{"updated_at": {"order": "desc"}}]
            queries.append(
                (
                    f"{es_url}/{os.getenv('ES_INDEX_NOTES', 'notes')}/_search",
                    qnote,
                    "note",
                )
            )
        if kind in (None, "highlight"):
            qhl = {
                "query": {
                    "bool": {
                        "must": (
                            [{"match": {"text_content": q}}]
                            if q
                            else [{"match_all": {}}]
                        ),
                        "filter": [{"match": {"user_id": user_id}}]
                        + ([{"terms": {"tag_ids": tag_ids}}] if tag_ids else []),
                    }
                },
                "highlight": {"fields": {"text_content": {}}},
                "from": offset,
                "size": limit,
            }
            if sort_by == "updated_at":
                qhl["sort"] = [{"updated_at": {"order": "desc"}}]
            queries.append(
                (
                    f"{es_url}/{os.getenv('ES_INDEX_HIGHLIGHTS', 'highlights')}/_search",
                    qhl,
                    "highlight",
                )
            )
        if kind in (None, "book"):
            qbook = {
                "query": {
                    "bool": {
                        "must": (
                            [
                                {
                                    "multi_match": {
                                        "query": q,
                                        "fields": ["title^2", "author"],
                                    }
                                }
                            ]
                            if q
                            else [{"match_all": {}}]
                        ),
                        "filter": [{"match": {"user_id": user_id}}],
                    }
                },
                "highlight": {"fields": {"title": {}, "author": {}}},
                "from": offset,
                "size": limit,
            }
            if sort_by == "updated_at":
                qbook["sort"] = [{"updated_at": {"order": "desc"}}]
            queries.append(
                (
                    f"{es_url}/{os.getenv('ES_INDEX_BOOKS', 'books')}/_search",
                    qbook,
                    "book",
                )
            )
        for url, payload, k in queries:
            try:
                data = json.dumps(payload).encode()
                req = request.Request(
                    url,
                    data=data,
                    headers={"Content-Type": "application/json"},
                    method="POST",
                )
                with request.urlopen(req, timeout=5) as resp:
                    out = json.loads(resp.read().decode())
                    hits = out.get("hits", {}).get("hits", [])
                    for h in hits:
                        src = h.get("_source", {})
                        hl = h.get("highlight", {})
                        fragments = []
                        if k == "note":
                            fragments = hl.get("content", []) or []
                        elif k == "highlight":
                            fragments = hl.get("text_content", []) or []
                        else:
                            fragments = (hl.get("title", []) or []) + (
                                hl.get("author", []) or []
                            )
                        items.append(
                            {
                                "kind": k,
                                "id": src.get("id"),
                                (
                                    "content"
                                    if k == "note"
                                    else ("comment" if k == "highlight" else "title")
                                ): (
                                    src.get("content")
                                    if k == "note"
                                    else (
                                        src.get("text_content")
                                        if k == "highlight"
                                        else src.get("title")
                                    )
                                ),
                                ("book_id" if k != "book" else "author"): (
                                    src.get("book_id")
                                    if k != "book"
                                    else src.get("author")
                                ),
                                "score": float(h.get("_score") or 0),
                                "highlight": {"fragments": fragments},
                            }
                        )
                used_es = True
            except Exception:
                used_es = False
    if not used_es:
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            if kind in (None, "note"):
                base = "SELECT 'note' as kind, id::text, content, book_id::text, updated_at, version, 0 AS score FROM notes WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL"
                params = {"q": q, "limit": limit, "offset": offset}
                if tag_ids:
                    base += " AND EXISTS (SELECT 1 FROM note_tags nt WHERE nt.note_id = notes.id AND nt.tag_id = ANY(:tids))"
                    params["tids"] = tag_ids
                if q:
                    base += " AND content ILIKE '%' || CAST(:q AS text) || '%'"
                base += " ORDER BY updated_at DESC LIMIT :limit OFFSET :offset"
                res = await conn.execute(text(base), params)
                rows = res.fetchall()
                for r in rows:
                    items.append(
                        {
                            "kind": r[0],
                            "id": r[1],
                            "content": r[2],
                            "book_id": r[3],
                            "updated_at": str(r[4]),
                            "etag": f'W/"{int(r[5])}"',
                            "score": float(r[6]),
                        }
                    )
            if kind in (None, "highlight"):
                base = "SELECT 'highlight' as kind, id::text, comment, book_id::text, updated_at, version, 0 AS score FROM highlights WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL"
                params = {"q": q, "limit": limit, "offset": offset}
                if tag_ids:
                    base += " AND EXISTS (SELECT 1 FROM highlight_tags ht WHERE ht.highlight_id = highlights.id AND ht.tag_id = ANY(:tids))"
                    params["tids"] = tag_ids
                if q:
                    base += " AND comment ILIKE '%' || CAST(:q AS text) || '%'"
                base += " ORDER BY updated_at DESC LIMIT :limit OFFSET :offset"
                res = await conn.execute(text(base), params)
                rows = res.fetchall()
                for r in rows:
                    items.append(
                        {
                            "kind": r[0],
                            "id": r[1],
                            "comment": r[2],
                            "book_id": r[3],
                            "updated_at": str(r[4]),
                            "etag": f'W/"{int(r[5])}"',
                            "score": float(r[6]),
                        }
                    )
            if kind in (None, "book"):
                base = "SELECT 'book' as kind, id::text, title, author, updated_at, version FROM books WHERE user_id = current_setting('app.user_id')::uuid"
                params = {"q": q, "limit": limit, "offset": offset}
                if q:
                    base += " AND (title ILIKE '%' || :q || '%' OR author ILIKE '%' || :q || '%')"
                base += " ORDER BY updated_at DESC LIMIT :limit OFFSET :offset"
                res = await conn.execute(text(base), params)
                rows = res.fetchall()
                for r in rows:
                    items.append(
                        {
                            "kind": r[0],
                            "id": r[1],
                            "title": r[2],
                            "author": r[3],
                            "updated_at": str(r[4]),
                            "etag": f'W/"{int(r[5])}"',
                        }
                    )
    if response is not None:
        response.headers["X-Search-Engine"] = (
            "elasticsearch" if used_es else "postgres-tsvector"
        )
    return {"status": "success", "data": items}


@router.post("/reindex")
async def reindex(limit: int = Query(100, ge=1, le=1000), auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        resn = await conn.execute(
            text(
                "SELECT id::text, book_id::text, content FROM notes WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL ORDER BY updated_at DESC LIMIT :limit"
            ),
            {"limit": limit},
        )
        for r in resn.fetchall():
            index_note(r[0], user_id, r[1], r[2], None)
        resh = await conn.execute(
            text(
                "SELECT id::text, book_id::text, comment, color FROM highlights WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL ORDER BY updated_at DESC LIMIT :limit"
            ),
            {"limit": limit},
        )
        for r in resh.fetchall():
            index_highlight(r[0], user_id, r[1], r[2], r[3], None)
    return {"status": "success"}


@router.post("/reindex_all")
async def reindex_all(
    limit: int = Query(1000, ge=1, le=5000), auth=Depends(require_user)
):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        resn = await conn.execute(
            text(
                "SELECT id::text, user_id::text, book_id::text, content FROM notes WHERE deleted_at IS NULL ORDER BY updated_at DESC LIMIT :limit"
            ),
            {"limit": limit},
        )
        for r in resn.fetchall():
            index_note(r[0], r[1], r[2], r[3], None)
        resh = await conn.execute(
            text(
                "SELECT id::text, user_id::text, book_id::text, comment, color FROM highlights WHERE deleted_at IS NULL ORDER BY updated_at DESC LIMIT :limit"
            ),
            {"limit": limit},
        )
        for r in resh.fetchall():
            index_highlight(r[0], r[1], r[2], r[3], r[4], None)
    return {"status": "success"}


@router.post("/reindex_books")
async def reindex_books(
    limit: int = Query(1000, ge=1, le=5000), auth=Depends(require_user)
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        resb = await conn.execute(
            text(
                "SELECT id::text, title, author FROM books WHERE user_id = current_setting('app.user_id')::uuid ORDER BY updated_at DESC LIMIT :limit"
            ),
            {"limit": limit},
        )
        for r in resb.fetchall():
            index_book(r[0], user_id, r[1], r[2])
    return {"status": "success"}


==================================================
FILE_PATH: api/app/admin.py
==================================================

"""
后台管理接口

职责：
- 用户管理：列表/更新（ETag 并发控制，审计日志记录）
- 支付网关：列表/创建/更新（JSON 配置），启用/禁用
- 翻译管理：列表/新增/更新/删除
- 计费流水：账户与流水查询
- 区域定价：列表与新增/更新

说明：
- 仅新增注释，不改动管理员验证与业务逻辑
"""
import json
import os
import uuid

from fastapi import APIRouter, Body, Depends, Header, HTTPException
from sqlalchemy import text

from .auth import require_user
from .db import engine

router = APIRouter(prefix="/api/v1/admin", tags=["admin"])


def require_admin(auth=Depends(require_user)):
    user_id, _ = auth
    admin_id = os.getenv("ADMIN_USER_ID", "")
    if admin_id and user_id == admin_id:
        return True
    raise HTTPException(status_code=401, detail="admin_unauthorized")


@router.get("/users")
async def list_users(limit: int = 50, offset: int = 0, _=Depends(require_admin)):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        res = await conn.execute(
            text(
                "SELECT id::text, email, display_name, is_active, updated_at, version FROM users ORDER BY updated_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "email": r[1],
                    "display_name": r[2],
                    "is_active": bool(r[3]),
                    "updated_at": str(r[4]),
                    "etag": f'W/"{int(r[5])}"',
                }
                for r in rows
            ],
        }


@router.patch("/users/{user_id}")
async def update_user(
    user_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    _=Depends(require_admin),
):
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        ver = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    display_name = body.get("display_name")
    is_active = body.get("is_active")
    membership_tier = body.get("membership_tier")
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))

        before = await conn.execute(
            text(
                "SELECT to_jsonb(u) FROM (SELECT id, email, display_name, is_active, version FROM users WHERE id = cast(:id as uuid)) u"
            ),
            {"id": user_id},
        )
        b = before.fetchone()
        res = await conn.execute(
            text(
                "UPDATE users SET display_name = COALESCE(:dn, display_name), is_active = COALESCE(:ia, is_active), membership_tier = COALESCE(:mt, membership_tier), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND version = :v"
            ),
            {
                "dn": display_name,
                "ia": is_active,
                "mt": membership_tier,
                "id": user_id,
                "v": ver,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
        after = await conn.execute(
            text(
                "SELECT to_jsonb(u) FROM (SELECT id, email, display_name, is_active, membership_tier, version FROM users WHERE id = cast(:id as uuid)) u"
            ),
            {"id": user_id},
        )
        a = after.fetchone()
        await conn.execute(
            text(
                "INSERT INTO audit_logs(id, actor_id, action, entity, entity_id, before, after) VALUES (cast(:id as uuid), NULL, 'admin.update_user', 'users', cast(:eid as uuid), cast(:b as jsonb), cast(:a as jsonb))"
            ),
            {"id": str(uuid.uuid4()), "eid": user_id, "b": json.dumps(b[0]) if b and b[0] else "{}", "a": json.dumps(a[0]) if a and a[0] else "{}"},
        )
    return {"status": "success"}


@router.get("/gateways")
async def list_gateways(limit: int = 50, offset: int = 0, _=Depends(require_admin)):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        res = await conn.execute(
            text(
                "SELECT id::text, name, config, is_active, updated_at, version FROM payment_gateways ORDER BY updated_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "name": r[1],
                    "config": r[2],
                    "is_active": bool(r[3]),
                    "updated_at": str(r[4]),
                    "etag": f'W/"{int(r[5])}"',
                }
                for r in rows
            ],
        }


@router.post("/gateways")
async def create_gateway(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    _=Depends(require_admin),
):
    name = body.get("name")
    config = body.get("config")
    is_active = bool(body.get("is_active", True))
    if not name or config is None:
        raise HTTPException(status_code=400, detail="invalid_payload")
    gid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        await conn.execute(
            text(
                "INSERT INTO payment_gateways(id, name, config, is_active) VALUES (cast(:id as uuid), :n, cast(:c as jsonb), :a) ON CONFLICT (name) DO NOTHING"
            ),
            {"id": gid, "n": name, "c": json.dumps(config), "a": is_active},
        )
    return {"status": "success", "data": {"id": gid}}


@router.patch("/gateways/{gateway_id}")
async def update_gateway(
    gateway_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    _=Depends(require_admin),
):
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        ver = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    name = body.get("name")
    config = body.get("config")
    is_active = body.get("is_active")
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        res = await conn.execute(
            text(
                "UPDATE payment_gateways SET name = COALESCE(:n, name), config = COALESCE(cast(:c as jsonb), config), is_active = COALESCE(:a, is_active), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND version = :v"
            ),
            {
                "n": name,
                "c": json.dumps(config) if config is not None else None,
                "a": is_active,
                "id": gateway_id,
                "v": ver,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


@router.get("/translations")
async def list_translations(
    namespace: str | None = None,
    lang: str | None = None,
    limit: int = 50,
    offset: int = 0,
    _=Depends(require_admin),
):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        base = "SELECT id::text, namespace, key, lang, value, updated_at, version FROM translations WHERE deleted_at IS NULL"
        params = {"l": limit, "o": offset}
        if namespace:
            base += " AND namespace = :ns"
            params["ns"] = namespace
        if lang:
            base += " AND lang = :lg"
            params["lg"] = lang
        base += " ORDER BY updated_at DESC LIMIT :l OFFSET :o"
        res = await conn.execute(text(base), params)
    rows = res.fetchall()
    return {
        "status": "success",
        "data": [
            {
                "id": r[0],
                "namespace": r[1],
                "key": r[2],
                "lang": r[3],
                "value": r[4],
                "updated_at": str(r[5]),
                "etag": f'W/"{int(r[6])}"',
            }
            for r in rows
        ],
    }


@router.post("/translations")
async def upsert_translation(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    _=Depends(require_admin),
):
    ns = body.get("namespace")
    key = body.get("key")
    lang = body.get("lang")
    value = body.get("value")
    if not ns or not key or not lang or value is None:
        raise HTTPException(status_code=400, detail="invalid_payload")
    tid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        await conn.execute(
            text(
                "INSERT INTO translations(id, namespace, key, lang, value) VALUES (cast(:id as uuid), :ns, :k, :lg, cast(:v as jsonb)) ON CONFLICT (namespace, key, lang) WHERE deleted_at IS NULL DO UPDATE SET value = EXCLUDED.value, version = translations.version + 1, updated_at = now()"
            ),
            {"id": tid, "ns": ns, "k": key, "lg": lang, "v": json.dumps(value)},
        )
    return {"status": "success", "data": {"id": tid}}


@router.patch("/translations/{id}")
async def update_translation(
    id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    _=Depends(require_admin),
):
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        ver = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    value = body.get("value")
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        res = await conn.execute(
            text(
                "UPDATE translations SET value = COALESCE(cast(:v as jsonb), value), version = version + 1, updated_at = now() WHERE id = cast(:id as uuid) AND deleted_at IS NULL AND version = :ver"
            ),
            {
                "v": json.dumps(value) if value is not None else None,
                "id": id,
                "ver": ver,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


@router.delete("/translations/{id}")
async def delete_translation(id: str, _=Depends(require_admin)):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        await conn.execute(
            text(
                "UPDATE translations SET deleted_at = now(), updated_at = now(), version = version + 1 WHERE id = cast(:id as uuid) AND deleted_at IS NULL"
            ),
            {"id": id},
        )
    return {"status": "success"}


@router.get("/credits/accounts")
async def credits_accounts(limit: int = 50, offset: int = 0, _=Depends(require_admin)):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        res = await conn.execute(
            text(
                "SELECT owner_id::text, balance, currency, updated_at FROM credit_accounts ORDER BY updated_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "owner_id": r[0],
                    "balance": int(r[1]),
                    "currency": r[2],
                    "updated_at": str(r[3]),
                }
                for r in rows
            ],
        }


@router.get("/credits/ledger")
async def credits_ledger(
    owner_id: str | None = None,
    limit: int = 50,
    offset: int = 0,
    _=Depends(require_admin),
):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        base = "SELECT id::text, owner_id::text, amount, currency, reason, related_id::text, direction, created_at FROM credit_ledger"
        params = {"l": limit, "o": offset}
        if owner_id:
            base += " WHERE owner_id = cast(:oid as uuid)"
            params["oid"] = owner_id
        base += " ORDER BY created_at DESC LIMIT :l OFFSET :o"
        res = await conn.execute(text(base), params)
        rows = res.fetchall()
    return {
        "status": "success",
        "data": [
            {
                "id": r[0],
                "owner_id": r[1],
                "amount": int(r[2]),
                "currency": r[3],
                "reason": r[4],
                "related_id": r[5],
                "direction": r[6],
                "created_at": str(r[7]),
            }
            for r in rows
        ],
    }


@router.get("/pricing/regions")
async def list_regional_prices(
    limit: int = 50, offset: int = 0, _=Depends(require_admin)
):
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        res = await conn.execute(
            text(
                "SELECT id::text, plan_code, currency, period, amount_minor, updated_at, version FROM regional_prices ORDER BY updated_at DESC LIMIT :l OFFSET :o"
            ),
            {"l": limit, "o": offset},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "plan_code": r[1],
                    "currency": r[2],
                    "period": r[3],
                    "amount_minor": int(r[4]),
                    "updated_at": str(r[5]),
                    "etag": f'W/"{int(r[6])}"',
                }
                for r in rows
            ],
        }


@router.post("/pricing/regions")
async def upsert_regional_price(body: dict = Body(...), _=Depends(require_admin)):
    plan_code = body.get("plan_code")
    currency = body.get("currency")
    period = body.get("period")
    amount_minor = body.get("amount_minor")
    if not plan_code or not currency or not period or not isinstance(amount_minor, int):
        raise HTTPException(status_code=400, detail="invalid_payload")
    pid = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(text("SELECT set_config('app.role', 'admin', true)"))
        await conn.execute(
            text(
                "INSERT INTO regional_prices(id, plan_code, currency, period, amount_minor) VALUES (cast(:id as uuid), :p, :c, :r, :a) ON CONFLICT (plan_code, currency, period) DO UPDATE SET amount_minor = EXCLUDED.amount_minor, version = regional_prices.version + 1, updated_at = now()"
            ),
            {"id": pid, "p": plan_code, "c": currency, "r": period, "a": amount_minor},
        )
    return {"status": "success", "data": {"id": pid}}


==================================================
FILE_PATH: api/app/__init__.py
==================================================




==================================================
FILE_PATH: api/app/realtime.py
==================================================

import base64
import json
import os
import time
import uuid

from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from jose import jwt
from sqlalchemy import text

from .db import engine

router = APIRouter()

AUTH_SECRET = os.getenv("AUTH_SECRET", "dev_secret")

_clients: dict[str, set] = {}
_versions: dict[str, int] = {}
_counters: dict[str, int] = {}
_last_snapshot_at: dict[str, float] = {}


async def _load_version(user_id: str, note_id: str) -> int:
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT COALESCE(MAX(version_number), 0) FROM note_versions WHERE owner_id = current_setting('app.user_id')::uuid AND note_id = cast(:nid as uuid)"
            ),
            {"nid": note_id},
        )
        row = res.fetchone()
        return int(row[0] or 0)


async def _snapshot(user_id: str, note_id: str, version: int, update_bytes: bytes):
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        vid = str(uuid.uuid4())
        await conn.execute(
            text(
                "INSERT INTO note_versions(id, owner_id, note_id, version_number, update_data) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, cast(:nid as uuid), :ver, :upd)"
            ),
            {"id": vid, "nid": note_id, "ver": version, "upd": update_bytes},
        )


@router.websocket("/ws/notes/{note_id}")
async def ws_note(websocket: WebSocket, note_id: str):
    await websocket.accept()
    token = websocket.query_params.get("token") or websocket.query_params.get(
        "access_token"
    )
    if not token:
        await websocket.send_text(json.dumps({"type": "error", "code": "unauthorized"}))
        await websocket.close()
        return
    try:
        # 【重要】verify_aud=False 因为 token 包含 aud: authenticated (PowerSync 要求)
        payload = jwt.decode(token, AUTH_SECRET, options={"verify_aud": False})
        user_id = payload["sub"]
    except Exception:
        await websocket.send_text(
            json.dumps({"type": "error", "code": "invalid_token"})
        )
        await websocket.close()
        return
    if note_id not in _versions:
        _versions[note_id] = await _load_version(user_id, note_id)
        _counters[note_id] = 0
        _last_snapshot_at[note_id] = time.monotonic()
    if note_id not in _clients:
        _clients[note_id] = set()
    _clients[note_id].add(websocket)
    await websocket.send_text(
        json.dumps({"type": "ready", "version": _versions[note_id]})
    )
    try:
        while True:
            msg = await websocket.receive_text()
            data = json.loads(msg)
            if data.get("type") == "update":
                client_ver = int(data.get("client_version") or 0)
                upd_b64 = data.get("update") or ""
                if _versions[note_id] > client_ver:
                    await websocket.send_text(
                        json.dumps({"type": "conflict", "version": _versions[note_id]})
                    )
                    continue
                upd_bytes = base64.b64decode(upd_b64)
                _versions[note_id] = _versions[note_id] + 1
                _counters[note_id] = _counters[note_id] + 1
                for ws in list(_clients.get(note_id, set())):
                    try:
                        await ws.send_text(
                            json.dumps(
                                {
                                    "type": "apply",
                                    "version": _versions[note_id],
                                    "update": upd_b64,
                                }
                            )
                        )
                    except Exception:
                        pass
                need_snap = False
                if _counters[note_id] >= 100:
                    need_snap = True
                else:
                    if time.monotonic() - _last_snapshot_at[note_id] >= 300:
                        need_snap = True
                if need_snap:
                    await _snapshot(user_id, note_id, _versions[note_id], upd_bytes)
                    _counters[note_id] = 0
                    _last_snapshot_at[note_id] = time.monotonic()
            else:
                await websocket.send_text(
                    json.dumps({"type": "error", "code": "bad_message"})
                )
    except WebSocketDisconnect:
        pass
    finally:
        try:
            _clients.get(note_id, set()).discard(websocket)
        except Exception:
            pass


==================================================
FILE_PATH: api/app/tasks/cover_tasks.py
==================================================

"""
封面提取任务模块

包含书籍封面提取相关的 Celery 任务
"""
import asyncio
import json

from celery import shared_task
from sqlalchemy import text

from ..db import engine
from ..storage import (
    get_s3,
    ensure_bucket,
    upload_bytes,
    make_object_key,
    BUCKET,
)
from ..realtime import ws_broadcast
from .common import (
    _optimize_cover_image,
    _extract_epub_cover,
    _extract_pdf_cover,
    _extract_epub_metadata,
    _extract_pdf_metadata,
)


@shared_task(name="tasks.extract_book_cover")
def extract_book_cover(book_id: str, user_id: str):
    """
    提取书籍封面并保存到存储
    仅支持 EPUB 和 PDF 格式，其他格式需先通过 Calibre 转换为 EPUB
    """
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[Cover] Book not found: {book_id}")
                return
            
            minio_key, original_format, title, converted_epub_key = row[0], row[1], row[2], row[3]
            fmt_lower = (original_format or '').lower()
            
            # 对于非 EPUB/PDF 格式，优先使用转换后的 EPUB
            if fmt_lower not in ('epub', 'pdf'):
                if converted_epub_key:
                    print(f"[Cover] Using converted EPUB for: {title}")
                    minio_key = converted_epub_key
                    fmt_lower = 'epub'
                else:
                    print(f"[Cover] Non-EPUB/PDF format ({fmt_lower}) needs conversion first: {book_id}")
                    return
            
            if not minio_key:
                print(f"[Cover] No minio_key for book: {book_id}")
                return
            
            print(f"[Cover] Extracting cover for: {title} ({fmt_lower})")
            
            # 下载书籍文件
            try:
                client = get_s3()
                ensure_bucket(client, BUCKET)
                resp = client.get_object(Bucket=BUCKET, Key=minio_key)
                book_data = resp["Body"].read()
            except Exception as e:
                print(f"[Cover] Failed to download book: {e}")
                return
            
            # 根据格式提取封面（只支持 EPUB 和 PDF）
            cover_data = None
            if fmt_lower == 'epub':
                cover_data = _extract_epub_cover(book_data)
            elif fmt_lower == 'pdf':
                cover_data = _extract_pdf_cover(book_data)
            
            if not cover_data:
                print(f"[Cover] No cover found for: {book_id}")
                return
            
            # 优化封面图片：转换为 WebP 并压缩
            optimized_data, content_type = _optimize_cover_image(cover_data, max_width=400, quality=80)
            
            # 上传封面到存储
            cover_key = make_object_key(user_id, f"covers/{book_id}.webp")
            
            try:
                upload_bytes(BUCKET, cover_key, optimized_data, content_type)
                print(f"[Cover] Uploaded cover: {cover_key} ({len(optimized_data)} bytes)")
            except Exception as e:
                print(f"[Cover] Failed to upload cover: {e}")
                return
            
            # 更新数据库
            await conn.execute(
                text("UPDATE books SET cover_image_key = :key, updated_at = now() WHERE id = cast(:id as uuid)"),
                {"key": cover_key, "id": book_id},
            )
            print(f"[Cover] Updated book with cover: {book_id}")
            
            # 广播更新事件
            try:
                asyncio.create_task(
                    ws_broadcast(
                        f"book:{book_id}",
                        json.dumps({"event": "COVER_EXTRACTED", "cover_key": cover_key}),
                    )
                )
            except Exception:
                pass
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.extract_book_cover_and_metadata")
def extract_book_cover_and_metadata(book_id: str, user_id: str):
    """
    合并的封面+元数据提取任务
    只下载一次文件，同时提取封面和元数据，提高 PDF 处理效率
    """
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, author, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[CoverMeta] Book not found: {book_id}")
                return
            
            minio_key, original_format, current_title, current_author, converted_epub_key = row[0], row[1], row[2], row[3], row[4]
            fmt_lower = (original_format or '').lower()
            
            # 对于非 EPUB/PDF 格式，优先使用转换后的 EPUB
            if fmt_lower not in ('epub', 'pdf'):
                if converted_epub_key:
                    print(f"[CoverMeta] Using converted EPUB")
                    minio_key = converted_epub_key
                    fmt_lower = 'epub'
                else:
                    print(f"[CoverMeta] Non-EPUB/PDF format ({fmt_lower}) needs conversion first: {book_id}")
                    return
            
            if not minio_key:
                print(f"[CoverMeta] No minio_key for book: {book_id}")
                return
            
            print(f"[CoverMeta] Extracting cover and metadata for: {book_id} (format: {fmt_lower})")
            
            # 下载书籍文件（只下载一次）
            try:
                client = get_s3()
                ensure_bucket(client, BUCKET)
                resp = client.get_object(Bucket=BUCKET, Key=minio_key)
                book_data = resp["Body"].read()
                print(f"[CoverMeta] Downloaded {len(book_data)} bytes")
            except Exception as e:
                print(f"[CoverMeta] Failed to download book: {e}")
                return
            
            # ============ 提取封面 ============
            cover_data = None
            if fmt_lower == 'epub':
                cover_data = _extract_epub_cover(book_data)
            elif fmt_lower == 'pdf':
                cover_data = _extract_pdf_cover(book_data)
            
            cover_key = None
            if cover_data:
                # 优化封面图片
                optimized_data, content_type = _optimize_cover_image(cover_data, max_width=400, quality=80)
                cover_key = make_object_key(user_id, f"covers/{book_id}.webp")
                try:
                    upload_bytes(BUCKET, cover_key, optimized_data, content_type)
                    print(f"[CoverMeta] Uploaded cover: {cover_key} ({len(optimized_data)} bytes)")
                except Exception as e:
                    print(f"[CoverMeta] Failed to upload cover: {e}")
                    cover_key = None
            else:
                print(f"[CoverMeta] No cover found for: {book_id}")
            
            # ============ 提取元数据 ============
            metadata = {"title": None, "author": None, "page_count": None}
            if fmt_lower == 'epub':
                metadata = _extract_epub_metadata(book_data)
            elif fmt_lower == 'pdf':
                metadata = _extract_pdf_metadata(book_data)
            
            # ============ 构建数据库更新 ============
            updates = []
            params = {"id": book_id}
            
            # 更新封面
            if cover_key:
                updates.append("cover_image_key = :cover_key")
                params["cover_key"] = cover_key
            
            # 更新作者（如果当前为空且提取到了）
            if metadata.get("author") and (not current_author or current_author.strip() == ""):
                updates.append("author = :author")
                params["author"] = metadata["author"]
                print(f"[CoverMeta] Will update author to: {metadata['author']}")
            
            # 更新标题（如果需要）
            if metadata.get("title"):
                extracted_title = metadata["title"].strip()
                should_update = (
                    not current_title or 
                    current_title.strip() == "" or 
                    "_" in current_title or 
                    current_title.endswith(('.epub', '.pdf', '.mobi', '.azw3')) or
                    ("-" in (current_title or "") and "-" not in extracted_title and len(extracted_title) < len(current_title or ""))
                )
                if should_update:
                    updates.append("title = :title")
                    params["title"] = extracted_title
                    print(f"[CoverMeta] Will update title to: '{extracted_title}'")
            
            # 更新 meta 字段：page_count + metadata_extracted
            if metadata.get("page_count"):
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', cast(:page_count as integer), 'needs_manual', false, 'metadata_extracted', true)")
                params["page_count"] = int(metadata["page_count"])
                print(f"[CoverMeta] Will update page_count to: {metadata['page_count']}")
            else:
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || '{\"metadata_extracted\": true}'::jsonb")
            
            # ============ 更新图片型 PDF 检测结果（仅对 PDF 格式）============
            if fmt_lower == 'pdf' and 'is_image_based' in metadata:
                is_image_based = metadata.get("is_image_based", False)
                confidence = metadata.get("digitalization_confidence", 1.0)
                # is_digitalized = true 表示"已检测"，confidence < 0.8 表示是图片型
                updates.append("is_digitalized = true")
                updates.append("initial_digitalization_confidence = :confidence")
                params["confidence"] = confidence
                print(f"[CoverMeta] PDF type detection: is_image_based={is_image_based}, confidence={confidence}")
            
            # 执行更新
            if updates:
                updates.append("updated_at = now()")
                update_sql = f"UPDATE books SET {', '.join(updates)} WHERE id = cast(:id as uuid)"
                await conn.execute(text(update_sql), params)
                print(f"[CoverMeta] Updated book: {book_id}")
            
            # 广播更新事件
            try:
                event_data = {
                    "event": "COVER_AND_METADATA_EXTRACTED",
                    "cover_key": cover_key,
                    "title": metadata.get("title"),
                    "author": metadata.get("author"),
                    "page_count": metadata.get("page_count"),
                    "metadata_extracted": True,
                    "is_image_based": metadata.get("is_image_based", False),
                    "digitalization_confidence": metadata.get("digitalization_confidence", 1.0),
                }
                # 【关键修复】使用 await 而不是 create_task，确保广播消息立即发送
                await ws_broadcast(
                    f"book:{book_id}",
                    json.dumps(event_data),
                )
                print(f"[CoverMeta] WebSocket event broadcasted: COVER_AND_METADATA_EXTRACTED")
            except Exception as e:
                print(f"[CoverMeta] Failed to broadcast WebSocket event: {e}")
    
    asyncio.get_event_loop().run_until_complete(_run())


==================================================
FILE_PATH: api/app/tasks/convert_tasks.py
==================================================

"""
格式转换任务模块

包含使用 Calibre 进行格式转换的 Celery 任务
"""
import asyncio
import json
import os
import time

from celery import shared_task
from sqlalchemy import text

from ..db import engine
from ..celery_app import celery_app
from ..storage import (
    get_s3,
    ensure_bucket,
    upload_bytes,
    make_object_key,
    BUCKET,
)
from ..realtime import ws_broadcast

# Calibre 共享卷目录
CALIBRE_BOOKS_DIR = os.environ.get("CALIBRE_CONVERT_DIR", "/calibre_books")


@shared_task(name="tasks.convert_to_epub")
def convert_to_epub(book_id: str, user_id: str):
    """
    使用 Calibre 容器将非 EPUB/PDF 格式的书籍转换为 EPUB
    通过共享卷与 Calibre 容器交互，然后轮询等待转换完成
    
    状态流转：pending -> processing -> completed/failed
    
    【重要】每个数据库操作使用独立事务，避免长事务问题
    """
    import uuid as _uuid
    
    async def _update_status(status: str, extra_sql: str = "", extra_params: dict = None):
        """独立事务更新状态"""
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            params = {"id": book_id, **(extra_params or {})}
            if extra_sql:
                sql = f"UPDATE books SET conversion_status = '{status}', {extra_sql}, updated_at = now() WHERE id = cast(:id as uuid)"
            else:
                sql = f"UPDATE books SET conversion_status = '{status}', updated_at = now() WHERE id = cast(:id as uuid)"
            await conn.execute(text(sql), params)
            print(f"[Convert] Status updated to '{status}' for book: {book_id}")
    
    async def _get_book_info():
        """独立事务获取书籍信息"""
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            return res.fetchone()
    
    async def _update_converted_epub(epub_key: str):
        """独立事务更新转换后的 EPUB 信息"""
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            await conn.execute(
                text("UPDATE books SET minio_key = :key, converted_epub_key = :key, conversion_status = 'completed', updated_at = now() WHERE id = cast(:id as uuid)"),
                {"key": epub_key, "id": book_id},
            )
            print(f"[Convert] Updated book with converted EPUB, status='completed': {book_id}")
    
    async def _run():
        # 步骤1：更新状态为 processing
        await _update_status('processing')
        
        # 步骤2：获取书籍信息
        row = await _get_book_info()
        if not row:
            print(f"[Convert] Book not found: {book_id}")
            return
        
        minio_key, original_format, title, existing_epub = row[0], row[1], row[2], row[3]
        fmt_lower = (original_format or '').lower()
        
        # 如果已经是 EPUB 或已有转换后的 EPUB，跳过
        if fmt_lower == 'epub':
            print(f"[Convert] Book is already EPUB, skipping: {book_id}")
            await _update_status('completed')
            return
        if existing_epub:
            print(f"[Convert] Book already has converted EPUB, skipping: {book_id}")
            await _update_status('completed')
            return
        
        # PDF 不需要转换
        if fmt_lower == 'pdf':
            print(f"[Convert] PDF format does not need conversion: {book_id}")
            await _update_status('completed')
            return
        
        print(f"[Convert] Converting {fmt_lower} to EPUB: {title}")
        
        job_id = str(_uuid.uuid4())[:8]
        input_filename = f"input-{job_id}.{fmt_lower}"
        output_filename = f"output-{job_id}.epub"
        
        # Calibre 容器中的路径是 /books，Worker 容器中的路径是 /calibre_books
        worker_input_path = os.path.join(CALIBRE_BOOKS_DIR, input_filename)
        worker_output_path = os.path.join(CALIBRE_BOOKS_DIR, output_filename)
        calibre_input_path = f"/books/{input_filename}"
        calibre_output_path = f"/books/{output_filename}"
        
        try:
            # 从存储下载源文件
            client = get_s3()
            ensure_bucket(client, BUCKET)
            resp = client.get_object(Bucket=BUCKET, Key=minio_key)
            book_data = resp["Body"].read()
            
            # 写入共享卷
            os.makedirs(CALIBRE_BOOKS_DIR, exist_ok=True)
            with open(worker_input_path, 'wb') as f:
                f.write(book_data)
            print(f"[Convert] Wrote source file: {worker_input_path} ({len(book_data)} bytes)")
            
            # 创建转换请求文件（Calibre 容器中的监控脚本会读取并执行）
            request_file = os.path.join(CALIBRE_BOOKS_DIR, f"convert-{job_id}.request")
            with open(request_file, 'w') as f:
                f.write(f"{calibre_input_path}\n{calibre_output_path}\n")
            print(f"[Convert] Created conversion request: {request_file}")
            
            # 轮询等待转换完成（最多等待 5 分钟）
            done_file = os.path.join(CALIBRE_BOOKS_DIR, f"convert-{job_id}.done")
            error_file = os.path.join(CALIBRE_BOOKS_DIR, f"convert-{job_id}.error")
            
            max_wait = 300  # 5 分钟
            wait_interval = 2  # 每 2 秒检查一次
            waited = 0
            
            while waited < max_wait:
                if os.path.exists(done_file):
                    print(f"[Convert] Conversion completed!")
                    break
                if os.path.exists(error_file):
                    with open(error_file, 'r') as f:
                        error_msg = f.read()
                    print(f"[Convert] Conversion failed: {error_msg}")
                    # 清理
                    try:
                        os.remove(request_file)
                        os.remove(error_file)
                        os.remove(worker_input_path)
                    except:
                        pass
                    # 标记转换失败
                    await _update_status('failed', 
                        "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('conversion_error', :err)",
                        {"err": error_msg[:500]})
                    return
                
                time.sleep(wait_interval)
                waited += wait_interval
                if waited % 30 == 0:
                    print(f"[Convert] Still waiting... ({waited}s)")
            
            if waited >= max_wait:
                print(f"[Convert] Conversion timed out after {max_wait}s")
                # 标记为转换失败（超时）
                await _update_status('failed',
                    "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('needs_manual_conversion', true, 'conversion_error', 'timeout')")
                return
            
            # 读取转换后的文件
            if not os.path.exists(worker_output_path):
                print(f"[Convert] Output file not found: {worker_output_path}")
                await _update_status('failed',
                    "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('conversion_error', 'output_not_found')")
                return
            
            with open(worker_output_path, 'rb') as f:
                epub_data = f.read()
            print(f"[Convert] Read converted EPUB: {len(epub_data)} bytes")
            
            # 上传到存储
            epub_key = make_object_key(user_id, f"converted/{book_id}.epub")
            upload_bytes(BUCKET, epub_key, epub_data, "application/epub+zip")
            print(f"[Convert] Uploaded converted EPUB: {epub_key}")
            
            # 删除 S3 中的原始非 EPUB/PDF 文件（节省存储空间）
            try:
                client.delete_object(Bucket=BUCKET, Key=minio_key)
                print(f"[Convert] Deleted original file from S3: {minio_key}")
            except Exception as del_e:
                print(f"[Convert] Warning: Failed to delete original file: {del_e}")
            
            # 【关键】使用独立事务更新数据库
            await _update_converted_epub(epub_key)
            
            # 清理临时文件
            for f in [worker_input_path, worker_output_path, request_file, done_file]:
                try:
                    os.remove(f)
                except:
                    pass
            
            # 广播转换完成事件
            try:
                asyncio.create_task(
                    ws_broadcast(
                        f"book:{book_id}",
                        json.dumps({"event": "CONVERTED_TO_EPUB", "epub_key": epub_key}),
                    )
                )
            except Exception:
                pass
            
        except Exception as e:
            print(f"[Convert] Conversion error: {e}")
            import traceback
            traceback.print_exc()
            # 标记为失败
            try:
                await _update_status('failed',
                    "meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('conversion_error', :err)",
                    {"err": str(e)[:500]})
            except:
                pass
            return
        
        # 【架构变更】转换完成后，检查是否已有封面
        # extract_ebook_metadata_calibre 任务已经并行提取了元数据和封面
        # 只有在封面不存在时才触发补充提取
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT cover_image_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            has_cover = row and row[0]
        
        if not has_cover:
            # 封面还没有，使用转换后的 EPUB 提取封面
            print(f"[Convert] No cover found, triggering EPUB cover extraction for: {book_id}")
            celery_app.send_task("tasks.extract_book_cover_and_metadata", args=[book_id, user_id])
        else:
            print(f"[Convert] Cover already exists, skipping extraction for: {book_id}")
    
    asyncio.get_event_loop().run_until_complete(_run())


==================================================
FILE_PATH: api/app/tasks/analysis_tasks.py
==================================================

"""
分析与 SRS 卡片任务模块

包含深度分析和 SRS 卡片生成的 Celery 任务
"""
import asyncio
import json
import tempfile
import os

from celery import shared_task
from sqlalchemy import text

from ..db import engine
from ..storage import (
    upload_bytes,
    read_full,
    make_object_key,
    BUCKET,
)
from ..realtime import ws_broadcast
from ..ocr import get_ocr
from .common import _quick_confidence
from .ocr_tasks import _pdf_to_images


@shared_task(name="tasks.deep_analyze_book")
def deep_analyze_book(book_id: str, user_id: str):
    """
    对书籍进行深度分析：类型检测 + OCR
    
    用于手动触发的完整分析，生成详细报告
    """
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                return
            key = row[0]
            img, conf = _quick_confidence(key)
            
            ocr = get_ocr()
            ocr_res = {"regions": [], "text": ""}
            
            # 判断文件类型
            is_pdf = key.lower().endswith('.pdf')
            
            # 图片尺寸变量
            ocr_image_width = 0
            ocr_image_height = 0
            
            if is_pdf:
                # PDF 文件：先转换为图片再 OCR（处理所有页面）
                print(f"[OCR] Processing PDF: {key}")
                pdf_data = read_full(BUCKET, key)
                if pdf_data:
                    page_images, ocr_image_width, ocr_image_height = _pdf_to_images(pdf_data, max_pages=0, dpi=150)
                    all_text = []
                    all_regions = []
                    total_pages = page_images[0][2] if page_images else 0
                    
                    for page_num, img_bytes, _ in page_images:
                        fd, temp_path = tempfile.mkstemp(suffix='.png')
                        try:
                            os.write(fd, img_bytes)
                            os.close(fd)
                            
                            page_result = ocr.recognize("", temp_path)
                            if page_result.get("text"):
                                all_text.append(f"--- Page {page_num} ---")
                                all_text.append(page_result["text"])
                                for r in page_result.get("regions", []):
                                    r["page"] = page_num
                                    all_regions.append(r)
                            print(f"[OCR] Page {page_num}/{total_pages}: {len(page_result.get('text', ''))} chars, {len(page_result.get('regions', []))} regions")
                        except Exception as e:
                            print(f"[OCR] Page {page_num}/{total_pages} failed: {e}")
                        finally:
                            try:
                                os.remove(temp_path)
                            except Exception:
                                pass
                    
                    print(f"[OCR] Completed: {len(all_regions)} text regions, {len(''.join(all_text))} total chars")
                    ocr_res = {"regions": all_regions, "text": "\n".join(all_text)}
                    
                    # 触发搜索索引
                    try:
                        from ..search_sync import index_book_content
                        index_book_content(book_id, user_id, all_regions)
                        print(f"[OCR] Triggered search indexing for book {book_id}")
                    except Exception as e:
                        print(f"[OCR] Warning: Failed to index book content: {e}")
            else:
                # 图片文件：直接 OCR
                ocr_res = ocr.recognize(BUCKET, key)
            
            # 生成报告
            rep_key = make_object_key(user_id, f"digitalize-report-{book_id}.json")
            report_data = {
                "is_image_based": img, 
                "confidence": conf, 
                "ocr": ocr_res,
            }
            if ocr_image_width > 0 and ocr_image_height > 0:
                report_data["image_width"] = ocr_image_width
                report_data["image_height"] = ocr_image_height
            
            upload_bytes(
                BUCKET,
                rep_key,
                json.dumps(report_data).encode("utf-8"),
                "application/json",
            )
            
            await conn.execute(
                text(
                    "UPDATE books SET is_digitalized = :dig, digitalize_report_key = :rk, updated_at = now() WHERE id = cast(:id as uuid)"
                ),
                {"dig": (not img and conf >= 0.8), "rk": rep_key, "id": book_id},
            )
        
        # WebSocket 通知
        try:
            asyncio.create_task(
                ws_broadcast(
                    f"book:{book_id}",
                    json.dumps(
                        {
                            "event": "DEEP_ANALYZED",
                            "digitalized": (not img and conf >= 0.8),
                            "confidence": conf,
                        }
                    ),
                )
            )
        except Exception:
            pass
        
        # 审计日志
        try:
            async with engine.begin() as conn2:
                await conn2.execute(
                    text(
                        "INSERT INTO audit_logs(id, owner_id, action, details) VALUES (gen_random_uuid(), cast(:uid as uuid), :act, cast(:det as jsonb))"
                    ),
                    {
                        "uid": user_id,
                        "act": "task_deep_analyze_book",
                        "det": json.dumps(
                            {
                                "book_id": book_id,
                                "digitalized": (not img and conf >= 0.8),
                                "confidence": conf,
                            }
                        ),
                    },
                )
        except Exception:
            pass

    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.generate_srs_card")
def generate_srs_card(highlight_id: str):
    """
    根据高亮内容自动生成 SRS 复习卡片
    """
    async def _run():
        async with engine.begin() as conn:
            res = await conn.execute(
                text(
                    "SELECT user_id::text, comment FROM highlights WHERE id = cast(:id as uuid)"
                ),
                {"id": highlight_id},
            )
            row = res.fetchone()
            if not row:
                return
            user_id = row[0]
            comment = row[1] or ""
            
            # 只有足够长的评论才生成卡片
            if len(comment) <= 20:
                return
            
            question = "这段高亮主要表达了什么？"
            answer = comment.strip()
            
            import uuid as _uuid
            card_id = str(_uuid.uuid4())
            
            await conn.execute(
                text(
                    "INSERT INTO srs_cards(id, owner_id, highlight_id, question, answer) VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:hid as uuid), :q, :a) ON CONFLICT (highlight_id) DO NOTHING"
                ),
                {
                    "id": card_id,
                    "uid": user_id,
                    "hid": highlight_id,
                    "q": question,
                    "a": answer,
                },
            )
            
            # WebSocket 通知
            try:
                asyncio.create_task(
                    ws_broadcast(
                        f"highlight:{highlight_id}",
                        json.dumps({"event": "SRS_CARD_CREATED", "card_id": card_id}),
                    )
                )
            except Exception:
                pass

    asyncio.get_event_loop().run_until_complete(_run())


==================================================
FILE_PATH: api/app/tasks/metadata_tasks.py
==================================================

"""
元数据提取任务模块

包含书籍元数据提取相关的 Celery 任务（Calibre 和本地方法）
"""
import asyncio
import json
import os
import re
import time

from celery import shared_task
from sqlalchemy import text

from ..db import engine
from ..storage import (
    get_s3,
    ensure_bucket,
    upload_bytes,
    make_object_key,
    BUCKET,
)
from ..realtime import ws_broadcast
from .common import (
    _optimize_cover_image,
    _extract_epub_metadata,
    _extract_pdf_metadata,
)

# Calibre 共享卷目录
CALIBRE_BOOKS_DIR = os.environ.get("CALIBRE_CONVERT_DIR", "/calibre_books")


@shared_task(name="tasks.extract_ebook_metadata_calibre")
def extract_ebook_metadata_calibre(book_id: str, user_id: str):
    """
    使用 Calibre 容器从书籍中提取元数据（标题、作者、封面）
    
    通过共享卷与 Calibre 容器交互：
    1. 将书籍下载到共享卷
    2. 创建元数据提取请求文件
    3. 轮询等待提取完成
    4. 读取结果并更新数据库
    
    优势：
    - 支持更多格式（mobi, azw3, epub, pdf 等）
    - 更准确的元数据提取
    - PDF 类型检测集成
    """
    import uuid as _uuid
    
    async def _run():
        # 获取书籍信息
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, author FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[CalibreMeta] Book not found: {book_id}")
                return
            
            minio_key, original_format, current_title, current_author = row[0], row[1], row[2], row[3]
            fmt_lower = (original_format or '').lower()
            
            print(f"[CalibreMeta] Extracting metadata for {book_id} (format: {fmt_lower})")
        
        # 下载文件到共享卷
        job_id = str(_uuid.uuid4())[:8]
        input_filename = f"meta-{job_id}.{fmt_lower}"
        cover_filename = f"cover-{job_id}.jpg"
        
        # Worker 容器中的路径 (/calibre_books) 和 Calibre 容器中的路径 (/books) 不同
        worker_input_path = os.path.join(CALIBRE_BOOKS_DIR, input_filename)
        worker_cover_path = os.path.join(CALIBRE_BOOKS_DIR, cover_filename)
        worker_metadata_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.txt")
        worker_request_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.metadata.request")
        worker_done_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.done")
        worker_error_path = os.path.join(CALIBRE_BOOKS_DIR, f"metadata-{job_id}.error")
        
        # Calibre 容器中的路径
        calibre_input_path = f"/books/{input_filename}"
        calibre_cover_path = f"/books/{cover_filename}"
        
        # 用于存储下载的文件数据（PDF 需要额外分析）
        book_data = None
        
        try:
            # 从 S3 下载文件
            client = get_s3()
            ensure_bucket(client, BUCKET)
            resp = client.get_object(Bucket=BUCKET, Key=minio_key)
            book_data = resp["Body"].read()
            
            os.makedirs(CALIBRE_BOOKS_DIR, exist_ok=True)
            with open(worker_input_path, 'wb') as f:
                f.write(book_data)
            print(f"[CalibreMeta] Downloaded {len(book_data)} bytes to {worker_input_path}")
            
            # 创建元数据提取请求文件
            with open(worker_request_path, 'w') as f:
                f.write(f"{calibre_input_path}\n{calibre_cover_path}\n")
            print(f"[CalibreMeta] Created request file: {worker_request_path}")
            
            # 轮询等待完成（最多等待 60 秒，PDF 可能较慢）
            max_wait = 60
            wait_interval = 0.5
            waited = 0
            
            while waited < max_wait:
                if os.path.exists(worker_done_path):
                    print(f"[CalibreMeta] Metadata extraction completed!")
                    break
                if os.path.exists(worker_error_path):
                    with open(worker_error_path, 'r') as f:
                        error_msg = f.read()
                    print(f"[CalibreMeta] Extraction failed: {error_msg}")
                    # 清理文件
                    for p in [worker_request_path, worker_error_path, worker_input_path]:
                        try:
                            if os.path.exists(p):
                                os.remove(p)
                        except:
                            pass
                    return
                
                time.sleep(wait_interval)
                waited += wait_interval
            
            if waited >= max_wait:
                print(f"[CalibreMeta] Timeout waiting for metadata extraction")
                # 继续处理，可能部分成功
            
            # 解析元数据输出
            metadata = {"title": None, "author": None, "page_count": None}
            if os.path.exists(worker_metadata_path):
                with open(worker_metadata_path, 'r', encoding='utf-8', errors='ignore') as f:
                    output = f.read()
                print(f"[CalibreMeta] ebook-meta output:\n{output}")
                
                # 解析元数据
                title_match = re.search(r'^Title\s*:\s*(.+)$', output, re.MULTILINE)
                if title_match:
                    metadata["title"] = title_match.group(1).strip()
                
                author_match = re.search(r'^Author\(s\)\s*:\s*(.+)$', output, re.MULTILINE)
                if author_match:
                    author_str = author_match.group(1).strip()
                    # 移除排序名称部分 [xxx]
                    author_str = re.sub(r'\s*\[.*?\]', '', author_str)
                    metadata["author"] = author_str.strip()
                
                # 尝试提取页数
                pages_match = re.search(r'^Pages?\s*:\s*(\d+)', output, re.MULTILINE | re.IGNORECASE)
                if pages_match:
                    metadata["page_count"] = int(pages_match.group(1))
            
            # 读取封面
            cover_key = None
            if os.path.exists(worker_cover_path):
                with open(worker_cover_path, 'rb') as f:
                    cover_data = f.read()
                
                if cover_data and len(cover_data) > 1000:  # 至少 1KB
                    # 优化封面
                    optimized_data, content_type = _optimize_cover_image(cover_data, max_width=400, quality=80)
                    cover_key = make_object_key(user_id, f"covers/{book_id}.webp")
                    upload_bytes(BUCKET, cover_key, optimized_data, content_type)
                    print(f"[CalibreMeta] Uploaded cover: {cover_key} ({len(optimized_data)} bytes)")
                else:
                    print(f"[CalibreMeta] Cover too small or empty, skipping")
            else:
                print(f"[CalibreMeta] No cover file found")
            
            # 【PDF 特殊处理】检测是否为图片型 PDF（需要 OCR）
            is_image_based = False
            digitalization_confidence = 1.0
            
            if fmt_lower == 'pdf' and book_data:
                print(f"[CalibreMeta] Analyzing PDF for OCR requirement...")
                pdf_analysis = _extract_pdf_metadata(book_data)
                is_image_based = pdf_analysis.get("is_image_based", False)
                digitalization_confidence = pdf_analysis.get("digitalization_confidence", 1.0)
                if pdf_analysis.get("page_count"):
                    metadata["page_count"] = pdf_analysis["page_count"]
                print(f"[CalibreMeta] PDF analysis: is_image_based={is_image_based}, confidence={digitalization_confidence:.2f}")
            
            # 更新数据库
            updates = []
            params = {"id": book_id}
            
            if cover_key:
                updates.append("cover_image_key = :cover_key")
                params["cover_key"] = cover_key
            
            # 更新作者（如果当前为空）
            if metadata.get("author") and (not current_author or current_author.strip() == ""):
                updates.append("author = :author")
                params["author"] = metadata["author"]
                print(f"[CalibreMeta] Will update author to: {metadata['author']}")
            
            # 更新标题（如果需要）
            if metadata.get("title"):
                extracted_title = metadata["title"].strip()
                should_update = (
                    not current_title or 
                    current_title.strip() == "" or 
                    "_" in current_title or 
                    current_title.endswith(('.epub', '.pdf', '.mobi', '.azw3')) or
                    ("-" in (current_title or "") and "-" not in extracted_title and len(extracted_title) < len(current_title or ""))
                )
                if should_update:
                    updates.append("title = :title")
                    params["title"] = extracted_title
                    print(f"[CalibreMeta] Will update title to: '{extracted_title}'")
            
            # 更新页数
            meta_updates = []
            if metadata.get("page_count"):
                meta_updates.append(f"'page_count', {metadata['page_count']}::int")
            
            # PDF 特殊：更新图片型检测结果
            if fmt_lower == 'pdf':
                updates.append("is_digitalized = true")
                updates.append("initial_digitalization_confidence = :confidence")
                params["confidence"] = digitalization_confidence
            
            # 标记元数据已提取（合并所有 meta 更新，使用 JSON 字面量避免类型推断问题）
            meta_updates.append("'metadata_extracted', true::boolean")
            meta_updates.append("'extraction_method', 'calibre'::text")
            updates.append(f"meta = COALESCE(meta, '{{}}'::jsonb) || jsonb_build_object({', '.join(meta_updates)})")
            
            if updates:
                updates.append("updated_at = now()")
                update_sql = f"UPDATE books SET {', '.join(updates)} WHERE id = cast(:id as uuid)"
                async with engine.begin() as conn:
                    await conn.execute(
                        text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                    )
                    await conn.execute(text(update_sql), params)
                    print(f"[CalibreMeta] Updated book: {book_id}")
            
            # 广播更新事件
            try:
                event_data = {
                    "event": "METADATA_EXTRACTED",
                    "cover_key": cover_key,
                    "title": metadata.get("title"),
                    "author": metadata.get("author"),
                    "extraction_method": "calibre",
                    "format": fmt_lower,
                }
                # PDF 特殊：包含 OCR 检测信息
                if fmt_lower == 'pdf':
                    event_data["is_image_based"] = is_image_based
                    event_data["digitalization_confidence"] = digitalization_confidence
                    event_data["needs_ocr"] = is_image_based and digitalization_confidence < 0.8
                
                await ws_broadcast(f"book:{book_id}", json.dumps(event_data))
                print(f"[CalibreMeta] WebSocket event broadcasted")
            except Exception as e:
                print(f"[CalibreMeta] Failed to broadcast: {e}")
            
        except Exception as e:
            print(f"[CalibreMeta] Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # 清理临时文件
            for path in [worker_input_path, worker_cover_path, worker_metadata_path, 
                         worker_request_path, worker_done_path, worker_error_path]:
                try:
                    if os.path.exists(path):
                        os.remove(path)
                except:
                    pass
    
    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.extract_book_metadata")
def extract_book_metadata(book_id: str, user_id: str):
    """
    从书籍文件中提取元数据 (title, author, page_count) 并更新数据库
    仅支持 EPUB 和 PDF 格式，其他格式需先通过 Calibre 转换为 EPUB
    """
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key, original_format, title, author, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[Metadata] Book not found: {book_id}")
                return
            
            minio_key, original_format, current_title, current_author, converted_epub_key = row[0], row[1], row[2], row[3], row[4]
            fmt_lower = (original_format or '').lower()
            
            # 对于非 EPUB/PDF 格式，优先使用转换后的 EPUB
            if fmt_lower not in ('epub', 'pdf'):
                if converted_epub_key:
                    print(f"[Metadata] Using converted EPUB for metadata extraction")
                    minio_key = converted_epub_key
                    fmt_lower = 'epub'
                else:
                    print(f"[Metadata] Non-EPUB/PDF format ({fmt_lower}) needs conversion first: {book_id}")
                    return
            
            if not minio_key:
                print(f"[Metadata] No minio_key for book: {book_id}")
                return
            
            print(f"[Metadata] Extracting metadata for book: {book_id} (format: {fmt_lower})")
            
            # 下载书籍文件
            try:
                client = get_s3()
                ensure_bucket(client, BUCKET)
                resp = client.get_object(Bucket=BUCKET, Key=minio_key)
                book_data = resp["Body"].read()
            except Exception as e:
                print(f"[Metadata] Failed to download book: {e}")
                return
            
            # 根据格式提取元数据（只支持 EPUB 和 PDF）
            metadata = {"title": None, "author": None, "page_count": None}
            
            if fmt_lower == 'epub':
                metadata = _extract_epub_metadata(book_data)
            elif fmt_lower == 'pdf':
                metadata = _extract_pdf_metadata(book_data)
            
            # 构建更新语句
            updates = []
            params = {"id": book_id}
            
            # 只有在当前 author 为空且提取到了 author 时才更新
            if metadata.get("author") and (not current_author or current_author.strip() == ""):
                updates.append("author = :author")
                params["author"] = metadata["author"]
                print(f"[Metadata] Will update author to: {metadata['author']}")
            
            # 只有在当前 title 是文件名格式（或为空）且提取到了更好的 title 时才更新
            if metadata.get("title"):
                extracted_title = metadata["title"].strip()
                # 检查是否需要更新标题
                should_update = (
                    not current_title or 
                    current_title.strip() == "" or 
                    "_" in current_title or 
                    current_title.endswith(('.epub', '.pdf', '.mobi', '.azw3')) or
                    ("-" in (current_title or "") and "-" not in extracted_title and len(extracted_title) < len(current_title or ""))
                )
                if should_update:
                    updates.append("title = :title")
                    params["title"] = extracted_title
                    print(f"[Metadata] Will update title from '{current_title}' to: '{extracted_title}'")
                else:
                    print(f"[Metadata] Title not updated, current: '{current_title}', extracted: '{extracted_title}'")
            
            # 更新 meta 字段：page_count 和 metadata_extracted
            if metadata.get("page_count"):
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', cast(:page_count as integer), 'needs_manual', false, 'metadata_extracted', true)")
                params["page_count"] = int(metadata["page_count"])
                print(f"[Metadata] Will update page_count to: {metadata['page_count']}")
            else:
                # 无论是否提取到有效数据，都标记元数据提取任务已完成
                updates.append("meta = COALESCE(meta, '{}'::jsonb) || '{\"metadata_extracted\": true}'::jsonb")
            
            if updates:
                updates.append("updated_at = now()")
                update_sql = f"UPDATE books SET {', '.join(updates)} WHERE id = cast(:id as uuid)"
                await conn.execute(text(update_sql), params)
                print(f"[Metadata] Updated book metadata for: {book_id}, metadata_extracted=true")
                
                # 广播更新事件
                try:
                    event_data = {
                        "event": "METADATA_EXTRACTED",
                        "title": metadata.get("title"),
                        "author": metadata.get("author"),
                        "page_count": metadata.get("page_count"),
                        "metadata_extracted": True,
                    }
                    asyncio.create_task(
                        ws_broadcast(
                            f"book:{book_id}",
                            json.dumps(event_data),
                        )
                    )
                except Exception:
                    pass
            else:
                # 即使没有其他更新，也要标记 metadata_extracted
                await conn.execute(
                    text("UPDATE books SET meta = COALESCE(meta, '{}'::jsonb) || '{\"metadata_extracted\": true}'::jsonb, updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id},
                )
                print(f"[Metadata] No metadata updates, but marked metadata_extracted=true for: {book_id}")
    
    asyncio.get_event_loop().run_until_complete(_run())


==================================================
FILE_PATH: api/app/tasks/common.py
==================================================

"""
Celery 任务模块 - 共享基础设施

包含：
- 共享导入
- 配置常量
- 工具函数（图片优化、元数据提取等）
"""
import json
import os
import io
import tempfile
import zipfile

from celery import shared_task
from sqlalchemy import text
from sqlalchemy import text as _text

from ..db import engine
from ..services import get_ocr
from ..storage import make_object_key, read_head, read_full, upload_bytes, get_s3, ensure_bucket, presigned_get
from ..ws import broadcast as ws_broadcast

# ============================================================================
# 配置常量
# ============================================================================

BUCKET = os.getenv("MINIO_BUCKET", "athena")
CALIBRE_HOST = os.getenv("CALIBRE_HOST", "calibre")
CALIBRE_BOOKS_DIR = os.getenv("CALIBRE_CONVERT_DIR", "/calibre_books")

# ============================================================================
# 工具函数
# ============================================================================

def _quick_confidence(key: str) -> tuple[bool, float]:
    """Quick heuristic to guess whether a file is image based."""
    try:
        head = None
        if isinstance(key, str) and key.startswith("http"):
            import urllib.request

            with urllib.request.urlopen(key) as resp:
                head = resp.read(65536)
        else:
            head = read_head(BUCKET, key, 65536)
        if not head:
            return (False, 0.0)
        txt = None
        for enc in ("utf-8", "gb18030", "latin1"):
            try:
                txt = head.decode(enc, errors="ignore")
                break
            except Exception:
                continue
        if not txt:
            return (False, 0.0)
        import re

        cjk = len(re.findall(r"[\u4e00-\u9fff]", txt))
        latin = len(re.findall(r"[A-Za-z]", txt))
        total = max(1, len(txt))
        ratio = (cjk + latin) / total
        is_image_based = ratio < 0.02
        conf = max(0.0, min(1.0, ratio * 5.0))
        return (is_image_based, conf)
    except Exception:
        return (False, 0.0)


def _optimize_cover_image(image_data: bytes, max_width: int = 400, quality: int = 80) -> tuple[bytes, str]:
    """Convert a cover image to a normalized WebP rendition."""
    try:
        from PIL import Image

        img = Image.open(io.BytesIO(image_data))

        if img.mode in ("RGBA", "LA", "P"):
            img = img.convert("RGBA")
        elif img.mode != "RGB":
            img = img.convert("RGB")

        target_width = max_width
        target_height = int(max_width * 1.5)  # 2:3 ratio
        img_ratio = img.width / img.height
        target_ratio = target_width / target_height

        if img_ratio > target_ratio:
            new_width = int(img.height * target_ratio)
            left = (img.width - new_width) // 2
            img = img.crop((left, 0, left + new_width, img.height))
        elif img_ratio < target_ratio:
            new_height = int(img.width / target_ratio)
            top = (img.height - new_height) // 2
            img = img.crop((0, top, img.width, top + new_height))

        resample = getattr(Image, "Resampling", Image).LANCZOS
        img = img.resize((target_width, target_height), resample)

        output = io.BytesIO()
        img.save(output, format="WEBP", quality=quality, lossless=False)
        webp_data = output.getvalue()
        print(f"[Cover] Optimized: {len(image_data)} -> {len(webp_data)} bytes (400x600 WebP)")
        return webp_data, "image/webp"
    except Exception as e:
        print(f"[Cover] Failed to optimize image, using original: {e}")
        if image_data[:8].startswith(b"\x89PNG"):
            return image_data, "image/png"
        return image_data, "image/jpeg"


def _extract_epub_metadata(epub_data: bytes) -> dict:
    """Extract title/author information from an EPUB file."""
    metadata = {"title": None, "author": None}
    try:
        with zipfile.ZipFile(io.BytesIO(epub_data)) as zf:
            opf_path = None
            for name in zf.namelist():
                if name.endswith(".opf"):
                    opf_path = name
                    break

            if opf_path:
                import re

                opf_content = zf.read(opf_path).decode("utf-8", errors="ignore")
                title_match = re.search(r"<dc:title[^>]*>([^<]+)</dc:title>", opf_content, re.IGNORECASE)
                if title_match:
                    metadata["title"] = title_match.group(1).strip()

                author_match = re.search(r"<dc:creator[^>]*>([^<]+)</dc:creator>", opf_content, re.IGNORECASE)
                if author_match:
                    metadata["author"] = author_match.group(1).strip()

                print(f"[Metadata] EPUB metadata extracted: title={metadata['title']}, author={metadata['author']}")
    except Exception as e:
        print(f"[Metadata] Failed to extract EPUB metadata: {e}")
    return metadata


def _extract_pdf_metadata(pdf_data: bytes) -> dict:
    """Extract metadata (title, author, page count) and a quick digitalization score."""
    metadata = {"title": None, "author": None, "page_count": None, "is_image_based": False, "digitalization_confidence": 1.0}
    try:
        import fitz  # PyMuPDF

        doc = fitz.open(stream=pdf_data, filetype="pdf")
        pdf_meta = doc.metadata
        if pdf_meta:
            if pdf_meta.get("title"):
                metadata["title"] = pdf_meta["title"].strip()
            if pdf_meta.get("author"):
                metadata["author"] = pdf_meta["author"].strip()

        page_count = len(doc)
        metadata["page_count"] = page_count

        sample_pages = min(5, page_count)
        total_text_chars = 0
        total_cjk_chars = 0

        import re

        for i in range(sample_pages):
            page = doc[i]
            text = page.get_text("text")
            if text:
                clean_text = text.strip()
                total_text_chars += len(clean_text)
                total_cjk_chars += len(re.findall(r"[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff]", clean_text))

        avg_chars_per_page = total_text_chars / sample_pages if sample_pages > 0 else 0

        if avg_chars_per_page < 50:
            metadata["is_image_based"] = True
            metadata["digitalization_confidence"] = 0.1
            print(f"[Metadata] PDF detected as IMAGE-BASED: avg {avg_chars_per_page:.1f} chars/page (threshold: 50)")
        elif avg_chars_per_page < 200:
            metadata["is_image_based"] = True
            metadata["digitalization_confidence"] = 0.3
            print(f"[Metadata] PDF detected as PARTIALLY IMAGE-BASED: avg {avg_chars_per_page:.1f} chars/page")
        else:
            metadata["is_image_based"] = False
            metadata["digitalization_confidence"] = min(1.0, avg_chars_per_page / 500)
            print(f"[Metadata] PDF detected as DIGITAL: avg {avg_chars_per_page:.1f} chars/page")

        doc.close()
        print(
            f"[Metadata] PDF metadata extracted: title={metadata['title']}, author={metadata['author']}, pages={page_count}, is_image_based={metadata['is_image_based']}"
        )
    except Exception as e:
        print(f"[Metadata] Failed to extract PDF metadata: {e}")
    return metadata


def _extract_epub_cover(epub_data: bytes) -> bytes | None:
    """从 EPUB 文件中提取封面图片"""
    try:
        with zipfile.ZipFile(io.BytesIO(epub_data)) as zf:
            opf_path = None
            for name in zf.namelist():
                if name.endswith('.opf'):
                    opf_path = name
                    break
            
            if opf_path:
                opf_content = zf.read(opf_path).decode('utf-8', errors='ignore')
                
                import re
                cover_patterns = [
                    r'<item[^>]*id\s*=\s*["\']cover["\'][^>]*href\s*=\s*["\']([^"\']+)["\']',
                    r'<item[^>]*href\s*=\s*["\']([^"\']+)["\'][^>]*id\s*=\s*["\']cover["\']',
                    r'<item[^>]*properties\s*=\s*["\']cover-image["\'][^>]*href\s*=\s*["\']([^"\']+)["\']',
                    r'<item[^>]*href\s*=\s*["\']([^"\']+)["\'][^>]*properties\s*=\s*["\']cover-image["\']',
                ]
                
                for pattern in cover_patterns:
                    match = re.search(pattern, opf_content, re.IGNORECASE)
                    if match:
                        cover_href = match.group(1)
                        opf_dir = os.path.dirname(opf_path)
                        if opf_dir:
                            cover_path = f"{opf_dir}/{cover_href}"
                        else:
                            cover_path = cover_href
                        
                        for name in zf.namelist():
                            if name.endswith(cover_href) or name == cover_path:
                                return zf.read(name)
            
            cover_names = ['cover.jpg', 'cover.jpeg', 'cover.png', 'Cover.jpg', 'Cover.jpeg', 'Cover.png']
            for name in zf.namelist():
                for cover_name in cover_names:
                    if name.endswith(cover_name):
                        return zf.read(name)
            
            for name in zf.namelist():
                lower = name.lower()
                if lower.endswith(('.jpg', '.jpeg', '.png')) and 'cover' in lower:
                    return zf.read(name)
                    
    except Exception as e:
        print(f"[Cover] Failed to extract EPUB cover: {e}")
    return None


def _extract_pdf_cover(pdf_data: bytes) -> bytes | None:
    """从 PDF 文件中提取第一页作为封面"""
    try:
        import fitz  # PyMuPDF
        
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        if len(doc) > 0:
            page = doc[0]
            pix = page.get_pixmap(matrix=fitz.Matrix(2, 2))
            img_data = pix.tobytes("jpeg")
            doc.close()
            return img_data
    except Exception as e:
        print(f"[Cover] Failed to extract PDF cover: {e}")
    return None


def run_async(coro):
    """在同步任务中运行异步代码"""
    import asyncio
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    return loop.run_until_complete(coro)


==================================================
FILE_PATH: api/app/tasks/__init__.py
==================================================

"""
Celery 任务模块包

将原 tasks.py (2144 行) 拆分为以下模块：
- common.py         - 共享工具函数（封面优化、元数据提取等）
- cover_tasks.py    - 封面提取任务
- metadata_tasks.py - 元数据提取任务（Calibre + 本地）
- convert_tasks.py  - 格式转换任务
- ocr_tasks.py      - OCR 处理任务
- analysis_tasks.py - 深度分析与 SRS 卡片任务

所有任务保持原有的 task name，确保向后兼容：
- tasks.extract_book_cover
- tasks.extract_book_cover_and_metadata
- tasks.extract_ebook_metadata_calibre
- tasks.extract_book_metadata
- tasks.convert_to_epub
- tasks.analyze_book_type
- tasks.process_book_ocr
- tasks.deep_analyze_book
- tasks.generate_srs_card
"""

# 导入所有任务，确保 Celery 能发现它们
from .cover_tasks import (
    extract_book_cover,
    extract_book_cover_and_metadata,
)
from .metadata_tasks import (
    extract_ebook_metadata_calibre,
    extract_book_metadata,
)
from .convert_tasks import (
    convert_to_epub,
)
from .ocr_tasks import (
    analyze_book_type,
    process_book_ocr,
)
from .analysis_tasks import (
    deep_analyze_book,
    generate_srs_card,
)

# 导出共享工具函数（供其他模块使用）
from .common import (
    _quick_confidence,
    _optimize_cover_image,
    _extract_epub_metadata,
    _extract_pdf_metadata,
    _extract_epub_cover,
    _extract_pdf_cover,
)

__all__ = [
    # 任务
    "extract_book_cover",
    "extract_book_cover_and_metadata",
    "extract_ebook_metadata_calibre",
    "extract_book_metadata",
    "convert_to_epub",
    "analyze_book_type",
    "process_book_ocr",
    "deep_analyze_book",
    "generate_srs_card",
    # 工具函数
    "_quick_confidence",
    "_optimize_cover_image",
    "_extract_epub_metadata",
    "_extract_pdf_metadata",
    "_extract_epub_cover",
    "_extract_pdf_cover",
]


==================================================
FILE_PATH: api/app/tasks/ocr_tasks.py
==================================================

"""
OCR 处理任务模块

包含 PDF OCR 识别相关的 Celery 任务和辅助函数
"""
import asyncio
import json
import os
import tempfile
import time

from celery import shared_task
from sqlalchemy import text

from ..db import engine
from ..storage import (
    upload_bytes,
    read_full,
    read_head,
    BUCKET,
)
from ..realtime import ws_broadcast
from .common import _quick_confidence


def _get_optimal_workers(reserved_cores: int = 2, max_workers: int = 8) -> int:
    """
    动态计算最优工作线程数
    
    考虑因素：
    1. 系统总 CPU 核心数
    2. 当前 CPU 使用率
    3. 预留核心给其他任务（API、其他 Celery 任务）
    4. 最大工作线程数限制（避免内存过高）
    """
    import psutil
    
    cpu_count = os.cpu_count() or 4
    
    try:
        cpu_percent = psutil.cpu_percent(interval=0.1)
        idle_cores = int(cpu_count * (100 - cpu_percent) / 100)
    except Exception:
        idle_cores = cpu_count // 2
    
    available_cores = max(1, idle_cores - reserved_cores)
    workers = min(available_cores, max_workers)
    
    return max(1, workers)


def _pdf_to_images_with_sizes(pdf_data: bytes, max_pages: int = 0, dpi: int = 150) -> list:
    """
    将 PDF 转换为图片列表，用于 OCR
    **每页单独记录尺寸**，因为 PDF 每页尺寸可能不同
    """
    import fitz  # PyMuPDF
    
    pages = []
    try:
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        total_pages = len(doc)
        pages_to_process = total_pages if max_pages <= 0 else min(total_pages, max_pages)
        
        print(f"[OCR] PDF has {total_pages} pages, will process {pages_to_process} pages")
        
        for page_num in range(pages_to_process):
            page = doc[page_num]
            
            pdf_rect = page.rect
            pdf_width = pdf_rect.width
            pdf_height = pdf_rect.height
            
            mat = fitz.Matrix(dpi / 72, dpi / 72)
            pix = page.get_pixmap(matrix=mat)
            
            pixel_width = pix.width
            pixel_height = pix.height
            
            if page_num == 0:
                print(f"[OCR] First page: PDF size {pdf_width:.1f}x{pdf_height:.1f} pt -> {pixel_width}x{pixel_height} px at {dpi} DPI")
            
            img_data = pix.tobytes("png")
            
            pages.append({
                "page_num": page_num + 1,
                "total_pages": total_pages,
                "image_bytes": img_data,
                "width": pixel_width,
                "height": pixel_height,
                "pdf_width": pdf_width,
                "pdf_height": pdf_height,
                "dpi": dpi,
            })
        
        doc.close()
    except Exception as e:
        print(f"[OCR] Failed to convert PDF to images: {e}")
    
    return pages


def _pdf_to_images(pdf_data: bytes, max_pages: int = 0, dpi: int = 150) -> tuple:
    """
    将 PDF 转换为图片列表（兼容旧接口）
    Returns:
        (images, image_width, image_height)
        images: [(page_num, image_bytes, total_pages), ...]
    """
    pages = _pdf_to_images_with_sizes(pdf_data, max_pages, dpi)
    if not pages:
        return [], 0, 0
    
    images = [(p["page_num"], p["image_bytes"], p["total_pages"]) for p in pages]
    return images, pages[0]["width"], pages[0]["height"]


def _pipeline_ocr_process(
    pdf_data: bytes,
    ocr_instance,
    max_pages: int = 0,
    dpi: int = 150,
    batch_size: int = 20,
    progress_callback=None,
) -> tuple:
    """
    流水线模式处理 PDF OCR
    
    使用生产者-消费者模式，CPU 图片转换和 OCR 识别并行执行：
    - 生产者：将 PDF 页面转换为图片（CPU 密集）
    - 消费者：对图片执行 OCR（CPU/GPU 密集）
    """
    import fitz
    from queue import Queue
    from threading import Thread, Event
    from concurrent.futures import ThreadPoolExecutor
    
    doc = fitz.open(stream=pdf_data, filetype="pdf")
    total_pages = len(doc)
    pages_to_process = total_pages if max_pages <= 0 else min(total_pages, max_pages)
    
    print(f"[OCR Pipeline] PDF has {total_pages} pages, will process {pages_to_process} pages")
    
    image_workers = _get_optimal_workers(reserved_cores=2, max_workers=6)
    print(f"[OCR Pipeline] Using {image_workers} workers for image conversion")
    
    ocr_pages = [None] * pages_to_process
    all_text_parts = []
    processed_count = 0
    
    image_queue = Queue(maxsize=batch_size * 2)
    conversion_done = Event()
    
    def convert_page(page_num: int) -> dict:
        """转换单个页面为图片"""
        try:
            page = doc[page_num]
            pdf_rect = page.rect
            pdf_width = pdf_rect.width
            pdf_height = pdf_rect.height
            
            mat = fitz.Matrix(dpi / 72, dpi / 72)
            pix = page.get_pixmap(matrix=mat)
            img_data = pix.tobytes("png")
            
            return {
                "page_num": page_num + 1,
                "image_bytes": img_data,
                "width": pix.width,
                "height": pix.height,
                "pdf_width": pdf_width,
                "pdf_height": pdf_height,
                "dpi": dpi,
                "error": None,
            }
        except Exception as e:
            return {
                "page_num": page_num + 1,
                "image_bytes": None,
                "width": 0,
                "height": 0,
                "pdf_width": 0,
                "pdf_height": 0,
                "dpi": dpi,
                "error": str(e),
            }
    
    def image_producer():
        """生产者：批量转换 PDF 页面为图片"""
        with ThreadPoolExecutor(max_workers=image_workers) as executor:
            for batch_start in range(0, pages_to_process, batch_size):
                batch_end = min(batch_start + batch_size, pages_to_process)
                batch_pages = range(batch_start, batch_end)
                
                futures = {executor.submit(convert_page, p): p for p in batch_pages}
                
                for future in futures:
                    try:
                        result = future.result(timeout=60)
                        image_queue.put(result)
                    except Exception as e:
                        page_num = futures[future]
                        image_queue.put({
                            "page_num": page_num + 1,
                            "image_bytes": None,
                            "error": str(e),
                        })
        
        conversion_done.set()
        print(f"[OCR Pipeline] Image conversion completed for {pages_to_process} pages")
    
    def ocr_consumer():
        """消费者：对图片执行 OCR"""
        nonlocal processed_count
        
        while True:
            if conversion_done.is_set() and image_queue.empty():
                break
            
            try:
                page_info = image_queue.get(timeout=1)
            except Exception:
                continue
            
            page_num = page_info["page_num"]
            page_idx = page_num - 1
            
            if page_info.get("error") or not page_info.get("image_bytes"):
                ocr_pages[page_idx] = {
                    "page_num": page_num,
                    "width": page_info.get("width", 0),
                    "height": page_info.get("height", 0),
                    "pdf_width": page_info.get("pdf_width", 0),
                    "pdf_height": page_info.get("pdf_height", 0),
                    "dpi": page_info.get("dpi", dpi),
                    "regions": [],
                    "text": "",
                    "error": page_info.get("error", "Unknown error"),
                }
                processed_count += 1
                image_queue.task_done()
                continue
            
            fd, temp_path = tempfile.mkstemp(suffix='.png')
            try:
                os.write(fd, page_info["image_bytes"])
                os.close(fd)
                
                page_result = ocr_instance.recognize("", temp_path)
                
                page_data = {
                    "page_num": page_num,
                    "width": page_info["width"],
                    "height": page_info["height"],
                    "pdf_width": page_info["pdf_width"],
                    "pdf_height": page_info["pdf_height"],
                    "dpi": page_info["dpi"],
                    "regions": page_result.get("regions", []),
                    "text": page_result.get("text", ""),
                }
                ocr_pages[page_idx] = page_data
                
                if page_result.get("text"):
                    all_text_parts.append((page_num, page_result["text"]))
                
                processed_count += 1
                
                if progress_callback:
                    progress_callback(processed_count, pages_to_process)
                
                if processed_count % 10 == 0 or processed_count == pages_to_process:
                    print(f"[OCR Pipeline] Progress: {processed_count}/{pages_to_process} pages ({processed_count * 100 // pages_to_process}%)")
                
            except Exception as e:
                ocr_pages[page_idx] = {
                    "page_num": page_num,
                    "width": page_info["width"],
                    "height": page_info["height"],
                    "pdf_width": page_info["pdf_width"],
                    "pdf_height": page_info["pdf_height"],
                    "dpi": page_info["dpi"],
                    "regions": [],
                    "text": "",
                    "error": str(e),
                }
                processed_count += 1
            finally:
                try:
                    os.remove(temp_path)
                except Exception:
                    pass
                image_queue.task_done()
    
    producer_thread = Thread(target=image_producer, name="OCR-ImageProducer")
    consumer_thread = Thread(target=ocr_consumer, name="OCR-Consumer")
    
    print(f"[OCR Pipeline] Starting pipeline processing...")
    start_time = time.time()
    
    producer_thread.start()
    consumer_thread.start()
    
    producer_thread.join()
    consumer_thread.join()
    
    doc.close()
    
    elapsed = time.time() - start_time
    print(f"[OCR Pipeline] Completed in {elapsed:.1f}s, avg {elapsed / pages_to_process:.2f}s per page")
    
    all_text_parts.sort(key=lambda x: x[0])
    full_text_parts = []
    for page_num, text in all_text_parts:
        full_text_parts.append(f"--- Page {page_num} ---")
        full_text_parts.append(text)
    
    ocr_pages = [p for p in ocr_pages if p is not None]
    
    return ocr_pages, "\n".join(full_text_parts), total_pages, len(ocr_pages)


@shared_task(name="tasks.analyze_book_type")
def analyze_book_type(book_id: str, user_id: str):
    """
    【已废弃】此任务已被 extract_book_cover_and_metadata 取代
    
    保留此函数仅为向后兼容，实际 PDF 类型检测已整合到元数据提取流程中。
    """
    async def _run():
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            res = await conn.execute(
                text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                return
            key = row[0]
            is_image_based, conf = _quick_confidence(key)
            
            await conn.execute(
                text(
                    "UPDATE books SET is_digitalized = true, initial_digitalization_confidence = :c, updated_at = now() WHERE id = cast(:id as uuid)"
                ),
                {"c": conf, "id": book_id},
            )
            print(f"[AnalyzeBookType] Book {book_id}: is_image_based={is_image_based}, confidence={conf:.2f}")
        
        try:
            await ws_broadcast(
                f"book:{book_id}",
                json.dumps({
                    "event": "ANALYZED",
                    "confidence": conf,
                    "is_image_based": is_image_based,
                    "is_digitalized": True,
                }),
            )
            print(f"[AnalyzeBookType] WebSocket event broadcasted: ANALYZED")
        except Exception as e:
            print(f"[AnalyzeBookType] Failed to broadcast WebSocket event: {e}")
        
        try:
            async with engine.begin() as conn2:
                await conn2.execute(
                    text(
                        "INSERT INTO audit_logs(id, owner_id, action, details) VALUES (gen_random_uuid(), cast(:uid as uuid), :act, cast(:det as jsonb))"
                    ),
                    {
                        "uid": user_id,
                        "act": "task_analyze_book_type",
                        "det": json.dumps({"book_id": book_id, "confidence": conf, "is_image_based": is_image_based}),
                    },
                )
        except Exception:
            pass

    asyncio.get_event_loop().run_until_complete(_run())


@shared_task(name="tasks.process_book_ocr")
def process_book_ocr(book_id: str, user_id: str):
    """
    处理书籍 OCR 任务（双层 PDF 生成模式）
    
    **架构重构说明**：
    - 旧方案：生成 JSON，前端渲染透明 DOM（存在文字对齐问题）
    - 新方案：后端生成双层 PDF (Invisible Text Layer)，前端直接使用 react-pdf 渲染
    
    优化策略：
    1. 使用生产者-消费者模式：CPU 图片转换和 OCR 识别并行执行
    2. 动态计算工作线程数，预留核心给其他任务
    3. 借助 OCRmyPDF-PaddleOCR 插件生成透明文字层
    4. 生成的双层 PDF 替换原文件，前端无需额外处理
    """
    from ..ocr import get_ocr
    
    print(f"[OCR] Starting OCR task for book {book_id} (Layered PDF Mode)")

    def _embed_ocr_text_to_pdf_with_paddle_plugin(pdf_data: bytes, ocr_pages: list) -> bytes:
        """
        使用 OCRmyPDF-PaddleOCR 插件将 PaddleOCR 识别的文字嵌入 PDF 作为透明文字层
        """
        from pathlib import Path
        from app.services.ocrmypdf_paddle import create_layered_pdf_with_paddle
        
        start_time = time.time()
        print(f"[PaddleOCR Plugin] Starting to embed text layer using OCRmyPDF-PaddleOCR plugin...")
        
        try:
            with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_in:
                temp_in.write(pdf_data)
                temp_in_path = temp_in.name
            
            with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_out:
                temp_out_path = temp_out.name
            
            success = create_layered_pdf_with_paddle(
                pdf_path=temp_in_path,
                output_path=temp_out_path,
                ocr_pages=ocr_pages
            )
            
            if not success:
                raise Exception("Failed to create layered PDF with PaddleOCR plugin")
            
            with open(temp_out_path, 'rb') as f:
                result_data = f.read()
            
            try:
                os.remove(temp_in_path)
                os.remove(temp_out_path)
            except Exception:
                pass
            
            elapsed = time.time() - start_time
            total_regions = sum(len(p.get('regions', [])) for p in ocr_pages)
            print(f"[PaddleOCR Plugin] Successfully embedded {total_regions} text regions in {elapsed:.1f}s")
            
            return result_data
            
        except Exception as e:
            import traceback
            print(f"[PaddleOCR Plugin] Failed to embed text layer: {e}")
            traceback.print_exc()
            raise Exception(f"PaddleOCR Plugin text embedding failed: {e}")

    async def _run():
        # 获取书籍信息并更新状态
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            
            res = await conn.execute(
                text("SELECT minio_key, title FROM books WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            row = res.fetchone()
            if not row:
                print(f"[OCR] Book not found: {book_id}")
                return
            
            minio_key, book_title = row
            
            await conn.execute(
                text("""
                    UPDATE books 
                    SET ocr_status = 'processing', updated_at = now() 
                    WHERE id = cast(:id as uuid)
                """),
                {"id": book_id}
            )
        
        original_minio_key = minio_key
        print(f"[OCR] Processing: {book_title} ({minio_key})")
        
        # 下载 PDF
        pdf_data = read_full(BUCKET, minio_key)
        if not pdf_data:
            print(f"[OCR] Failed to download PDF: {minio_key}")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        print(f"[OCR] Downloaded PDF: {len(pdf_data)} bytes")
        
        # 流水线 OCR 处理
        ocr = get_ocr()
        
        try:
            ocr_pages, full_text, total_pages, processed_pages = _pipeline_ocr_process(
                pdf_data=pdf_data,
                ocr_instance=ocr,
                max_pages=0,
                dpi=150,
                batch_size=20,
                progress_callback=None,
            )
        except Exception as e:
            print(f"[OCR] Pipeline processing failed: {e}")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        if not ocr_pages:
            print(f"[OCR] No pages processed")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        print(f"[OCR] Pipeline completed: {processed_pages}/{total_pages} pages")
        
        # 生成双层 PDF
        print(f"[OCR] Generating layered PDF with PaddleOCR Plugin...")
        try:
            layered_pdf_data = _embed_ocr_text_to_pdf_with_paddle_plugin(pdf_data, ocr_pages)
            print(f"[OCR] Layered PDF generated: {len(layered_pdf_data)} bytes")
        except Exception as e:
            print(f"[OCR] Failed to generate layered PDF: {e}")
            import traceback
            traceback.print_exc()
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        # 上传双层 PDF
        layered_pdf_key = f"users/{user_id}/layered/{book_id}.pdf"
        try:
            upload_bytes(BUCKET, layered_pdf_key, layered_pdf_data, "application/pdf")
            print(f"[OCR] Uploaded layered PDF: {layered_pdf_key}")
        except Exception as e:
            print(f"[OCR] Failed to upload layered PDF: {e}")
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
            return
        
        # 备份原始 PDF
        backup_key = f"users/{user_id}/backups/{book_id}_original.pdf"
        try:
            try:
                read_head(BUCKET, backup_key)
                print(f"[OCR] Backup already exists: {backup_key}")
            except Exception:
                upload_bytes(BUCKET, backup_key, pdf_data, "application/pdf")
                print(f"[OCR] Created backup: {backup_key}")
        except Exception as e:
            print(f"[OCR] Warning: Failed to create backup: {e}")
        
        # 更新数据库
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            
            await conn.execute(
                text("""
                    UPDATE books 
                    SET 
                        minio_key = :layered_key,
                        ocr_status = 'completed',
                        ocr_text = :ocr_text,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {
                    "id": book_id,
                    "layered_key": layered_pdf_key,
                    "ocr_text": full_text[:50000] if full_text else "",
                }
            )
            
            print(f"[OCR] Successfully completed OCR for book {book_id}")
            print(f"[OCR]   Original: {original_minio_key}")
            print(f"[OCR]   Backup: {backup_key}")
            print(f"[OCR]   Layered PDF: {layered_pdf_key}")
        
        # 触发搜索索引
        try:
            from ..search_sync import index_book_content
            search_regions = []
            for page_info in ocr_pages:
                page_num = page_info.get("page_num", 1)
                for region in page_info.get("regions", []):
                    search_regions.append({
                        "text": region.get("text", ""),
                        "page": page_num
                    })
            index_book_content(book_id, user_id, search_regions)
            print(f"[OCR] Triggered search indexing for book {book_id} with {len(search_regions)} regions")
        except Exception as e:
            print(f"[OCR] Warning: Failed to index book content for search: {e}")
        
        # WebSocket 通知
        try:
            await ws_broadcast(
                f"book:{book_id}",
                json.dumps({
                    "event": "OCR_COMPLETED",
                    "book_id": book_id,
                    "ocr_status": "completed",
                    "layered_pdf_key": layered_pdf_key,
                    "message": "OCR processing completed successfully"
                })
            )
        except Exception as e:
            print(f"[OCR] Warning: Failed to broadcast WebSocket message: {e}")
    
    try:
        asyncio.get_event_loop().run_until_complete(_run())
    except Exception as e:
        print(f"[OCR] Task failed with error: {e}")
        import traceback
        traceback.print_exc()
        
        async def _mark_failed():
            async with engine.begin() as conn:
                await conn.execute(
                    text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
                )
                await conn.execute(
                    text("UPDATE books SET ocr_status = 'failed', updated_at = now() WHERE id = cast(:id as uuid)"),
                    {"id": book_id}
                )
        asyncio.get_event_loop().run_until_complete(_mark_failed())


==================================================
FILE_PATH: api/app/services/glyphless_font.py
==================================================

"""
GlyphLess Font for Transparent Text Layer

无字形字体，用于创建透明文字层（完全复制自 OCRmyPDF-EasyOCR）
"""

import importlib.resources
from pikepdf import Dictionary, Name, Pdf

# 从 OCRmyPDF-EasyOCR 复制的 GlyphLess Font 二进制数据
# 这是一个最小化的 TrueType 字体，没有任何字形（glyph）
# 用于创建透明的、可搜索的文字层
GLYPHLESS_FONT = b'\x00\x01\x00\x00\x00\x0c\x00\x80\x00\x03\x00 cmap\x00\x00\x00\x8c\x00\x00\x00\x1aOS/2\x00\x00\x00\xa8\x00\x00\x00`head\x00\x00\x01\x08\x00\x00\x006hhea\x00\x00\x01@\x00\x00\x00$hmtx\x00\x00\x01d\x00\x00\x00\x08loca\x00\x00\x01l\x00\x00\x00\x06maxp\x00\x00\x01t\x00\x00\x00 name\x00\x00\x01\x94\x00\x00\x00\xc5post\x00\x00\x02\\\x00\x00\x00 \x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\xbe\xd0_\x0f<\xf5\x00\x0b\x08\x00\x00\x00\x00\x00\xd0\xd2\x9c]\x00\x00\x00\x00\xdb\xdf\x0c\xd4\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00GlyphLessFont\x00\x00\x00\x00\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\xe8\x00\x00\x03\xe8\x00\x00\x00d\x00\x00\x00d\x00\x00\x00d\x00\x00\x03\xe8\x00\x00\x03\xe8\x00\x00\x00\x00\x00\x02\x03\xe8\x00\x00\x03\xe8\x00\x00\x03\xe8\xff\xff\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xf4\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x90\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x0e\x00\x12\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\x00\x00\x00\x02\x00\x04\x00\x01\x00\x00\x00 \x00\x03\x00\x01\x00\x00\x00$\x00\x06\x00\x16\x00\x00GlyphLessFont\x00\x00\x00\x00\x00R\x00e\x00g\x00u\x00l\x00a\x00r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00G\x00l\x00y\x00p\x00h\x00L\x00e\x00s\x00s\x00F\x00o\x00n\x00t\x00\x00\x00\x00\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00 \x001\x00.\x000\x00\x00\x00\x00\x00\x00\x00\x00\x00G\x00l\x00y\x00p\x00h\x00L\x00e\x00s\x00s\x00F\x00o\x00n\x00t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x80'

CHAR_ASPECT = 2  # 字符宽高比


def register_glyphlessfont(pdf: Pdf):
    """
    在 PDF 中注册 GlyphLess Font
    
    创建一个透明的、无字形的字体，用于 OCR 文字层。
    这个字体的所有字符都没有视觉形状，但可以被选中和搜索。
    
    完全复制自 OCRmyPDF-EasyOCR 的实现。
    
    Args:
        pdf: pikepdf.Pdf 对象
    
    Returns:
        字体对象的间接引用
    """
    PLACEHOLDER = Name.Placeholder

    basefont = pdf.make_indirect(
        Dictionary(
            BaseFont=Name.GlyphLessFont,
            DescendantFonts=[PLACEHOLDER],
            Encoding=Name("/Identity-H"),
            Subtype=Name.Type0,
            ToUnicode=PLACEHOLDER,
            Type=Name.Font,
        )
    )
    
    cid_font_type2 = pdf.make_indirect(
        Dictionary(
            BaseFont=Name.GlyphLessFont,
            CIDToGIDMap=PLACEHOLDER,
            CIDSystemInfo=Dictionary(
                Ordering="Identity",
                Registry="Adobe",
                Supplement=0,
            ),
            FontDescriptor=PLACEHOLDER,
            Subtype=Name.CIDFontType2,
            Type=Name.Font,
            DW=1000 // CHAR_ASPECT,
        )
    )
    
    basefont.DescendantFonts = [cid_font_type2]
    cid_font_type2.CIDToGIDMap = pdf.make_stream(b"\x00\x01" * 65536)
    
    basefont.ToUnicode = pdf.make_stream(
        b"/CIDInit /ProcSet findresource begin\n"
        b"12 dict begin\n"
        b"begincmap\n"
        b"/CIDSystemInfo\n"
        b"<<\n"
        b"  /Registry (Adobe)\n"
        b"  /Ordering (UCS)\n"
        b"  /Supplement 0\n"
        b">> def\n"
        b"/CMapName /Adobe-Identify-UCS def\n"
        b"/CMapType 2 def\n"
        b"1 begincodespacerange\n"
        b"<0000> <FFFF>\n"
        b"endcodespacerange\n"
        b"1 beginbfrange\n"
        b"<0000> <FFFF> <0000>\n"
        b"endbfrange\n"
        b"endcmap\n"
        b"CMapName currentdict /CMap defineresource pop\n"
        b"end\n"
        b"end\n"
    )
    
    font_descriptor = pdf.make_indirect(
        Dictionary(
            Ascent=1000,
            CapHeight=1000,
            Descent=-1,
            Flags=5,  # Fixed pitch and symbolic
            FontBBox=[0, 0, 1000 // CHAR_ASPECT, 1000],
            FontFile2=PLACEHOLDER,
            FontName=Name.GlyphLessFont,
            ItalicAngle=0,
            StemV=80,
            Type=Name.FontDescriptor,
        )
    )
    
    font_descriptor.FontFile2 = pdf.make_stream(GLYPHLESS_FONT)
    cid_font_type2.FontDescriptor = font_descriptor
    
    return basefont


==================================================
FILE_PATH: api/app/services/tts.py
==================================================

"""
TTS（文本转语音）引擎封装

职责：
- 生产环境优先使用 Edge TTS（微软在线合成），支持设置 `voice` 与 `rate`
- 失败或本地离线时回退到 `MockTTS`，生成示例正弦波与简单字幕分割

返回：
- `synthesize(text) -> (audio_bytes, captions)`
- `synthesize_vtt(text) -> (audio_bytes, vtt_string)`
"""
import asyncio
import io
import math
import os

class MockTTS:
    def synthesize(self, text: str) -> tuple[bytes, list[dict]]:
        rate = 16000
        duration = max(0.1, len(text) / 32)
        samples = int(duration * rate)
        buf = io.BytesIO()
        import wave

        w = wave.open(buf, "wb")
        w.setnchannels(1)
        w.setsampwidth(2)
        w.setframerate(rate)
        for i in range(samples):
            val = int(32767 * math.sin(2 * math.pi * 440 * (i / rate)))
            w.writeframes(val.to_bytes(2, byteorder="little", signed=True))
        w.close()
        captions = []
        t = 0.0
        for chunk in text.split():
            captions.append(
                {"start": round(t, 2), "end": round(t + 0.2, 2), "text": chunk}
            )
            t += 0.2
        return buf.getvalue(), captions

class EdgeTTSEngine:
    def __init__(self, voice: str | None = None, rate: str | None = None):
        self.voice = voice or os.getenv("TTS_VOICE", "zh-CN-XiaoxiaoNeural")
        self.rate = rate or os.getenv("TTS_RATE", "+0%")

    async def _gen(self, text: str) -> bytes:
        import edge_tts

        c = edge_tts.Communicate(text, voice=self.voice, rate=self.rate)
        audio = b""
        async for chunk in c.stream():
            if chunk["type"] == "audio":
                audio += chunk["data"]
        return audio

    def synthesize(self, text: str) -> tuple[bytes, list[dict]]:
        try:
            audio = asyncio.get_event_loop().run_until_complete(self._gen(text))
        except Exception:
            audio = asyncio.run(self._gen(text))
        captions = []
        t = 0.0
        for w in text.split():
            s = t
            e = t + 0.2
            captions.append({"start": round(s, 2), "end": round(e, 2), "text": w})
            t = e
        return audio, captions

    def synthesize_vtt(self, text: str) -> tuple[bytes, str]:
        audio, caps = self.synthesize(text)

        def _fmt(t: float) -> str:
            ms = int(round(t * 1000))
            h = ms // 3600000
            ms = ms % 3600000
            m = ms // 60000
            ms = ms % 60000
            s = ms // 1000
            ms = ms % 1000
            return f"{h:02d}:{m:02d}:{s:02d}.{ms:03d}"

        lines = ["WEBVTT"]
        idx = 1
        for c in caps:
            start = _fmt(float(c["start"]))
            end = _fmt(float(c["end"]))
            lines.append(str(idx))
            lines.append(f"{start} --> {end}")
            lines.append(str(c["text"]))
            lines.append("")
            idx += 1
        vtt = "\n".join(lines)
        return audio, vtt

def get_tts():
    """
    获取 TTS 引擎实例
    生产环境返回 `EdgeTTSEngine`，异常时回退到 `MockTTS`
    """
    try:
        return EdgeTTSEngine()
    except Exception:
        return MockTTS()


==================================================
FILE_PATH: api/app/services/ocr.py
==================================================

"""
OCR 引擎封装

职责：
- 在生产环境使用 PaddleOCR 3.x（PP-OCRv5 系列）进行文本检测与识别
- 在 CI/测试环境使用 `MockOCR` 返回空结果以保证稳定性

实现要点：
- 通过预签名 URL 下载原文件到带正确后缀的临时路径，避免 `predict()` 因查询参数无法识别类型
- 统一返回结构：`{"regions": [{text, confidence, bbox?, polygon?}], "text": "..."}`
- 兼容不同版本返回的结果结构（属性或字典）
"""
import io
import os
from typing import Any
from ..storage import presigned_get


class MockOCR:
    """Mock OCR for CI/testing environments"""
    def recognize(self, bucket: str, key: str) -> dict:
        return {"pages": [], "text": ""}


class PaddleOCREngine:
    """
    PP-OCRv5 Engine (PaddleOCR 3.x API)
    - 支持：简体中文、繁体中文、英文、日文、手写体
    - GPU 自动检测：PaddlePaddle 3.0 根据安装版本自动选择设备
    - 推荐并发：2 Workers (8GB GPU) / 3 Workers (12GB GPU)
    
    PaddleOCR 3.x 主要变化：
    - 使用 predict() 而非 ocr()
    - 通过 text_detection_model_name / text_recognition_model_name 指定模型
    - 设备选择由 PaddlePaddle 框架自动处理
    """
    
    def __init__(self):
        from paddleocr import PaddleOCR
        
        # PaddleOCR 3.x 初始化参数
        # 模型选择：PP-OCRv5_server (高精度) 或 PP-OCRv5_mobile (平衡)
        use_mobile = os.getenv("OCR_USE_MOBILE", "true").lower() == "true"
        
        model_suffix = "mobile" if use_mobile else "server"
        det_model = os.getenv("OCR_DET_MODEL", f"PP-OCRv5_{model_suffix}_det")
        rec_model = os.getenv("OCR_REC_MODEL", f"PP-OCRv5_{model_suffix}_rec")
        
        self.ocr = PaddleOCR(
            text_detection_model_name=det_model,
            text_recognition_model_name=rec_model,
            use_doc_orientation_classify=False,  # 关闭文档方向分类（加速）
            use_doc_unwarping=False,             # 关闭文档矫正（加速）
            use_textline_orientation=False,      # 关闭文本行方向分类（加速）
        )
        
        import logging
        logging.info(f"[OCR] PaddleOCR 3.x initialized with det={det_model}, rec={rec_model}")

    def _download_to_temp(self, bucket: str, key: str) -> str:
        """
        下载文件到临时目录并返回本地路径
        PaddleOCR 3.x 的 predict() 方法需要文件后缀来识别文件类型
        presigned URL 中的查询参数会导致后缀识别失败
        """
        import tempfile
        import requests
        from urllib.parse import urlparse
        
        url = presigned_get(bucket, key) if not key.startswith("http") else key
        
        # 从 key 中提取原始文件扩展名
        path = urlparse(key if not key.startswith("http") else url).path
        # 获取不含查询参数的路径的扩展名
        ext = os.path.splitext(path.split('?')[0])[1] or '.png'
        
        # 创建临时文件
        fd, temp_path = tempfile.mkstemp(suffix=ext)
        try:
            response = requests.get(url, timeout=60)
            response.raise_for_status()
            os.write(fd, response.content)
        finally:
            os.close(fd)
        
        return temp_path

    def recognize(self, bucket: str, key: str) -> dict:
        """
        识别单张图片
        Args:
            bucket: S3 bucket 名称，如果为空则 key 视为本地文件路径
            key: S3 object key 或本地文件路径
        返回: {"pages": [{"text": "行文本", "confidence": 0.99}], "text": "完整文本"}
        """
        temp_path = None
        is_local = not bucket  # bucket 为空表示 key 是本地路径
        
        try:
            if is_local:
                # 直接使用本地路径
                file_path = key
            else:
                # 从 S3 下载到临时文件（带正确后缀）
                temp_path = self._download_to_temp(bucket, key)
                file_path = temp_path
            
            # PaddleOCR 3.x 使用 predict() 方法
            results = self.ocr.predict(file_path)
            
            regions = []
            text = ""
            
            for res in results:
                # 获取识别结果 - 包含坐标信息
                rec_texts = getattr(res, 'rec_texts', []) or []
                rec_scores = getattr(res, 'rec_scores', []) or []
                rec_polys = getattr(res, 'rec_polys', []) or []  # 4点多边形坐标
                rec_boxes = getattr(res, 'rec_boxes', []) or []  # 边界框 [x1,y1,x2,y2]
                
                # 兼容 res['res'] 格式
                if not rec_texts and hasattr(res, '__getitem__'):
                    try:
                        res_data = res.get('res', res) if isinstance(res, dict) else res
                        rec_texts = getattr(res_data, 'rec_texts', []) or res_data.get('rec_texts', []) if isinstance(res_data, dict) else []
                        rec_scores = getattr(res_data, 'rec_scores', []) or res_data.get('rec_scores', []) if isinstance(res_data, dict) else []
                        rec_polys = getattr(res_data, 'rec_polys', []) or res_data.get('rec_polys', []) if isinstance(res_data, dict) else []
                        rec_boxes = getattr(res_data, 'rec_boxes', []) or res_data.get('rec_boxes', []) if isinstance(res_data, dict) else []
                    except Exception:
                        pass
                
                for i, txt in enumerate(rec_texts):
                    if txt:
                        score = rec_scores[i] if i < len(rec_scores) else 0.0
                        text += txt + "\n"
                        
                        region = {
                            "text": txt,
                            "confidence": float(score),
                        }
                        
                        # 添加边界框坐标 [x1, y1, x2, y2]
                        if i < len(rec_boxes):
                            bbox = rec_boxes[i]
                            if hasattr(bbox, 'tolist'):
                                bbox = bbox.tolist()
                            region["bbox"] = [float(v) for v in bbox]
                        
                        # 添加多边形坐标 [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
                        if i < len(rec_polys):
                            poly = rec_polys[i]
                            if hasattr(poly, 'tolist'):
                                poly = poly.tolist()
                            region["polygon"] = [[float(p[0]), float(p[1])] for p in poly]
                        
                        regions.append(region)
            
            return {"regions": regions, "text": text.strip()}
        except Exception as e:
            import logging
            logging.warning(f"[OCR] Recognition failed: {e}")
            return {"pages": [], "text": ""}
        finally:
            # 清理临时文件
            if temp_path and os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                except Exception:
                    pass


class OCRmyPDFEngine:
    """
    OCRmyPDF 引擎 - 使用 PaddleOCR 作为识别引擎生成高质量双层PDF
    
    优势：
    - 自动处理坐标映射，文字对齐精确
    - 支持图像预处理（去噪、矫正、优化）
    - 生成的PDF完全兼容标准
    - 透明文字层与原图完美对齐
    
    工作流程：
    1. 使用 PaddleOCR 识别文字和坐标
    2. 生成 hOCR 格式中间文件
    3. OCRmyPDF 使用 hOCR 数据生成双层PDF
    """
    
    def __init__(self):
        self.paddle_engine = PaddleOCREngine()
        import logging
        logging.info("[OCR] OCRmyPDF engine initialized with PaddleOCR backend")
    
    def recognize(self, bucket: str, key: str) -> dict:
        """
        识别图片（兼容接口）
        对于双层PDF生成，使用 create_searchable_pdf() 方法
        """
        return self.paddle_engine.recognize(bucket, key)
    
    def create_searchable_pdf(self, input_pdf_path: str, output_pdf_path: str, ocr_results: list = None) -> bool:
        """
        创建可搜索的双层PDF
        
        Args:
            input_pdf_path: 原始PDF路径（图片型PDF）
            output_pdf_path: 输出PDF路径
            ocr_results: 可选的OCR结果（PaddleOCR格式），如果提供则使用，否则重新识别
        
        Returns:
            bool: 成功返回True，失败返回False
        """
        import ocrmypdf
        import tempfile
        import os
        import logging
        
        try:
            if ocr_results:
                # 使用已有的 PaddleOCR 结果生成 hOCR
                hocr_path = self._paddle_to_hocr(input_pdf_path, ocr_results)
                
                # 使用 hOCR 生成双层PDF
                ocrmypdf.ocr(
                    input_pdf_path,
                    output_pdf_path,
                    language='chi_sim+eng',
                    sidecar=None,
                    deskew=False,  # 已经由PaddleOCR处理
                    clean=False,   # 不修改原图
                    force_ocr=True,
                    skip_text=True,  # 跳过已有文字层
                    optimize=1,
                    pdf_renderer='hocr',
                    use_threads=True,
                    jobs=4,
                    # 使用自定义的 hOCR 文件
                    tesseract_config='--user-words ' + hocr_path if os.path.exists(hocr_path) else '',
                )
                
                # 清理临时文件
                if os.path.exists(hocr_path):
                    os.remove(hocr_path)
            else:
                # 直接使用 OCRmyPDF 的默认引擎（Tesseract）
                ocrmypdf.ocr(
                    input_pdf_path,
                    output_pdf_path,
                    language='chi_sim+eng',
                    deskew=True,
                    clean=True,
                    force_ocr=True,
                    skip_text=True,
                    optimize=1,
                    use_threads=True,
                    jobs=4,
                    png_quality=85,
                    jpeg_quality=85,
                )
            
            logging.info(f"[OCRmyPDF] Successfully created searchable PDF: {output_pdf_path}")
            return True
            
        except Exception as e:
            logging.error(f"[OCRmyPDF] Failed to create searchable PDF: {e}")
            return False
    
    def _paddle_to_hocr(self, pdf_path: str, ocr_results: list) -> str:
        """
        将 PaddleOCR 结果转换为 hOCR 格式
        
        hOCR 格式示例:
        <div class='ocr_page' title='bbox 0 0 1240 1754'>
          <div class='ocr_carea' title='bbox 100 100 500 150'>
            <span class='ocrx_word' title='bbox 100 100 200 150'>中国</span>
          </div>
        </div>
        """
        import tempfile
        import fitz
        from html import escape
        
        # 打开PDF获取页面尺寸
        doc = fitz.open(pdf_path)
        
        fd, hocr_path = tempfile.mkstemp(suffix='.hocr')
        
        try:
            with os.fdopen(fd, 'w', encoding='utf-8') as f:
                f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
                f.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ')
                f.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n')
                f.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">\n')
                f.write('<head><meta http-equiv="content-type" content="text/html; charset=utf-8" />\n')
                f.write('<title>OCR Output</title></head><body>\n')
                
                for page_info in ocr_results:
                    page_num = page_info.get('page_num', 1)
                    page_idx = page_num - 1
                    
                    if page_idx >= len(doc):
                        continue
                    
                    page = doc[page_idx]
                    page_rect = page.rect
                    width = int(page_rect.width)
                    height = int(page_rect.height)
                    
                    # OCR 图片尺寸
                    ocr_width = page_info.get('width', width)
                    ocr_height = page_info.get('height', height)
                    
                    # 计算缩放比例
                    scale_x = width / ocr_width if ocr_width > 0 else 1
                    scale_y = height / ocr_height if ocr_height > 0 else 1
                    
                    f.write(f'<div class="ocr_page" id="page_{page_num}" title="bbox 0 0 {width} {height}">\n')
                    
                    regions = page_info.get('regions', [])
                    for i, region in enumerate(regions):
                        text = region.get('text', '').strip()
                        if not text:
                            continue
                        
                        # 获取坐标
                        bbox = region.get('bbox') or region.get('box')
                        if not bbox:
                            polygon = region.get('polygon')
                            if polygon and len(polygon) >= 4:
                                # 从多边形提取边界框
                                xs = [p[0] for p in polygon]
                                ys = [p[1] for p in polygon]
                                bbox = [min(xs), min(ys), max(xs), max(ys)]
                        
                        if not bbox:
                            continue
                        
                        # 处理不同格式
                        if isinstance(bbox[0], list):
                            x1, y1 = bbox[0]
                            x2, y2 = bbox[2]
                        else:
                            x1, y1, x2, y2 = bbox[:4]
                        
                        # 映射到PDF坐标
                        x1 = int(x1 * scale_x)
                        y1 = int(y1 * scale_y)
                        x2 = int(x2 * scale_x)
                        y2 = int(y2 * scale_y)
                        
                        # 确保坐标正确
                        if x1 > x2:
                            x1, x2 = x2, x1
                        if y1 > y2:
                            y1, y2 = y2, y1
                        
                        confidence = region.get('confidence', 1.0)
                        
                        # 写入 hOCR
                        f.write(f'  <div class="ocr_carea" id="carea_{page_num}_{i}">\n')
                        f.write(f'    <span class="ocrx_word" title="bbox {x1} {y1} {x2} {y2}; x_wconf {int(confidence * 100)}">')
                        f.write(escape(text))
                        f.write('</span>\n')
                        f.write('  </div>\n')
                    
                    f.write('</div>\n')
                
                f.write('</body></html>\n')
            
            doc.close()
            return hocr_path
            
        except Exception as e:
            if os.path.exists(hocr_path):
                os.remove(hocr_path)
            raise e


def get_ocr(use_ocrmypdf: bool = True):
    """
    获取 OCR 引擎实例
    
    Args:
        use_ocrmypdf: 是否使用 OCRmyPDF 引擎（推荐）
    
    Returns:
        OCR引擎实例
    """
    try:
        if use_ocrmypdf:
            try:
                return OCRmyPDFEngine()
            except Exception as e:
                import logging
                logging.warning(f"[OCR] Failed to load OCRmyPDF, falling back to PaddleOCR: {e}")
                return PaddleOCREngine()
        else:
            return PaddleOCREngine()
    except Exception as e:
        import logging
        logging.warning(f"[OCR] Failed to load PaddleOCR, using MockOCR: {e}")
        return MockOCR()


==================================================
FILE_PATH: api/app/services/embedder.py
==================================================

"""
嵌入向量引擎

说明：
- `LocalEmbedder` 使用 BGE-M3 本地模型（优先 GPU，失败回退 CPU）
- `MockEmbedder` 在 CI/测试环境返回固定向量
- `get_embedder` 根据环境选择实现
"""
import os
import logging


class MockEmbedder:
    """Mock Embedder for CI/testing environments"""
    
    def __init__(self, dim: int = 1024):
        self.dim = dim

    def embed(self, texts: list[str]) -> list[list[float]]:
        return [[0.0] * self.dim for _ in texts]


class LocalEmbedder:
    """
    BGE-M3 Local Embedding Engine
    - 模型: BAAI/bge-m3 (1024 维度)
    - 支持: 中英日韩等多语言
    - 设备: 优先 GPU，fallback 到 CPU
    """
    
    def __init__(self):
        from FlagEmbedding import BGEM3FlagModel

        # 缓存目录配置
        cache = (
            os.getenv("HF_HOME") or os.getenv("TRANSFORMERS_CACHE") or "/app/.hf_cache"
        )
        os.environ["HF_HOME"] = cache
        os.environ["TRANSFORMERS_CACHE"] = cache
        os.environ["HUGGINGFACE_HUB_CACHE"] = cache
        
        # 模型配置
        model_name = os.getenv("EMBEDDING_MODEL_NAME", "BAAI/bge-m3")
        
        # 设备选择: 优先使用 GPU
        use_gpu = os.getenv("EMBEDDING_USE_GPU", "true").lower() == "true"
        device = "cuda" if use_gpu else "cpu"
        
        try:
            self.model = BGEM3FlagModel(
                model_name_or_path=model_name,
                device=device,
                use_fp16=use_gpu,  # GPU 时使用半精度加速
            )
            logging.info(f"[Embedder] Loaded {model_name} on {device}")
        except Exception as e:
            logging.warning(f"[Embedder] Failed to load on {device}, fallback to CPU: {e}")
            self.model = BGEM3FlagModel(
                model_name_or_path=model_name,
                device="cpu",
                use_fp16=False,
            )

    def embed(self, texts: list[str]) -> list[list[float]]:
        """
        生成文本向量
        返回: List[List[float]] - 1024 维向量列表
        """
        try:
            # BGE-M3 返回 dense_vecs
            output = self.model.encode(
                texts,
                batch_size=32,
                max_length=512,
            )
            vecs = output.get("dense_vecs") if isinstance(output, dict) else output
            return [list(map(float, v)) for v in vecs]
        except Exception as e:
            logging.warning(f"[Embedder] Encoding failed: {e}")
            return [[0.0] * 1024 for _ in texts]


def get_embedder():
    """
    获取 Embedder 实例
    生产环境返回 LocalEmbedder，CI/测试环境返回 MockEmbedder
    """
    try:
        return LocalEmbedder()
    except Exception as e:
        logging.warning(f"[Embedder] Failed to load BGE-M3, using MockEmbedder: {e}")
        return MockEmbedder()


==================================================
FILE_PATH: api/app/services/book_service.py
==================================================

"""
书籍服务（内部）

功能：
- 生成上传 URL（预签名 PUT）与对象键
- 创建书籍记录，复用 ETag 去重
"""
import os
import uuid
from sqlalchemy import text

from ..db import engine
from ..storage import make_object_key, presigned_put, presigned_get, stat_etag

BUCKET = os.getenv("MINIO_BUCKET", "athena")


async def get_upload_url(user_id: str, filename: str, content_type: str | None = None) -> dict:
  key = make_object_key(user_id, filename)
  url = presigned_put(BUCKET, key, content_type=content_type)
  return {"key": key, "upload_url": url}


async def create_book(user_id: str, body: dict) -> dict:
  key = body.get("key")
  title = body.get("title") or "Untitled"
  author = body.get("author") or ""
  language = body.get("language") or ""
  original_format = body.get("original_format") or ""
  size = body.get("size") or None
  book_id = str(uuid.uuid4())
  etag = stat_etag(BUCKET, key)

  async with engine.begin() as conn:
    await conn.execute(text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id})
    if etag:
      res = await conn.execute(text("SELECT id::text FROM books WHERE user_id = current_setting('app.user_id')::uuid AND source_etag = :e"), {"e": etag})
      row = res.fetchone()
      if row:
        return {"id": row[0], "download_url": presigned_get(BUCKET, key)}
    await conn.execute(text("""
      INSERT INTO books(id, user_id, title, author, language, original_format, minio_key, size, source_etag)
      VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt, :key, :size, :etag)
    """), {"id": book_id, "uid": user_id, "title": title, "author": author, "language": language, "fmt": original_format, "key": key, "size": size, "etag": etag})

  return {"id": book_id, "download_url": presigned_get(BUCKET, key)}


==================================================
FILE_PATH: api/app/services/ocrmypdf_paddle.py
==================================================

"""
OCRmyPDF PaddleOCR Plugin

参照 OCRmyPDF-EasyOCR 的实现模式，创建 PaddleOCR 插件。
使用 PaddleOCR 的精确多边形坐标生成双层 PDF。

关键特性：
- 使用 pikepdf 直接生成文字层 PDF（与 OCRmyPDF-EasyOCR 相同的方法）
- PaddleOCR 的多边形坐标 (polygon) 提供精确的文字位置
- 透明文字层（Rendering Mode 3）完美覆盖原图
- 支持旋转文本（使用文字矩阵 Tm）
"""

import logging
import os
from math import atan2, cos, hypot, sin
from pathlib import Path
from typing import Iterable, NamedTuple

from pikepdf import (
    ContentStreamInstruction,
    Dictionary,
    Name,
    Operator,
    Pdf,
    unparse_content_stream,
)
from PIL import Image

log = logging.getLogger(__name__)

# 字符宽高比（用于水平拉伸计算）
CHAR_ASPECT = 2


class PaddleOCRResult(NamedTuple):
    """PaddleOCR 识别结果"""
    polygon: list  # 四边形坐标 [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
    text: str
    confidence: float


def paddle_result_to_quad(region: dict) -> PaddleOCRResult:
    """
    将 PaddleOCR 的 region 转换为标准格式
    
    PaddleOCR 输出格式:
    {
        "text": "文本内容",
        "confidence": 0.95,
        "polygon": [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]  # 左上、右上、右下、左下
    }
    """
    polygon = region.get("polygon", [])
    if not polygon or len(polygon) < 4:
        # 如果没有 polygon，尝试从 bbox 生成
        bbox = region.get("bbox") or region.get("box")
        if bbox:
            if isinstance(bbox[0], list):
                x1, y1 = bbox[0]
                x2, y2 = bbox[2]
            else:
                x1, y1, x2, y2 = bbox[:4]
            polygon = [[x1, y1], [x2, y1], [x2, y2], [x1, y2]]
    
    # 展平为一维列表 [x1, y1, x2, y2, x3, y3, x4, y4]
    quad = []
    for point in polygon[:4]:  # 只取前4个点
        quad.extend(point[:2])  # 只取 x, y
    
    return PaddleOCRResult(
        polygon=quad,
        text=region.get("text", ""),
        confidence=region.get("confidence", 1.0)
    )


def pt_from_pixel(polygon, scale, height):
    """
    将像素坐标转换为 PDF 点坐标
    
    Args:
        polygon: 一维列表 [x1, y1, x2, y2, x3, y3, x4, y4]
        scale: (scale_x, scale_y) 缩放比例
        height: 图片高度（用于 Y 轴翻转）
    
    Returns:
        PDF 点坐标列表 [x1, y1, x2, y2, x3, y3, x4, y4]
    """
    point_pairs = [
        (x * scale[0], (height - y) * scale[1]) 
        for x, y in zip(polygon[0::2], polygon[1::2])
    ]
    return [elm for pt in point_pairs for elm in pt]


def bbox_string(bbox):
    """格式化边界框坐标为字符串"""
    return ", ".join(f"{elm:.0f}" for elm in bbox)


class ContentStreamBuilder:
    """PDF 内容流构建器（与 OCRmyPDF-EasyOCR 相同）"""
    
    def __init__(self, instructions=None):
        self._instructions = instructions or []

    def q(self):
        """保存图形状态"""
        inst = [ContentStreamInstruction([], Operator("q"))]
        return ContentStreamBuilder(self._instructions + inst)

    def Q(self):
        """恢复图形状态"""
        inst = [ContentStreamInstruction([], Operator("Q"))]
        return ContentStreamBuilder(self._instructions + inst)

    def BT(self):
        """开始文本对象"""
        inst = [ContentStreamInstruction([], Operator("BT"))]
        return ContentStreamBuilder(self._instructions + inst)

    def ET(self):
        """结束文本对象"""
        inst = [ContentStreamInstruction([], Operator("ET"))]
        return ContentStreamBuilder(self._instructions + inst)

    def BDC(self, mctype: Name, mcid: int):
        """开始标记内容序列"""
        inst = [
            ContentStreamInstruction([mctype, Dictionary(MCID=mcid)], Operator("BDC"))
        ]
        return ContentStreamBuilder(self._instructions + inst)

    def EMC(self):
        """结束标记内容序列"""
        inst = [ContentStreamInstruction([], Operator("EMC"))]
        return ContentStreamBuilder(self._instructions + inst)

    def Tf(self, font: Name, size: float):
        """设置文本字体和大小"""
        inst = [ContentStreamInstruction([font, size], Operator("Tf"))]
        return ContentStreamBuilder(self._instructions + inst)

    def Tm(self, a: float, b: float, c: float, d: float, e: float, f: float):
        """设置文本矩阵（用于定位和旋转文字）"""
        inst = [ContentStreamInstruction([a, b, c, d, e, f], Operator("Tm"))]
        return ContentStreamBuilder(self._instructions + inst)

    def Tr(self, mode: int):
        """设置文本渲染模式 (3 = 不可见/透明)"""
        inst = [ContentStreamInstruction([mode], Operator("Tr"))]
        return ContentStreamBuilder(self._instructions + inst)

    def Tz(self, scale: float):
        """设置文本水平缩放"""
        inst = [ContentStreamInstruction([scale], Operator("Tz"))]
        return ContentStreamBuilder(self._instructions + inst)

    def TJ(self, text):
        """显示文本"""
        inst = [ContentStreamInstruction([[text.encode("utf-16be")]], Operator("TJ"))]
        return ContentStreamBuilder(self._instructions + inst)

    def build(self):
        return self._instructions

    def add(self, other):
        return ContentStreamBuilder(self._instructions + other._instructions)


def generate_text_content_stream(
    results: Iterable[PaddleOCRResult],
    scale: tuple[float, float],
    height: int,
):
    """
    生成 PDF 文本内容流
    
    核心算法（与 OCRmyPDF-EasyOCR 相同）：
    1. 将 OCR 坐标转换为 PDF 坐标（Y轴翻转）
    2. 计算文字角度（使用 atan2）
    3. 根据 bbox 高度计算字体大小
    4. 使用 Tm 矩阵精确定位文字（包含旋转）
    5. 使用 Tz 水平拉伸以匹配实际宽度
    6. 使用 Tr(3) 设置为不可见（透明）
    
    Args:
        results: PaddleOCR 识别结果列表
        scale: (scale_x, scale_y) 缩放比例
        height: 图片高度
    
    Returns:
        PDF 内容流指令列表
    """
    cs = ContentStreamBuilder()
    cs = cs.add(cs.q())
    
    for n, result in enumerate(results):
        if not result.text:
            continue
        
        log.debug(f"Textline '{result.text}' in-image bbox: {bbox_string(result.polygon)}")
        
        # 转换为 PDF 坐标（Y轴翻转）
        bbox = pt_from_pixel(result.polygon, scale, height)
        
        # 计算文字角度（基于底边）
        angle = -atan2(bbox[5] - bbox[7], bbox[4] - bbox[6])
        if abs(angle) < 0.01:  # 小于 0.57 度，视为水平
            angle = 0.0
        cos_a, sin_a = cos(angle), sin(angle)
        
        # 计算字体大小（基于左边的高度）
        font_size = hypot(bbox[0] - bbox[6], bbox[1] - bbox[7])
        
        log.debug(f"Textline '{result.text}' PDF bbox: {bbox_string(bbox)}")
        
        # 计算文字框宽度（底边长度）
        box_width = hypot(bbox[4] - bbox[6], bbox[5] - bbox[7])
        
        if len(result.text) == 0 or box_width == 0 or font_size == 0:
            continue
        
        # 计算水平拉伸比例
        # 100% = 正常宽度
        # CHAR_ASPECT 是字符宽高比调整因子
        h_stretch = 100.0 * box_width / len(result.text) / font_size * CHAR_ASPECT
        
        # 构建文本对象
        cs = cs.add(
            ContentStreamBuilder()
            .BT()
            .BDC(Name.Span, n)
            .Tr(3)  # 透明模式（不可见）
            .Tm(cos_a, -sin_a, sin_a, cos_a, bbox[6], bbox[7])  # 文本矩阵（旋转+定位）
            .Tf(Name("/f-0-0"), font_size)
            .Tz(h_stretch)  # 水平拉伸
            .TJ(result.text)
            .EMC()
            .ET()
        )
    
    cs = cs.Q()
    return cs.build()


def paddle_to_pdf(
    image_filename: Path,
    image_scale: float,
    regions: list,
    output_pdf: Path,
):
    """
    使用 PaddleOCR 结果生成文字层 PDF（完全参照 OCRmyPDF-EasyOCR）
    
    Args:
        image_filename: 原始图片路径
        image_scale: 图片缩放比例（1.0 = 原始大小）
        regions: PaddleOCR 识别结果列表（dict 格式）
        output_pdf: 输出 PDF 路径
    
    Returns:
        output_pdf
    """
    # 转换为标准格式
    results = [paddle_result_to_quad(r) for r in regions]
    
    # 获取图片尺寸和 DPI
    with Image.open(image_filename) as im:
        dpi = im.info.get("dpi", (72, 72))
        scale = 72.0 / dpi[0] / image_scale, 72.0 / dpi[1] / image_scale
        width = im.width
        height = im.height
    
    # 创建 PDF
    with Pdf.new() as pdf:
        # 创建空白页
        pdf.add_blank_page(page_size=(width * scale[0], height * scale[1]))
        
        # 注册 GlyphLessFont（无字形字体，用于透明文字层）
        from .glyphless_font import register_glyphlessfont
        pdf.pages[0].Resources = Dictionary(
            Font=Dictionary({"/f-0-0": register_glyphlessfont(pdf)})
        )
        
        # 生成文本内容流
        cs = generate_text_content_stream(results, scale, height)
        pdf.pages[0].Contents = pdf.make_stream(unparse_content_stream(cs))
        
        pdf.save(output_pdf)
    
    return output_pdf


def create_layered_pdf_with_paddle(pdf_path: str, output_path: str, ocr_pages: list) -> bool:
    """
    使用 PaddleOCR 结果和 OCRmyPDF 创建双层 PDF
    
    工作流程：
    1. 将 PDF 每页转换为图片
    2. 为每页生成带文字层的 PDF（使用 paddle_to_pdf）
    3. 使用 OCRmyPDF 的 sandwich 模式将文字层叠加到原始 PDF
    
    Args:
        pdf_path: 原始 PDF 路径
        output_path: 输出 PDF 路径
        ocr_pages: OCR 结果列表（PaddleOCR 格式）
    
    Returns:
        bool: 成功返回 True
    """
    import fitz  # PyMuPDF
    import tempfile
    import ocrmypdf
    
    try:
        doc = fitz.open(pdf_path)
        temp_dir = tempfile.mkdtemp()
        
        log.info(f"[PaddleOCR Plugin] Processing {len(ocr_pages)} pages...")
        
        # 为每页生成带文字层的 PDF
        text_pdfs = []
        for page_info in ocr_pages:
            page_num = page_info.get("page_num", 1)
            page_idx = page_num - 1
            
            if page_idx >= len(doc):
                continue
            
            page = doc[page_idx]
            
            # 渲染页面为图片
            pix = page.get_pixmap(dpi=150)
            img_path = Path(temp_dir) / f"page_{page_num}.png"
            pix.save(str(img_path))
            
            # 生成文字层 PDF
            text_pdf_path = Path(temp_dir) / f"text_{page_num}.pdf"
            regions = page_info.get("regions", [])
            
            paddle_to_pdf(
                image_filename=img_path,
                image_scale=1.0,
                regions=regions,
                output_pdf=text_pdf_path,
            )
            
            text_pdfs.append(text_pdf_path)
        
        doc.close()
        
        # 使用 OCRmyPDF 的 sandwich 模式合并
        # 注意：这里直接使用 OCRmyPDF 的内部 API 会更高效
        # 但为了简单起见，先使用基本的叠加方法
        
        log.info(f"[PaddleOCR Plugin] Merging text layers with original PDF...")
        
        # 简化方案：直接使用 pikepdf 叠加
        _merge_text_layers(pdf_path, text_pdfs, output_path)
        
        # 清理临时文件
        import shutil
        shutil.rmtree(temp_dir)
        
        log.info(f"[PaddleOCR Plugin] Successfully created layered PDF: {output_path}")
        return True
        
    except Exception as e:
        log.error(f"[PaddleOCR Plugin] Failed to create layered PDF: {e}")
        import traceback
        traceback.print_exc()
        return False


def _merge_text_layers(original_pdf: str, text_pdfs: list, output_pdf: str):
    """
    将文字层 PDF 叠加到原始 PDF
    
    使用 pikepdf 将透明文字层复制到原始 PDF 的每一页
    
    关键：使用 copy_foreign() 复制来自其他 PDF 的对象，
    避免 "attempted to unparse a pikepdf.Object from a destroyed pikepdf.Pdf" 错误
    """
    from pikepdf import Pdf, Page, Array
    
    # 打开原始 PDF（不使用 with，因为需要在循环中保持打开状态直到保存）
    original = Pdf.open(original_pdf)
    
    try:
        # 为每页添加文字层
        for i, text_pdf_path in enumerate(text_pdfs):
            if i >= len(original.pages):
                break
            
            # 打开文字层 PDF
            text_pdf = Pdf.open(text_pdf_path)
            
            try:
                if len(text_pdf.pages) == 0:
                    continue
                
                # 获取原始页面和文字层页面
                original_page = original.pages[i]
                text_page = text_pdf.pages[0]
                
                # 复制文字层的内容流和资源
                # 关键：使用 copy_foreign() 将对象复制到目标 PDF
                if '/Contents' in text_page:
                    # 复制内容流（必须使用 copy_foreign）
                    if isinstance(text_page.Contents, Array):
                        copied_contents = [original.copy_foreign(c) for c in text_page.Contents]
                    else:
                        copied_contents = [original.copy_foreign(text_page.Contents)]
                    
                    # 如果原始页面已有内容流，追加文字层内容
                    if '/Contents' in original_page:
                        # 确保 Contents 是数组
                        if isinstance(original_page.Contents, Array):
                            for c in copied_contents:
                                original_page.Contents.append(c)
                        else:
                            # 转换为数组
                            original_contents = original_page.Contents
                            original_page.Contents = Array([original_contents] + copied_contents)
                    else:
                        if len(copied_contents) == 1:
                            original_page.Contents = copied_contents[0]
                        else:
                            original_page.Contents = Array(copied_contents)
                
                # 合并资源（字体）- 同样需要 copy_foreign
                if '/Resources' in text_page:
                    if '/Resources' not in original_page:
                        original_page.Resources = Dictionary()
                    
                    if '/Font' in text_page.Resources:
                        if '/Font' not in original_page.Resources:
                            original_page.Resources.Font = Dictionary()
                        
                        # 复制字体资源（必须使用 copy_foreign）
                        for font_name, font_obj in text_page.Resources.Font.items():
                            original_page.Resources.Font[font_name] = original.copy_foreign(font_obj)
            
            finally:
                text_pdf.close()
        
        # 保存结果
        original.save(output_pdf)
    
    finally:
        original.close()


==================================================
FILE_PATH: api/app/services/__init__.py
==================================================

"""
服务工厂与统一出口

本模块用于聚合并导出服务工厂方法，方便上层通过单一入口获取能力：
- `get_ocr`：返回 OCR 引擎（生产为 PaddleOCR，测试为 Mock）
- `get_embedder`：返回嵌入向量引擎（生产为本地 BGE-M3，测试为 Mock）
- `get_tts`：返回 TTS 引擎（生产为 Edge TTS，失败回退 Mock）

同时通配导出 `book_service` 内部服务函数，供路由与任务模块调用。
"""
from .book_service import *
from .ocr import get_ocr
from .embedder import get_embedder
from .tts import get_tts


==================================================
FILE_PATH: api/app/books/ocr.py
==================================================

"""
OCR 相关路由

包含：
- /{book_id}/ocr - 获取 OCR 结果
- /{book_id}/ocr/full - 获取完整 OCR 数据（含坐标）
- /{book_id}/ocr/quota - 获取 OCR 配额信息
- /{book_id}/ocr [POST] - 触发 OCR 任务
- /{book_id}/ocr/status - 获取 OCR 状态
- /{book_id}/ocr/page/{page} - 获取单页 OCR
- /{book_id}/ocr/search - OCR 内容搜索
"""
import os
import gzip
import json
from datetime import datetime, timezone
from fastapi import APIRouter, Depends, HTTPException, Query, Response
from sqlalchemy import text

from .common import (
    BOOKS_BUCKET, engine, read_full, celery_app, require_user,
)

router = APIRouter()

ES_URL = os.getenv("ES_URL", "http://opensearch:9200")


@router.get("/{book_id}/ocr")
async def get_book_ocr(book_id: str, auth=Depends(require_user)):
    """
    获取书籍的 OCR 识别结果
    返回按页组织的文本内容，用于前端显示和搜索
    """
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT digitalize_report_key, ocr_result_key, is_digitalized, ocr_status FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        
        old_report_key, new_ocr_key, is_digitalized, ocr_status = row
        report_key = new_ocr_key or old_report_key
        
        if not report_key:
            return {
                "status": "success",
                "data": {
                    "available": False,
                    "is_digitalized": bool(is_digitalized),
                    "ocr_status": ocr_status,
                    "pages": {},
                    "total_pages": 0,
                    "total_chars": 0,
                }
            }
        
        try:
            report_data = read_full(BOOKS_BUCKET, report_key)
            if not report_data:
                raise Exception("Report not found")
            
            report = json.loads(report_data)
            
            if "pages" in report and isinstance(report["pages"], list):
                # 新版格式
                ocr_pages = report.get("pages", [])
                pages_formatted = {}
                total_chars = 0
                
                for page_data in ocr_pages:
                    page_num = page_data.get("page_num", 1)
                    page_text = page_data.get("text", "")
                    if page_text:
                        pages_formatted[str(page_num)] = page_text
                        total_chars += len(page_text)
                
                return {
                    "status": "success",
                    "data": {
                        "available": True,
                        "is_digitalized": bool(is_digitalized),
                        "ocr_status": ocr_status,
                        "is_image_based": True,
                        "confidence": 1.0,
                        "pages": pages_formatted,
                        "total_pages": report.get("total_pages", len(pages_formatted)),
                        "total_chars": total_chars,
                    }
                }
            else:
                # 旧版格式
                ocr_result = report.get("ocr", {})
                ocr_pages = ocr_result.get("pages", [])
                
                pages_dict = {}
                for item in ocr_pages:
                    page_num = item.get("page", 1)
                    item_text = item.get("text", "")
                    if item_text:
                        if page_num not in pages_dict:
                            pages_dict[page_num] = []
                        pages_dict[page_num].append(item_text)
                
                pages_formatted = {}
                total_chars = 0
                for page_num, texts in pages_dict.items():
                    page_text = "\n".join(texts)
                    pages_formatted[str(page_num)] = page_text
                    total_chars += len(page_text)
                
                return {
                    "status": "success",
                    "data": {
                        "available": True,
                        "is_digitalized": bool(is_digitalized),
                        "ocr_status": ocr_status,
                        "is_image_based": report.get("is_image_based", False),
                        "confidence": report.get("confidence", 0),
                        "pages": pages_formatted,
                        "total_pages": len(pages_formatted),
                        "total_chars": total_chars,
                    }
                }
        except Exception as e:
            print(f"[OCR] Failed to read report: {e}")
            return {
                "status": "success",
                "data": {
                    "available": False,
                    "is_digitalized": bool(is_digitalized),
                    "ocr_status": ocr_status,
                    "pages": {},
                    "total_pages": 0,
                    "total_chars": 0,
                    "error": str(e),
                }
            }


@router.get("/{book_id}/ocr/full")
async def get_book_ocr_full(book_id: str, auth=Depends(require_user)):
    """
    获取书籍完整的 OCR 识别结果（含所有页面坐标信息）
    用于前端一次性下载并缓存到 IndexedDB
    """
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT digitalize_report_key, ocr_result_key, is_digitalized FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        old_report_key, new_ocr_key, is_digitalized = row
        report_key = new_ocr_key or old_report_key
        
        if not report_key:
            raise HTTPException(status_code=404, detail="ocr_not_available")
        
        try:
            report_data = read_full(BOOKS_BUCKET, report_key)
            if not report_data:
                raise Exception("Report not found")
            
            report = json.loads(report_data)
            
            if "pages" in report and isinstance(report["pages"], list):
                # 新版格式
                ocr_pages = report.get("pages", [])
                page_sizes = {}
                all_regions = []
                total_chars = 0
                
                for page_data in ocr_pages:
                    page_num = page_data.get("page_num", 1)
                    page_sizes[str(page_num)] = {
                        "width": page_data.get("width", 0),
                        "height": page_data.get("height", 0),
                        "pdf_width": page_data.get("pdf_width", 0),
                        "pdf_height": page_data.get("pdf_height", 0),
                        "dpi": page_data.get("dpi", 150),
                    }
                    
                    for region in page_data.get("regions", []):
                        region_with_page = region.copy()
                        region_with_page["page"] = page_num
                        all_regions.append(region_with_page)
                    
                    total_chars += len(page_data.get("text", ""))
                
                response_data = {
                    "is_image_based": True,
                    "confidence": 1.0,
                    "total_pages": report.get("total_pages", len(ocr_pages)),
                    "total_chars": total_chars,
                    "total_regions": len(all_regions),
                    "page_sizes": page_sizes,
                    "regions": all_regions,
                }
            else:
                # 旧版格式
                ocr_result = report.get("ocr", {})
                all_regions = ocr_result.get("regions", [])
                total_chars = sum(len(r.get("text", "")) for r in all_regions)
                page_numbers = set(r.get("page", 1) for r in all_regions)
                total_pages = max(page_numbers) if page_numbers else 0
                
                page_sizes = report.get("page_sizes", {})
                if not page_sizes:
                    page_sizes = {}
                    page_regions_map = {}
                    for r in all_regions:
                        p = r.get("page", 1)
                        if p not in page_regions_map:
                            page_regions_map[p] = []
                        page_regions_map[p].append(r)
                    
                    for page_num, regions in page_regions_map.items():
                        max_x, max_y = 0.0, 0.0
                        for r in regions:
                            bbox = r.get("bbox", [])
                            if len(bbox) >= 4:
                                max_x = max(max_x, bbox[2])
                                max_y = max(max_y, bbox[3])
                        
                        if max_x > 0 and max_y > 0:
                            page_sizes[str(page_num)] = {
                                "width": int(max_x * 1.08),
                                "height": int(max_y * 1.08)
                            }
                
                response_data = {
                    "is_image_based": report.get("is_image_based", False),
                    "confidence": report.get("confidence", 0),
                    "total_pages": total_pages,
                    "total_chars": total_chars,
                    "total_regions": len(all_regions),
                    "page_sizes": page_sizes,
                    "regions": all_regions,
                }
            
            json_bytes = json.dumps(response_data, ensure_ascii=False).encode("utf-8")
            compressed = gzip.compress(json_bytes, compresslevel=6)
            
            return Response(
                content=compressed,
                media_type="application/json",
                headers={
                    "Content-Encoding": "gzip",
                    "Content-Length": str(len(compressed)),
                    "X-Original-Size": str(len(json_bytes)),
                    "X-Compressed-Size": str(len(compressed)),
                }
            )
        except Exception as e:
            print(f"[OCR] Failed to read full OCR data: {e}")
            import traceback
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(e))


@router.get("/{book_id}/ocr/quota")
async def get_ocr_quota_info(book_id: str, auth=Depends(require_user)):
    """获取 OCR 配额信息"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        res = await conn.execute(
            text("""
                SELECT id, is_digitalized, initial_digitalization_confidence, ocr_status,
                       COALESCE((meta->>'page_count')::int, 0) as page_count
                FROM books 
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        _, is_digitalized, confidence, ocr_status, page_count = row
        
        # 获取系统配置
        settings_res = await conn.execute(
            text("""
                SELECT key, value FROM system_settings 
                WHERE key IN (
                    'ocr_page_thresholds', 'ocr_max_pages', 'ocr_monthly_free_quota',
                    'monthly_gift_ocr_count'
                )
            """)
        )
        settings = {r[0]: r[1] for r in settings_res.fetchall()}
        
        thresholds = settings.get("ocr_page_thresholds", {"standard": 600, "double": 1000, "triple": 2000})
        max_pages = int(settings.get("ocr_max_pages", 2000))
        free_quota = int(settings.get("ocr_monthly_free_quota", 3))
        gift_quota = int(settings.get("monthly_gift_ocr_count", 3))
        
        # 获取用户信息
        user_res = await conn.execute(
            text("""
                SELECT membership_tier, membership_expire_at, free_ocr_usage,
                       COALESCE(ocr_addon_balance, 0) as addon_balance
                FROM users WHERE id = cast(:uid as uuid)
            """),
            {"uid": user_id},
        )
        user_row = user_res.fetchone()
        if not user_row:
            raise HTTPException(status_code=401, detail="user_not_found")
        
        tier, membership_expire_at, free_ocr_used, addon_balance = user_row
        
        is_pro = False
        if tier and tier != "FREE" and membership_expire_at:
            if membership_expire_at > datetime.now(timezone.utc):
                is_pro = True
        
        # 计算阶梯
        if page_count <= thresholds["standard"]:
            tier_level = 1
            units_needed = 1
        elif page_count <= thresholds["double"]:
            tier_level = 2
            units_needed = 2
        elif page_count <= thresholds["triple"]:
            tier_level = 3
            units_needed = 3
        else:
            tier_level = 3
            units_needed = 3
        
        free_remaining = max(0, free_quota - (free_ocr_used or 0))
        pro_remaining = max(0, gift_quota - (free_ocr_used or 0)) if is_pro else 0
        
        can_trigger = True
        reason = None
        
        is_already_digital = is_digitalized and (confidence is not None and confidence >= 0.8)
        
        if is_already_digital:
            can_trigger = False
            reason = "书籍已是文字型，无需 OCR"
        elif ocr_status in ('pending', 'processing'):
            can_trigger = False
            reason = "OCR 任务正在处理中"
        elif ocr_status == 'completed':
            can_trigger = False
            reason = "书籍已完成 OCR"
        elif not page_count or page_count == 0:
            can_trigger = False
            reason = "无法获取书籍页数"
        elif page_count > max_pages:
            can_trigger = False
            reason = f"页数超过上限 (最大 {max_pages} 页)"
        elif not is_pro:
            if tier_level > 1:
                can_trigger = False
                reason = "免费用户仅支持 ≤600 页的书籍"
            elif free_remaining < 1:
                can_trigger = False
                reason = "本月免费配额已用尽"
        else:
            if tier_level == 1 and pro_remaining >= 1:
                pass
            elif addon_balance < units_needed:
                can_trigger = False
                reason = "配额不足，请购买加油包"
        
        return {
            "status": "success",
            "data": {
                "pageCount": page_count if page_count > 0 else None,
                "tier": tier_level,
                "cost": units_needed,
                "canTrigger": can_trigger,
                "reason": reason,
                "freeRemaining": free_remaining if not is_pro else 0,
                "proRemaining": pro_remaining,
                "addonRemaining": addon_balance,
                "isPro": is_pro,
                "maxPages": max_pages,
            }
        }


@router.post("/{book_id}/ocr")
async def trigger_book_ocr(book_id: str, auth=Depends(require_user)):
    """用户主动请求对图片型 PDF 进行 OCR 处理"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        res = await conn.execute(
            text("""
                SELECT id, is_digitalized, initial_digitalization_confidence, 
                       ocr_status, ocr_requested_at, minio_key, 
                       COALESCE((meta->>'page_count')::int, 0) as page_count,
                       canonical_book_id, ocr_result_key, content_sha256
                FROM books 
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        (book_id_db, is_digitalized, confidence, ocr_status, ocr_requested_at, 
         minio_key, page_count, canonical_book_id, current_ocr_result_key, content_sha256) = row
        
        # 检查是否可以复用已有 OCR 数据
        can_instant_complete = False
        reusable_ocr_result_key = None
        
        if content_sha256:
            ocr_res = await conn.execute(
                text("""
                    SELECT ocr_result_key 
                    FROM books 
                    WHERE content_sha256 = :sha 
                      AND ocr_status = 'completed' 
                      AND ocr_result_key IS NOT NULL
                      AND id != cast(:book_id as uuid)
                    ORDER BY deleted_at IS NULL DESC, ocr_requested_at DESC
                    LIMIT 1
                """),
                {"sha": content_sha256, "book_id": book_id},
            )
            ocr_row = ocr_res.fetchone()
            if ocr_row:
                can_instant_complete = True
                reusable_ocr_result_key = ocr_row[0]
                print(f"[OCR] Found reusable OCR for {book_id} via SHA256 {content_sha256[:16]}...")
        
        if is_digitalized and (confidence is not None and confidence >= 0.8):
            raise HTTPException(status_code=400, detail="already_digitalized")
        
        if ocr_status in ('pending', 'processing'):
            queue_res = await conn.execute(
                text("""
                    SELECT COUNT(*) FROM books 
                    WHERE ocr_status IN ('pending', 'processing') 
                    AND ocr_requested_at < :req_at
                """),
                {"req_at": ocr_requested_at or datetime.now(timezone.utc)},
            )
            queue_pos = (queue_res.fetchone()[0] or 0) + 1
            
            raise HTTPException(
                status_code=409,
                detail={
                    "code": "ocr_in_progress",
                    "queuePosition": queue_pos
                }
            )
        
        if not page_count or page_count == 0:
            raise HTTPException(
                status_code=400,
                detail={
                    "code": "OCR_NEEDS_MANUAL_CHECK",
                    "message": "无法获取书籍页数信息，请联系客服"
                }
            )
        
        # 获取系统配置
        settings_res = await conn.execute(
            text("""
                SELECT key, value FROM system_settings 
                WHERE key IN (
                    'ocr_page_thresholds', 'ocr_max_pages', 'ocr_monthly_free_quota',
                    'monthly_gift_ocr_count', 'ocr_minutes_per_book'
                )
            """)
        )
        settings = {r[0]: r[1] for r in settings_res.fetchall()}
        
        thresholds = settings.get("ocr_page_thresholds", {"standard": 600, "double": 1000, "triple": 2000})
        max_pages = int(settings.get("ocr_max_pages", 2000))
        free_quota = int(settings.get("ocr_monthly_free_quota", 3))
        gift_quota = int(settings.get("monthly_gift_ocr_count", 3))
        minutes_per_book = int(settings.get("ocr_minutes_per_book", 5))
        
        if page_count > max_pages:
            raise HTTPException(
                status_code=400,
                detail={
                    "code": "OCR_MAX_PAGES_EXCEEDED",
                    "pages": page_count,
                    "limit": max_pages
                }
            )
        
        # 计算所需单位
        if page_count <= thresholds["standard"]:
            units_needed = 1
        elif page_count <= thresholds["double"]:
            units_needed = 2
        elif page_count <= thresholds["triple"]:
            units_needed = 3
        else:
            units_needed = 3
        
        # 检查用户配额
        user_res = await conn.execute(
            text("""
                SELECT membership_tier, membership_expire_at, free_ocr_usage,
                       COALESCE(monthly_gift_reset_at, '1970-01-01'::timestamptz) as gift_reset_at
                FROM users WHERE id = cast(:uid as uuid)
            """),
            {"uid": user_id},
        )
        user_row = user_res.fetchone()
        if not user_row:
            raise HTTPException(status_code=401, detail="user_not_found")
        
        tier, membership_expire_at, free_ocr_used, gift_reset_at = user_row
        
        is_pro = False
        if tier and tier != "FREE" and membership_expire_at:
            if membership_expire_at > datetime.now(timezone.utc):
                is_pro = True
        
        # 检查月度赠送是否需要重置
        now_utc = datetime.now(timezone.utc)
        if is_pro and gift_reset_at < now_utc.replace(day=1, hour=0, minute=0, second=0, microsecond=0):
            await conn.execute(
                text("UPDATE users SET free_ocr_usage = 0, monthly_gift_reset_at = now() WHERE id = cast(:uid as uuid)"),
                {"uid": user_id}
            )
            free_ocr_used = 0
        
        can_use_free = units_needed == 1
        
        if is_pro:
            if can_use_free and free_ocr_used < gift_quota:
                quota_type = "monthly_gift"
            else:
                addon_res = await conn.execute(
                    text("SELECT ocr_addon_balance FROM users WHERE id = cast(:uid as uuid)"),
                    {"uid": user_id}
                )
                addon_balance = (addon_res.fetchone() or (0,))[0] or 0
                if addon_balance < units_needed:
                    raise HTTPException(
                        status_code=403,
                        detail={
                            "code": "ocr_quota_exceeded",
                            "quota": {
                                "giftUsed": free_ocr_used,
                                "giftLimit": gift_quota,
                                "addonBalance": addon_balance,
                                "unitsNeeded": units_needed,
                                "pageCount": page_count
                            }
                        }
                    )
                quota_type = "addon"
        else:
            if not can_use_free:
                raise HTTPException(
                    status_code=403,
                    detail={
                        "code": "OCR_MAX_PAGES_EXCEEDED",
                        "message": "免费用户仅支持 600 页以内的书籍 OCR"
                    }
                )
            if free_ocr_used >= free_quota:
                raise HTTPException(
                    status_code=403,
                    detail={
                        "code": "ocr_quota_exceeded",
                        "quota": {
                            "used": free_ocr_used,
                            "limit": free_quota
                        }
                    }
                )
            quota_type = "free"
        
        # 扣除配额
        if quota_type == "monthly_gift":
            await conn.execute(
                text("UPDATE users SET free_ocr_usage = free_ocr_usage + 1 WHERE id = cast(:uid as uuid)"),
                {"uid": user_id}
            )
        elif quota_type == "addon":
            await conn.execute(
                text("UPDATE users SET ocr_addon_balance = ocr_addon_balance - :units WHERE id = cast(:uid as uuid)"),
                {"uid": user_id, "units": units_needed}
            )
        elif quota_type == "free":
            await conn.execute(
                text("UPDATE users SET free_ocr_usage = free_ocr_usage + 1 WHERE id = cast(:uid as uuid)"),
                {"uid": user_id}
            )
        
        # 如果可以秒完成
        if can_instant_complete and reusable_ocr_result_key:
            await conn.execute(
                text("""
                    UPDATE books 
                    SET ocr_status = 'completed', 
                        ocr_requested_at = now(),
                        ocr_result_key = :ocr_key,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                """),
                {"id": book_id, "ocr_key": reusable_ocr_result_key}
            )
            
            print(f"[OCR] Instant completed for {book_id} using reusable OCR result")
            fake_processing_seconds = min(60, max(3, (page_count or 10) * 0.5))
            
            return {
                "status": "instant_completed",
                "estimatedSeconds": fake_processing_seconds,
                "pageCount": page_count,
                "message": "OCR data inherited from shared source"
            }
        
        # 正常流程
        await conn.execute(
            text("""
                UPDATE books 
                SET ocr_status = 'pending', 
                    ocr_requested_at = now(),
                    updated_at = now()
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id}
        )
        
        queue_res = await conn.execute(
            text("""
                SELECT COUNT(*) FROM books 
                WHERE ocr_status IN ('pending', 'processing') 
                AND ocr_requested_at < now()
            """)
        )
        queue_position = (queue_res.fetchone()[0] or 0) + 1
        estimated_minutes = max(minutes_per_book, queue_position * minutes_per_book + (page_count or 100) // 50)
        
        try:
            celery_app.send_task(
                "tasks.process_book_ocr",
                args=[book_id, user_id],
                priority=7 if is_pro else 3
            )
        except Exception as e:
            print(f"[OCR] Failed to dispatch Celery task: {e}")
            await conn.execute(
                text("UPDATE books SET ocr_status = NULL, ocr_requested_at = NULL WHERE id = cast(:id as uuid)"),
                {"id": book_id},
            )
            raise HTTPException(status_code=503, detail="ocr_service_unavailable")
    
    return {
        "status": "queued",
        "queuePosition": queue_position,
        "estimatedMinutes": estimated_minutes
    }


@router.get("/{book_id}/ocr/status")
async def get_book_ocr_status(book_id: str, auth=Depends(require_user)):
    """查询书籍的 OCR 处理状态"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        res = await conn.execute(
            text("""
                SELECT id, is_digitalized, ocr_status, ocr_requested_at, 
                       vector_indexed_at, COALESCE((meta->>'page_count')::int, 0) as page_count,
                       meta->>'ocr_error' as ocr_error
                FROM books 
                WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        book_id_db, is_digitalized, ocr_status, ocr_requested_at, vector_indexed_at, page_count, ocr_error = row
        
        result = {
            "bookId": str(book_id_db),
            "isDigitalized": bool(is_digitalized),
            "ocrStatus": ocr_status,
        }
        
        if ocr_status == 'pending':
            queue_res = await conn.execute(
                text("""
                    SELECT COUNT(*) FROM books 
                    WHERE ocr_status IN ('pending', 'processing') 
                    AND ocr_requested_at < :req_at
                """),
                {"req_at": ocr_requested_at},
            )
            queue_pos = (queue_res.fetchone()[0] or 0) + 1
            result["queuePosition"] = queue_pos
            settings_row = await conn.execute(
                text("SELECT value FROM system_settings WHERE key = 'ocr_minutes_per_book'")
            )
            mins_per_book = int((settings_row.fetchone() or (5,))[0])
            result["estimatedMinutes"] = max(mins_per_book, queue_pos * mins_per_book + (page_count or 100) // 50)
        
        elif ocr_status == 'processing':
            settings_row = await conn.execute(
                text("SELECT value FROM system_settings WHERE key = 'ocr_minutes_per_book'")
            )
            mins_per_book = int((settings_row.fetchone() or (5,))[0])
            result["estimatedMinutes"] = max(mins_per_book, (page_count or 100) // 50)
        
        elif ocr_status == 'completed':
            result["completedAt"] = str(vector_indexed_at) if vector_indexed_at else None
        
        elif ocr_status == 'failed':
            result["errorCode"] = "ocr_failed"
            if ocr_error:
                result["errorMessage"] = ocr_error
        
        return result


@router.get("/{book_id}/ocr/page/{page}")
async def get_book_ocr_page(
    book_id: str, 
    page: int,
    auth=Depends(require_user)
):
    """获取书籍单页的 OCR 识别结果（含坐标信息）"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT digitalize_report_key FROM books WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="ocr_not_available")
        
        report_key = row[0]
        
        try:
            report_data = read_full(BOOKS_BUCKET, report_key)
            if not report_data:
                raise Exception("Report not found")
            
            report = json.loads(report_data)
            ocr_result = report.get("ocr", {})
            all_regions = ocr_result.get("regions", [])
            
            page_regions = [
                {
                    "text": r.get("text", ""),
                    "confidence": r.get("confidence", 0),
                    "bbox": r.get("bbox"),
                    "polygon": r.get("polygon"),
                }
                for r in all_regions
                if r.get("page") == page
            ]
            
            page_sizes = report.get("page_sizes", {})
            page_size = page_sizes.get(str(page), {})
            
            if page_size:
                image_width = page_size.get("width", 0)
                image_height = page_size.get("height", 0)
            else:
                max_x, max_y = 0.0, 0.0
                for r in page_regions:
                    bbox = r.get("bbox", [])
                    if bbox and len(bbox) >= 4:
                        max_x = max(max_x, bbox[2])
                        max_y = max(max_y, bbox[3])
                
                if max_x > 0 and max_y > 0:
                    image_width = int(max_x * 1.08)
                    image_height = int(max_y * 1.08)
                else:
                    image_width = 0
                    image_height = 0
            
            return {
                "status": "success",
                "data": {
                    "regions": page_regions,
                    "page": page,
                    "image_width": image_width,
                    "image_height": image_height,
                    "total_regions": len(page_regions),
                }
            }
        except Exception as e:
            print(f"[OCR] Failed to read page {page} OCR: {e}")
            raise HTTPException(status_code=500, detail=str(e))


@router.get("/{book_id}/ocr/search")
async def search_book_ocr(
    book_id: str, 
    q: str = Query(..., min_length=1, description="搜索关键词"),
    auth=Depends(require_user)
):
    """在书籍 OCR 内容中搜索"""
    import requests
    
    user_id, _ = auth
    
    if not ES_URL:
        raise HTTPException(status_code=503, detail="search_unavailable")
    
    try:
        query = {
            "query": {
                "bool": {
                    "must": [
                        {"match": {"content": q}},
                        {"term": {"book_id": book_id}},
                        {"term": {"user_id": user_id}},
                    ]
                }
            },
            "size": 50,
            "sort": [{"page": "asc"}],
            "_source": ["page", "content"],
            "highlight": {
                "fields": {"content": {}},
                "pre_tags": ["<mark>"],
                "post_tags": ["</mark>"],
            }
        }
        
        resp = requests.post(f"{ES_URL}/book_content/_search", json=query, timeout=10)
        resp.raise_for_status()
        result = resp.json()
        
        hits = []
        for hit in result.get("hits", {}).get("hits", []):
            src = hit.get("_source", {})
            highlight = hit.get("highlight", {}).get("content", [])
            hits.append({
                "page": src.get("page"),
                "content": src.get("content", "")[:200],
                "highlight": highlight[0] if highlight else None,
                "score": hit.get("_score", 0),
            })
        
        return {
            "status": "success",
            "data": {
                "query": q,
                "total": result.get("hits", {}).get("total", {}).get("value", 0),
                "hits": hits,
            }
        }
    except Exception as e:
        print(f"[Search] Failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


==================================================
FILE_PATH: api/app/books/shelves.py
==================================================

"""
书架相关路由

包含：
- / [POST] - 创建书架
- / [GET] - 书架列表
- /{shelf_id} [PATCH] - 更新书架
- /{shelf_id} [DELETE] - 删除书架
- /{shelf_id}/items [POST] - 添加书籍到书架
- /{shelf_id}/items [GET] - 获取书架内书籍
- /{shelf_id}/items/{book_id} [DELETE] - 从书架移除书籍
"""
from fastapi import APIRouter, Body, Depends, Header, HTTPException, Query
from sqlalchemy import text

from .common import (
    BOOKS_BUCKET, r, engine, uuid, presigned_get,
    require_user, require_write_permission,
)

router = APIRouter()


@router.post("/")
async def create_shelf(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    name = body.get("name")
    if not name:
        raise HTTPException(status_code=400, detail="missing_name")
    description = body.get("description") or ""
    if idempotency_key:
        idem_key = f"idem:shelves:create:{user_id}:{idempotency_key}"
        cached = r.get(idem_key)
        if cached:
            return {"status": "success", "data": {"id": cached}}
    shelf_id = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO shelves(id, user_id, name, description) VALUES (cast(:id as uuid), cast(:uid as uuid), :name, :desc)"
            ),
            {"id": shelf_id, "uid": user_id, "name": name, "desc": description},
        )
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, shelf_id)
    return {"status": "success", "data": {"id": shelf_id}}


@router.get("/")
async def list_shelves(
    limit: int = Query(20, ge=1, le=100),
    cursor: str | None = Query(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        cond = "WHERE user_id = current_setting('app.user_id')::uuid"
        order = "ORDER BY updated_at DESC, id DESC"
        params = {"limit": limit + 1}
        if cursor:
            try:
                ts_str, last_id = cursor.split("|", 1)
                cond += " AND (updated_at < cast(:ts as timestamptz) OR (updated_at = cast(:ts as timestamptz) AND id < cast(:id as uuid)))"
                params.update({"ts": ts_str, "id": last_id})
            except Exception:
                pass
        q = text(
            """
            SELECT id::text, name, description, updated_at, version
            FROM shelves
            """
            + cond
            + "\n"
            + order
            + "\n"
            + "LIMIT :limit"
        )
        res = await conn.execute(q, params)
        rows = res.fetchall()
        take = rows[:limit]
        items = [
            {
                "id": r[0],
                "name": r[1],
                "description": r[2],
                "updated_at": str(r[3]),
                "etag": f'W/"{int(r[4])}"',
            }
            for r in take
        ]
        next_cursor = None
        if len(rows) > limit:
            last = take[-1]
            next_cursor = f"{last[3]}|{last[0]}"
        return {
            "status": "success",
            "data": {
                "items": items,
                "next_cursor": next_cursor,
                "has_more": len(rows) > limit,
            },
        }


@router.patch("/{shelf_id}")
async def update_shelf(
    shelf_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    name = body.get("name")
    description = body.get("description")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            UPDATE shelves SET
              name = COALESCE(:name, name),
              description = COALESCE(:desc, description),
              version = version + 1,
              updated_at = now()
            WHERE id = cast(:id as uuid) AND version = :ver
            """
            ),
            {"name": name, "desc": description, "id": shelf_id, "ver": current_version},
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


@router.delete("/{shelf_id}")
async def delete_shelf(
    shelf_id: str,
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    """删除书架（同时删除书架内的关联关系）"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        # 先删除书架内的书籍关联
        await conn.execute(
            text(
                """
            DELETE FROM shelf_items 
            WHERE shelf_id = cast(:sid as uuid)
              AND shelf_id IN (SELECT id FROM shelves WHERE user_id = current_setting('app.user_id')::uuid)
            """
            ),
            {"sid": shelf_id},
        )
        # 再删除书架本身
        res = await conn.execute(
            text(
                """
            DELETE FROM shelves 
            WHERE id = cast(:sid as uuid) 
              AND user_id = current_setting('app.user_id')::uuid
            """
            ),
            {"sid": shelf_id},
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=404, detail="shelf_not_found")
    return {"status": "success"}


@router.post("/{shelf_id}/items")
async def add_item(
    shelf_id: str,
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    book_id = body.get("book_id")
    if not book_id:
        raise HTTPException(status_code=400, detail="missing_book_id")
    if idempotency_key:
        idem_key = (
            f"idem:shelves:add_item:{user_id}:{shelf_id}:{book_id}:{idempotency_key}"
        )
        if r.get(idem_key):
            return {"status": "success"}
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "INSERT INTO shelf_items(shelf_id, book_id) VALUES (cast(:sid as uuid), cast(:bid as uuid)) ON CONFLICT DO NOTHING"
            ),
            {"sid": shelf_id, "bid": book_id},
        )
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, "1")
    return {"status": "success"}


@router.get("/{shelf_id}/items")
async def list_items(shelf_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            SELECT b.id::text, b.title, b.author, b.language, b.minio_key
            FROM shelf_items si
            JOIN books b ON b.id = si.book_id
            WHERE si.shelf_id = cast(:sid as uuid)
            ORDER BY b.updated_at DESC
            """
            ),
            {"sid": shelf_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "title": r[1],
                    "author": r[2],
                    "language": r[3],
                    "download_url": presigned_get(BOOKS_BUCKET, r[4]),
                }
                for r in rows
            ],
        }


@router.delete("/{shelf_id}/items/{book_id}")
async def remove_item(
    shelf_id: str,
    book_id: str,
    idempotency_key: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if idempotency_key:
        idem_key = (
            f"idem:shelves:remove_item:{user_id}:{shelf_id}:{book_id}:{idempotency_key}"
        )
        if r.get(idem_key):
            return {"status": "success"}
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "DELETE FROM shelf_items WHERE shelf_id = cast(:sid as uuid) AND book_id = cast(:bid as uuid)"
            ),
            {"sid": shelf_id, "bid": book_id},
        )
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, "1")
    return {"status": "success"}


==================================================
FILE_PATH: api/app/books/upload.py
==================================================

"""
上传相关路由

包含：
- /upload_init - 上传初始化（含全局 SHA256 去重）
- /upload_complete - 上传完成
- /dedup_reference - 秒传引用
- /upload_proxy - 文件代理上传
"""
from fastapi import APIRouter, Body, Depends, File, Header, HTTPException, UploadFile
from sqlalchemy import text

from .common import (
    BOOKS_BUCKET, r, engine, uuid, presigned_get, stat_etag,
    make_object_key, upload_bytes, index_book, celery_app,
    require_user, require_upload_permission,
    svc_get_upload_url, read_full, _quick_confidence,
)

router = APIRouter()


@router.post("/upload_init")
async def upload_init(
    body: dict = Body(...),
    quota=Depends(require_upload_permission),
    auth=Depends(require_user),
):
    """
    初始化上传，支持全局 SHA256 去重。
    
    如果客户端提供了 content_sha256，服务端会检查是否已有相同文件：
    - 全局已存在：返回 dedup_available=true，客户端可跳过上传
    - 仅当前用户已有：返回现有 book_id
    """
    user_id, _ = auth
    filename = body.get("filename")
    if not filename:
        raise HTTPException(status_code=400, detail="missing_filename")
    content_type = body.get("content_type")
    content_sha256 = body.get("content_sha256")
    
    # 如果提供了 SHA256，检查全局去重
    if content_sha256 and len(content_sha256) == 64:
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            # 1. 先检查当前用户是否已有相同文件（排除软删除的）
            res = await conn.execute(
                text(
                    "SELECT id::text, title FROM books WHERE user_id = cast(:uid as uuid) AND content_sha256 = :sha AND deleted_at IS NULL"
                ),
                {"uid": user_id, "sha": content_sha256},
            )
            own_row = res.fetchone()
            if own_row:
                return {
                    "status": "success",
                    "data": {
                        "dedup_hit": "own",
                        "existing_book_id": own_row[0],
                        "existing_title": own_row[1],
                        "message": "您已上传过该文件"
                    }
                }
            
            # 2. 检查全局是否有相同文件
            res = await conn.execute(
                text(
                    """SELECT id::text, minio_key, cover_image_key, deleted_at
                       FROM books WHERE content_sha256 = :sha 
                       ORDER BY deleted_at IS NULL DESC, created_at ASC
                       LIMIT 1"""
                ),
                {"sha": content_sha256},
            )
            global_row = res.fetchone()
            if global_row:
                canonical_id = global_row[0]
                is_soft_deleted = global_row[3] is not None
                print(f"[Upload Init] Global dedup hit for SHA256 {content_sha256[:16]}..., canonical={canonical_id}, soft_deleted={is_soft_deleted}")
                return {
                    "status": "success",
                    "data": {
                        "dedup_hit": "global",
                        "dedup_available": True,
                        "canonical_book_id": canonical_id,
                        "canonical_minio_key": global_row[1],
                        "canonical_cover_key": global_row[2],
                        "message": "文件已存在，可快速添加到书库"
                    }
                }
    
    # 没有去重命中，返回上传 URL
    print(f"[Upload Init] No dedup hit, creating new upload for {filename}")
    data = await svc_get_upload_url(user_id, filename, content_type)
    data["dedup_hit"] = None
    return {"status": "success", "data": data}


@router.post("/upload_complete")
async def upload_complete(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    auth=Depends(require_user),
):
    import hashlib
    
    user_id, _ = auth
    key = body.get("key")
    if not key:
        raise HTTPException(status_code=400, detail="missing_key")
    title = body.get("title") or "Untitled"
    author = body.get("author") or ""
    language = body.get("language") or ""
    original_format = body.get("original_format") or ""
    size = body.get("size") or None
    content_sha256 = body.get("content_sha256")
    
    # 如果客户端没有提供 SHA256，服务器自己计算
    if not content_sha256 or len(content_sha256) != 64:
        print(f"[Upload] Client did not provide SHA256, computing server-side for {key}...")
        try:
            file_data = read_full(BOOKS_BUCKET, key)
            if file_data:
                content_sha256 = hashlib.sha256(file_data).hexdigest()
                print(f"[Upload] Server computed SHA256: {content_sha256[:16]}...")
            else:
                print(f"[Upload] Warning: Could not read file for SHA256 computation")
                content_sha256 = None
        except Exception as e:
            print(f"[Upload] Warning: Server-side SHA256 computation failed: {e}")
            content_sha256 = None
    
    if idempotency_key:
        idem_key = f"idem:books:upload_complete:{user_id}:{idempotency_key}"
        cached = r.get(idem_key)
        if cached:
            return {"status": "success", "data": eval(cached)}
    
    book_id = str(uuid.uuid4())
    etag = stat_etag(BOOKS_BUCKET, key)
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )

        if etag:
            res = await conn.execute(
                text(
                    "SELECT id::text, deleted_at FROM books WHERE user_id = current_setting('app.user_id')::uuid AND source_etag = :e"
                ),
                {"e": etag},
            )
            row = res.fetchone()
            if row:
                existing_book_id = row[0]
                was_deleted = row[1] is not None
                
                if was_deleted:
                    await conn.execute(
                        text("UPDATE books SET deleted_at = NULL, updated_at = now() WHERE id = cast(:id as uuid)"),
                        {"id": existing_book_id},
                    )
                    print(f"[Upload] Restored soft-deleted book {existing_book_id} with same etag")
                
                download_url = presigned_get(BOOKS_BUCKET, key)
                index_book(existing_book_id, user_id, title, author)
                data = {"id": existing_book_id, "download_url": download_url}
                if idempotency_key:
                    r.setex(idem_key, 24 * 3600, str(data))
                try:
                    celery_app.send_task("tasks.analyze_book_type", args=[existing_book_id, user_id])
                    celery_app.send_task("tasks.deep_analyze_book", args=[existing_book_id, user_id])
                except Exception:
                    pass
                return {"status": "success", "data": data}
    
    img_based, conf = _quick_confidence(BOOKS_BUCKET, key)
    
    # 非 EPUB/PDF 格式需要转换
    fmt_lower = (original_format or '').lower()
    needs_conversion = fmt_lower not in ('epub', 'pdf')
    conversion_status = 'pending' if needs_conversion else None
    
    async with engine.begin() as conn:
        await conn.execute(
            text(
                """
        INSERT INTO books(id, user_id, title, author, language, original_format, minio_key, size, is_digitalized, initial_digitalization_confidence, source_etag, content_sha256, storage_ref_count, conversion_status)
        VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt, :key, :size, :dig, :conf, :etag, :sha256, 1, :conv_status)
        """
            ),
            {
                "id": book_id,
                "uid": user_id,
                "title": title,
                "author": author,
                "language": language,
                "fmt": original_format,
                "key": key,
                "size": size,
                "dig": (conf >= 0.8),
                "conf": conf,
                "etag": etag,
                "sha256": content_sha256,
                "conv_status": conversion_status,
            },
        )
        await conn.execute(
            text(
                "UPDATE books SET meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', 1, 'needs_manual', true) WHERE id = cast(:id as uuid)"
            ),
            {"id": book_id},
        )
    
    sha_log = content_sha256[:16] if content_sha256 else 'None'
    print(f"[Upload] Created book {book_id} for user {user_id}, SHA256={sha_log}..., title={title}")
    
    download_url = presigned_get(BOOKS_BUCKET, key)
    index_book(book_id, user_id, title, author)
    data = {"id": book_id, "download_url": download_url}
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, str(data))
    
    # 所有格式均使用 Calibre 提取元数据
    try:
        print(f"[Upload] Using Calibre for metadata extraction (format: {fmt_lower})...")
        celery_app.send_task("tasks.extract_ebook_metadata_calibre", args=[book_id, user_id])
        
        if fmt_lower not in ('epub', 'pdf'):
            print(f"[Upload] Non-EPUB/PDF format, also starting conversion to EPUB...")
            celery_app.send_task("tasks.convert_to_epub", args=[book_id, user_id])
            
    except Exception as e:
        print(f"[Upload] Failed to queue background tasks: {e}")
        
    return {"status": "success", "data": data}


@router.post("/dedup_reference")
async def dedup_reference(
    body: dict = Body(...),
    idempotency_key: str | None = Header(None),
    quota=Depends(require_upload_permission),
    auth=Depends(require_user),
):
    """
    全局去重秒传：当 upload_init 返回 dedup_available=true 时调用。
    不需要实际上传文件，直接创建指向已有存储的书籍记录。
    """
    import json
    
    user_id, _ = auth
    content_sha256 = body.get("content_sha256")
    canonical_book_id = body.get("canonical_book_id")
    title = body.get("title") or "Untitled"
    author = body.get("author") or ""
    language = body.get("language") or ""
    original_format = body.get("original_format") or ""
    
    if not content_sha256 or not canonical_book_id:
        raise HTTPException(status_code=400, detail="missing_content_sha256_or_canonical_book_id")
    
    if idempotency_key:
        idem_key = f"idem:books:dedup_reference:{user_id}:{idempotency_key}"
        cached = r.get(idem_key)
        if cached:
            return {"status": "success", "data": eval(cached)}
    
    book_id = str(uuid.uuid4())
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        # 获取原始书籍信息
        res = await conn.execute(
            text(
                """
                SELECT minio_key, cover_image_key, size, original_format, is_digitalized, 
                       initial_digitalization_confidence, meta, ocr_status, ocr_result_key
                FROM books WHERE id = cast(:cid as uuid) AND content_sha256 = :sha
                """
            ),
            {"cid": canonical_book_id, "sha": content_sha256},
        )
        canonical = res.fetchone()
        if not canonical:
            raise HTTPException(status_code=404, detail="canonical_book_not_found")
        
        (c_minio_key, c_cover_key, c_size, c_fmt, c_dig, c_conf, c_meta,
         c_ocr_status, c_ocr_result_key) = canonical
        
        # 增加原始存储的引用计数
        await conn.execute(
            text(
                "UPDATE books SET storage_ref_count = COALESCE(storage_ref_count, 1) + 1 WHERE id = cast(:cid as uuid)"
            ),
            {"cid": canonical_book_id},
        )
        
        # 判断是否需要标记为图片型
        canonical_has_ocr = c_ocr_status == 'completed' and c_ocr_result_key is not None
        if canonical_has_ocr:
            new_is_digitalized = True
            new_confidence = c_conf if c_conf and c_conf < 0.5 else 0.1
        else:
            new_is_digitalized = c_dig
            new_confidence = c_conf
        
        await conn.execute(
            text(
                """
                INSERT INTO books(id, user_id, title, author, language, original_format, 
                                  minio_key, cover_image_key, size, is_digitalized, initial_digitalization_confidence,
                                  content_sha256, canonical_book_id, storage_ref_count, meta)
                VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt,
                        :key, :cover, :size, :dig, :conf, :sha256, cast(:cid as uuid), 0, cast(:meta as jsonb))
                """
            ),
            {
                "id": book_id,
                "uid": user_id,
                "title": title,
                "author": author,
                "language": language,
                "fmt": c_fmt if not original_format else original_format,
                "key": c_minio_key,
                "cover": c_cover_key,
                "size": c_size,
                "dig": new_is_digitalized,
                "conf": new_confidence,
                "sha256": content_sha256,
                "cid": canonical_book_id,
                "meta": json.dumps(c_meta) if c_meta else None,
            },
        )
    
    print(f"[Dedup Reference] Created book {book_id} for user {user_id}, canonical={canonical_book_id}, has_ocr={canonical_has_ocr}")
    
    download_url = presigned_get(BOOKS_BUCKET, c_minio_key)
    index_book(book_id, user_id, title, author)
    
    data = {
        "id": book_id,
        "download_url": download_url,
        "dedup_hit": "global",
        "canonical_has_ocr": canonical_has_ocr,
    }
    
    if idempotency_key:
        r.setex(idem_key, 24 * 3600, str(data))
    
    return {"status": "success", "data": data}


@router.post("/upload_proxy")
async def upload_proxy(
    title: str | None = None,
    file: UploadFile = File(...),
    quota=Depends(require_upload_permission),
    auth=Depends(require_user),
):
    import os as _os
    
    user_id, _ = auth
    name = file.filename or "upload.bin"
    fmt = (name.split(".")[-1] or "bin").lower()
    key = make_object_key(user_id, name)
    content = await file.read()
    
    upload_bytes(
        _os.getenv("MINIO_BUCKET", "athena"),
        key,
        content,
        file.content_type or "application/octet-stream",
    )
    
    img_based, conf = _quick_confidence(_os.getenv("MINIO_BUCKET", "athena"), key)
    etag = stat_etag(_os.getenv("MINIO_BUCKET", "athena"), key)
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        if etag:
            res = await conn.execute(
                text(
                    "SELECT id::text FROM books WHERE user_id = current_setting('app.user_id')::uuid AND source_etag = :e"
                ),
                {"e": etag},
            )
            row = res.fetchone()
            if row:
                download_url = presigned_get(_os.getenv("MINIO_BUCKET", "athena"), key)
                return {
                    "status": "success",
                    "data": {"id": row[0], "download_url": download_url},
                }
        book_id = str(uuid.uuid4())
        await conn.execute(
            text(
                """
            INSERT INTO books(id, user_id, title, original_format, minio_key, is_digitalized, initial_digitalization_confidence, source_etag)
            VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :t, :f, :k, :dig, :conf, :etag)
            """
            ),
            {
                "id": book_id,
                "t": title or name.replace(f".{fmt}", ""),
                "k": key,
                "f": fmt,
                "dig": (conf >= 0.8),
                "conf": conf,
                "etag": etag,
            },
        )
    download_url = presigned_get(_os.getenv("MINIO_BUCKET", "athena"), key)
    return {"status": "success", "data": {"id": book_id, "download_url": download_url}}


==================================================
FILE_PATH: api/app/books/common.py
==================================================

"""
书籍模块共享基础设施

包含：
- 共享导入
- 配置常量
- 工具函数
"""
import os
import uuid
import hashlib

import redis
from fastapi import (
    APIRouter,
    Body,
    Depends,
    File,
    Header,
    HTTPException,
    Query,
    Response,
    UploadFile,
)
from sqlalchemy import text

from ..auth import require_user
from ..celery_app import celery_app
from ..db import engine
from ..dependencies import require_upload_permission, require_write_permission
from ..search_sync import delete_book as delete_book_from_index
from ..search_sync import index_book
from ..storage import (
    delete_object,
    ensure_bucket,
    get_s3,
    make_object_key,
    presigned_get,
    presigned_put,
    read_head,
    read_full,
    stat_etag,
    upload_bytes,
)
from ..services.book_service import get_upload_url as svc_get_upload_url, create_book as svc_create_book
from ..ws import broadcast as ws_broadcast

# ============================================================================
# 配置常量
# ============================================================================

BOOKS_BUCKET = os.getenv("MINIO_BUCKET", "athena")
REDIS_HOST = os.getenv("REDIS_HOST", "redis")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)

# ============================================================================
# 工具函数
# ============================================================================

def _quick_confidence(bucket: str, key: str) -> tuple[bool, float]:
    """
    快速检测 PDF 是否为图片型。
    
    使用 PyMuPDF 检查前 6 页的文本内容，这比检查字节头更可靠。
    
    返回 (is_image_based, confidence):
    - is_image_based: 是否为图片型 PDF
    - confidence: 置信度，用于前端判断（confidence < 0.8 表示图片型）
    """
    try:
        import fitz  # PyMuPDF
        
        # 获取文件数据
        pdf_data = None
        if isinstance(key, str) and key.startswith("http"):
            import urllib.request
            try:
                with urllib.request.urlopen(key) as resp:
                    pdf_data = resp.read()
            except Exception:
                pdf_data = None
        else:
            pdf_data = read_full(bucket, key)
        
        if not pdf_data:
            return (False, 0.0)
        
        # 非 PDF 文件直接返回数字型
        if not key.lower().endswith('.pdf'):
            return (False, 1.0)  # 非 PDF 默认是数字型
        
        # 使用 PyMuPDF 提取前 6 页文本
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        total_pages = len(doc)
        pages_to_check = min(6, total_pages)
        
        total_chars = 0
        meaningful_chars = 0
        
        for i in range(pages_to_check):
            page = doc[i]
            text_content = page.get_text()
            
            if text_content:
                total_chars += len(text_content)
                # 统计有意义的字符（中文、英文字母）
                import re
                cjk = len(re.findall(r'[\u4e00-\u9fff]', text_content))
                latin = len(re.findall(r'[A-Za-z]', text_content))
                meaningful_chars += cjk + latin
        
        doc.close()
        
        # 计算比例
        if total_chars == 0:
            # 完全没有文本，是纯图片型
            return (True, 0.1)
        
        ratio = meaningful_chars / max(1, total_chars)
        
        # 判断标准：
        # - 如果有意义字符占比 < 5%，认为是图片型
        # - 每页平均文本少于 50 字符，也认为是图片型
        avg_chars_per_page = total_chars / pages_to_check
        
        is_image_based = ratio < 0.05 or avg_chars_per_page < 50
        
        # confidence 规则：
        # - 图片型：confidence < 0.8
        # - 数字型：confidence >= 0.8
        if is_image_based:
            conf = max(0.1, min(0.5, ratio * 5.0))  # 图片型 conf 最高 0.5
        else:
            conf = max(0.8, min(1.0, 0.8 + ratio * 0.2))  # 数字型 conf 最低 0.8
        
        print(f"[PDF Detection] {key}: {pages_to_check} pages, {total_chars} chars, ratio={ratio:.3f}, avg={avg_chars_per_page:.0f}, is_image={is_image_based}, conf={conf:.2f}")
        return (is_image_based, conf)
        
    except Exception as e:
        print(f"[PDF Detection] Error: {e}")
        return (False, 0.0)


==================================================
FILE_PATH: api/app/books/metadata.py
==================================================

"""
书籍元数据相关路由

包含：
- / [GET] - 书籍列表
- /{book_id} [GET] - 书籍详情
- /register - 注册外部书籍
- /{book_id}/deep_analyze - 深度分析
- /{book_id}/metadata [PATCH] - 更新元数据
- /{book_id} [PATCH] - 更新书籍
- /{book_id}/shelves - 获取书籍所属书架
"""
from fastapi import APIRouter, Body, Depends, Header, HTTPException, Query, Response
from sqlalchemy import text

from .common import (
    BOOKS_BUCKET, engine, uuid, presigned_get, make_object_key,
    upload_bytes, read_head, index_book,
    require_user, require_write_permission, _quick_confidence,
)

router = APIRouter()


@router.get("/")
async def list_books(
    limit: int = Query(20, ge=1, le=100),
    cursor: str | None = Query(None),
    auth=Depends(require_user),
):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        cond = "WHERE user_id = current_setting('app.user_id')::uuid AND deleted_at IS NULL"
        order = "ORDER BY updated_at DESC, id DESC"
        params = {"limit": limit + 1}
        if cursor:
            try:
                ts_str, last_id = cursor.split("|", 1)
                cond += " AND (updated_at < cast(:ts as timestamptz) OR (updated_at = cast(:ts as timestamptz) AND id < cast(:id as uuid)))"
                params.update({"ts": ts_str, "id": last_id})
            except Exception:
                pass
        q = text(
            """
            SELECT b.id::text, b.title, b.author, b.language, b.original_format, b.minio_key, b.size, b.created_at, b.updated_at, b.version, COALESCE(b.is_digitalized,false), COALESCE(b.initial_digitalization_confidence,0), b.cover_image_key,
                   COALESCE(rp.progress, 0) as progress, rp.finished_at, b.converted_epub_key, b.ocr_status, b.conversion_status
            FROM books b
            LEFT JOIN reading_progress rp ON rp.book_id = b.id AND rp.user_id = current_setting('app.user_id')::uuid
            """
            + cond.replace("WHERE", "WHERE b.")
            + "\n"
            + order.replace("updated_at", "b.updated_at").replace("id", "b.id")
            + "\n"
            + "LIMIT :limit"
        )
        res = await conn.execute(q, params)
        rows = res.fetchall()
        take = rows[:limit]
        items = []

        def _hint(key: str, lang: str, size: int | None):
            try:
                head = read_head(BOOKS_BUCKET, key, 65536)
                if not head:
                    return None
                txt = None
                for enc in ("utf-8", "gb18030", "latin1"):
                    try:
                        txt = head.decode(enc, errors="ignore")
                        break
                    except Exception:
                        continue
                if not txt:
                    return None
                import re
                cjk = len(re.findall(r"[\u4e00-\u9fff]", txt))
                latin_words = len(re.findall(r"[A-Za-z]+", txt))
                if lang and lang.lower().startswith("zh"):
                    ratio = cjk / max(1, len(txt))
                    bpc = 2.0
                    est = int((ratio) * (size or 0) / bpc) if size else cjk
                    return f"约{est/10000.0:.1f}万字"
                else:
                    return f"约{latin_words}词"
            except Exception:
                return None

        for r in take:
            key_for_download = r[15] if r[15] else r[5]
            download = key_for_download
            if not (isinstance(download, str) and download.startswith("http")):
                download = presigned_get(BOOKS_BUCKET, key_for_download)
            hint = _hint(key_for_download, r[3] or "", r[6])
            cover_url = None
            if r[12]:
                cover_url = presigned_get(BOOKS_BUCKET, r[12])
            
            is_image_based = (bool(r[10]) and float(r[11]) < 0.8) or r[16] == 'completed'
            
            items.append(
                {
                    "id": r[0],
                    "title": r[1],
                    "author": r[2],
                    "language": r[3],
                    "original_format": r[4],
                    "size": r[6],
                    "created_at": str(r[7]),
                    "updated_at": str(r[8]),
                    "etag": f'W/"{int(r[9])}"',
                    "download_url": download,
                    "cover_url": cover_url,
                    "text_hint": hint,
                    "is_digitalized": bool(r[10]),
                    "initial_digitalization_confidence": float(r[11]),
                    "progress": float(r[13]) if r[13] else 0,
                    "finished_at": str(r[14]) if r[14] else None,
                    "ocr_status": r[16],
                    "is_image_based": is_image_based,
                    "conversion_status": r[17],
                }
            )
        next_cursor = None
        if len(rows) > limit:
            last = take[-1]
            next_cursor = f"{last[8]}|{last[0]}"
        return {
            "status": "success",
            "data": {
                "items": items,
                "next_cursor": next_cursor,
                "has_more": len(rows) > limit,
            },
        }


@router.get("/{book_id}")
async def get_book(book_id: str, auth=Depends(require_user), response: Response = None):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            SELECT id::text, title, author, language, original_format, minio_key, size, created_at, updated_at, version,
                   COALESCE(is_digitalized,false), COALESCE(initial_digitalization_confidence,0), converted_epub_key, digitalize_report_key, cover_image_key,
                   COALESCE(metadata_confirmed, false), ocr_status, meta, deleted_at, user_id, conversion_status
            FROM books WHERE id = cast(:id as uuid)
            """
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        
        deleted_at = row[18]
        book_user_id = str(row[19])
        if deleted_at is not None and book_user_id != user_id:
            raise HTTPException(status_code=404, detail="not_found")
        
        if response is not None:
            response.headers["ETag"] = f'W/"{int(row[9])}"'
        
        key_for_download = row[12] if row[12] else row[5]
        download = key_for_download
        if not (isinstance(download, str) and download.startswith("http")):
            download = presigned_get(BOOKS_BUCKET, key_for_download)
        hint = None
        try:
            head = read_head(BOOKS_BUCKET, key_for_download, 65536)
            if head:
                for enc in ("utf-8", "gb18030", "latin1"):
                    try:
                        txt = head.decode(enc, errors="ignore")
                        break
                    except Exception:
                        txt = None
                if txt:
                    import re
                    cjk = len(re.findall(r"[\u4e00-\u9fff]", txt))
                    latin_words = len(re.findall(r"[A-Za-z]+", txt))
                    if (row[3] or "").lower().startswith("zh"):
                        hint = f"约{cjk/10000.0:.1f}万字"
                    else:
                        hint = f"约{latin_words}词"
        except Exception:
            hint = None
        
        cover_url = None
        if row[14]:
            cover_url = presigned_get(BOOKS_BUCKET, row[14])
        
        meta = row[17] or {}
        page_count = meta.get("page_count") if isinstance(meta, dict) else None
        metadata_extracted = meta.get("metadata_extracted", False) if isinstance(meta, dict) else False
        
        is_image_based = (bool(row[10]) and float(row[11]) < 0.8) or row[16] == 'completed'
        
        return {
            "status": "success",
            "data": {
                "id": row[0],
                "title": row[1],
                "author": row[2],
                "language": row[3],
                "original_format": row[4],
                "size": row[6],
                "created_at": str(row[7]),
                "updated_at": str(row[8]),
                "etag": f'W/"{int(row[9])}"',
                "download_url": download,
                "cover_url": cover_url,
                "cover_image_key": row[14],
                "text_hint": hint,
                "is_digitalized": bool(row[10]),
                "initial_digitalization_confidence": float(row[11]),
                "converted_epub_key": row[12],
                "digitalize_report_key": row[13],
                "metadata_confirmed": bool(row[15]),
                "metadata_extracted": bool(metadata_extracted),
                "ocr_status": row[16],
                "page_count": page_count,
                "is_image_based": is_image_based,
                "conversion_status": row[20],
            },
        }


@router.get("/{book_id}/shelves")
async def get_book_shelves(book_id: str, auth=Depends(require_user)):
    """查询某本书所属的所有书架"""
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            SELECT s.id::text, s.name, s.description, s.updated_at
            FROM shelf_items si
            JOIN shelves s ON s.id = si.shelf_id
            WHERE si.book_id = cast(:bid as uuid)
              AND s.user_id = current_setting('app.user_id')::uuid
            ORDER BY s.name
            """
            ),
            {"bid": book_id},
        )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": {
                "items": [
                    {
                        "id": r[0],
                        "name": r[1],
                        "description": r[2],
                        "updated_at": str(r[3]),
                    }
                    for r in rows
                ]
            },
        }


@router.post("/register")
async def register_book(body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    object_url = body.get("object_url")
    if not object_url or not isinstance(object_url, str):
        raise HTTPException(status_code=400, detail="invalid_object_url")
    title = body.get("title") or "Untitled"
    author = body.get("author") or ""
    language = body.get("language") or ""
    original_format = (body.get("original_format") or "").lower()
    size = body.get("size") or None
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT id::text FROM books WHERE user_id = current_setting('app.user_id')::uuid AND minio_key = :key"
            ),
            {"key": object_url},
        )
        row = res.fetchone()
        if row:
            return {
                "status": "success",
                "data": {"id": row[0], "download_url": object_url},
            }
        book_id = str(uuid.uuid4())
        img_based, conf = _quick_confidence(BOOKS_BUCKET, object_url)
        await conn.execute(
            text(
                """
            INSERT INTO books(id, user_id, title, author, language, original_format, minio_key, size, is_digitalized, initial_digitalization_confidence)
            VALUES (cast(:id as uuid), cast(:uid as uuid), :title, :author, :language, :fmt, :key, :size, :dig, :conf)
            """
            ),
            {
                "id": book_id,
                "uid": user_id,
                "title": title,
                "author": author,
                "language": language,
                "fmt": original_format,
                "key": object_url,
                "size": size,
                "dig": (conf >= 0.8),
                "conf": conf,
            },
        )
    index_book(book_id, user_id, title, author)
    return {"status": "success", "data": {"id": book_id, "download_url": object_url}}


@router.post("/{book_id}/deep_analyze")
async def deep_analyze(book_id: str, auth=Depends(require_user)):
    import json
    
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT minio_key FROM books WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        key = row[0]
        img_based, conf = _quick_confidence(BOOKS_BUCKET, key)
        report = {"is_image_based": img_based, "confidence": conf}
        rep_key = make_object_key(user_id, f"digitalize-report-{book_id}.json")
        upload_bytes(
            BOOKS_BUCKET,
            rep_key,
            json.dumps(report).encode("utf-8"),
            "application/json",
        )
        await conn.execute(
            text(
                "UPDATE books SET is_digitalized = :dig, initial_digitalization_confidence = :conf, digitalize_report_key = :rk, updated_at = now() WHERE id = cast(:id as uuid)"
            ),
            {
                "dig": (not img_based and conf >= 0.8),
                "conf": conf,
                "rk": rep_key,
                "id": book_id,
            },
        )
        await conn.execute(
            text(
                "UPDATE books SET meta = COALESCE(meta, '{}'::jsonb) || jsonb_build_object('page_count', 1) WHERE id = cast(:id as uuid) AND (meta->>'page_count') IS NULL"
            ),
            {"id": book_id},
        )
    return {
        "status": "success",
        "data": {"is_digitalized": (not img_based and conf >= 0.8), "confidence": conf},
    }


@router.patch("/{book_id}/metadata")
async def update_book_metadata(
    book_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    auth=Depends(require_user),
):
    """用户确认或修改书籍的元数据（书名、作者）"""
    import hashlib
    
    user_id, _ = auth
    title = body.get("title")
    author = body.get("author")
    confirmed = body.get("confirmed", True)
    
    current_version = None
    if if_match and if_match.startswith('W/"'):
        try:
            current_version = int(if_match.split('"')[1])
        except Exception:
            raise HTTPException(status_code=400, detail="invalid_if_match")
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        
        res = await conn.execute(
            text("""
                SELECT id, title, author, version, metadata_confirmed
                FROM books WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        book_id_db, old_title, old_author, version, already_confirmed = row
        
        if current_version is not None and version != current_version:
            raise HTTPException(
                status_code=409,
                detail={
                    "error": "version_conflict",
                    "message": "书籍信息已被其他设备修改，请刷新后重试",
                    "currentVersion": version
                }
            )
        
        new_title = title if title is not None else old_title
        new_author = author if author is not None else old_author
        
        metadata_str = f"{new_title}|{new_author or ''}"
        metadata_hash = hashlib.sha256(metadata_str.encode('utf-8')).hexdigest()[:16]
        metadata_version = f"sha256:{metadata_hash}"
        
        if confirmed:
            update_res = await conn.execute(
                text("""
                    UPDATE books SET
                        title = COALESCE(:title, title),
                        author = COALESCE(:author, author),
                        metadata_confirmed = TRUE,
                        metadata_confirmed_at = now(),
                        version = version + 1,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                    RETURNING version
                """),
                {"title": title, "author": author, "id": book_id},
            )
        else:
            update_res = await conn.execute(
                text("""
                    UPDATE books SET
                        title = COALESCE(:title, title),
                        author = COALESCE(:author, author),
                        version = version + 1,
                        updated_at = now()
                    WHERE id = cast(:id as uuid)
                    RETURNING version
                """),
                {"title": title, "author": author, "id": book_id},
            )
        
        new_version_row = update_res.fetchone()
        new_version = new_version_row[0] if new_version_row else version + 1
        
        final_res = await conn.execute(
            text("""
                SELECT id, title, author, metadata_confirmed, metadata_confirmed_at, version
                FROM books WHERE id = cast(:id as uuid)
            """),
            {"id": book_id},
        )
        final_row = final_res.fetchone()
    
    return {
        "id": str(final_row[0]),
        "title": final_row[1],
        "author": final_row[2],
        "metadataConfirmed": bool(final_row[3]),
        "metadataConfirmedAt": str(final_row[4]) if final_row[4] else None,
        "metadataVersion": metadata_version,
        "version": final_row[5]
    }


@router.patch("/{book_id}")
async def update_book(
    book_id: str,
    body: dict = Body(...),
    if_match: str | None = Header(None),
    quota=Depends(require_write_permission),
    auth=Depends(require_user),
):
    user_id, _ = auth
    if not if_match or not if_match.startswith('W/"'):
        raise HTTPException(status_code=428, detail="missing_if_match")
    try:
        current_version = int(if_match.split('"')[1])
    except Exception:
        raise HTTPException(status_code=400, detail="invalid_if_match")
    title = body.get("title")
    author = body.get("author")
    language = body.get("language")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                """
            UPDATE books SET
              title = COALESCE(:title, title),
              author = COALESCE(:author, author),
              language = COALESCE(:language, language),
              version = version + 1,
              updated_at = now()
            WHERE id = cast(:id as uuid) AND version = :ver
            """
            ),
            {
                "title": title,
                "author": author,
                "language": language,
                "id": book_id,
                "ver": current_version,
            },
        )
        if res.rowcount == 0:
            raise HTTPException(status_code=409, detail="version_conflict")
    return {"status": "success"}


==================================================
FILE_PATH: api/app/books/delete.py
==================================================

"""
删除相关路由

包含：
- /{book_id} [DELETE] - 删除书籍
"""
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import text

from .common import (
    BOOKS_BUCKET, engine, delete_object, delete_book_from_index,
    require_user, require_write_permission,
)

router = APIRouter()


@router.delete("/{book_id}")
async def delete_book(book_id: str, quota=Depends(require_write_permission), auth=Depends(require_user)):
    """
    删除书籍 - 分离公共信息和私人信息
    
    【私人信息】- 用户删除时立即物理删除：
    - 笔记 (notes) 和笔记标签 (note_tags)
    - 高亮 (highlights) 和高亮标签 (highlight_tags)
    - AI 对话 (ai_conversations, ai_messages, ai_conversation_contexts)
    - 阅读进度 (reading_progress)
    - 阅读会话 (reading_sessions)
    - 书架关联 (shelf_items)
    - 转换任务 (conversion_jobs)
    - OCR 任务 (ocr_jobs)
    
    【公共信息】- 只有最后一位用户删除时才物理删除：
    - 书籍文件 (MinIO)
    - 封面图片 (MinIO)
    - OCR 结果 (MinIO)
    - 数字化报告 (MinIO)
    - 向量索引 (OpenSearch)
    - 书籍记录 (books 表)
    """
    user_id, _ = auth
    try:
        async with engine.begin() as conn:
            await conn.execute(
                text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
            )
            
            # 获取书籍信息
            res = await conn.execute(
                text("""
                    SELECT id, minio_key, cover_image_key, canonical_book_id, storage_ref_count,
                           ocr_result_key, digitalize_report_key, content_sha256
                    FROM books 
                    WHERE id = cast(:id as uuid) AND user_id = cast(:uid as uuid)
                """),
                {"id": book_id, "uid": user_id},
            )
            book = res.fetchone()
            if not book:
                raise HTTPException(status_code=404, detail="not_found")
            
            (_, minio_key, cover_key, canonical_book_id, storage_ref_count,
             ocr_result_key, digitalize_report_key, content_sha256) = book
            
            is_dedup_reference = canonical_book_id is not None
            has_references = (storage_ref_count or 0) > 1
            
            # ========================================
            # 第一步：删除所有【私人信息】
            # ========================================
            
            # 1.1 删除书架关联
            await conn.execute(
                text("DELETE FROM shelf_items WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.2 删除笔记标签关联，然后删除笔记
            await conn.execute(
                text("DELETE FROM note_tags WHERE note_id IN (SELECT id FROM notes WHERE book_id = cast(:id as uuid))"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM notes WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.3 删除高亮标签关联，然后删除高亮
            await conn.execute(
                text("DELETE FROM highlight_tags WHERE highlight_id IN (SELECT id FROM highlights WHERE book_id = cast(:id as uuid))"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM highlights WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.4 删除 AI 对话上下文和消息
            await conn.execute(
                text("""
                    DELETE FROM ai_conversation_contexts 
                    WHERE book_ids @> to_jsonb(ARRAY[cast(:id as text)])::jsonb
                """),
                {"id": book_id},
            )
            await conn.execute(
                text("""
                    DELETE FROM ai_messages 
                    WHERE conversation_id NOT IN (SELECT conversation_id FROM ai_conversation_contexts)
                """),
            )
            await conn.execute(
                text("""
                    DELETE FROM ai_conversations 
                    WHERE id NOT IN (SELECT conversation_id FROM ai_conversation_contexts)
                """),
            )
            
            # 1.5 删除阅读进度和会话
            await conn.execute(
                text("DELETE FROM reading_progress WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM reading_sessions WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            # 1.6 删除转换任务和 OCR 任务
            await conn.execute(
                text("DELETE FROM conversion_jobs WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            await conn.execute(
                text("DELETE FROM ocr_jobs WHERE book_id = cast(:id as uuid)"),
                {"id": book_id},
            )
            
            print(f"[Delete Book] Deleted private data for {book_id}")
            
            # ========================================
            # 第二步：处理书籍记录和【公共信息】
            # ========================================
            
            if is_dedup_reference:
                # 情况1：这是一个去重引用
                res = await conn.execute(
                    text("""
                        SELECT storage_ref_count, deleted_at, minio_key, cover_image_key, 
                               ocr_result_key, digitalize_report_key, content_sha256
                        FROM books WHERE id = cast(:cid as uuid)
                    """),
                    {"cid": canonical_book_id},
                )
                canonical_info = res.fetchone()
                
                # 减少引用计数
                await conn.execute(
                    text("""
                        UPDATE books 
                        SET storage_ref_count = GREATEST(COALESCE(storage_ref_count, 1) - 1, 0)
                        WHERE id = cast(:cid as uuid)
                    """),
                    {"cid": canonical_book_id},
                )
                
                # 删除当前书籍记录
                await conn.execute(
                    text("DELETE FROM books WHERE id = cast(:id as uuid)"),
                    {"id": book_id},
                )
                print(f"[Delete Book] Deleted dedup reference {book_id}, decremented ref count of {canonical_book_id}")
                
                # 检查原书是否需要清理
                if canonical_info:
                    c_ref_count, c_deleted_at, c_minio_key, c_cover_key, c_ocr_key, c_report_key, c_sha256 = canonical_info
                    new_ref_count = max((c_ref_count or 1) - 1, 0)
                    
                    if c_deleted_at and new_ref_count <= 1:
                        other_count = 0
                        if c_sha256:
                            res = await conn.execute(
                                text("""
                                    SELECT COUNT(*) FROM books 
                                    WHERE content_sha256 = :sha AND id != cast(:cid as uuid)
                                """),
                                {"sha": c_sha256, "cid": canonical_book_id},
                            )
                            other_count = res.scalar() or 0
                        
                        if other_count == 0:
                            await conn.execute(
                                text("DELETE FROM books WHERE id = cast(:cid as uuid)"),
                                {"cid": canonical_book_id},
                            )
                            
                            files_to_delete = [f for f in [c_minio_key, c_cover_key, c_ocr_key, c_report_key] if f]
                            for file_key in files_to_delete:
                                try:
                                    delete_object(BOOKS_BUCKET, file_key)
                                    print(f"[Delete Book] Cleaned up canonical MinIO file: {file_key}")
                                except Exception as e:
                                    print(f"[Delete Book] Failed to delete canonical file {file_key}: {e}")
                            
                            delete_book_from_index(canonical_book_id)
                            print(f"[Delete Book] Cleaned up soft-deleted canonical {canonical_book_id} (no more references)")
                
            elif has_references:
                # 情况2：这是原书，但有其他用户引用
                await conn.execute(
                    text("""
                        UPDATE books 
                        SET deleted_at = NOW(), updated_at = NOW()
                        WHERE id = cast(:id as uuid)
                    """),
                    {"id": book_id},
                )
                print(f"[Delete Book] Soft deleted {book_id} (has {storage_ref_count} references, public data preserved)")
                
            else:
                # 情况3：没有引用（最后一位用户删除）
                other_books_count = 0
                if content_sha256:
                    res = await conn.execute(
                        text("""
                            SELECT COUNT(*) FROM books 
                            WHERE content_sha256 = :sha AND id != cast(:id as uuid)
                        """),
                        {"sha": content_sha256, "id": book_id},
                    )
                    other_books_count = res.scalar() or 0
                
                await conn.execute(
                    text("DELETE FROM books WHERE id = cast(:id as uuid)"),
                    {"id": book_id},
                )
                
                if other_books_count == 0:
                    files_to_delete = [f for f in [minio_key, cover_key, ocr_result_key, digitalize_report_key] if f]
                    for file_key in files_to_delete:
                        try:
                            delete_object(BOOKS_BUCKET, file_key)
                            print(f"[Delete Book] Deleted MinIO file: {file_key}")
                        except Exception as e:
                            print(f"[Delete Book] Failed to delete MinIO file {file_key}: {e}")
                    
                    delete_book_from_index(book_id)
                    print(f"[Delete Book] Fully deleted {book_id} (last user, all public data removed)")
                else:
                    print(f"[Delete Book] Deleted {book_id} but preserved public data ({other_books_count} other books share same SHA256)")
        
        return {"status": "success"}
    except HTTPException:
        raise
    except Exception as e:
        import traceback
        print(f"[Delete Book] Error: {e}")
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"delete_failed: {str(e)}")


==================================================
FILE_PATH: api/app/books/content.py
==================================================

"""
内容访问相关路由

包含：
- /{book_id}/cover - 获取封面
- /{book_id}/content - 获取书籍内容
- /{book_id}/presign - 预签名下载
- /{book_id}/presign_put_converted - 转换后上传预签名
- /{book_id}/presign_get_source - 源文件获取预签名
"""
import os
from fastapi import APIRouter, Depends, Header, HTTPException, Query
from fastapi.responses import Response as FastAPIResponse
from sqlalchemy import text
from jose import jwt

from .common import (
    BOOKS_BUCKET, engine, presigned_get, presigned_put,
    make_object_key, upload_bytes, get_s3, ensure_bucket,
    require_user, read_full,
)

router = APIRouter()

AUTH_SECRET = os.getenv("AUTH_SECRET", "dev_secret")


def _parse_auth_token(authorization: str | None, token: str | None) -> str:
    """解析认证 token"""
    auth_token = None
    if authorization and authorization.startswith("Bearer "):
        auth_token = authorization.split(" ", 1)[1]
    elif token:
        auth_token = token
    
    if not auth_token:
        raise HTTPException(status_code=401, detail="unauthorized")
    
    try:
        payload = jwt.decode(auth_token, AUTH_SECRET, algorithms=["HS256"], options={"verify_aud": False})
        return payload["sub"]
    except Exception as e:
        raise HTTPException(status_code=401, detail=f"invalid_token: {str(e)}")


@router.get("/{book_id}/cover")
async def get_book_cover(
    book_id: str,
    token: str = Query(None),
    authorization: str = Header(None),
):
    """
    获取书籍封面图片（通过 API 代理）
    解决移动端无法直接访问 localhost 存储的问题
    """
    user_id = _parse_auth_token(authorization, token)
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT cover_image_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="cover_not_found")
        
        cover_key = row[0]
        
        try:
            client = get_s3()
            ensure_bucket(client, BOOKS_BUCKET)
            resp = client.get_object(Bucket=BOOKS_BUCKET, Key=cover_key)
            cover_data = resp["Body"].read()
            content_type = resp.get("ContentType", "image/webp")
            
            return FastAPIResponse(
                content=cover_data,
                media_type=content_type,
                headers={
                    "Cache-Control": "public, max-age=86400",
                    "Content-Disposition": "inline",
                    "Access-Control-Allow-Origin": "*",
                }
            )
        except Exception as e:
            raise HTTPException(status_code=404, detail=f"cover_fetch_error: {str(e)}")


@router.get("/{book_id}/content")
async def get_book_content(
    book_id: str,
    token: str = Query(None),
    authorization: str = Header(None),
):
    """
    获取书籍内容（通过 API 代理）
    支持 HTTP Range 请求以实现流式加载
    """
    user_id = _parse_auth_token(authorization, token)
    
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT minio_key, original_format, converted_epub_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="book_not_found")
        
        minio_key, original_format, converted_epub_key = row[0], row[1], row[2]
        
        # 优先使用转换后的 EPUB
        if converted_epub_key:
            minio_key = converted_epub_key
            original_format = "epub"
        
        content_type_map = {
            "epub": "application/epub+zip",
            "pdf": "application/pdf",
        }
        content_type = content_type_map.get(original_format, "application/epub+zip")
        
        try:
            client = get_s3()
            ensure_bucket(client, BOOKS_BUCKET)
            resp = client.get_object(Bucket=BOOKS_BUCKET, Key=minio_key)
            book_data = resp["Body"].read()
            content_length = len(book_data)
            
            return FastAPIResponse(
                content=book_data,
                media_type=content_type,
                headers={
                    "Content-Length": str(content_length),
                    "Accept-Ranges": "bytes",
                    "Cache-Control": "private, max-age=3600",
                    "Content-Disposition": f"inline; filename=\"book.{original_format}\"",
                }
            )
        except Exception as e:
            raise HTTPException(status_code=404, detail=f"book_fetch_error: {str(e)}")


@router.get("/{book_id}/presign")
async def presign_book_download(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        return {
            "status": "success",
            "data": {"download_url": presigned_get(BOOKS_BUCKET, row[0])},
        }


@router.post("/{book_id}/presign_put_converted")
async def presign_put_converted(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    key = make_object_key(user_id, f"converted/{book_id}.epub")
    url = presigned_put(BOOKS_BUCKET, key)
    return {"status": "success", "data": {"put_url": url, "key": key}}


@router.post("/{book_id}/presign_get_source")
async def presign_get_source(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT minio_key, original_format FROM books WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        key, fmt = row[0], (row[1] or "").lower()
        
        if isinstance(key, str) and key.startswith("http"):
            try:
                from urllib.parse import urlparse, urlunparse

                u = urlparse(key)
                if u.hostname in ("127.0.0.1", "localhost"):
                    host = "host.docker.internal" + (f":{u.port}" if u.port else "")
                    key = urlunparse(
                        (u.scheme, host, u.path, u.params, u.query, u.fragment)
                    )
                else:
                    import urllib.request

                    with urllib.request.urlopen(key) as resp:
                        data = resp.read()
                    ext = ("." + fmt) if fmt else ""
                    new_key = make_object_key(user_id, f"ingested-{book_id}{ext}")
                    upload_bytes(
                        BOOKS_BUCKET, new_key, data, "application/octet-stream"
                    )
                    await conn.execute(
                        text(
                            "UPDATE books SET minio_key = :k, updated_at = now() WHERE id = cast(:id as uuid)"
                        ),
                        {"k": new_key, "id": book_id},
                    )
                    key = new_key
            except Exception:
                raise HTTPException(status_code=400, detail="ingest_failed")
        
        if isinstance(key, str) and key.startswith("http"):
            from urllib.parse import urlparse

            u = urlparse(key)
            path = u.path.lstrip("/")
            parts = path.split("/", 1)
            if len(parts) == 2:
                bkt, obj = parts[0], parts[1]
                url = presigned_get(bkt, obj)
                return {"status": "success", "data": {"get_url": url}}
            return {"status": "success", "data": {"get_url": key}}
        url = presigned_get(BOOKS_BUCKET, key)
    return {"status": "success", "data": {"get_url": url}}


==================================================
FILE_PATH: api/app/books/__init__.py
==================================================

"""
书籍模块包初始化

模块结构：
- common.py: 共享基础设施、配置常量、工具函数
- upload.py: 上传相关端点 (upload_init, upload_complete, dedup_reference, upload_proxy)
- content.py: 内容访问端点 (cover, content, presign)
- ocr.py: OCR 相关端点 (ocr, ocr/full, ocr/quota, ocr/status, ocr/page, ocr/search)
- metadata.py: 元数据 CRUD (list, detail, register, deep_analyze, update)
- delete.py: 删除逻辑 (软删除/硬删除)
- convert.py: 格式转换端点 (convert, jobs)
- shelves.py: 书架 CRUD

完全模块化：
- 原 books.py 可以逐步废弃
- main.py 应引用此包的 router 和 shelves_router

@see 04 - 数据库全景与迁移Database_Schema_and_Migration_Log.md
@see 05 - API 契约与协议API_Contracts_and_Protocols.md
"""
from fastapi import APIRouter

# 导入子模块路由
from . import upload
from . import content
from . import ocr
from . import metadata
from . import delete
from . import convert
from . import shelves

# 创建主路由器
router = APIRouter(prefix="/api/v1/books", tags=["books"])
shelves_router = APIRouter(prefix="/api/v1/shelves", tags=["shelves"])

# ============================================================================
# 注册 Books 路由（按 path 顺序注册，具体路径优先于参数化路径）
# ============================================================================

# 上传相关 - 无参数路径优先
router.include_router(upload.router, tags=["books"])

# 作业列表 - /jobs/list 必须在 /{book_id} 之前
router.include_router(convert.router, tags=["books"])

# 元数据 - 包含 / 和 /register 以及 /{book_id} 通配
router.include_router(metadata.router, tags=["books"])

# 内容访问 - /{book_id}/cover, /{book_id}/content 等
router.include_router(content.router, tags=["books"])

# OCR - /{book_id}/ocr 等
router.include_router(ocr.router, tags=["books"])

# 删除 - /{book_id} DELETE
router.include_router(delete.router, tags=["books"])

# ============================================================================
# 注册 Shelves 路由
# ============================================================================
shelves_router.include_router(shelves.router, tags=["shelves"])

# ============================================================================
# 导出共享基础设施（供其他模块使用）
# ============================================================================
from .common import (
    BOOKS_BUCKET,
    r,
    _quick_confidence,
    engine,
    require_user,
    require_upload_permission,
    require_write_permission,
    celery_app,
    presigned_get,
    presigned_put,
    read_full,
    read_head,
    delete_object,
    upload_bytes,
    make_object_key,
    ensure_bucket,
    get_s3,
    stat_etag,
    delete_book_from_index,
    index_book,
    ws_broadcast,
    HTTPException,
    Body,
    Depends,
    Query,
    Response,
    Header,
    File,
    UploadFile,
    uuid,
)

__all__ = [
    'router',
    'shelves_router',
    'BOOKS_BUCKET',
    'r',
    '_quick_confidence',
]


==================================================
FILE_PATH: api/app/books/convert.py
==================================================

"""
格式转换相关路由

包含：
- /{book_id}/convert - 请求转换
- /{book_id}/convert/output - 获取转换输出
- /{book_id}/processing/status - 处理状态
- /{book_id}/set_converted - 设置转换完成
- /jobs/list - 作业列表
- /jobs/{job_id}/complete - 完成作业
- /jobs/{job_id}/fail - 失败作业
- /jobs/{job_id}/simulate - 模拟作业
"""
from fastapi import APIRouter, Body, Depends, HTTPException, Query
from sqlalchemy import text

from .common import (
    BOOKS_BUCKET, engine, uuid, presigned_get, upload_bytes,
    require_user, ws_broadcast,
)

router = APIRouter()


@router.get("/{book_id}/processing/status")
async def processing_status(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT status FROM conversion_jobs WHERE owner_id = current_setting('app.user_id')::uuid AND book_id = cast(:bid as uuid) ORDER BY created_at DESC LIMIT 1"
            ),
            {"bid": book_id},
        )
        row = res.fetchone()
        if not row:
            return {"status": "success", "data": {"status": "ACTIVE"}}
        st = row[0]
        mapped = (
            "ACTIVE"
            if st in ("succeeded", "active")
            else ("FAILED" if st == "failed" else "PENDING")
        )
        return {"status": "success", "data": {"status": mapped}}


@router.get("/{book_id}/convert/output")
async def presign_convert_output(book_id: str, auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT output_key FROM conversion_jobs WHERE owner_id = current_setting('app.user_id')::uuid AND book_id = cast(:bid as uuid) AND status = 'completed' ORDER BY updated_at DESC LIMIT 1"
            ),
            {"bid": book_id},
        )
        row = res.fetchone()
        if not row or not row[0]:
            raise HTTPException(status_code=404, detail="not_found")
        return {
            "status": "success",
            "data": {"download_url": presigned_get(BOOKS_BUCKET, row[0])},
        }


@router.post("/{book_id}/set_converted")
async def set_converted(
    book_id: str, body: dict = Body(...), auth=Depends(require_user)
):
    import json as _j
    
    user_id, _ = auth
    key = body.get("key")
    if not key:
        raise HTTPException(status_code=400, detail="missing_key")
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE books SET converted_epub_key = :k, updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"k": key, "id": book_id},
        )
    try:
        await ws_broadcast(
            f"book:{book_id}", _j.dumps({"event": "STANDARDIZED", "epub_key": key})
        )
    except Exception:
        pass
    return {"status": "success"}


@router.post("/{book_id}/convert")
async def request_convert(
    book_id: str, body: dict = Body(...), auth=Depends(require_user)
):
    user_id, _ = auth
    target_format = (body.get("target_format") or "epub").lower()
    job_id = str(uuid.uuid4())
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text("SELECT minio_key FROM books WHERE id = cast(:id as uuid)"),
            {"id": book_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        source_key = row[0]
        await conn.execute(
            text(
                """
            INSERT INTO conversion_jobs(id, user_id, book_id, source_key, target_format, status)
            VALUES (cast(:id as uuid), cast(:uid as uuid), cast(:bid as uuid), :src, :fmt, 'pending')
            """
            ),
            {
                "id": job_id,
                "uid": user_id,
                "bid": book_id,
                "src": source_key,
                "fmt": target_format,
            },
        )
    return {"status": "success", "data": {"job_id": job_id, "status": "pending"}}


@router.get("/jobs/list")
async def list_jobs(status: str | None = Query(None), auth=Depends(require_user)):
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        if status:
            res = await conn.execute(
                text(
                    "SELECT id::text, book_id::text, target_format, status, created_at FROM conversion_jobs WHERE user_id = current_setting('app.user_id')::uuid AND status = :st ORDER BY created_at DESC"
                ),
                {"st": status},
            )
        else:
            res = await conn.execute(
                text(
                    "SELECT id::text, book_id::text, target_format, status, created_at FROM conversion_jobs WHERE user_id = current_setting('app.user_id')::uuid ORDER BY created_at DESC"
                )
            )
        rows = res.fetchall()
        return {
            "status": "success",
            "data": [
                {
                    "id": r[0],
                    "book_id": r[1],
                    "target_format": r[2],
                    "status": r[3],
                    "created_at": str(r[4]),
                }
                for r in rows
            ],
        }


@router.post("/jobs/{job_id}/complete")
async def complete_job(
    job_id: str, body: dict = Body(None), auth=Depends(require_user)
):
    user_id, _ = auth
    output_key = (body or {}).get("output_key") or ""
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE conversion_jobs SET status='completed', output_key = COALESCE(:out, output_key), updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id, "out": output_key},
        )
    return {"status": "success"}


@router.post("/jobs/{job_id}/fail")
async def fail_job(job_id: str, body: dict = Body(...), auth=Depends(require_user)):
    user_id, _ = auth
    message = body.get("error") or ""
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        await conn.execute(
            text(
                "UPDATE conversion_jobs SET status='failed', error = :msg, updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id, "msg": message},
        )
    return {"status": "success"}


@router.post("/jobs/{job_id}/simulate")
async def simulate_job(job_id: str, auth=Depends(require_user)):
    import math
    
    user_id, _ = auth
    async with engine.begin() as conn:
        await conn.execute(
            text("SELECT set_config('app.user_id', :v, true)"), {"v": user_id}
        )
        res = await conn.execute(
            text(
                "SELECT book_id::text FROM conversion_jobs WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id},
        )
        row = res.fetchone()
        if not row:
            raise HTTPException(status_code=404, detail="not_found")
        book_id = row[0]
        out_key = f"converted/{book_id}.epub"
        upload_bytes(
            BOOKS_BUCKET, out_key, b"converted content", "application/epub+zip"
        )
        res2 = await conn.execute(
            text(
                "SELECT price_amount, unit_size, currency FROM pricing_rules WHERE service_type = 'VECTORIZE' AND unit_type = 'CHARS' AND is_active = TRUE ORDER BY updated_at DESC LIMIT 1"
            )
        )
        rule = res2.fetchone()
        if rule:
            qty = 100000
            max(1, math.ceil(qty / int(rule[1])))
            sres = await conn.execute(
                text("SELECT key, value FROM system_settings WHERE key LIKE 'free_%'")
            )
            settings = {r[0]: r[1] for r in sres.fetchall()}
            mtres = await conn.execute(
                text(
                    "SELECT membership_tier FROM users WHERE id = current_setting('app.user_id')::uuid"
                )
            )
            mtrow = mtres.fetchone()
            tier = (mtrow and mtrow[0]) or "FREE"
            tres = await conn.execute(
                text("SELECT value FROM system_settings WHERE key = 'membership_tiers'")
            )
            trow = tres.fetchone()
            mconf = trow and trow[0]
            free_chars = None
            if isinstance(mconf, dict) and tier in mconf:
                try:
                    free_chars = int((mconf[tier] or {}).get("free_vector_chars") or 0)
                except Exception:
                    free_chars = 0
            if free_chars is None:
                free_chars = int(settings.get("free_vector_chars", 0))

            ures = await conn.execute(
                text(
                    "SELECT used_units FROM free_quota_usage WHERE owner_id = current_setting('app.user_id')::uuid AND service_type = 'VECTORIZE' AND period_start = current_date"
                )
            )
            urow = ures.fetchone()
            used = int(urow[0]) if urow else 0
            remain = max(0, free_chars - used)
            payable_chars = max(0, qty - remain)
            if remain > 0:
                await conn.execute(
                    text(
                        "INSERT INTO free_quota_usage(owner_id, service_type, used_units) VALUES (current_setting('app.user_id')::uuid, 'VECTORIZE', :u) ON CONFLICT (owner_id, service_type, period_start) DO UPDATE SET used_units = free_quota_usage.used_units + EXCLUDED.used_units"
                    ),
                    {"u": min(qty, remain)},
                )
            if payable_chars > 0:
                units_pay = max(1, math.ceil(payable_chars / int(rule[1])))
                amt = int(round(float(rule[0]) * 100)) * units_pay
                await conn.execute(
                    text(
                        "INSERT INTO credit_accounts(owner_id) VALUES (current_setting('app.user_id')::uuid) ON CONFLICT (owner_id) DO NOTHING"
                    )
                )
                bal = await conn.execute(
                    text(
                        "SELECT balance FROM credit_accounts WHERE owner_id = current_setting('app.user_id')::uuid"
                    )
                )
                b = bal.fetchone()
                if not b or int(b[0]) < amt:
                    await conn.execute(
                        text(
                            "UPDATE conversion_jobs SET status='failed', updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
                        ),
                        {"id": job_id},
                    )
                    raise HTTPException(status_code=400, detail="insufficient_balance")
                await conn.execute(
                    text(
                        "UPDATE credit_accounts SET balance = balance - :amt, updated_at = now() WHERE owner_id = current_setting('app.user_id')::uuid"
                    ),
                    {"amt": amt},
                )
                lid = str(uuid.uuid4())
                await conn.execute(
                    text(
                        "INSERT INTO credit_ledger(id, owner_id, amount, currency, reason, related_id, direction) VALUES (cast(:id as uuid), current_setting('app.user_id')::uuid, :amt, :cur, 'vectorize', cast(:rid as uuid), 'debit')"
                    ),
                    {"id": lid, "amt": amt, "cur": rule[2], "rid": job_id},
                )
        await conn.execute(
            text(
                "UPDATE conversion_jobs SET status='completed', output_key = :out, updated_at = now() WHERE id = cast(:id as uuid) AND user_id = current_setting('app.user_id')::uuid"
            ),
            {"id": job_id, "out": out_key},
        )
    return {"status": "success", "data": {"output_key": out_key}}


==================================================
FILE_PATH: docker/opensearch/Dockerfile
==================================================

# 继承自私有镜像源的基础镜像
FROM zukubq0aouv2k2.xuanyuan.run/opensearchproject/opensearch:2.11.1

# 声明维护者信息
LABEL maintainer="Athena DevOps"

# [重要] 安装中文分词与增强插件
# 注意：插件版本必须与 OpenSearch 版本严格一致。
# 如果构建失败，请检查插件版本号是否与 latest 镜像版本匹配。
# 这里以 2.11.1 为例，实际使用时需根据 latest 的具体版本调整 URL

# 1. 安装 IK Analysis (中文分词)
RUN /usr/share/opensearch/bin/opensearch-plugin install --batch https://get.infini.cloud/opensearch/analysis-ik/2.11.1

# 2. 安装 Pinyin Analysis (拼音搜索)
RUN /usr/share/opensearch/bin/opensearch-plugin install --batch https://get.infini.cloud/opensearch/analysis-pinyin/2.11.1

# 3. 安装 STConvert (简繁转换)
RUN /usr/share/opensearch/bin/opensearch-plugin install --batch https://get.infini.cloud/opensearch/analysis-stconvert/2.11.1


==================================================
FILE_PATH: docker/powersync/powersync.yaml
==================================================

# PowerSync Service 配置 - Open Edition
# @see https://docs.powersync.com/self-hosted/configuration

# 复制配置
replication:
  connections:
    - type: postgresql
      uri: !env PS_DATABASE_URI
      # 禁用 SSL（容器内部通信）
      sslmode: disable

# 同步规则
sync_rules:
  path: /app/sync_rules.yaml

# JWT 认证 - 使用 Supabase 风格 HS256 对称密钥
client_auth:
  supabase: true
  supabase_jwt_secret: !env PS_SUPABASE_JWT_SECRET

# 存储配置 - 使用 MongoDB
storage:
  type: mongodb
  uri: !env PS_MONGO_URI

# API 监听
api:
  port: 8080
  
# 指标监控
telemetry:
  disable_telemetry_sharing: true
  internal_service_endpoint: http://127.0.0.1:9090

# 日志
log_level: !env PS_LOG_LEVEL


==================================================
FILE_PATH: docker/powersync/sync_rules.yaml
==================================================

# PowerSync 同步规则配置 - Open Edition
# @see https://docs.powersync.com/usage/sync-rules
# @see 09 - APP-FIRST架构改造计划.md - Phase 1
#
# 使用 bucket_definitions 定义数据同步规则

bucket_definitions:
  # ============ 用户数据桶 ============
  # 每个用户有自己的数据桶，包含所有个人数据
  user_data:
    # 参数化桶 - 按用户 ID 分区
    parameters: SELECT token_parameters.user_id as user_id
    
    data:
      # 书籍元数据
      # 注意：is_image_based 在前端根据 is_digitalized 和 initial_digitalization_confidence 计算
      # is_image_based = !is_digitalized || (is_digitalized && confidence < 0.8)
      # is_digitalized = true 表示文字型（有文字层）
      - SELECT 
          id, user_id, title, author, 
          cover_image_key as cover_url,
          original_format as file_type, 
          size as file_size, 
          content_sha256, 
          minio_key as storage_key,
          metadata_confirmed,
          is_digitalized,
          initial_digitalization_confidence,
          (meta->>'page_count')::integer as page_count,
          ocr_status, 
          conversion_status, 
          converted_epub_key,
          created_at, updated_at, deleted_at
        FROM books
        WHERE user_id = bucket.user_id
      
      # 阅读进度
      - SELECT 
          id, user_id, book_id, device_id, 
          progress, last_position, last_location, finished_at, updated_at
        FROM reading_progress
        WHERE user_id = bucket.user_id
      
      # 阅读会话
      - SELECT 
          id, user_id, book_id, device_id,
          is_active, total_ms, created_at, updated_at
        FROM reading_sessions
        WHERE user_id = bucket.user_id
      
      # 笔记
      - SELECT 
          id, user_id, book_id, device_id,
          content, page_number, position_cfi, color,
          is_deleted, deleted_at, created_at, updated_at
        FROM notes
        WHERE user_id = bucket.user_id
      
      # 高亮
      - SELECT 
          id, user_id, book_id, device_id,
          text, page_number, position_start_cfi, position_end_cfi, color,
          is_deleted, deleted_at, created_at, updated_at
        FROM highlights
        WHERE user_id = bucket.user_id
      
      # 书签
      - SELECT 
          id, user_id, book_id, device_id,
          title, page_number, position_cfi,
          is_deleted, deleted_at, created_at, updated_at
        FROM bookmarks
        WHERE user_id = bucket.user_id
      
      # 书架
      - SELECT 
          id, user_id, name, description, cover_url,
          sort_order, is_deleted, deleted_at, created_at, updated_at
        FROM shelves
        WHERE user_id = bucket.user_id
      
      # 书架书籍关联
      # 2025-12-15: 已添加 user_id 列，现在可以通过 PowerSync 同步
      - SELECT 
          id, user_id, shelf_id, book_id, sort_order, added_at
        FROM shelf_books
        WHERE user_id = bucket.user_id
      
      # 用户设置
      - SELECT 
          id, user_id, device_id, settings_json, updated_at
        FROM user_settings
        WHERE user_id = bucket.user_id


==================================================
FILE_PATH: docker/nginx/Dockerfile
==================================================

# Athena Nginx Dockerfile（生产环境）
# 基于 Alpine Linux 的轻量级 Nginx 镜像

FROM zukubq0aouv2k2.xuanyuan.run/nginx:1.25-alpine

# 安装必要的工具
RUN apk add --no-cache \
    tzdata \
    curl

# 设置时区为上海
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# 复制 Nginx 配置
COPY nginx.conf /etc/nginx/nginx.conf

# 创建日志目录
RUN mkdir -p /var/log/nginx && \
    touch /var/log/nginx/access.log && \
    touch /var/log/nginx/error.log

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost/health || exit 1

# 暴露端口
EXPOSE 80 443

# 启动 Nginx
CMD ["nginx", "-g", "daemon off;"]


==================================================
FILE_PATH: docker/frpc/Dockerfile
==================================================

# Athena FRP 客户端 Dockerfile
FROM zukubq0aouv2k2.xuanyuan.run/snowdreamtech/frpc:0.64.0

# 安装 bash 用于脚本
RUN apk add --no-cache bash tzdata

# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# 创建配置目录
RUN mkdir -p /etc/frp

# 健康检查（检查进程是否运行）
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD ps aux | grep frpc | grep -v grep || exit 1

# 启动 FRP 客户端
CMD ["frpc", "-c", "/etc/frp/frpc.toml"]


==================================================
FILE_PATH: docker/frpc/frpc.toml
==================================================

# =========================================================================
# Athena FRP 客户端配置文件（生产环境）
# =========================================================================
# 说明：
# - 此配置用于生产环境的内网穿透
# - 与 WxLibrary 的 FRP 配置独立，使用不同的代理名称和域名
# - 建议使用独立的 auth token
# =========================================================================

# FRP 服务器配置
serverAddr = "154.40.32.146"
serverPort = 7000
auth.method = "token"
auth.token = "athena_frp_token_2024"  # 建议修改为独立的 token

# === 连接稳定性优化 ===
transport.dialServerTimeout = 90
transport.dialServerKeepAlive = 600
transport.poolCount = 5

# === 心跳机制优化 ===
transport.heartbeatInterval = 15
transport.heartbeatTimeout = 90

# === 重连机制优化 ===
loginFailExit = false

# === 日志配置 ===
log.level = "info"
log.maxDays = 7

# =========================================================================
# HTTP 代理 - Athena Web 入口
# =========================================================================
[[proxies]]
name = "athena-web"
type = "http"
localIP = "nginx"        # Docker 网络内的 Nginx 服务名
localPort = 80           # Nginx 内部端口
customDomains = ["athena.yourdomain.com"]  # 修改为实际域名

# =========================================================================
# HTTPS 代理 - Athena Web 入口（SSL）
# =========================================================================
[[proxies]]
name = "athena-web-ssl"
type = "https"
localIP = "nginx"
localPort = 443
customDomains = ["athena.yourdomain.com"]  # 修改为实际域名

# =========================================================================
# HTTP 代理 - API 子域名（可选）
# =========================================================================
[[proxies]]
name = "athena-api"
type = "http"
localIP = "nginx"
localPort = 80
customDomains = ["api.athena.yourdomain.com"]  # 修改为实际域名

# =========================================================================
# WebSocket 代理 - PowerSync 实时同步（如果需要直接暴露）
# =========================================================================
# [[proxies]]
# name = "athena-powersync"
# type = "tcp"
# localIP = "powersync"
# localPort = 8090
# remotePort = 58090  # FRP 服务器上的端口

# =========================================================================
# 监控端口（可选，仅开发/测试环境）
# =========================================================================
# [[proxies]]
# name = "athena-grafana"
# type = "http"
# localIP = "grafana"
# localPort = 3000
# customDomains = ["grafana.athena.yourdomain.com"]


==================================================
FILE_PATH: contracts/errors.yaml
==================================================

codes:
  unauthorized: 用户未认证或令牌缺失
  invalid_token: 令牌无效
  missing_refresh_token: 缺少刷新令牌
  invalid_refresh: 刷新令牌无效
  missing_session: 缺少会话ID
  invalid_email: 邮箱不合法
  invalid_payload: 请求体不合法
  missing_if_match: 缺少If-Match
  invalid_if_match: If-Match不合法
  version_conflict: 版本冲突
  not_found: 资源不存在
  bad_signature: Webhook签名不合法
  insufficient_balance: 余额不足
  admin_unauthorized: 管理权限校验失败
  http_error: HTTP错误
  internal_error: 服务器内部错误

==================================================
FILE_PATH: contracts/api/v1/shelves.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Shelves API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/shelves:
    post:
      operationId: createShelf
      summary: 创建书架
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
        "409": { description: Conflict }
    get:
      operationId: listShelves
      summary: 列出书架
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/shelves/{shelf_id}:
    patch:
      operationId: updateShelf
      summary: 更新书架（并发控制）
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: shelf_id
          required: true
          schema:
            type: string
        - in: header
          name: If-Match
          schema:
            type: string
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
        "404": { description: Not Found }
        "409": { description: Conflict }
  /api/v1/shelves/{shelf_id}/items:
    post:
      operationId: addShelfItem
      summary: 书架添加书籍
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: shelf_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
        "404": { description: Not Found }
    get:
      operationId: listShelfItems
      summary: 列出书架书籍
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: shelf_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/shelves/{shelf_id}/items/{book_id}:
    delete:
      operationId: removeShelfItem
      summary: 从书架移除书籍
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: shelf_id
          required: true
          schema:
            type: string
        - in: path
          name: book_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
        "404": { description: Not Found }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer


==================================================
FILE_PATH: contracts/api/v1/ai.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena AI API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
security:
  - bearerAuth: []
paths:
  /api/v1/ai/stream:
    get:
      summary: Stream AI response (SSE)
      operationId: aiStream
      parameters:
        - in: query
          name: conversation_id
          schema: { type: string, format: uuid }
        - in: query
          name: prompt
          schema: { type: string }
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/ai/conversations:
    get:
      summary: List conversations
      operationId: listConversations
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
    post:
      summary: Create conversation
      operationId: createConversation
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/ai/messages:
    get:
      summary: List messages
      operationId: listMessages
      parameters:
        - in: query
          name: conversation_id
          schema: { type: string, format: uuid }
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/notes.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Notes API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/notes:
    get:
      operationId: listNotes
      summary: List notes with cursor pagination
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: limit
          schema:
            type: integer
        - in: query
          name: cursor
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
    post:
      operationId: createNote
      summary: Create note (idempotent)
      security:
        - bearerAuth: []
      parameters:
        - in: header
          name: Idempotency-Key
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [book_id, content]
              properties:
                book_id:
                  type: string
                content:
                  type: string
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
  /api/v1/notes/{note_id}:
    get:
      operationId: getNote
      summary: Get note
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: note_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "404":
          description: Not Found
    patch:
      operationId: updateNote
      summary: Update note with optimistic concurrency
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: note_id
          required: true
          schema:
            type: string
        - in: header
          name: If-Match
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        "200":
          description: OK
        "409":
          description: Version Conflict
    delete:
      operationId: deleteNote
      summary: Soft delete note
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: note_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "404":
          description: Not Found
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/search.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Search API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/search:
    get:
      operationId: search
      summary: Search notes/highlights/books
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: q
          schema:
            type: string
        - in: query
          name: kind
          schema:
            type: string
            enum: [note, highlight, book]
        - in: query
          name: tag_ids
          schema:
            type: array
            items:
              type: string
        - in: query
          name: sort_by
          schema:
            type: string
            enum: [relevance, updated_at]
        - in: query
          name: limit
          schema:
            type: integer
        - in: query
          name: offset
          schema:
            type: integer
      responses:
        "200":
          description: OK
          headers:
            X-Search-Engine:
              schema:
                type: string
              description: elasticsearch or postgres-tsvector
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                  data:
                    type: array
                    items:
                      oneOf:
                        - $ref: '#/components/schemas/SearchNote'
                        - $ref: '#/components/schemas/SearchHighlight'
                        - $ref: '#/components/schemas/SearchBook'
        "401":
          description: Unauthorized
        "400": { description: Bad Request }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
  schemas:
    SearchNote:
      type: object
      properties:
        kind:
          type: string
          enum: [note]
        id:
          type: string
        content:
          type: string
        book_id:
          type: string
        updated_at:
          type: string
        etag:
          type: string
        score:
          type: number
        highlight:
          $ref: '#/components/schemas/HighlightFragments'
    SearchHighlight:
      type: object
      properties:
        kind:
          type: string
          enum: [highlight]
        id:
          type: string
        comment:
          type: string
        book_id:
          type: string
        updated_at:
          type: string
        etag:
          type: string
        score:
          type: number
        highlight:
          $ref: '#/components/schemas/HighlightFragments'
    SearchBook:
      type: object
      properties:
        kind:
          type: string
          enum: [book]
        id:
          type: string
        title:
          type: string
        author:
          type: string
        updated_at:
          type: string
        etag:
          type: string
    HighlightFragments:
      type: object
      properties:
        fragments:
          type: array
          items:
            type: string

==================================================
FILE_PATH: contracts/api/v1/highlights.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Highlights API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/highlights:
    get:
      operationId: listHighlights
      summary: List highlights
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: book_id
          schema:
            type: string
        - in: query
          name: limit
          schema:
            type: integer
        - in: query
          name: cursor
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
    post:
      operationId: createHighlight
      summary: Create highlight (idempotent)
      security:
        - bearerAuth: []
      parameters:
        - in: header
          name: Idempotency-Key
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [book_id, start_location, end_location]
              properties:
                book_id:
                  type: string
                start_location:
                  type: integer
                end_location:
                  type: integer
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
  /api/v1/highlights/{highlight_id}:
    patch:
      operationId: updateHighlight
      summary: Update highlight
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: highlight_id
          required: true
          schema:
            type: string
        - in: header
          name: If-Match
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        "200":
          description: OK
        "409":
          description: Version Conflict
    delete:
      operationId: deleteHighlight
      summary: Soft delete highlight
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: highlight_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "404":
          description: Not Found
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/tags.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Tags API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/tags:
    post:
      operationId: createTag
      summary: 创建标签
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
        "409": { description: Conflict }
    get:
      operationId: listTags
      summary: 列出标签
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/tags/{tag_id}:
    patch:
      operationId: updateTag
      summary: 更新标签（并发控制）
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: tag_id
          required: true
          schema:
            type: string
        - in: header
          name: If-Match
          schema:
            type: string
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
        "404": { description: Not Found }
        "409": { description: Conflict }
    delete:
      operationId: deleteTag
      summary: 删除标签
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: tag_id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
        "404": { description: Not Found }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/books.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Books API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/books:
    get:
      summary: List books
      operationId: listBooks
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
    post:
      summary: Upload proxy
      operationId: uploadProxy
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
  /api/v1/books/register:
    post:
      summary: Register external object url (idempotent)
      operationId: registerBook
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
  /api/v1/books/upload_init:
    post:
      summary: Init direct upload
      operationId: uploadInit
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/upload_complete:
    post:
      summary: Complete direct upload
      operationId: uploadComplete
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
  /api/v1/books/{book_id}:
    get:
      summary: Get book detail
      operationId: getBook
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
    patch:
      summary: Update book
      operationId: patchBook
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
        - in: header
          name: If-Match
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
        "409": { description: Conflict }
    delete:
      summary: Delete book
      operationId: deleteBook
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/{book_id}/presign:
    get:
      summary: Presign download
      operationId: presignDownload
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/{book_id}/convert:
    post:
      summary: Request convert
      operationId: requestConvert
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/jobs/list:
    get:
      summary: List conversion jobs
      operationId: listJobs
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: status
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/jobs/{job_id}/complete:
    post:
      summary: Complete job
      operationId: completeJob
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: job_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/jobs/{job_id}/fail:
    post:
      summary: Fail job
      operationId: failJob
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: job_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/{book_id}/processing/status:
    get:
      summary: Get processing status
      operationId: getProcessingStatus
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/books/{book_id}/convert/output:
    get:
      summary: Presign convert output
      operationId: presignConvertOutput
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: book_id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/profile.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Profile API
  version: 1.0.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/profile/me:
    get:
      operationId: getProfileMe
      summary: 获取当前用户资料
      security:
        - bearerAuth: []
      responses:
        '200':
          description: OK
          headers:
            ETag:
              description: 资源版本标签
              schema: { type: string }
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Profile'
        '401': { description: Unauthorized }
    patch:
      operationId: patchProfileMe
      summary: 更新当前用户资料（乐观并发 + 幂等）
      security:
        - bearerAuth: []
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ProfileUpdate'
      responses:
        '200':
          description: OK
          headers:
            ETag:
              description: 新版本标签
              schema: { type: string }
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Profile'
        '400': { description: INVALID }
        '409': { description: VERSION_CONFLICT }

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Profile:
      type: object
      properties:
        user_id: { type: string, format: uuid }
        display_name: { type: string }
        timezone: { type: string }
        language: { type: string }
        version: { type: integer }
    ProfileUpdate:
      type: object
      properties:
        display_name: { type: string }
        timezone: { type: string }
        language: { type: string }


==================================================
FILE_PATH: contracts/api/v1/translate.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Translate API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
security:
  - bearerAuth: []
paths:
  /api/v1/translate:
    post:
      summary: Translate text and charge accordingly
      operationId: translateText
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/srs.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena SRS API
  version: 1.0.0
  description: 智能复习（SRS）接口契约：牌组、卡片、队列、评分与表现。
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: /api/v1
tags:
  - name: SRS
    description: 智能复习（Spaced Repetition System）相关操作
security:
  - bearerAuth: []
paths:
  /srs/decks:
    get:
      tags: [SRS]
      summary: 列出牌组
      operationId: listDecks
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/Deck' }
        '401': { description: Unauthorized }
    post:
      tags: [SRS]
      summary: 创建牌组
      operationId: createDeck
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/DeckCreate' }
      responses:
        '201': { description: Created }
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
  /srs/cards:
    get:
      tags: [SRS]
      summary: 拉取到期卡片队列
      operationId: listDueCards
      parameters:
        - in: query
          name: deckId
          schema: { type: string, format: uuid }
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/Card' }
        '401': { description: Unauthorized }
    post:
      tags: [SRS]
      summary: 从笔记/高亮创建卡片（幂等）
      operationId: createCard
      parameters:
        - in: header
          name: Idempotency-Key
          required: false
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/CardCreate' }
      responses:
        '201': { description: Created }
        '409': { description: Conflict }
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
  /srs/cards/{cardId}:
    patch:
      tags: [SRS]
      summary: 暂停或恢复卡片
      operationId: patchCard
      parameters:
        - in: path
          name: cardId
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                is_suspended: { type: boolean }
      responses:
        '200': { description: OK }
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
        '404': { description: Not Found }
  /srs/cards/{cardId}/review:
    post:
      tags: [SRS]
      summary: 提交评分与调度（幂等）
      operationId: reviewCard
      parameters:
        - in: path
          name: cardId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: Idempotency-Key
          required: false
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/ReviewRequest' }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/ReviewResponse' }
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
        '404': { description: Not Found }
  /srs/performance:
    get:
      tags: [SRS]
      summary: 查询复习表现（聚合）
      operationId: getPerformance
      parameters:
        - in: query
          name: since
          schema: { type: string, format: date-time }
        - in: query
          name: until
          schema: { type: string, format: date-time }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/PerformanceList' }
        '401': { description: Unauthorized }
  /srs/settings:
    get:
      tags: [SRS]
      summary: 获取SRS参数设置
      operationId: getSettings
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/SRSSettings' }
        '401': { description: Unauthorized }
    put:
      tags: [SRS]
      summary: 更新SRS参数设置
      operationId: putSettings
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/SRSSettings' }
      responses:
        '200': { description: OK }
        '400': { description: Bad Request }
        '401': { description: Unauthorized }

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Deck:
      type: object
      properties:
        id: { type: string, format: uuid }
        name: { type: string }
        description: { type: string }
        created_at: { type: string, format: date-time }
    DeckCreate:
      type: object
      required: [name]
      properties:
        name: { type: string }
        description: { type: string }
    Card:
      type: object
      properties:
        id: { type: string, format: uuid }
        deck_id: { type: string, format: uuid }
        source_type: { type: string, enum: [NOTE, HIGHLIGHT] }
        source_id: { type: string, format: uuid }
        prompt: { type: string }
        answer: { type: string }
        ease: { type: number }
        interval: { type: integer }
        due_at: { type: string, format: date-time }
        is_suspended: { type: boolean }
    CardCreate:
      type: object
      required: [deck_id, source_type, source_id, prompt]
      properties:
        deck_id: { type: string, format: uuid }
        source_type: { type: string, enum: [NOTE, HIGHLIGHT] }
        source_id: { type: string, format: uuid }
        prompt: { type: string }
        answer: { type: string }
    ReviewRequest:
      type: object
      required: [rating]
      properties:
        rating: { type: integer, minimum: 0, maximum: 5 }
    ReviewResponse:
      type: object
      properties:
        card_id: { type: string, format: uuid }
        new_interval: { type: integer }
        new_ease: { type: number }
        next_due_at: { type: string, format: date-time }
    PerformanceItem:
      type: object
      properties:
        day: { type: string, format: date }
        reviews: { type: integer }
        avg_rating: { type: number }
        retention: { type: number }
    PerformanceList:
      type: object
      properties:
        items:
          type: array
          items: { $ref: '#/components/schemas/PerformanceItem' }
    SRSSettings:
      type: object
      properties:
        algorithm: { type: string, enum: [SM2, FSRS] }
        fsrs_weights:
          type: array
          items: { type: number }

==================================================
FILE_PATH: contracts/api/v1/billing.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Billing API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/billing/balance:
    get:
      summary: Get balance
      operationId: getBillingBalance
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
  /api/v1/billing/ledger:
    get:
      summary: List ledger
      operationId: listBillingLedger
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: limit
          schema:
            type: integer
        - in: query
          name: offset
          schema:
            type: integer
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
  /api/v1/billing/sessions:
    post:
      summary: Create payment session
      operationId: createPaymentSession
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400":
          description: Bad Request
        "401":
          description: Unauthorized
  /api/v1/billing/webhook/{gateway}:
    post:
      summary: Payment webhook
      security: []
      operationId: paymentWebhook
      parameters:
        - in: path
          name: gateway
          schema:
            type: string
        - in: header
          name: X-Signature
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401":
          description: Bad Signature
  /api/v1/billing/consume:
    post:
      summary: Consume credits
      operationId: consumeCredits
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400":
          description: Invalid Amount
        "401":
          description: Unauthorized
  /api/v1/billing/exchange:
    post:
      summary: Exchange between wallet and credits
      operationId: exchangeWalletCredits
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "400":
          description: Invalid Request
        "401":
          description: Unauthorized
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/admin.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Admin API
  version: 1.0.0
  description: 管理面板后端契约（初版），只读与少量管理操作。
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
    description: 本地开发
tags:
  - name: Users
    description: 用户管理
  - name: FeatureFlags
    description: 特性开关配置
  - name: UserFeatureFlags
    description: 用户级开关覆盖
  - name: PromptTemplates
    description: 提示词模板管理
  - name: AuditLogs
    description: 审计日志查询
  - name: Metrics
    description: 运营指标
  - name: Tasks
    description: 运维任务
  - name: I18nLanguages
    description: 语言配置
  - name: I18nTranslations
    description: 翻译配置
security:
  - bearerAuth: []
paths:
  /api/v1/admin/users:
    get:
      tags: [Users]
      summary: 列出用户（分页/筛选）
      operationId: adminListUsers
      parameters:
        - in: query
          name: q
          schema: { type: string }
          description: 关键字（邮箱/昵称）
        - in: query
          name: role
          schema: { type: string, enum: [user, admin] }
        - in: query
          name: isActive
          schema: { type: boolean }
        - in: query
          name: page
          schema: { type: integer, minimum: 1, default: 1 }
        - in: query
          name: page_size
          schema: { type: integer, minimum: 1, maximum: 200, default: 20 }
        - in: query
          name: sort
          schema: { type: string, enum: [created_at, last_login_at] }
        - in: query
          name: order
          schema: { type: string, enum: [asc, desc], default: desc }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserList'
        '401': { description: Unauthorized }
  /api/v1/admin/users/{userId}:
    get:
      tags: [Users]
      summary: 获取用户详情
      operationId: adminGetUser
      parameters:
        - in: path
          name: userId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/User' }
        '401': { description: Unauthorized }
    patch:
      tags: [Users]
      summary: 更新用户属性（角色/激活）
      operationId: adminPatchUser
      parameters:
        - in: path
          name: userId
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/UpdateUser' }
      responses:
        '200': { description: OK }
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
        '403': { description: Forbidden }
        '409': { description: Conflict }
  /api/v1/admin/feature-flags:
    get:
      tags: [FeatureFlags]
      summary: 列出所有特性开关
      operationId: adminListFeatureFlags
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/FeatureFlag' }
        '401': { description: Unauthorized }
    post:
      tags: [FeatureFlags]
      summary: 创建特性开关
      operationId: adminCreateFeatureFlag
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/FeatureFlagCreate' }
      responses:
        '201': { description: Created }
        '409': { description: Duplicate Key }
        '401': { description: Unauthorized }
  /api/v1/admin/feature-flags/{key}:
    patch:
      tags: [FeatureFlags]
      summary: 更新特性开关（并发控制）
      operationId: adminUpdateFeatureFlag
      parameters:
        - in: path
          name: key
          required: true
          schema: { type: string }
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/FeatureFlagUpdate' }
      responses:
        '200': { description: OK, headers: { ETag: { $ref: '#/components/headers/ETag' } } }
        '409': { description: VERSION_CONFLICT }
        '401': { description: Unauthorized }
    delete:
      tags: [FeatureFlags]
      summary: 删除特性开关
      operationId: adminDeleteFeatureFlag
      parameters:
        - in: path
          name: key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }
        '401': { description: Unauthorized }
  /api/v1/admin/user-feature-flags/{userId}:
    get:
      tags: [UserFeatureFlags]
      summary: 获取用户特性开关覆盖
      operationId: adminGetUserFlags
      parameters:
        - in: path
          name: userId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/UserFeatureFlags' }
        '401': { description: Unauthorized }
    put:
      tags: [UserFeatureFlags]
      summary: 设置用户覆盖（幂等）
      operationId: adminPutUserFlags
      parameters:
        - in: path
          name: userId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: Idempotency-Key
          required: false
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/UserFeatureFlags' }
      responses:
        '200': { description: OK }
        '401': { description: Unauthorized }
  /api/v1/admin/prompt-templates:
    get:
      tags: [PromptTemplates]
      summary: 列出提示词模板
      operationId: adminListPromptTemplates
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items: { $ref: '#/components/schemas/PromptTemplate' }
        '401': { description: Unauthorized }
  /api/v1/admin/prompt-templates/{name}:
    put:
      tags: [PromptTemplates]
      summary: 更新提示词模板（并发控制）
      operationId: adminPutPromptTemplate
      parameters:
        - in: path
          name: name
          required: true
          schema: { type: string }
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/PromptTemplateUpdate' }
      responses:
        '200': { description: OK, headers: { ETag: { $ref: '#/components/headers/ETag' } } }
        '409': { description: VERSION_CONFLICT }
  /api/v1/admin/audit-logs:
    get:
      tags: [AuditLogs]
      summary: 查询审计日志（分页/筛选）
      operationId: adminListAuditLogs
      parameters:
        - in: query
          name: user_id
          schema: { type: string, format: uuid }
        - in: query
          name: action
          schema: { type: string }
        - in: query
          name: since
          schema: { type: string, format: date-time }
        - in: query
          name: until
          schema: { type: string, format: date-time }
        - in: query
          name: page
          schema: { type: integer, minimum: 1, default: 1 }
        - in: query
          name: page_size
          schema: { type: integer, minimum: 1, maximum: 200, default: 50 }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/AuditLogList' }
        '401': { description: Unauthorized }
  /api/v1/admin/metrics:
    get:
      tags: [Metrics]
      summary: 获取运营指标（受限字段）
      operationId: adminGetMetrics
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/OperationalMetrics' }
        '401': { description: Unauthorized }
  /api/v1/admin/tasks/reindex/{userId}:
    post:
      tags: [Tasks]
      summary: 单用户数据重建索引（入队）
      operationId: adminReindexUser
      parameters:
        - in: path
          name: userId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: Idempotency-Key
          required: false
          schema: { type: string, format: uuid }
      responses:
        '202':
          description: Accepted
        '401': { description: Unauthorized }
          

  /api/v1/admin/i18n/languages:
    get:
      tags: [I18nLanguages]
      summary: 列出支持语言（分页）
      operationId: adminListLanguages
      parameters:
        - in: query
          name: cursor
          schema: { type: string }
        - in: query
          name: page_size
          schema: { type: integer, minimum: 1, maximum: 200, default: 50 }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/I18nLanguageList' }
        '401': { description: Unauthorized }
    post:
      tags: [I18nLanguages]
      summary: 新增语言
      operationId: adminCreateLanguage
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [code, name]
              properties:
                code: { type: string }
                name: { type: string }
      responses:
        '201': { description: Created }
        '401': { description: Unauthorized }

  /api/v1/admin/i18n/languages/{code}:
    patch:
      tags: [I18nLanguages]
      summary: 更新语言（启用/禁用/改名，并发控制）
      operationId: adminPatchLanguage
      parameters:
        - in: path
          name: code
          required: true
          schema: { type: string }
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                name: { type: string }
                is_active: { type: boolean }
      responses:
        '200': { description: OK, headers: { ETag: { $ref: '#/components/headers/ETag' } } }
        '409': { description: VERSION_CONFLICT }
        '401': { description: Unauthorized }
    delete:
      tags: [I18nLanguages]
      summary: 删除语言
      operationId: adminDeleteLanguage
      parameters:
        - in: path
          name: code
          required: true
          schema: { type: string }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }
        '401': { description: Unauthorized }

  /api/v1/admin/i18n/translations:
    get:
      tags: [I18nTranslations]
      summary: 查询翻译键值对
      operationId: adminListTranslations
      parameters:
        - in: query
          name: cursor
          schema: { type: string }
        - in: query
          name: page_size
          schema: { type: integer, minimum: 1, maximum: 200, default: 50 }
        - in: query
          name: lang_code
          schema: { type: string }
        - in: query
          name: key
          schema: { type: string }
          description: 模糊搜索
        - in: query
          name: view
          schema: { type: string, enum: [key_based, language_based], default: key_based }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/I18nTranslationItem' }
                  next_cursor: { type: string }
        '401': { description: Unauthorized }
    put:
      tags: [I18nTranslations]
      summary: 批量UPSERT翻译（幂等）
      operationId: adminPutTranslations
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: array
              items:
                type: object
                required: [key, lang_code, value]
                properties:
                  key: { type: string }
                  lang_code: { type: string }
                  value: { type: string }
      responses:
        '200': { description: OK }
        '401': { description: Unauthorized }

  /api/v1/admin/i18n/publish:
    post:
      tags: [I18nTranslations]
      summary: 触发发布到 MinIO/CDN（异步）
      operationId: adminPublishTranslations
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '202':
          description: Accepted
          content:
            application/json:
              schema: { $ref: '#/components/schemas/I18nPublishAccepted' }
        '401': { description: Unauthorized }

  /api/v1/admin/i18n/import:
    post:
      tags: [I18nTranslations]
      summary: 批量导入翻译（CSV/JSON，异步）
      operationId: adminImportTranslations
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file: { type: string, format: binary }
                format: { type: string, enum: [csv, json] }
      responses:
        '202':
          description: Accepted
          content:
            application/json:
              schema: { $ref: '#/components/schemas/I18nPublishAccepted' }
        '401': { description: Unauthorized }

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  headers:
    ETag:
      description: 资源版本标签，用于并发控制
      schema: { type: string }
  schemas:
    User:
      type: object
      properties:
        id: { type: string, format: uuid }
        email: { type: string }
        display_name: { type: string }
        role: { type: string, enum: [user, admin] }
        is_active: { type: boolean }
        created_at: { type: string, format: date-time }
        last_login_at: { type: string, format: date-time }
    UserList:
      type: object
      properties:
        items:
          type: array
          items: { $ref: '#/components/schemas/User' }
        page: { type: integer }
        page_size: { type: integer }
        total: { type: integer }
    UpdateUser:
      type: object
      properties:
        role: { type: string, enum: [user, admin] }
        is_active: { type: boolean }
    FeatureFlag:
      type: object
      properties:
        key: { type: string }
        enabled: { type: boolean }
        description: { type: string }
        version: { type: integer }
        updated_at: { type: string, format: date-time }
    FeatureFlagCreate:
      type: object
      required: [key, enabled]
      properties:
        key: { type: string }
        enabled: { type: boolean }
        description: { type: string }
    FeatureFlagUpdate:
      type: object
      properties:
        enabled: { type: boolean }
        description: { type: string }
        version: { type: integer }
    UserFeatureFlags:
      type: object
      properties:
        user_id: { type: string, format: uuid }
        overrides:
          type: array
          items:
            type: object
            properties:
              key: { type: string }
              enabled: { type: boolean }
    PromptTemplate:
      type: object
      properties:
        name: { type: string }
        version: { type: integer }
        content: { type: string }
        updated_at: { type: string, format: date-time }
    PromptTemplateUpdate:
      type: object
      required: [content]
      properties:
        content: { type: string }
    AuditLog:
      type: object
      properties:
        id: { type: string, format: uuid }
        actor_user_id: { type: string, format: uuid }
        target_user_id: { type: string, format: uuid }
        action: { type: string }
        metadata: { type: object }
        created_at: { type: string, format: date-time }
    AuditLogList:
      type: object
      properties:
        items:
          type: array
          items: { $ref: '#/components/schemas/AuditLog' }
        page: { type: integer }
        page_size: { type: integer }
        total: { type: integer }
    OperationalMetrics:
      type: object
      properties:
        active_users_24h: { type: integer }
        new_users_24h: { type: integer }
        book_uploads_24h: { type: integer }
        ai_tokens_24h: { type: integer }
        errors_24h: { type: integer }
    I18nLanguage:
      type: object
      properties:
        code: { type: string }
        name: { type: string }
        is_active: { type: boolean }
        version: { type: integer }
        updated_at: { type: string, format: date-time }
    I18nLanguageList:
      type: object
      properties:
        items:
          type: array
          items: { $ref: '#/components/schemas/I18nLanguage' }
        next_cursor: { type: string }
    I18nTranslationItem:
      type: object
      properties:
        key: { type: string }
        translations:
          type: object
          additionalProperties: { type: string }
    I18nPublishAccepted:
      type: object
      properties:
        job_id: { type: string }


==================================================
FILE_PATH: contracts/api/v1/reading_sessions.yaml
==================================================

openapi: 3.0.3
info:
  title: Reader Progress Sessions API
  version: 1.0.0
  description: 心跳会话模型的阅读进度同步API。
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: /
security:
  - bearerAuth: []
tags:
  - name: reading-sessions
    description: 阅读会话心跳与进度同步

paths:
  /api/v1/reading-sessions/start:
    post:
      tags: [reading-sessions]
      summary: 开启阅读会话
      operationId: startReadingSession
      parameters:
        - name: X-Timezone
          in: header
          required: false
          description: 客户端IANA时区名称（如 Asia/Shanghai），用于本地日期计算
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/StartSessionRequest'
            examples:
              pdf:
                value: { book_id: "e9c3c8a5-86e0-4e03-9b28-88b3c3c1b8e0" }
      responses:
        '200':
          description: 会话已创建
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StartSessionResponse'
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
        '409': { description: Conflict }

  /api/v1/reading-sessions/{sessionId}/heartbeat:
    post:
      tags: [reading-sessions]
      summary: 发送心跳并同步进度
      operationId: heartbeatReadingSession
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: X-Timezone
          in: header
          required: false
          description: 客户端IANA时区名称（如 Asia/Shanghai），用于本地日期计算
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/HeartbeatRequest'
            examples:
              pdf:
                value:
                  last_location: { type: PDF, page: 125, zoom: 1.2, scrollTop: 420 }
                  progress_percentage: 0.45
              epub:
                value:
                  last_location: { type: EPUB, cfi: "epubcfi(/6/2[chapter]!/4/1:0)" }
                  progress_percentage: 0.21
      responses:
        '204':
          description: 已同步，无内容返回
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
        '404': { description: Not Found }

  /api/v1/reading-sessions/{sessionId}/end:
    post:
      tags: [reading-sessions]
      summary: 结束阅读会话并执行最终同步
      operationId: endReadingSession
      parameters:
        - name: sessionId
          in: path
          required: true
          schema:
            type: string
            format: uuid
        - name: X-Timezone
          in: header
          required: false
          description: 客户端IANA时区名称（如 Asia/Shanghai），用于本地日期计算
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/HeartbeatRequest'
            examples:
              final:
                value:
                  last_location: { type: PDF, page: 131, zoom: 1.1, scrollTop: 300 }
                  progress_percentage: 0.51
      responses:
        '204':
          description: 会话已结束并完成同步
        '400': { description: Bad Request }
        '401': { description: Unauthorized }
        '404': { description: Not Found }

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    StartSessionRequest:
      type: object
      required: [book_id]
      properties:
        book_id:
          type: string
          format: uuid
    StartSessionResponse:
      type: object
      required: [session_id]
      properties:
        session_id:
          type: string
          format: uuid

    HeartbeatRequest:
      type: object
      required: [last_location]
      properties:
        last_location:
          $ref: '#/components/schemas/LastLocation'
        progress_percentage:
          type: number
          format: float
          minimum: 0
          maximum: 1

    LastLocation:
      oneOf:
        - $ref: '#/components/schemas/PdfLocation'
        - $ref: '#/components/schemas/EpubLocation'
      discriminator:
        propertyName: type

    PdfLocation:
      type: object
      required: [type, page]
      properties:
        type:
          type: string
          enum: [PDF]
        page:
          type: integer
          minimum: 1
        zoom:
          type: number
          format: float
        scrollTop:
          type: integer

    EpubLocation:
      type: object
      required: [type, cfi]
      properties:
        type:
          type: string
          enum: [EPUB]
        cfi:
          type: string

==================================================
FILE_PATH: contracts/api/v1/tts.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena TTS API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
security:
  - bearerAuth: []
paths:
  /api/v1/tts:
    post:
      summary: Generate TTS and return download url
      operationId: ttsGenerate
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/tts/heartbeat:
    post:
      summary: Accumulate TTS duration
      operationId: ttsHeartbeat
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/dict.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Dictionary API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
security:
  - bearerAuth: []
paths:
  /api/v1/dict/packages:
    get:
      summary: List dictionary packages
      operationId: listDictPackages
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/dict/packages/upload_init:
    post:
      summary: Init upload
      operationId: dictUploadInit
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/dict/packages/upload_complete:
    post:
      summary: Complete upload
      operationId: dictUploadComplete
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/dict/lookup:
    post:
      summary: Lookup word
      operationId: dictLookup
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
  /api/v1/dict/history:
    get:
      summary: List lookup history
      operationId: dictHistory
      responses:
        "200": { description: OK }
        "401": { description: Unauthorized }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/export.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Export API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
security:
  - bearerAuth: []
paths:
  /api/v1/export/ocr/{job_id}:
    get:
      summary: Export OCR result
      operationId: exportOcr
      parameters:
        - in: path
          name: job_id
          schema:
            type: string
        - in: query
          name: format
          schema:
            type: string
            enum: [txt, md, markdown, pdf]
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
        "400": { description: Bad Request }
  /api/v1/export/notes:
    get:
      summary: Export notes
      operationId: exportNotes
      parameters:
        - in: query
          name: format
          schema:
            type: string
            enum: [txt, md, markdown, pdf]
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
        "400": { description: Bad Request }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/pricing.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Pricing API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
security:
  - bearerAuth: []
paths:
  /api/v1/pricing/rules:
    get:
      summary: List pricing rules
      operationId: listPricingRules
      parameters:
        - in: query
          name: service_type
          schema:
            type: string
        - in: query
          name: region
          schema:
            type: string
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
  /api/v1/admin/pricing/rules:
    get:
      summary: Admin list pricing rules
      operationId: adminListPricingRules
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
    post:
      summary: Admin create pricing rule
      operationId: adminCreatePricingRule
      responses:
        "200":
          description: OK
        "400": { description: Bad Request }
        "401": { description: Unauthorized }
  /api/v1/admin/pricing/rules/{rule_id}:
    patch:
      summary: Admin update pricing rule
      operationId: adminUpdatePricingRule
      parameters:
        - in: path
          name: rule_id
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: OK
        "412": { description: ETag Mismatch }
        "401": { description: Unauthorized }
    delete:
      summary: Admin delete pricing rule
      operationId: adminDeletePricingRule
      parameters:
        - in: path
          name: rule_id
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          description: OK
        "401": { description: Unauthorized }
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer

==================================================
FILE_PATH: contracts/api/v1/auth.yaml
==================================================

openapi: 3.0.3
info:
  title: Athena Auth API
  version: 0.1.0
  license:
    name: MIT
    url: https://opensource.org/licenses/MIT
servers:
  - url: https://api.athena.app
paths:
  /api/v1/auth/email/send_code:
    post:
      operationId: sendEmailCode
      summary: Send email code
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [email]
              properties:
                email:
                  type: string
      responses:
        "200":
          description: OK
        "400":
          description: Bad Request
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                  data:
                    type: object
                    properties:
                      request_id:
                        type: string
                      message:
                        type: string
  /api/v1/auth/email/verify_code:
    post:
      operationId: verifyEmailCode
      summary: Verify email code and issue tokens
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [email, code]
              properties:
                email:
                  type: string
                code:
                  type: string
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                  data:
                    type: object
                    properties:
                      user:
                        type: object
                      tokens:
                        type: object
                        properties:
                          access_token:
                            type: string
                          refresh_token:
                            type: string
                          expires_in:
                            type: integer
                      session:
                        type: object
  /api/v1/auth/me:
    get:
      operationId: getMe
      summary: Get current user
      security:
        - bearerAuth: []
      responses:
        "200":
          description: OK
        "401":
          description: Unauthorized
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer