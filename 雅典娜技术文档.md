
## **《“雅典娜计划”产品与开发规则 v7.0》**

### **产品Slogan:**
雅典娜：把读过的每一本书，都变成你的知识资产。

### **核心价值主张 (UVP):**
为深度阅读者提供一个集无缝云同步、深度AI整合、极致笔记体验于一体的知识内化引擎，将碎片化的阅读转化为结构化的智慧。

---

所有DOCKER镜像拉取的私人域名地址是：zukubq0aouv2k2.xuanyuan.run

### **第一章：核心架构与技术栈 (最终版)**

#### **1. 架构原则:**
严格遵循前后端分离、微服务（初期为“主API服务”+“AI服务”）、无状态认证、契约驱动开发、一切皆容器化的核心原则。

#### **2. 技术栈选型 (最终锁定):**

| 领域 | 官方指定技术 | 备注 / 执行要点 |
|---|---|---|
| 前端 | React (Vite) + TypeScript | 状态管理：Zustand。数据获取/缓存：TanStack Query。**支持PWA**。 |
| 桌面端 | Tauri | P1阶段规划，复用Web前端代码。 |
| 后端 | Python 3.11+, FastAPI | 数据库交互：SQLAlchemy 2.0 (异步)。 |
| 认证 | JWT (HS256) + Refresh Tokens | OAuth + 邮箱验证码登录；Token管理：Redis；不提供手机号注册。 |
| 数据库 | PostgreSQL 15+ & pgvector | 统一存储关系数据和向量数据。 |
| 连接池 | PgBouncer | **[建议]** 高并发下减少连接建立开销；推荐会话池模式。
| 全文检索 | **OpenSearch** | **[决策]** 兼容 ES API，开源且无版权风险。 |
| 对象存储 | SeaweedFS（S3 Gateway） | **[架构]** 后端使用 `boto3` (S3协议) 连接 SeaweedFS 网关 (默认端口 8333)。<br>**[注意]** 代码中环境变量仍沿用 `MINIO_*` 前缀 (如 `MINIO_ENDPOINT`, `MINIO_BUCKET`) 以保持 S3 客户端库兼容性。 |
| 实时同步 | WebSocket + Yjs | 已接入 `ypy-websocket` 的 `WebsocketServer`，支持前端 Yjs 二进制协议；同时保留文本广播用于业务事件通知。 |
| 后台任务 | **Celery + Redis** | **[优化]** 使用Redis作为Broker和Backend。 |
| 部署 | Docker Compose (本地服务器) | 简单、高效，满足MVP及早期生产阶段。 |
| AI - LLM | OpenRouter API（Anthropic/OpenAI/DeepSeek 等） | 统一路由聚合与计费，避免前期GPU硬件投入。 |
| AI - Embedding | **Local (BGE-M3)** | **[决策]** 本地部署，零成本，数据隐私更佳。 |
| AI - OCR | **Local (PaddleOCR)** | **[决策]** 本地部署，无需外部API调用，支持批量处理。 |
| API网关 | **Traefik** | **[决策]** 轻量级，与Docker Compose原生集成，易于配置路由和限流。 |
| 密钥管理 | **Infisical** | **[决策]** 开源免费，替代Vault，与Docker Compose无缝集成。 |
| 可观测性 | athena-calibre-1 | **[新增]** Loki用于日志聚合，与Prometheus/Grafana构成完整监控栈。 |
| 错误监控 | **Sentry** | **[新增]** 主动捕获和分析线上运行时错误。 |
| 邮件服务 | Resend (生产) + Mailpit (开发) | **[建议]** 支持邮箱验证码登录；提供模板、速率限制与退信处理；开发者免费额度充足。 |
| 数据库备份 | **Barman** | **[新增]** 专业的PostgreSQL备份与恢复管理工具。 |

#### （更新）服务层实现现状
- OCR：`PaddleOCR` 本地部署；不可用时自动降级为 `MockOCR`（返回空结果），保障 CI/低资源环境通过。
- Embedding：`BAAI/bge-m3` 本地部署（CPU）；不可用时自动降级为 `MockEmbedder`（零向量）。
- TTS：`EdgeTTS`，生成音频与 VTT 字幕；不可用时降级为 `MockTTS`（合成哔声与伪字幕）。

#### **密钥管理与轮换策略（新增）**
- 轮换：所有静态 API Key ≤ 90 天轮换；紧急泄露处置流程（吊销、审计、再发行）。
- RBAC：服务级最小权限；密钥访问全量审计与告警（异常访问）。
- 存储：加密存储与传输；仅服务端注入；前端禁止持有密钥。

#### **全局域名与子域名策略（新增）**
- 主域与 canonical：`youdomin.com` 作为营销主域；`www.youdomin.com` 301 重定向到 `youdomin.com`；全站 HTTPS 与 HSTS（包含子域）。
- 核心子域：
  - `app.youdomin.com`：Web 应用前端
  - `api.youdomin.com`：后端 API（REST/WebSocket）
  - `cdn.youdomin.com`：静态资源与构建产物的 CDN 域
  - `assets.youdomin.com`：对象存储（MinIO 签名下载/上传）
  - `admin.youdomin.com`：管理员后台
  - `docs.youdomin.com`：文档与帮助中心（可选）
  - `og.youdomin.com`：动态 OG 图片生成（可选）
- 环境分域：
  - 预发：`staging.youdomin.com`、`app.staging.youdomin.com`、`api.staging.youdomin.com`
  - 开发：`dev.youdomin.com`、`api.dev.youdomin.com`（或内网域）
- SSO 与 Cookie：顶级域 Cookie `Domain=.youdomin.com`，`Secure`，`HttpOnly`，`SameSite=None`；营销与应用共享登录态，Header 动态显示“进入应用”。
- TLS：Traefik 自动签发 `youdomin.com` 与 `*.youdomin.com`（Let’s Encrypt），证书续期监控与回退策略。
- DNS：
  - A/AAAA：`youdomin.com`、`api.youdomin.com`、`app.youdomin.com`
  - CNAME：`cdn.youdomin.com` 指向 CDN 提供商；`assets.youdomin.com` 指向对象存储入口
  - 邮件：`MX`、`SPF`、`DKIM`、`DMARC`（与 Resend 集成）
- SEO 与 i18n：`https://youdomin.com/en/...`、`https://youdomin.com/zh-CN/...`；规范化 canonical 与 hreflang。

#### PgBouncer 连接池建议（新增）
- 模式选择：优先使用会话池（session pooling），避免ORM多语句事务中会话变量丢失；必要时评估事务池与`SET LOCAL`兼容性。
- 会话变量：所有数据库写/读操作在事务开始处执行 `SET LOCAL app.user_id` 与 `SET LOCAL app.role`；中间件确保未设置时拒绝访问。
- 连接上限：PgBouncer前置，提高连接重用率；数据库侧适当下调 `max_connections`，配合合理 `pool_size`。
- 超时与健康：配置 `query_timeout`、`server_idle_timeout`；启用探活（`healthcheck`）。
- 迁移注意：大规模迁移/批处理走直连或单独池，避免影响线上查询。

#### **3. CDN部署与动静分离架构 (v7.0新增)**

##### **3.1. 动静分离原则**
- **静态资源**: 包括但不限于前端构建产物(JS/CSS/字体/图标)、书籍封面、用户上传的图片等
- **动态内容**: API接口、用户数据、实时同步数据等

##### **3.2. 开发阶段动静分离实现**
```yaml
# docker-compose.dev.yml (开发环境)
version: '3.8'
services:
  # 开发阶段通过Nginx代理到前端Vite开发服务器(启用HMR)
  static-server:
    image: nginx:alpine
    volumes:
      - ./nginx/dev-proxy.conf:/etc/nginx/conf.d/default.conf
    ports:
      - "8080:80"
    depends_on:
      - api
    networks:
      - athena-network

  # API服务
  api:
    build: ./backend
    environment:
      - STATIC_BASE_URL=http://localhost:8080
    networks:
      - athena-network
```

> Nginx开发代理示例 (`./nginx/dev-proxy.conf`):
```nginx
server {
  listen 80;

  # 前端所有资源走Vite开发服务器(含HMR)
  location / {
    proxy_pass http://host.docker.internal:5173;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
  }

  # API通过容器网络代理到后端服务
  location /api/ {
    proxy_pass http://api:8000/;
    proxy_set_header Host $host;
  }
}
```

##### **3.3. 生产环境CDN架构**
```
用户请求 → CDN边缘节点 → 源站(静态资源/动态API)
                ↓
           静态资源缓存 → 直接返回
                ↓
           动态API请求 → 后端服务集群
```

##### **3.4. 静态资源缓存策略**
| 资源类型 | 缓存时间 | 缓存键 | 版本控制 |
|---|---|---|---|
| JS/CSS构建产物 | 1年 | 文件名哈希 | 构建时自动生成哈希文件名 |
| 字体文件 | 1年 | 文件名哈希 | 固定版本号 |
| 书籍封面 | 30天 | 文件ID+更新时间 | 文件修改时自动失效 |
| 用户上传图片 | 7天 | 文件ID+更新时间 | 文件修改时自动失效 |

##### **3.5. 动态内容缓存策略**
- **API响应缓存**: 使用Redis缓存频繁访问但不常变更的数据
- **CDN API缓存**: 仅缓存GET请求，缓存时间不超过5分钟
- **用户特定数据**: 不使用CDN缓存，仅使用应用层缓存

##### **3.6. 部署流程**
1. **构建阶段**: 前端构建生成带哈希的静态资源文件
2. **上传阶段**: 静态资源上传至对象存储(MinIO/S3)
3. **CDN配置**: 配置CDN源站指向对象存储
4. **API部署**: 动态API服务部署至服务器集群
5. **域名配置**: 静态资源使用独立域名(如static.athena.com)

##### **3.7. 开发规则**
- 所有静态资源引用必须使用绝对路径，以CDN域名为基础
- API请求必须使用相对路径，由前端代理或环境变量处理
- 开发环境模拟生产环境的动静分离架构
- 静态资源变更必须更新版本号或哈希值

---

### **第二章：核心功能模块详解 (P0 - MVP阶段)**

#### **2.1. 账户与认证**
-   **功能:** 支持微信、微软、苹果、Google的OAuth授权登录/注册；手动登录仅支持邮箱验证码（Magic Code，无密码、无手机号）。提供基于角色的权限控制(RBAC)。
-   **数据对应:** `users`, `oauth_accounts`, `roles`, `user_roles`, `refresh_tokens`, `user_sessions`, `email_login_codes` 表。
 -   **安全与RLS:** 登录成功后，服务层在进入任何数据库查询前执行 `SET LOCAL app.user_id` 与 `SET LOCAL app.role`；所有查询统一过滤 `deleted_at IS NULL`；PgBouncer使用会话池，确保事务内会话变量有效。

#### **2.2. 书籍管理与组织**
-   **功能:** 个人云端书库，支持无限层级的书架/文件夹分类，所有设备实时同步。
-   **战略聚焦:** **完美支持** EPUB, PDF, MOBI, AZW, AZW3, TXT, FB2, RTF 等主流格式。通过 `linuxserver/calibre` 自动转换为EPUB，以支持最佳阅读和AI功能。
-   **数据对应:** `books`, `shelves`, `book_shelves`, `book_processing_tasks` 表。

#### **2.3. 沉浸式阅读器与进度**
-   **功能:** 专注、流畅、可定制的阅读体验，精确同步阅读进度和累计阅读时长。
-   **数据对应:** `reading_progress` 表。

#### **2.4. 笔记、高亮与标签**
-   **功能:** 零摩擦的知识捕获，支持多彩高亮，笔记与高亮深度链接，支持多对多标签。
-   **数据对应:** `highlights`, `notes`, `tags`, `note_tags` 表。

#### **2.5. AI知识内化引擎**
-   **功能:** 产品的灵魂。实现与单本书、整个知识库的智能对话，并可保存对话记录。
-   **数据对应:** `vectors` (使用pgvector), `ai_conversations` 表。

#### **2.6. 云端同步与按需下载 (MVP核心功能)**
-   **功能:** **对标Apple Books**。新设备上，书籍卡片显示“Cloud 图标”，用户点击后下载到本地。下载后直接打开至上次阅读位置，实现无缝跨设备体验。
-   **数据对应:** `books` (`is_locally_available`字段), `user_sessions`, `reading_progress` 表。
-   **技术实现:**
    1.  前端 `BookCard` 组件根据 `books.is_locally_available` 字段决定显示封面还是 Cloud 图标。
    2.  用户点击 Cloud 图标，调用 `POST /api/v1/books/{book_id}/download` 接口。
    3.  后端验证权限，提供 SeaweedFS S3 的预签名下载URL（`boto3.generate_presigned_url`；可通过 `MINIO_PUBLIC_ENDPOINT` 重写外网域）。
    4.  前端开始下载，更新UI为下载进度条。下载完成后，将文件存入本地IndexedDB，并更新本地状态。
    5.  打开阅读器时，从 `reading_progress` 表拉取 `last_location` 和 `progress_percentage`，直接跳转。

---

### **第三章：后续功能规划 (P1 - V1.1阶段)**

#### **3.1. OCR增值服务**
-   **功能:** 识别扫描版PDF或图片型书籍，结果提供给关键词搜索和Markdown导出。
-   **数据对应:** `user_credits` (`ocr_credits`字段), `credit_transactions` 表。

#### **3.2. 国际化 与全球化支付**
-   **功能:** 支持多语言界面和多币种、区域化定价。
-   **数据对应:** `languages`, `translations`, `currencies`, `regional_prices` 表。

#### **3.3. 语音读书 (TTS) & 离线词典**
-   **功能:** 提供听书和免费划词翻译功能。
-   **数据对应:** `dict_history` 表。

#### **3.4. 智能复习 (SRS)**
-   **功能:** 将笔记和高亮通过间隔重复算法推送给用户复习。
-   **数据对应:** `srs_reviews` 表。

#### **3.5. 后台管理与运营**
-   **功能:** 提供用户管理、数据看板、功能开关、Prompt模板管理等。
-   **数据对应:** `feature_flags`, `user_feature_flags`, `ai_prompt_templates`, `audit_logs` 表。

-   **运营配置（新增）**
    - 定价规则：`pricing_rules`（Admin CRUD，弱ETag并发）。字段：`service_type/unit_type/unit_size/price_amount/currency/region/remark_template/is_active/version`。占位符：`{unit_size}` `{price_amount}` `{currency}` `{approx_tokens}`。
    - 系统设置：`system_settings` 键集合（示例）：
      - `wallet_exchange_rate`: 支持数值或JSON映射，例如 `{ "CNY":100, "USD":20000, "default":100 }`。
      - `free_ocr_pages`、`free_vector_chars`：全局免费额度回退键。
      - `membership_tiers`: 会员等级配置（FREE/PRO等），示例：`{ "FREE": { "free_ocr_pages":0, "free_vector_chars":0 }, "PRO": { "free_ocr_pages":100, "free_vector_chars":300000 } }`。
    - 服务商管理（抽屉式、可热插拔）：`service_providers`（`service_type/name/endpoint/config/is_active/priority/version`）。接口：
      - `GET /api/v1/admin/providers?service_type=` 列表与筛选
      - `POST /api/v1/admin/providers` 新增/更新（幂等）
      - `PATCH /api/v1/admin/providers/{id}` 并发控制更新
    - 会员等级管理：`users.membership_tier`（Admin可修改），前端 `GET /api/v1/profile/me` 返回会员等级。

---

### **第四章：商业模型实现 (V9.1 落地版)**

#### **4.1. 核心机制：The Trap & The Hook**
-   **免费同步，限制上传 (The Hook)**:
    -   **策略**: 多端同步完全免费，但新书上传受限。
    -   **阈值**: 免费用户限制 50 本书 或 1GB 存储空间（可配置）。
    -   **实现**: `POST /api/v1/books/upload_init` 接口前置 `require_upload_permission` 依赖。检查 `user_stats` 表的 `book_count` 和 `storage_used`。
-   **只读锁 (The Trap)**:
    -   **触发**: 当用户存储或数量超限（如会员过期导致配额回退）。
    -   **表现**: 现有书籍可读，但禁止一切写操作（笔记、高亮、书架修改）。
    -   **实现**: 所有写操作接口（`notes`, `highlights`, `shelves`, `books` update/delete）前置 `require_write_permission` 依赖。违规返回 `403 Forbidden`。

#### **4.2. OCR 引擎 V9.1**
-   **阶梯计费**:
    -   `<= 600` 页: 消耗 1 标准单位。
    -   `600 - 1000` 页: 消耗 2 标准单位。
    -   `1000 - 2000` 页: 消耗 3 标准单位。
    -   `> 2000` 页: 拒绝处理。
-   **扣费策略 (混合模式)**:
    1.  **免费额度**: 优先扣除 `users.free_ocr_usage` (Pro会员每月重置)。
    2.  **加油包/余额**: 免费额度耗尽后，扣除通用 Credits (目前实现为 **1 单位 = 100 Credits**)。
-   **优先级队列 (Celery)**:
    -   **P0 (Priority 9)**: Pro 会员 + 付费购额 (Add-on)。
    -   **P1 (Priority 7)**: Pro 会员 + 免费赠额。
    -   **P2 (Priority 5)**: Free 会员 + 付费购额。
    -   **P3 (Priority 1)**: Free 会员 + 试用/其他。
-   **并发控制**: 基于 Redis `ocr:active_jobs` 集合，全局限制 GPU 并发数（默认 1）。

#### **4.3. 裂变与增长 (Invites)**
-   **机制**: 用户生成唯一邀请码，新用户在“个人资料”页兑换。
-   **奖励**: 双向奖励（邀请人与被邀请人）。
    -   **存储**: +500MB (配置键 `invite_bonus_storage`)。
    -   **配额**: +5 本书 (配置键 `invite_bonus_books`)。
-   **数据**: 记录于 `invites` 表，实时更新 `user_stats.extra_storage_quota` 等字段。

#### **4.4. 支付与 IAP**
-   **策略**: Web 端使用 Stripe/WeChat Pay；移动端强制使用 Apple/Google IAP。
-   **实现**:
    -   `pricing_rules` 表增加 `platform` ('web'/'ios'/'android') 和 `sku_id` 字段。
    -   后端提供 `/api/v1/billing/iap/verify` 接口接收客户端收据，验证后发放权益。
    -   **苹果税**: App 端仅展示 IAP 价格（通常较 Web 端上浮 30%），严禁引导至 Web 支付。

#### **4.5. 任务调度**
-   **每日任务**: 扫描 `users.membership_expire_at`，过期用户降级为 FREE。
-   **每月任务**: 扫描 `users.monthly_gift_reset_at`，重置 Pro 会员 `free_ocr_usage` 并发放月度 Credits 赠礼。

---

### **第五章：数据库 Schema 变更 (V9.1)**

#### **5.1 新增表**
-   **`user_stats`**: 用户资源统计
    -   `user_id` (PK, FK users)
    -   `storage_used` (BIGINT): 已用存储字节
    -   `book_count` (INT): 已上传书籍数
    -   `invite_count` (INT): 已邀请人数
    -   `extra_storage_quota` (BIGINT): 奖励/购买的额外存储
    -   `extra_book_quota` (INT): 奖励/购买的额外书位
-   **`invites`**: 裂变记录
    -   `inviter_id`, `invitee_id`, `invite_code`, `status`, `reward_granted`

#### **5.2 字段扩展**
-   **`users`**:
    -   `membership_expire_at`: 会员过期时间
    -   `monthly_gift_reset_at`: 月度赠礼重置时间
    -   `free_ocr_usage`: 当月已用免费 OCR 单位
-   **`pricing_rules`**:
    -   `platform`: 'web', 'ios', 'android'
    -   `sku_id`: IAP 商品 ID
-   **`ocr_jobs`**:
    -   `page_count`: 书籍页数
    -   `deduction_strategy`: 'free_quota' 或 'addon_quota'
    -   `deduction_amount`: 扣除数量

---

### **第五章：AI协作与开发流程**

-   **工作流:** 严格遵循"需求定义 -> 契约设计 -> AI代码生成 -> 自动化测试 -> 人工审查"的闭环流程。
-   **代码质量:** 通过Black/Prettier/Mypy/Sentry进行格式化、类型检查和错误监控。
-   **安全:** 所有数据库查询必须严格过滤 `user_id` 和 `deleted_at IS NULL`。在数据库层面启用 **RLS（行级安全）**。
    - **强制依赖与封装（新增）**：
      - FastAPI 全局依赖/中间件：统一从JWT提取`sub`与`role`，在进入任何数据库查询前执行 `SET LOCAL app.user_id = :sub; SET LOCAL app.role = :role;`。
      - Celery 任务上下文：提供装饰器/上下文管理器，确保后台任务连接数据库时亦设置会话变量；避免漏设导致RLS失效。
      - 示例：
        ```python
        from contextlib import asynccontextmanager
        from sqlalchemy import text

        @asynccontextmanager
        async def db_session_with_rls(user_id: str, role: str):
            async with db.session() as session:
                await session.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
                await session.execute(text("SET LOCAL app.role = :role"), {"role": role})
                yield session

        @celery.task
        def reindex_user_data(user_id: str):
            async with db_session_with_rls(user_id, 'user') as session:
                # 任务逻辑...
                ...
        ```

#### **5.1. 契约测试机制 (v7.0新增)**

##### **5.1.1. 契约设计原则**
- **API优先**: 所有新功能必须先定义API契约，再进行前后端开发
- **版本化**: 所有API端点必须包含版本号 (如 `/api/v1/`)
- **向后兼容**: 除非重大版本更新，否则保持API向后兼容
- **文档驱动**: 使用OpenAPI 3.0规范定义所有API契约

##### **5.1.2. 契约测试框架**
- **前端**: 使用Jest + Supertest进行API契约测试
- **后端**: 使用Pact进行消费者驱动的契约测试
- **集成测试**: 使用Docker Compose搭建完整测试环境
- **性能测试**: 使用Artillery进行API性能基准测试

##### **5.1.3. 契约测试流程**
1. **契约定义**: 在`contracts/`目录下定义API契约文件
2. **消费者测试**: 前端编写消费者测试，验证API响应符合预期
3. **提供者验证**: 后端运行提供者测试，确保实现符合契约
4. **CI/CD集成**: 在CI/CD流程中强制执行契约测试
5. **发布验证**: 发布前验证所有契约测试通过

##### **5.1.4. 契约测试目录结构**
```
contracts/
├── api/
│   ├── v1/
│   │   ├── auth.yaml
│   │   ├── books.yaml
│   │   ├── notes.yaml
│   │   └── ai.yaml
│   └── schemas/
│       ├── user.json
│       ├── book.json
│       └── note.json
├── tests/
│   ├── consumers/
│   │   ├── frontend.test.js
│   │   └── mobile.test.js
│   └── providers/
│       ├── backend.test.py
│       └── services.test.py
└── pacts/
    ├── frontend-backend.json
    └── mobile-backend.json
```

##### **5.1.5. 强制校验规则**
- **代码提交**: 所有代码提交必须通过契约测试
- **合并请求**: 合并到主分支前必须更新契约并验证
- **发布流程**: 发布前必须验证所有消费者契约
- **监控告警**: 生产环境API变更触发告警机制

##### **5.1.6. 契约测试自动化**
- **预提交钩子**: 使用Husky在提交前运行契约测试
- **CI流水线**: 在GitHub Actions中设置多阶段契约测试
- **定期验证**: 每日自动运行完整契约测试套件
- **报告生成**: 自动生成契约测试报告并通知团队

---

### **第六章：API标准与契约 (v7.0新增)**

#### **6.1 命名与风格**
- **RESTful资源命名**: 使用名词复数，如`/users`, `/books`, `/notes`。
- **HTTP方法**: `GET`(查询) / `POST`(创建) / `PUT`(整体更新) / `PATCH`(部分更新) / `DELETE`(删除)。
- **路径规范**: 版本前缀`/api/v1/`；子资源`/books/{bookId}/notes`；动作用动词后缀避免，如`/auth/login`。
- **字段命名**: 后端统一`snake_case`；前端通过适配器转换为`camelCase`，此为强制规则。
  ```ts
  // 前端适配器示例
  export const toCamel = (obj: any): any => Array.isArray(obj)
    ? obj.map(toCamel)
    : obj && typeof obj === 'object'
      ? Object.fromEntries(Object.entries(obj).map(([k,v]) => [k.replace(/_([a-z])/g,(_,c)=>c.toUpperCase()), toCamel(v)]))
      : obj;
  ```

#### **6.2 请求/响应统一格式**
- **Headers**: `Authorization: Bearer <JWT>`；`X-Client-Request-Id: <uuid>`（用于追踪）。
- **认证**: 服务端从JWT解析`user_id`，请求体不重复传`user_id`。
- **成功响应**:
  ```json
  {
    "status": "success",
    "data": { "user_id": "...", "display_name": "..." },
    "requestId": "<uuid>"
  }
  ```
- **失败响应**:
  ```json
  {
    "status": "error",
    "code": "UNIQUE_VIOLATION",
    "message": "The provided email already exists.",
    "details": { "field": "email" },
    "requestId": "<uuid>"
  }
  ```

#### **6.3 分页 / 排序 / 过滤**
- **分页策略**: 统一采用`cursor-based`；参数：`limit`(默认20, 最大100)、`cursor`(可为空)。响应返回`next_cursor`、`has_more`。
- **排序**: `sort_by`与`sort_order`(`asc`/`desc`)；默认按`created_at desc`。
- **字段选择**: `fields=name,email,...`；仅返回指定字段以降流量。

#### **6.4 错误码规范**
- **分类**: `CLIENT_ERROR`, `SERVER_ERROR`, `AUTHENTICATION_ERROR`, `AUTHORIZATION_ERROR`, `RESOURCE_NOT_FOUND`, `VALIDATION_ERROR`, `RATE_LIMITED`, `UNIQUE_VIOLATION`, `PAYMENT_REQUIRED`。
- **映射示例**:
  - `AUTHENTICATION_ERROR`: 未携带或无效JWT。
  - `AUTHORIZATION_ERROR`: 无访问目标资源的权限。
  - `RESOURCE_NOT_FOUND`: 资源不存在或已删除。
  - `VALIDATION_ERROR`: 字段校验失败（详情包含具体字段）。
  - `RATE_LIMITED`: 触发限流，中间件或应用层返回。
  - `UNIQUE_VIOLATION`: 唯一约束冲突（如`users.email`）。
  - 全局异常：未捕获的异常统一返回HTTP 500，错误对象为 `{"status":"error","error":{"code":"internal_error"}}`（实现见 `api/app/main.py`）。

#### **6.5 版本控制策略**
- **URI版本**: `/api/v1/`，未来演进为`/api/v2/`。
- **向前兼容**: 旧版本保留至公告的弃用日期，返回`Deprecation: true`响应头提示。
- **迁移流程**: 发布公告 -> 提供迁移指南 -> 双运行窗口 -> 分阶段下线旧版。

#### **6.6 网关与限流（Traefik示例）**
```yaml
http:
  routers:
    api:
      rule: PathPrefix(`/api/`)
      service: api-service
      middlewares: [api-rate-limit]
  middlewares:
    api-rate-limit:
      rateLimit:
        average: 100   # 每分钟平均请求
        burst: 50      # 突发
        period: 1m
```

**CORS 策略（新增）**
- 允许来源：`https://app.youdomin.com` 与 `https://youdomin.com` 访问 `https://api.youdomin.com`。
- 允许方法/头：`GET/POST/PATCH/DELETE`；`Authorization`、`Idempotency-Key`、`If-Match`；预检缓存 `Access-Control-Max-Age`。
- 响应头：`Access-Control-Allow-Origin` 精确匹配；拒绝未知来源与私有网络请求。

#### **6.7 契约SSOT（OpenAPI 3.0）**
- 所有API以`swagger.yaml`为单一事实来源；开发从契约开始。
- 示例（摘录）:
```yaml
openapi: 3.0.0
info:
  title: Athena API
  version: 1.0.0
servers:
  - url: /api/v1
paths:
  /auth/login:
    post:
      summary: 用户登录
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email: { type: string }
                password: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
components:
  schemas:
    AuthResponse:
      type: object
      properties:
        status: { type: string, enum: [success] }
        data:
          type: object
          properties:
            access_token: { type: string }
            refresh_token: { type: string }
```

#### **6.8 代码生成与实现**
- **前端**: 使用`openapi-generator`生成TypeScript API客户端。
- **后端**: 使用`datamodel-code-generator`从OpenAPI生成Pydantic模型；路由以契约校验入参/出参。
- **Swagger UI**: 部署于`/docs`与`/redoc`，与契约文件同步。
 
##### **6.8.1 命令参考**
- **契约校验**: `npx @redocly/cli lint contracts/api/v1/swagger.yaml`
- **前端客户端生成**: `openapi-generator-cli generate -i contracts/api/v1/swagger.yaml -g typescript-fetch -o frontend/src/api`
- **后端模型生成**: `datamodel-codegen --input contracts/api/v1/swagger.yaml --output backend/app/schemas.py`
- **提供者契约测试（FastAPI）**: `pytest -k contract --maxfail=1`
- **消费者契约测试（Jest）**: `npm run test:contracts`
 - **实现一致性校验（新增）**: `fastapi-openapi-tester --app backend.main:app --spec contracts/api/v1/swagger.yaml`

#### **6.9 契约测试与CI/CD**
- **流水线强制**: 1) 契约校验 2) 代码生成 3) 消费者/提供者测试（Pact/Jest） 4) 单元/集成测试。
- **发布门禁**: 契约测试必须通过；版本变更需包含变更说明与弃用计划。
 - **一致性校验（新增）**: 对后端自动生成的OpenAPI与`contracts/`契约进行差异比对，防止实现漂移（工具：`fastapi-openapi-tester`或等效）。
 - **SQL迁移Lint（新增）**: 在CI中执行 `sqlfluff lint` 对迁移脚本进行风格与语法检查，并作为强制步骤。
 - **i18n 同步与反硬编码检查（新增）**:
   - 构建前执行 `pnpm i18n:sync`：从 MinIO/CDN 拉取最新翻译 JSON 到 `src/locales/`，对齐键集合（新增缺失键、移除孤儿键、保持排序）。
   - 在 lint 阶段执行 `pnpm i18n:no-hardcode`：检测 `src/**/*.{ts,tsx,astro}` 中硬编码的用户可见字符串，统一要求使用 `t("key")` 引用。
   - 在 PR 门禁中强制步骤：`pnpm i18n:sync && pnpm i18n:check && pnpm i18n:no-hardcode` 全部通过后方可合并。

#### **6.10 Authorization 与 Scopes（新增）**
- **JWT Claims 约定**：`sub`（用户ID）、`role`（如`user`/`admin`）、`scopes`（字符串数组，如`["books:read","notes:write"]`）。
- **Scope 命名规范**：资源 + 操作，示例：`books:read|write|delete`、`notes:read|write|delete`、`vectors:query`、`ai:query`。
- **API 访问校验**：
  - 路由中含资源ID（如`/books/{bookId}`）时，必须校验资源归属：`WHERE user_id = :jwt.sub`。
  - 仅当`scopes`包含相应操作时允许访问；不足则返回`AUTHORIZATION_ERROR`。
- **RLS（行级安全）策略**：
  ```sql
  -- 针对 books 表启用 RLS
  ALTER TABLE books ENABLE ROW LEVEL SECURITY;
  -- 通过会话变量 app.user_id 实现所有权约束
  CREATE POLICY books_owner_policy ON books
    USING (user_id = current_setting('app.user_id')::uuid)
    WITH CHECK (user_id = current_setting('app.user_id')::uuid);
  -- 连接建立后，由网关或服务层设置会话变量
  -- SET app.user_id = '<jwt.sub>'::uuid;
  ```
- **RBAC 与审计**：`role=admin`可访问受限资源，但所有跨用户读写必须写入 `audit_logs`；建议在管理接口返回 `Deprecation: true` 头以提示风险操作。

#### **6.11 幂等性（新增）**
- **请求头约定**：所有写操作（`POST/PUT/PATCH/DELETE`）强制要求携带 `Idempotency-Key: <uuid>`，有效期默认 24h。
- **服务端策略**：首次执行后持久化请求指纹与响应；相同 `Idempotency-Key` 的重复请求直接返回已存响应，避免重复执行。
- **落库建议**：参见数据库白皮书 `idempotency_keys` 表；字段：`key`、`request_hash`、`response_status`、`response_body`、`expires_at`（索引：`expires_at`）。

#### **6.12 WebSocket 标准与 Yjs 协同（新增）**
- **认证**：在 `Sec-WebSocket-Protocol` 传递子协议 `bearer,<JWT>` 或在初次消息中携带 `Authorization: Bearer <JWT>`；未授权连接直接关闭，编码 `4401`。
- **消息信封（Envelope）**：统一结构，便于追踪与重试。
  ```json
  {
    "id": "uuid",
    "type": "subscribe|patch|ack|error|ping|pong",
    "channel": "ai_stream|doc:<docId>",
    "ts": 1730000000000,
    "payload": { "delta": "..." },
    "trace_id": "uuid"
  }
  ```
- **心跳与关闭码**：客户端每 30s 发送 `ping`；服务端返回 `pong`。关闭码：`4401` 未授权、`4009` 超时、`4000` 通用错误。
- **错误与重试**：分类 `AUTH_ERROR`/`PERMISSION_DENIED`/`RATE_LIMITED`/`CHANNEL_NOT_FOUND`/`BAD_FORMAT`；客户端对网络类错误指数退避重试，不重试权限类错误。
- **Yjs 协同约定**：频道命名 `doc:<docId>`；仅文档所有者（`user_id`）及受邀协作者可订阅与写入。变更形成快照并落 `note_versions`；关键操作写入 `audit_logs`。

---

## **《Tags & Search 垂直切片（标签管理与全局搜索）可执行规范（新增）》**

### 1. 数据库 DDL / RLS / 索引（v1）
- 既有：`tags` 与 `note_tags` 已定义，`tags.UNIQUE(user_id, name)` 已存在。
- 新增：`highlight_tags`（多对多关联）。
  ```sql
  CREATE TABLE IF NOT EXISTS highlight_tags (
    highlight_id UUID NOT NULL REFERENCES highlights(id) ON DELETE CASCADE,
    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (highlight_id, tag_id)
  );

  -- 索引建议：加速按用户与书籍聚合检索
  CREATE INDEX IF NOT EXISTS idx_highlight_tags_tag ON highlight_tags(tag_id);
  CREATE INDEX IF NOT EXISTS idx_note_tags_tag ON note_tags(tag_id);

  -- RLS：按用户隔离（依赖上游 highlights/notes/tags 的RLS）
  ALTER TABLE tags ENABLE ROW LEVEL SECURITY;
  CREATE POLICY tags_select ON tags FOR SELECT USING (user_id = current_setting('app.user_id')::uuid);
  CREATE POLICY tags_insert ON tags FOR INSERT WITH CHECK (user_id = current_setting('app.user_id')::uuid);
  CREATE POLICY tags_update ON tags FOR UPDATE USING (user_id = current_setting('app.user_id')::uuid);
  CREATE POLICY tags_delete ON tags FOR DELETE USING (user_id = current_setting('app.user_id')::uuid);
  -- 说明：`note_tags` 与 `highlight_tags` 依附父资源的RLS（notes/highlights/tags），服务层需确保三者同属当前用户。
  ```
- 幂等：标签关联写操作采用 `INSERT ... ON CONFLICT DO NOTHING`；同时支持 `Idempotency-Key` 记录于 `idempotency_keys`。
  -- 强化：零信任数据库级约束（新增）
  ```sql
  ALTER TABLE note_tags ENABLE ROW LEVEL SECURITY;
  CREATE POLICY note_tags_owner_policy ON note_tags
    USING (
      EXISTS (SELECT 1 FROM notes WHERE id = note_id AND user_id = current_setting('app.user_id')::uuid)
      AND
      EXISTS (SELECT 1 FROM tags WHERE id = tag_id AND user_id = current_setting('app.user_id')::uuid)
    );

  ALTER TABLE highlight_tags ENABLE ROW LEVEL SECURITY;
  CREATE POLICY highlight_tags_owner_policy ON highlight_tags
    USING (
      EXISTS (SELECT 1 FROM highlights WHERE id = highlight_id AND user_id = current_setting('app.user_id')::uuid)
      AND
      EXISTS (SELECT 1 FROM tags WHERE id = tag_id AND user_id = current_setting('app.user_id')::uuid)
    );
  ```
  - 幂等：标签关联写操作采用 `INSERT ... ON CONFLICT DO NOTHING`；同时支持 `Idempotency-Key` 记录于 `idempotency_keys`。

### 2. 搜索索引与同步（OpenSearch + Postgres）
- 索引：
  - `opensearch.notes`：文档字段 `id,user_id,book_id,title,content,tag_ids,created_at`；启用高亮（`content`）。
  - `opensearch.highlights`：字段 `id,user_id,book_id,text_content,color,chapter,tag_ids,created_at`；启用高亮（`text_content`）。
- 同步：
  - 写通道：`notes`/`highlights` 创建或更新后，异步写入OpenSearch（Celery任务）；删除标记 `deleted_at` 时从OpenSearch删除或打`is_deleted`过滤。
  - 失效：编辑笔记/高亮触发向量与缓存失效（与AI章节一致），同时更新OpenSearch文档。
- 回退：若 OpenSearch 不可用，当前后端回退为 Postgres 简单检索（`ILIKE`）；后续可扩展为 `tsvector` 高级检索列（如 `notes.content_tsvector`、`highlights.text_content_tsvector`）。
- 回退：若 OpenSearch 不可用，当前后端回退为 Postgres 简单检索（`ILIKE`）；后续可扩展为 `tsvector` 高级检索列（如 `notes.content_tsvector`、`highlights.text_content_tsvector`）。
 - 混合检索（新增）：同时执行关键词检索（OpenSearch）与向量ANN（pgvector），依据查询意图与置信度融合排序；对于包含特定术语的查询优先关键词结果。
 - 结构化元数据注入（新增）：构建Prompt时，将 `tags`、`book.title`、`book.author`、`highlight.color` 等元数据与文本片段一并注入，提升上下文相关性与答案稳定性。
  - Prompt 示例（新增）：
  ```text
  --- 资料 ---
  [source_id_1: 来自书籍《原则》第3章]
  (书籍片段文本...)
  关联标签: #决策模型, #生活哲学

  [source_id_2: 来自我的笔记“关于英雄主义”]
  (笔记内容...)
  关联标签: #历史, #人物传记

  任务：基于以上资料与标签，回答用户问题；必要时解释标签如何帮助定位相关论据。
  ```

- 全量重建/同步（新增）：
  ```python
  @shared_task
  def reindex_user_data(user_id: str):
      set_local_app_user(user_id)
      notes = db.fetch_all(sa.text(
          "SELECT id, user_id, book_id, title, content_markdown, created_at FROM notes WHERE user_id = :uid AND deleted_at IS NULL"
      ), { 'uid': user_id })
      opensearch.bulk_index('notes', [
          { 'id': n.id, 'user_id': user_id, 'book_id': n.book_id, 'title': n.title, 'content': n.content_markdown, 'created_at': n.created_at }
          for n in notes
      ])
      highs = db.fetch_all(sa.text(
          "SELECT id, user_id, book_id, text_content, chapter, color, created_at FROM highlights WHERE user_id = :uid AND deleted_at IS NULL"
      ), { 'uid': user_id })
      opensearch.bulk_index('highlights', [
          { 'id': h.id, 'user_id': user_id, 'book_id': h.book_id, 'text_content': h.text_content, 'chapter': h.chapter, 'color': h.color, 'created_at': h.created_at }
          for h in highs
      ])
      # 可选：清理索引中当前用户的陈旧文档
      opensearch.purge_stale('notes', user_id, [n.id for n in notes])
      opensearch.purge_stale('highlights', user_id, [h.id for h in highs])
  ```

### 3. REST API 契约（OpenAPI 3.0）
- 文件：`contracts/api/v1/tags.yaml` 与 `contracts/api/v1/search.yaml`。

```yaml
openapi: 3.0.3
info: { title: Athena Tags & Search, version: 1.0.0 }
paths:
  /api/v1/tags:
    get:
      summary: 列出当前用户所有标签
      responses:
        '200': { description: OK }
    post:
      summary: 创建标签
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [name]
              properties:
                name: { type: string, maxLength: 100 }
      responses:
        '201': { description: Created }

  /api/v1/tags/{id}:
    patch:
      summary: 重命名标签
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [name]
              properties:
                name: { type: string, maxLength: 100 }
      responses:
        '200': { description: OK }
        '409': { description: UNIQUE_VIOLATION }
    delete:
      summary: 软删除标签
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      responses:
        '204': { description: No Content }

  /api/v1/notes/{noteId}/tags/{tagId}:
    post:
      summary: 为笔记添加标签（幂等）
      responses: { '204': { description: No Content } }
    delete:
      summary: 移除笔记标签（幂等）
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses: { '204': { description: No Content } }

  /api/v1/highlights/{highlightId}/tags/{tagId}:
    post:
      summary: 为高亮添加标签（幂等）
      responses: { '204': { description: No Content } }
    delete:
      summary: 移除高亮标签（幂等）
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses: { '204': { description: No Content } }

  /api/v1/search:
    get:
      summary: 全局搜索（Notes/Highlights/Books），支持 OpenSearch 或 Postgres 回退（`ILIKE`）
      parameters:
        - in: query
          name: q
          schema: { type: string }
        - in: query
          name: types
          schema: { type: array, items: { type: string, enum: [note, highlight] } }
        - in: query
          name: tag_ids
          schema: { type: array, items: { type: string, format: uuid } }
        - in: query
          name: book_id
          schema: { type: string, format: uuid }
        - in: query
          name: limit
          schema: { type: integer, default: 20, maximum: 100 }
        - in: query
          name: cursor
          schema: { type: string }
      responses:
        '200':
          description: OK
          headers:
            X-Search-Engine: { schema: { type: string, enum: [elasticsearch, postgres-tsvector] } }
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items:
                      type: object
                      properties:
                        type: { type: string, enum: [note, highlight] }
                        id: { type: string, format: uuid }
                        book_id: { type: string, format: uuid }
                        title: { type: string }
                        snippet: { type: string, description: "可能包含HTML高亮标签（如<em>），前端需安全渲染（如 dangerouslySetInnerHTML）。" }
                        score: { type: number }
                        tag_ids:
                          type: array
                          items: { type: string, format: uuid }
                  next_cursor: { type: string }
                  has_more: { type: boolean }
```

### 4. 后端逻辑伪代码（FastAPI/SQLAlchemy/OpenSearch）
```python
async def add_tag_to_note(user_id, note_id, tag_id):
    set_local_app_user(user_id)
    ensure_ownership(note_id, tag_id)
    await db.execute(sa.text(
        "INSERT INTO note_tags(note_id, tag_id) VALUES (:n,:t) ON CONFLICT DO NOTHING"
    ), { 'n': note_id, 't': tag_id })
    return Response(status_code=204)

async def add_tag_to_highlight(user_id, highlight_id, tag_id):
    set_local_app_user(user_id)
    ensure_ownership_highlight(highlight_id, tag_id)
    await db.execute(sa.text(
        "INSERT INTO highlight_tags(highlight_id, tag_id) VALUES (:h,:t) ON CONFLICT DO NOTHING"
    ), { 'h': highlight_id, 't': tag_id })
    return Response(status_code=204)

async def global_search(user_id, q, filters, limit, cursor):
    set_local_app_user(user_id)
    if opensearch_available():
        res = await os_search(user_id, q, filters, limit, cursor)
        engine = 'opensearch'
    else:
        res = await pg_search(user_id, q, filters, limit, cursor)
        engine = 'postgres'
    return with_headers(res, { 'X-Search-Engine': engine })

async def os_search(user_id, q, filters, limit, cursor):
    should = []
    if 'note' in filters.types:
        should.append({ 'index': 'notes', 'query': build_os_query(q, user_id, filters) })
    if 'highlight' in filters.types:
        should.append({ 'index': 'highlights', 'query': build_os_query(q, user_id, filters) })
    hits = await opensearch.multi_search(should, limit, cursor)
    return normalize_hits(hits)

async def pg_search(user_id, q, filters, limit, cursor):
    items = []
    if 'note' in filters.types:
        items += await db.fetch_all(sa.text(
            "SELECT id, book_id, title, ts_headline('simple', content_markdown, plainto_tsquery(:q)) AS snippet, "
            "ts_rank(content_tsvector, plainto_tsquery(:q)) AS score FROM notes "
            "WHERE user_id = :uid AND deleted_at IS NULL"
        ), { 'q': q, 'uid': user_id }) )
    if 'highlight' in filters.types:
        items += await db.fetch_all(sa.text(
            "SELECT id, book_id, chapter AS title, ts_headline('simple', text_content, plainto_tsquery(:q)) AS snippet, "
            "ts_rank(text_content_tsvector, plainto_tsquery(:q)) AS score FROM highlights "
            "WHERE user_id = :uid AND deleted_at IS NULL AND text_content_tsvector @@ plainto_tsquery(:q)"
        ), { 'q': q, 'uid': user_id }) )
    items = apply_filters(items, filters)
    return paginate_and_cursor(items, limit, cursor)
```

### 5. 前端契约与交互
- 组件：
  - `TagPickerProps`: `{ selectedTagIds: string[]; onChange(tagIds: string[]): void; createTag(name: string): Promise<void>; }`
  - `GlobalSearchPanelProps`: `{ q: string; onSearch(q): void; filters: { types: ('note'|'highlight')[]; tagIds?: string[]; bookId?: string }; results: Array<Item>; loading: boolean }`
- 交互：
  - 标签选择器支持创建、选择、移除；重命名冲突返回 `409` 并提示。
  - 全局搜索显示来源类型标识与高亮片段；支持按标签/类型/书籍过滤与分页。
  - 统一空态与错误提示；OpenSearch不可用时提示“已回退至基础搜索”。

### 6. 合同测试与 E2E
- 契约测试：
  - 标签：`POST /tags` 幂等键强制校验与唯一约束（重名返回 `409`）；`PATCH /tags/{id}` 通过 `If-Match` 并发校验（冲突返回 `409`，成功返回新的 `ETag`）；`DELETE` 幂等键强制、软删除。
  - 关联：笔记/高亮添加/移除标签幂等（重复添加/移除返回 `204`）。
  - 搜索：查询、过滤（tags/types/book_id）、分页与高亮；返回头 `X-Search-Engine` 正确；`sort_by` 支持 `relevance/recency` 并按预期排序。
- E2E：
  - 用户创建标签→给笔记与高亮打标签→全局搜索按标签过滤命中→点击结果跳转阅读器。
  - OpenSearch中断回退：关闭OpenSearch后搜索仍可返回基础结果，UI提示回退状态。

### 7. CI Gate
- OpenAPI 契约校验（`tags.yaml`、`search.yaml`）。
- 迁移脚本校验：`highlight_tags` 创建与索引；RLS策略存在并生效。
- 覆盖率：总 ≥ 85%，改动 ≥ 80%。
- 冒烟用例：标签创建/重命名、关联幂等、搜索回退与过滤。

—— 本切片使 Notes/Highlights 通过标签互联，并激活全局检索能力；实现与既有 RLS、幂等、分页与错误码规范一致。

## **《Admin Panel 垂直切片（后台管理与运营）可执行规范（新增）》**

### 1. 数据库 DDL / RLS / 索引
- 既有：`roles`, `user_roles`（RBAC），`audit_logs`（审计），`feature_flags`, `user_feature_flags`, `ai_prompt_templates`（提示模板）。
- 目的：提供管理员对用户、功能开关、AI模板与审计日志的全栈管理能力，严格遵循零信任与可审计。

```sql
-- feature_flags（全局特性开关，管理员维护）
CREATE TABLE IF NOT EXISTS feature_flags (
  key VARCHAR(100) PRIMARY KEY,
  description TEXT,
  enabled_by_default BOOLEAN NOT NULL DEFAULT false,
  rollout_percentage INTEGER NOT NULL DEFAULT 100 CHECK (rollout_percentage BETWEEN 0 AND 100),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ
);
CREATE INDEX IF NOT EXISTS idx_feature_flags_deleted ON feature_flags(deleted_at);

-- user_feature_flags（用户层覆盖）
CREATE TABLE IF NOT EXISTS user_feature_flags (
  user_id UUID NOT NULL,
  flag_key VARCHAR(100) NOT NULL REFERENCES feature_flags(key) ON DELETE CASCADE,
  enabled BOOLEAN NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, flag_key)
);
CREATE INDEX IF NOT EXISTS idx_user_feature_flags_user ON user_feature_flags(user_id);

-- ai_prompt_templates（AI提示模板，支持版本化与软删）
CREATE TABLE IF NOT EXISTS ai_prompt_templates (
  id UUID PRIMARY KEY,
  name VARCHAR(120) NOT NULL,
  type VARCHAR(40) NOT NULL CHECK (type IN ('chat','summarize','explain','search')),
  template TEXT NOT NULL,
  variables JSONB,
  version INTEGER NOT NULL DEFAULT 1,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_by UUID NOT NULL REFERENCES users(id),
  updated_by UUID NOT NULL REFERENCES users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ
);
CREATE UNIQUE INDEX IF NOT EXISTS uniq_prompt_name_active ON ai_prompt_templates(name) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_prompt_deleted ON ai_prompt_templates(deleted_at);

-- audit_logs（审计日志 - 仅管理员查询）
CREATE TABLE IF NOT EXISTS audit_logs (
  id BIGSERIAL PRIMARY KEY,
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  actor_user_id UUID NOT NULL,
  action VARCHAR(80) NOT NULL,
  target_type VARCHAR(40) NOT NULL,
  target_id UUID,
  request_id UUID,
  details JSONB,
  INDEX (ts DESC)
);
CREATE INDEX IF NOT EXISTS idx_audit_actor ON audit_logs(actor_user_id);
CREATE INDEX IF NOT EXISTS idx_audit_target ON audit_logs(target_type, target_id);
CREATE INDEX IF NOT EXISTS idx_audit_req ON audit_logs(request_id);

-- RLS 策略（统一会话变量）：
-- 所有请求在数据库会话设置：SET LOCAL app.user_id = :jwt.sub; SET LOCAL app.role = :jwt.role;
-- 强制 RLS：对相关表启用并保持 FORCE ROW LEVEL SECURITY（若已启用则略过）。

ALTER TABLE feature_flags ENABLE ROW LEVEL SECURITY;
CREATE POLICY feature_flags_admin_read ON feature_flags FOR SELECT USING (current_setting('app.role', true) = 'admin');
CREATE POLICY feature_flags_admin_write ON feature_flags FOR INSERT, UPDATE, DELETE USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');

ALTER TABLE user_feature_flags ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_feature_flags_admin ON user_feature_flags FOR ALL USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');

ALTER TABLE ai_prompt_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY prompt_admin ON ai_prompt_templates FOR ALL USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');

ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY audit_admin_read ON audit_logs FOR SELECT USING (current_setting('app.role', true) = 'admin');
-- 注：普通用户不直接查询 audit_logs；审计由后台统一呈现。
```

### 2. REST API 契约（OpenAPI 3.0）
- 文件：`contracts/api/v1/admin.yaml`

```yaml
openapi: 3.0.3
info: { title: Athena Admin API, version: 1.0.0 }
paths:
  /api/v1/admin/users:
    get:
      summary: 列出用户（过滤与分页）
      parameters:
        - in: query
          name: q
          schema: { type: string, description: 按邮箱/名称模糊 }
        - in: query
          name: role
          schema: { type: string, enum: [user, admin] }
        - in: query
          name: limit
          schema: { type: integer, default: 20, maximum: 100 }
        - in: query
          name: cursor
          schema: { type: string }
      responses:
        '200': { description: OK }

  /api/v1/admin/users/{id}:
    get:
      summary: 获取用户详情
      responses: { '200': { description: OK }, '404': { description: Not Found } }

  /api/v1/admin/users/{id}/roles:
    patch:
      summary: 更新用户角色（幂等）
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                roles: { type: array, items: { type: string, enum: [user, admin] } }
      responses: { '204': { description: No Content } }

  /api/v1/admin/feature-flags:
    get: { summary: 列出所有特性开关, responses: { '200': { description: OK } } }
    post:
      summary: 创建特性开关
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [key]
              properties:
                key: { type: string }
                description: { type: string }
                enabled_by_default: { type: boolean }
                rollout_percentage: { type: integer, minimum: 0, maximum: 100 }
      responses: { '201': { description: Created }, '409': { description: Conflict } }

  /api/v1/admin/feature-flags/{key}:
    patch:
      summary: 更新特性开关
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                description: { type: string }
                enabled_by_default: { type: boolean }
                rollout_percentage: { type: integer, minimum: 0, maximum: 100 }
      responses: { '200': { description: OK } }
    delete:
      summary: 软删除
      responses: { '204': { description: No Content } }

  /api/v1/admin/users/{id}/feature-flags/{key}:
    put: { summary: 为用户设置开关, responses: { '204': { description: No Content } } }
    delete: { summary: 移除用户开关, responses: { '204': { description: No Content } } }

  /api/v1/admin/prompt-templates:
    get: { summary: 列表, responses: { '200': { description: OK } } }
    post:
      summary: 创建模板
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [name, type, template]
              properties:
                name: { type: string }
                type: { type: string, enum: [chat, summarize, explain, search] }
                template: { type: string }
                variables: { type: object }
      responses: { '201': { description: Created }, '409': { description: Conflict } }

  /api/v1/admin/prompt-templates/{id}:
    patch:
      summary: 更新模板（乐观并发）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                template: { type: string }
                variables: { type: object }
                is_active: { type: boolean }
      responses: { '200': { description: OK }, '409': { description: VERSION_CONFLICT } }
    delete:
      summary: 软删除
      responses: { '204': { description: No Content } }

  /api/v1/admin/audit-logs:
    get:
      summary: 查询审计日志（过滤）
      parameters:
        - in: query
          name: actor_user_id
          schema: { type: string, format: uuid }
        - in: query
          name: target_type
          schema: { type: string }
        - in: query
          name: action
          schema: { type: string }
        - in: query
          name: from
          schema: { type: string, format: date-time }
        - in: query
          name: to
          schema: { type: string, format: date-time }
      responses: { '200': { description: OK } }

  /api/v1/admin/metrics:
    get:
      summary: 运营看板指标
      responses: { '200': { description: OK } }

  /api/v1/admin/tasks/reindex/{userId}:
    post:
      summary: 触发单用户全量重建索引
      responses: { '202': { description: Accepted } }

  /api/v1/admin/ai-models:
    get: { summary: 列出 AI 模型，responses: { '200': { description: OK } } }
    post:
      summary: 创建 AI 模型
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [model_id]
              properties:
                model_id: { type: string }
                provider: { type: string }
                pricing_usd: { type: number }
                is_active: { type: boolean }
      responses: { '201': { description: Created } }
  /api/v1/admin/ai-models/{id}:
    patch:
      summary: 更新 AI 模型（乐观并发）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                is_active: { type: boolean }
                pricing_usd: { type: number }
      responses: { '200': { description: OK, headers: { ETag: { schema: { type: string } } } }, '409': { description: VERSION_CONFLICT } }
    delete:
      summary: 软删除
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses: { '204': { description: No Content } }

  /api/v1/admin/system-settings:
    get: { summary: 获取系统设置键值对, responses: { '200': { description: OK } } }
    patch:
      summary: 批量更新系统设置（乐观并发）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema: { type: object, additionalProperties: { type: string } }
      responses: { '200': { description: OK, headers: { ETag: { schema: { type: string } } } }, '409': { description: VERSION_CONFLICT } }

  /api/v1/admin/currencies:
    get: { summary: 列出汇率, responses: { '200': { description: OK } } }
    post:
      summary: 新增币种或汇率
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [code, rate_to_base]
              properties:
                code: { type: string }
                rate_to_base: { type: number }
      responses: { '201': { description: Created } }
  /api/v1/admin/currencies/{code}:
    patch:
      summary: 更新汇率（乐观并发）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                rate_to_base: { type: number }
      responses: { '200': { description: OK, headers: { ETag: { schema: { type: string } } } }, '409': { description: VERSION_CONFLICT } }
    delete:
      summary: 禁用或软删除币种
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses: { '204': { description: No Content } }

  /api/v1/admin/payment-gateways:
    get: { summary: 列出支付网关, responses: { '200': { description: OK } } }
    post:
      summary: 新增支付网关
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [provider_id, friendly_name]
              properties:
                provider_id: { type: string }
                friendly_name: { type: string }
                is_globally_active: { type: boolean }
                is_active: { type: boolean }
                weight: { type: integer }
                config: { type: object }
      responses: { '201': { description: Created } }
  /api/v1/admin/payment-gateways/{id}:
    patch:
      summary: 更新支付网关（乐观并发）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                is_globally_active: { type: boolean }
                is_active: { type: boolean }
                weight: { type: integer }
                config: { type: object }
      responses: { '200': { description: OK, headers: { ETag: { schema: { type: string } } } }, '409': { description: VERSION_CONFLICT } }
    delete:
      summary: 软删除支付网关
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses: { '204': { description: No Content } }

  /api/v1/admin/tasks/dlq:
    get:
      summary: 查看死信队列
      responses: { '200': { description: OK } }
  /api/v1/admin/tasks/dlq/{taskId}/retry:
    post:
      summary: 重试失败任务
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses: { '202': { description: Accepted } }
```

### 3. 后端逻辑伪代码（FastAPI/SQLAlchemy）
```python
def require_admin(scopes: list[str]):
    claims = parse_jwt()
    if claims.role != 'admin':
        raise AuthorizationError('ADMIN_ONLY')
    set_local_app_user(claims.sub)
    set_local_app_role('admin')  # 供RLS策略判断
    ensure_scopes(claims.scopes, scopes)

async def list_users(q: str|None, role: str|None, limit: int, cursor: str|None):
    require_admin(['users:read'])
    ql = sa.select(users)
    if q: ql = ql.where((users.c.email.ilike(f'%{q}%')) | (users.c.display_name.ilike(f'%{q}%')))
    if role: ql = ql.join(user_roles, user_roles.c.user_id == users.c.id).where(user_roles.c.role == role)
    return paginate( await db.fetch_all(ql), limit, cursor )

async def update_user_roles(user_id: UUID, roles_in: list[str]):
    require_admin(['users:write'])
    await db.execute(sa.text("DELETE FROM user_roles WHERE user_id = :u"), { 'u': user_id })
    for r in roles_in:
        await db.execute(sa.text("INSERT INTO user_roles(user_id, role) VALUES (:u,:r) ON CONFLICT DO NOTHING"), { 'u': user_id, 'r': r })
    record_audit('UPDATE_ROLES', target_type='user', target_id=user_id, details={'roles': roles_in})
    return Response(status_code=204)

async def list_feature_flags():
    require_admin(['flags:read'])
    return await db.fetch_all(sa.text("SELECT * FROM feature_flags WHERE deleted_at IS NULL"))

async def create_flag(payload):
    require_admin(['flags:write'])
    await db.execute(sa.text("INSERT INTO feature_flags(key, description, enabled_by_default, rollout_percentage) VALUES (:k,:d,:e,:p)"), payload)
    record_audit('CREATE_FLAG', 'feature_flag', payload['key'], payload)
    return Response(status_code=201)

async def set_user_flag(user_id, key, enabled):
    require_admin(['flags:write'])
    await db.execute(sa.text("INSERT INTO user_feature_flags(user_id, flag_key, enabled) VALUES (:u,:k,:e) ON CONFLICT (user_id,flag_key) DO UPDATE SET enabled = EXCLUDED.enabled"), { 'u': user_id, 'k': key, 'e': enabled })
    record_audit('SET_USER_FLAG', 'feature_flag', key, {'user_id': user_id, 'enabled': enabled})
    return Response(status_code=204)

async def create_prompt(payload):
    require_admin(['prompts:write'])
    await db.execute(sa.text("INSERT INTO ai_prompt_templates(id,name,type,template,variables,created_by,updated_by) VALUES (:id,:name,:type,:template,:variables,:by,:by)"), payload)
    record_audit('CREATE_PROMPT', 'prompt', payload['id'], payload)
    return Response(status_code=201)

async def update_prompt(id, payload, if_match):
    require_admin(['prompts:write'])
    tpl = await db.fetch_one(sa.text("SELECT version FROM ai_prompt_templates WHERE id = :id AND deleted_at IS NULL"), { 'id': id })
    if not tpl or str(tpl.version) != if_match: raise PreconditionFailed()
    await db.execute(sa.text("UPDATE ai_prompt_templates SET template = :t, variables = :v, is_active = COALESCE(:a, is_active), version = version + 1, updated_at = now() WHERE id = :id"), { 'id': id, **payload })
    record_audit('UPDATE_PROMPT', 'prompt', id, payload)
    return Response(status_code=200)

async def query_audit(filters):
    require_admin(['audit:read'])
    ql = sa.select(audit_logs)
    # 绑定过滤条件...
    return await db.fetch_all(ql)

async def metrics():
    require_admin(['metrics:read'])
    return {
        'users_total': await db.scalar(sa.text("SELECT COUNT(*) FROM users")),
        'books_total': await db.scalar(sa.text("SELECT COUNT(*) FROM books")),
        'notes_total': await db.scalar(sa.text("SELECT COUNT(*) FROM notes WHERE deleted_at IS NULL")),
        'highlights_total': await db.scalar(sa.text("SELECT COUNT(*) FROM highlights WHERE deleted_at IS NULL")),
        'active_users_7d': await db.scalar(sa.text("SELECT COUNT(DISTINCT user_id) FROM user_sessions WHERE last_seen >= now() - interval '7 days'"))
    }

async def trigger_reindex(user_id):
    require_admin(['tasks:write'])
    celery.enqueue('reindex_user_data', { 'user_id': user_id })
    record_audit('REINDEX_USER', 'user', user_id, {})
    return Response(status_code=202)

def record_audit(action, target_type, target_id, details):
    db.execute(sa.text("INSERT INTO audit_logs(actor_user_id, action, target_type, target_id, request_id, details) VALUES (:actor,:action,:tt,:tid,:rid,:details)"), {
        'actor': current_user_id(), 'action': action, 'tt': target_type, 'tid': target_id, 'rid': current_request_id(), 'details': json.dumps(details)
    })
```

### 4. 前端契约与交互
- 入口与布局：`AdminLayout`（左侧导航：用户、开关、模板、审计、指标、AI模型管理、商业与定价设置、支付网关管理、任务运维、国际化管理）。
- 组件：
  - `UserList`: `{ q, role, onFilterChange, data, loading }`
  - `UserDetail`: `{ user, roles, onUpdateRoles }`
  - `FeatureFlagManager`: `{ flags, onCreate, onUpdate, onDelete, userOverrides }`
  - `PromptTemplateEditor`: `{ templates, onCreate, onUpdate, onDelete }`（支持`If-Match`并发校验）
  - `AuditLogViewer`: `{ filters, logs, loading }`
  - `MetricsDashboard`: `{ metrics, loading }`
  - `AIModelsManager`: `{ models, onCreate, onToggle, onUpdatePricing }`
  - `CommercialSettingsForm`: `{ settings, onSave }`
  - `CurrenciesTable`: `{ currencies, onCreate, onUpdate, onDelete }`
  - `PaymentGatewaysTable`: `{ gateways, onCreate, onUpdate, onDelete }`
  - `DLQViewer`: `{ items, onRetry }`
  - `TranslationsManager`: `{ items, view, filters, onSearch, onBulkUpsert, onPublish }`
  - `LanguagesManager`: `{ items, onCreate, onPatch, onDelete }`
- 交互：
  - 仅 `role=admin` 可见；路由进入即校验 JWT 的 `role` 与 `scopes`。
  - 写操作全部记录 `audit_logs`；变更结果在列表页即时刷新（乐观更新并回滚冲突）。
  - 模板编辑使用 `ETag/If-Match`；冲突返回 `409`，提示“请刷新后重试”。
  - AI模型管理：切换 `is_active` 与价格；If-Match 冲突提示并回滚；预览前端可见性。
  - 商业与定价：编辑 `ai_service_fee_percentage`、`usd_to_credit_rate`、`ai_proxy_url` 等；提交后返回新的 `ETag`。
  - 支付网关：展示掩码配置；编辑时需确认；总开关/单开关与权重即时生效；遇冲突则提示。
  - 任务运维：浏览 DLQ 并重试；重试后任务入队并展示审计记录链接。
  - 数据主体请求（GDPR/CCPA）：支持导出与删除申请的受理与执行；日志去标识化策略与数据分类保留期在“系统设置”中配置并受审计约束。
  - 国际化管理：翻译工作台支持按键/按语言视图；批量 UPSERT 需携带 `Idempotency-Key`；发布按钮触发 `POST /api/v1/admin/i18n/publish` 并显示作业状态。

### 5. 合同测试与 E2E
- 契约测试：
  - 鉴权：无 `admin` 角色访问返回 `AUTHORIZATION_ERROR`。
  - 用户：列表过滤、角色更新幂等。
  - 开关：创建/更新/删除，用户覆盖 PUT/DELETE。
  - 模板：创建与并发更新（`If-Match`），软删与列表过滤。
  - AI模型：创建/更新 is_active 与价格；并发冲突返回 `409`；幂等键重复提交返回同响应。
  - 系统设置：If-Match 不匹配返回 `409`；ETag 更新链路正确。
  - 汇率：新增/更新/禁用；列表筛选与分页。
  - 支付网关：加密字段不回传原文；总开关与单开关控制可用性；权重变更影响选择策略。
  - DLQ：列表获取与重试；重试后任务入队并生成审计记录。
  - 审计：操作后存在审计记录（字段完整，含 `request_id`）。
  - 任务：`/tasks/reindex/{userId}` 返回 `202`，任务入队。
- E2E：
  - 管理员开启某开关→目标用户前端读取开关生效。
  - 管理员更新提示模板→AI查询使用新模板，旧模板软删不可见。
  - 管理员变更用户角色→用户权限即时变化（重新登录或令牌刷新）。

### 6. CI Gate
- OpenAPI 契约校验：`admin.yaml`。
- 迁移脚本存在且可回滚：`feature_flags`/`user_feature_flags`/`ai_prompt_templates`/`audit_logs` 的DDL与索引。
- RBAC 与 RLS 测试：`app.role=admin` 路径与普通用户路径分离；强制审计写入。
- 覆盖率：改动 ≥ 80%；契约测试必须通过。

---

## **垂直切片：智能复习（SRS） v1.0（可执行规范）**

### 1. 目标与范围
- 提供以“笔记/高亮”为素材的间隔重复复习系统，实现每日复习队列、评分、调度与表现统计闭环。
- 覆盖后端接口、数据库DDL/RLS、索引、物化视图与刷新策略、前端交互合同、测试与CI Gate。

### 2. 数据库设计（DDL/RLS/索引）
- 表：`srs_decks`（复习分组/牌组）
  ```sql
  CREATE TABLE srs_decks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id),
    name VARCHAR(100) NOT NULL,
    description TEXT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ NULL
  );
  CREATE INDEX ON srs_decks (user_id);
  ALTER TABLE srs_decks ENABLE ROW LEVEL SECURITY;
  CREATE POLICY srs_decks_owner ON srs_decks USING (user_id = current_setting('app.user_id')::uuid) WITH CHECK (user_id = current_setting('app.user_id')::uuid);
  ```
- 表：`srs_cards`（复习卡片，关联源）
  ```sql
  CREATE TABLE srs_cards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id),
    deck_id UUID NOT NULL REFERENCES srs_decks(id) ON DELETE CASCADE,
    source_type VARCHAR(20) NOT NULL CHECK (source_type IN ('NOTE','HIGHLIGHT')),
    source_id UUID NOT NULL,
    prompt TEXT NOT NULL, -- 正面
    answer TEXT NULL,     -- 反面
    ease FLOAT NOT NULL DEFAULT 2.5, -- SM-2/FSRS基线
    interval INTEGER NOT NULL DEFAULT 0, -- 天
    reps INTEGER NOT NULL DEFAULT 0,
    lapses INTEGER NOT NULL DEFAULT 0,
    due_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    is_suspended BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ NULL,
    UNIQUE (user_id, source_type, source_id)
  );
  CREATE INDEX ON srs_cards (user_id, deck_id);
  CREATE INDEX ON srs_cards (user_id, due_at) WHERE deleted_at IS NULL;
  ALTER TABLE srs_cards ENABLE ROW LEVEL SECURITY;
  CREATE POLICY srs_cards_owner ON srs_cards USING (user_id = current_setting('app.user_id')::uuid) WITH CHECK (user_id = current_setting('app.user_id')::uuid);
  ```
- 表：`srs_reviews`（复习记录）
  ```sql
  CREATE TABLE srs_reviews (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id),
    source_type VARCHAR(20) NOT NULL CHECK (source_type IN ('NOTE','HIGHLIGHT')),
    source_id UUID NOT NULL,
    rating INTEGER NOT NULL CHECK (rating BETWEEN 0 AND 5),
    previous_interval INTEGER NOT NULL,
    new_interval INTEGER NOT NULL,
    previous_ease FLOAT NOT NULL,
    new_ease FLOAT NOT NULL,
    reviewed_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
  );
  CREATE INDEX ON srs_reviews (user_id, source_type, source_id, reviewed_at);
  ALTER TABLE srs_reviews ENABLE ROW LEVEL SECURITY;
  CREATE POLICY srs_reviews_owner ON srs_reviews USING (user_id = current_setting('app.user_id')::uuid);
  ```
- 视图：`srs_performance_mv`（每日聚合表现，物化视图）
  ```sql
  CREATE MATERIALIZED VIEW srs_performance_mv AS
  SELECT user_id,
         date_trunc('day', reviewed_at) AS day,
         count(*) AS reviews,
         avg(rating)::float AS avg_rating,
         sum(CASE WHEN rating >= 3 THEN 1 ELSE 0 END)::float / nullif(count(*),0) AS retention
  FROM srs_reviews
  GROUP BY user_id, date_trunc('day', reviewed_at);

  CREATE UNIQUE INDEX ON srs_performance_mv (user_id, day);
  ```
- 刷新触发器：
  ```sql
  CREATE OR REPLACE FUNCTION refresh_srs_performance_mv() RETURNS trigger AS $$
  BEGIN
    PERFORM pg_try_advisory_lock(54321);
    REFRESH MATERIALIZED VIEW CONCURRENTLY srs_performance_mv;
    PERFORM pg_advisory_unlock(54321);
    RETURN NULL;
  END; $$ LANGUAGE plpgsql;

  DROP TRIGGER IF EXISTS trg_refresh_srs_performance_mv ON srs_reviews;
  CREATE TRIGGER trg_refresh_srs_performance_mv
  AFTER INSERT OR UPDATE OR DELETE ON srs_reviews
  FOR EACH STATEMENT EXECUTE FUNCTION refresh_srs_performance_mv();
  ```
- 安全：所有路由在进入数据库前执行 `SET LOCAL app.user_id`；管理员只读跨用户访问需写入 `audit_logs`。

### 3. REST 契约（contracts/api/v1/srs.yaml）
- 路由概览：
  - `GET /api/v1/srs/decks` 列出牌组；`POST /api/v1/srs/decks` 创建。
  - `GET /api/v1/srs/cards?deckId&due=now&limit` 拉取当日到期卡片（游标/limit）。
  - `POST /api/v1/srs/cards` 从笔记/高亮创建卡片（幂等）。
  - `PATCH /api/v1/srs/cards/{cardId}` 暂停/恢复。
  - `POST /api/v1/srs/cards/{cardId}/review` 提交评分（0-5），返回下次到期与更新后的调度参数；支持 `Idempotency-Key`。
  - `GET /api/v1/srs/performance?since&until` 返回聚合表现（基于 `srs_performance_mv`）。
  - `GET/PUT /api/v1/srs/settings` 获取/更新用户SRS参数（如FSRS权重）。

### 4. 后端伪代码（FastAPI + SQLAlchemy）
```python
def require_user(scope=None):
    # 验证JWT，设置SET LOCAL app.user_id
    ...

@router.get('/srs/cards')
async def list_due_cards(deck_id: UUID|None, cursor: str|None, limit: int=20):
    require_user('srs:read')
    # 仅拉取 due_at <= now() 且未暂停，按 due_at 升序
    rows = await db.execute(sa.text(
        """
        SELECT id, prompt, answer, due_at, ease, interval
        FROM srs_cards
        WHERE user_id = current_setting('app.user_id')::uuid
          AND deleted_at IS NULL
          AND is_suspended = FALSE
          AND due_at <= now()
          AND (:deck_id IS NULL OR deck_id = :deck_id)
        ORDER BY due_at ASC
        LIMIT :limit
        """
    ), { 'deck_id': deck_id, 'limit': limit })
    return rows

@router.post('/srs/cards/{card_id}/review')
async def review(card_id: UUID, rating: int, idem_key: str|None):
    require_user('srs:write')
    # 幂等：若 idem_key 已存在则返回记录的响应
    # 调度：按SM-2/FSRS更新 interval/ease/due_at，记录到 srs_reviews
    ...
```

### 5. 前端交互合同（React）
- 组件：
  - `SRSReviewQueue`: `{ deckId, fetchCards(limit), onReviewed(result) }`
  - `SRSCard`: `{ prompt, answer, onRate(0..5) }`
  - `DeckManager`: `{ decks, onCreate(name), onToggle(cardId) }`
- 行为：
  - 每次评分发送 `Idempotency-Key`；失败重试不重复计算。
  - 队列耗尽时提示“今日已完成”，展示表现概览（avg_rating、reviews）。

### 6. 契约测试与 E2E
- 契约测试：
  - 鉴权：无JWT拒绝；设置 `app.user_id` 后仅返回本人数据。
  - 队列：`due_at <= now()` 过滤与分页一致；暂停卡片不返回。
  - 评分：幂等与调度结果正确；写入 `srs_reviews` 后 `srs_performance_mv` 刷新。
- E2E：
  - 从高亮创建卡片 → 当日队列出现 → 评分后 `due_at` 推进与队列减少。
  - 暂停卡片 → 队列不显示；恢复后重新进入队列。

### 7. CI Gate
- OpenAPI 契约校验：`srs.yaml`。
- 迁移脚本：`srs_decks/srs_cards/srs_reviews/srs_performance_mv` 的DDL、索引与触发器。
- RLS 测试：会话变量未设时拒绝；跨用户访问被拒绝；管理员只读需审计。
- 覆盖率：改动 ≥ 80%；契约测试必须通过。

---


## **《“雅典娜计划”PostgreSQL数据库终极白皮书 v6.0》**

### **数据库类型:**
PostgreSQL 15+

#### Books 表字段（更新）
- 新增：`source_etag`（ETag 去重）、`is_digitalized`、`initial_digitalization_confidence`、`converted_epub_key`、`digitalize_report_key`
- 说明：上传与注册流程在入库前计算 ETag；若同用户已有相同 `source_etag`，直接复用原书并返回下载地址。

#### 新增/调整的核心表（与后端一致）
- `users`：`email`、`display_name`、`is_active`、`membership_tier`、`language`、`timezone`、`version`、`updated_at`
- `user_sessions`：`user_id`、`revoked`、`created_at`
- `reading_sessions`、`reading_daily`、`reading_progress`
- `doc_events`、`doc_snapshots`、`doc_conflicts`、`doc_drafts`（协同文档轨迹与快照）
- `free_quota_usage`（免费额度按日累计）
- `audit_logs`
- `ai_conversations`、`ai_messages`、`ai_query_cache`、`ai_conversation_contexts`
- `srs_cards`（唯一约束 `highlight_id`）与 `srs_reviews`（索引 `idx_srs_reviews_next`）
- `credit_products`（Credits 加油包）
- `payment_sessions` 增加 `external_id`（用于支付网关外部会话 ID）

### **核心设计原则:**
-   **主键 (PK):** UUID, DEFAULT `uuid_generate_v4()`。
-   **外键 (FK):** 统一 `_id` 后缀, 严格 `ON DELETE` 策略。
-   **时间戳:** 所有表必须包含 `created_at` 和 `updated_at` (类型 `TIMESTAMPTZ`, 自动更新)。
-   **软删除:** `deleted_at` (类型 `TIMESTAMPTZ`, `NULLABLE`)，核心业务表必备。
-   **约束:** `UNIQUE`, `CHECK`, `NOT NULL`, `ENUM` 类型。
-   **索引:** 预设`INDEX` (B-Tree), GIN, GiST (`pg_trgm`) 以优化查询。
-   **命名规范:** 严格遵循 `snake_case`，表名为复数。
-   **数据库初始化:** 必须启用以下扩展: `uuid-ossp`, `pg_trgm`, `pgcrypto`, `vector`, **`pg_partman`**。

#### **system_settings（系统设置）表（新增）**
- 目的：提供全局键值配置（仅管理员维护），用于运行时参数读取。
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| key | VARCHAR(120) | PK，配置键 |
| value | TEXT | 配置值（字符串），NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |

初始化建议：
```sql
INSERT INTO system_settings(key, value) VALUES ('original_file_retention_days', '30')
ON CONFLICT (key) DO UPDATE SET value = EXCLUDED.value;
```

#### **分区维护命令（pg_partman）（新增）**
- **创建时间分区**：
  ```sql
  SELECT partman.create_parent('public.ai_usage_logs', 'created_at', 'partman', 'time', 'monthly');
  ```
- **手动补建历史分区**：
  ```sql
  SELECT partman.run_maintenance(p_analyze := true);
  ```
- **清理过期分区**：
  ```sql
  SELECT partman.drop_partition_time('public.ai_usage_logs', now() - interval '12 months');
  ```
- **注意**：所有大表（如 `ai_usage_logs`、`ai_query_cache`）建议按时间分区并设置保留策略，降低查询成本与VACUUM压力。

#### **维护策略（新增）**
- 定期维护：`VACUUM (ANALYZE)` 全库；高频更新表按周执行，低频按月。
- 索引膨胀：监控 `pg_stat_all_indexes` 与 `pg_stat_user_tables`；必要时对特定索引执行 `REINDEX`。

#### **灾难恢复（DR）（新增）**
- 目标：RPO ≤ 15 分钟；RTO ≤ 60 分钟。
- 备份：每日全量 + 每小时增量；跨区域存储；校验备份完整性。
- 演练：每月恢复演练与验收（用时达标、数据一致性校验）。
- 统计信息：批量导入或大规模更新后执行 `ANALYZE`，确保计划稳定。
- 向量表特例：`vectors` 导入后优先 `ANALYZE`，并评估 `ivfflat.lists`/`hnsw.m` 参数。

---

### **模块一：用户与权限**

#### **1. users (用户表) (重大更新)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| email | TEXT | 用户邮箱, UNIQUE, NOT NULL, INDEX |
| password_hash | TEXT | 哈希后的密码, NULLABLE |
| display_name | VARCHAR(100) | 用户昵称 |
| is_active | BOOLEAN | 账户是否激活, NOT NULL, DEFAULT TRUE |
| last_login_at | TIMESTAMPTZ | 最后登录时间, INDEX |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | 软删除标记, NULLABLE, INDEX |
| two_factor_enabled | BOOLEAN | 是否启用二次验证, NOT NULL, DEFAULT FALSE |
| two_factor_secret | TEXT | 二次验证密钥, NULLABLE |
| backup_codes | TEXT[] | 备用验证码数组, NULLABLE |
| rate_limit_tier | VARCHAR(20) | 速率限制等级, NOT NULL, DEFAULT 'standard' |
| is_rate_limited | BOOLEAN | 是否被速率限制, NOT NULL, DEFAULT FALSE |
| rate_limit_until | TIMESTAMPTZ | 速率限制解除时间, NULLABLE |
| failed_login_attempts | INTEGER | 连续登录失败次数, NOT NULL, DEFAULT 0 |
| account_locked_until | TIMESTAMPTZ | 账户锁定时间, NULLABLE |
| password_changed_at | TIMESTAMPTZ | 密码最后修改时间, NULLABLE |
| email_verified_at | TIMESTAMPTZ | 邮箱验证时间, NULLABLE |
| allow_shared_cache | BOOLEAN | 是否允许参与匿名共享向量缓存, NOT NULL, DEFAULT TRUE |
| timezone | VARCHAR(64) | 用户首选时区（IANA名称，如 "Asia/Shanghai"），NOT NULL, DEFAULT 'UTC' |
| language | VARCHAR(10) | 用户界面语言，NOT NULL, DEFAULT 'en-US' |
> 说明：MVP阶段不提供手机号注册/登录，相关字段已移除；支持OAuth与邮箱验证码登录。

#### **2. oauth_accounts (OAuth账户关联表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | BIGSERIAL | PK |
| user_id | UUID | FK -> users(id) ON DELETE CASCADE, NOT NULL, INDEX |
| provider | VARCHAR(50) | OAuth提供商, NOT NULL |
| provider_user_id | TEXT | 来自OAuth提供商的用户唯一ID, NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| UNIQUE | (provider, provider_user_id) | |

#### **3. roles (角色表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| name | VARCHAR(50) | 角色名称, UNIQUE, NOT NULL |

#### **4. user_roles (用户-角色关联表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| user_id | UUID | PK, FK -> users(id) ON DELETE CASCADE |
| role_id | INTEGER | PK, FK -> roles(id) ON DELETE CASCADE |

#### **5. refresh_tokens (Refresh Token表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id) ON DELETE CASCADE, NOT NULL |
| token_hash | VARCHAR(255) | 哈希后的Refresh Token, UNIQUE, NOT NULL |
| expires_at | TIMESTAMPTZ | NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| revoked_at | TIMESTAMPTZ | 撤销时间，为NULL表示有效 |

#### **6. user_sessions (用户会话表) (重大更新)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id) ON DELETE CASCADE, NOT NULL, INDEX |
| device_fingerprint | TEXT | 设备唯一指纹, UNIQUE, NOT NULL |
| device_name | VARCHAR(255) | 设备名称, e.g., "Chrome on Windows" |
| device_type | VARCHAR(50) | 设备类型, NOT NULL, DEFAULT 'web' |
| device_os | VARCHAR(100) | 操作系统, NULLABLE |
| browser | VARCHAR(100) | 浏览器信息, NULLABLE |
| refresh_token_hash | VARCHAR(255) | 哈希后的Refresh Token, NOT NULL |
| ip_address | INET | 登录IP |
| location | VARCHAR(255) | 登录地点, NULLABLE |
| is_trusted | BOOLEAN | 是否为信任设备, NOT NULL, DEFAULT FALSE |
| is_active | BOOLEAN | 会话是否活跃, NOT NULL, DEFAULT TRUE |
| expires_at | TIMESTAMPTZ | 会话过期时间, NOT NULL |
| last_activity_at | TIMESTAMPTZ | 最后活动时间, NOT NULL, DEFAULT now() |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| revoked_at | TIMESTAMPTZ | 撤销时间, NULLABLE |
| revoked_reason | VARCHAR(100) | 撤销原因, NULLABLE |
| INDEX | (user_id, is_active) | 优化活跃会话查询 |
| INDEX | (user_id, expires_at) | 优化过期会话清理 |
| INDEX | (device_fingerprint, user_id) | 优化设备指纹查询 |
  
```sql
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_sessions_owner ON user_sessions FOR ALL USING (user_id = current_setting('app.user_id')::uuid) WITH CHECK (user_id = current_setting('app.user_id')::uuid);
```
#### **7. rate_limits (速率限制表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id) ON DELETE CASCADE, NULLABLE, INDEX |
| ip_address | INET | IP地址, NULLABLE, INDEX |
| endpoint | VARCHAR(255) | API端点, NOT NULL |
| request_count | INTEGER | 请求计数, NOT NULL, DEFAULT 1 |
| window_start | TIMESTAMPTZ | 时间窗口开始, NOT NULL |
| window_end | TIMESTAMPTZ | 时间窗口结束, NOT NULL |
| is_blocked | BOOLEAN | 是否被阻止, NOT NULL, DEFAULT FALSE |
| block_until | TIMESTAMPTZ | 阻止解除时间, NULLABLE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| INDEX | (user_id, endpoint, window_start) | 优化用户端点查询 |
| INDEX | (ip_address, endpoint, window_start) | 优化IP端点查询 |
| INDEX | (window_end) | 优化过期记录清理 |
| CHECK | (user_id IS NOT NULL OR ip_address IS NOT NULL) | 用户或IP至少一个不为空 |

#### **8. user_devices (用户设备表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id) ON DELETE CASCADE, NOT NULL, INDEX |
| device_fingerprint | TEXT | 设备唯一指纹, NOT NULL |
| device_name | VARCHAR(255) | 设备名称, NULLABLE |
| device_type | VARCHAR(50) | 设备类型, NOT NULL, DEFAULT 'web' |
| device_os | VARCHAR(100) | 操作系统, NULLABLE |
| browser | VARCHAR(100) | 浏览器信息, NULLABLE |
| is_trusted | BOOLEAN | 是否为信任设备, NOT NULL, DEFAULT FALSE |
| last_seen_at | TIMESTAMPTZ | 最后使用时间, NOT NULL, DEFAULT now() |
| first_seen_at | TIMESTAMPTZ | 首次使用时间, NOT NULL, DEFAULT now() |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| UNIQUE | (user_id, device_fingerprint) | 用户设备唯一性 |
| INDEX | (user_id, is_trusted) | 优化信任设备查询 |
| INDEX | (user_id, last_seen_at) | 优化最近使用设备查询 |

#### **9. authentication_logs (认证日志表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id) ON DELETE CASCADE, NULLABLE, INDEX |
| ip_address | INET | IP地址, NULLABLE, INDEX |
| user_agent | TEXT | 用户代理, NULLABLE |
| event_type | VARCHAR(50) | 事件类型, NOT NULL |
| event_result | VARCHAR(20) | 事件结果, NOT NULL |
| details | JSONB | 事件详情, NULLABLE |
| device_fingerprint | TEXT | 设备指纹, NULLABLE |
| session_id | UUID | 会话ID, NULLABLE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| INDEX | (user_id, event_type, created_at) | 优化用户事件查询 |
| INDEX | (ip_address, event_type, created_at) | 优化IP事件查询 |
| INDEX | (event_type, event_result, created_at) | 优化事件类型结果查询 |
| PARTITION BY | RANGE (created_at) | 按时间分区 |

#### **10. email_login_codes (邮箱验证码登录表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| email | TEXT | 目标邮箱（小写存储）, NOT NULL, INDEX |
| code_hash | VARCHAR(64) | 哈希后的6位验证码, NOT NULL |
| request_id | UUID | 客户端请求ID，用于幂等与追踪, NOT NULL |
| sent_at | TIMESTAMPTZ | 发送时间, NOT NULL, DEFAULT now() |
| expires_at | TIMESTAMPTZ | 过期时间(默认10分钟), NOT NULL |
| consumed_at | TIMESTAMPTZ | 验证成功时间, NULLABLE |
| ip_address | INET | 申请IP, NULLABLE, INDEX |
| user_agent | TEXT | UA, NULLABLE |
| retry_count | INTEGER | 重发次数, NOT NULL, DEFAULT 0 |
| throttle_until | TIMESTAMPTZ | 节流解除时间, NULLABLE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| UNIQUE | (email, request_id) | 幂等保证 |
| INDEX | (email, expires_at DESC) | 优化查找有效验证码 |
| INDEX | (ip_address, sent_at) | 频率限制 |

> 说明：验证码仅以哈希形式存储；单邮箱/单IP设置速率限制与节流，失败重试计数进入 `authentication_logs`；后台任务定期清理过期记录。

---

### **模块二：书籍与组织**

#### **7. books (书籍表) (重大更新)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL |
| title | TEXT | NOT NULL, INDEX (使用Elasticsearch) |
| author | TEXT | INDEX (使用Elasticsearch) |
| publisher | VARCHAR(255) | 出版社 |
| description | TEXT | 内容简介 |
| language | VARCHAR(10) | 语言 |
| isbn | VARCHAR(20) | ISBN编号, INDEX |
| series | VARCHAR(255) | 丛书名称, INDEX |
| series_index | FLOAT | 丛书中的编号 |
| rating | SMALLINT | 用户评分, CHECK (rating >= 1 AND rating <= 5) |
| minio_key | TEXT | 当前系统使用的EPUB文件在MinIO的存储路径, NOT NULL |
| original_minio_key | TEXT | 原始上传文件在MinIO的存储路径, NULLABLE |
| cover_image_key | TEXT | 封面图片在MinIO的存储路径 |
| format | VARCHAR(10) | 文件格式, INDEX |
| file_size_bytes | BIGINT | 文件大小 (字节) |
| page_count | INTEGER | 总页数 |
| file_fingerprint | VARCHAR(64) | 文件内容的SHA256哈希, INDEX |
| charset | VARCHAR(20) | 文本编码 |
| ocr_result_key | TEXT | OCR结果JSON在MinIO的存储路径（按页或整文件），NULLABLE |
| **original_format** | VARCHAR(10) | **[新增]** 原始上传格式, e.g., 'PDF', 'MOBI', NOT NULL |
| **is_image_based** | BOOLEAN | **[新增]** 是否为图片型书籍, DEFAULT FALSE |
| **ocr_page_count** | INTEGER | **[新增]** 已OCR的页数, DEFAULT 0 |
| **text_extraction_confidence** | FLOAT | **[新增]** 文本提取置信度 (0-1) |
| **is_locally_available** | BOOLEAN | **[新增]** 已在当前设备下载, DEFAULT FALSE |
| status | VARCHAR(20) | 书籍状态, ENUM('ANALYZING', 'PENDING_USER_ACTION', 'ACTIVE', 'ARCHIVED', 'FAILED'), NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE, INDEX |
| UNIQUE | (user_id, file_fingerprint) | |

#### **8. book_processing_tasks (书籍处理任务表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| book_id | UUID | FK -> books(id) ON DELETE CASCADE, UNIQUE, NOT NULL |
| current_step | VARCHAR(50) | **[更新]** 处理步骤, ENUM('UPLOADED', 'VALIDATING', 'EXTRACTING', 'CONVERTING', 'ANALYZING', 'PENDING_USER_ACTION', 'OCR_PROCESSING', 'OCR_PREPROCESSING', 'OCR_EXTRACTING', 'OCR_POSTPROCESSING', 'INDEXING', 'EMBEDDING', 'COMPLETED', 'FAILED', 'CANCELLED') |
| step_progress | INTEGER | **[新增]** 当前步骤进度百分比 (0-100), DEFAULT 0 |
| estimated_remaining_minutes | INTEGER | **[新增]** 预估剩余时间(分钟), NULLABLE |
| retry_count | INTEGER | **[新增]** 重试次数, DEFAULT 0 |
| max_retries | INTEGER | **[新增]** 最大重试次数, DEFAULT 3 |
| error_code | VARCHAR(50) | **[新增]** 错误代码, NULLABLE |
| error_message | TEXT | **[新增]** 错误详细信息, NULLABLE |
| details | JSONB | 存储每步的详细信息，如错误信息、耗时等 |
| started_at | TIMESTAMPTZ | **[新增]** 开始处理时间, NULLABLE |
| completed_at | TIMESTAMPTZ | **[新增]** 完成时间, NULLABLE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| INDEX | (current_step, created_at) | |
| INDEX | (book_id, current_step) | |

##### **8.x Dead Letter Queue（新增）**
- **触发条件**：当 `retry_count >= max_retries` 且任务仍未成功时，除将 `current_step='FAILED'` 外，推送一条消息到 DLQ（如 `Redis Stream: dlq.book_processing`）。
- **消息载荷**：`{ task_id, book_id, user_id, error_code, error_message, last_step, timestamp }`，用于后续人工干预与批量重试。
- **对齐策略**：
  - 生产者（各处理任务）统一在失败达阈值时写入DLQ；
  - 后台管理面板提供DLQ浏览、重试与归档接口；
  - 重试从DLQ消费后，生成新的处理链条并记录审计日志。

#### **8.1. book_processing_step_logs (书籍处理步骤日志表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| task_id | UUID | FK -> book_processing_tasks(id) ON DELETE CASCADE, NOT NULL, INDEX |
| step_name | VARCHAR(50) | 步骤名称, NOT NULL |
| status | VARCHAR(20) | 步骤状态, ENUM('STARTED', 'IN_PROGRESS', 'COMPLETED', 'FAILED', 'SKIPPED'), NOT NULL |
| progress | INTEGER | 进度百分比 (0-100), DEFAULT 0 |
| message | TEXT | 步骤消息或状态描述 |
| metadata | JSONB | 步骤元数据，如处理参数、中间结果等 |
| started_at | TIMESTAMPTZ | 步骤开始时间, NOT NULL, DEFAULT now() |
| completed_at | TIMESTAMPTZ | 步骤完成时间, NULLABLE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| INDEX | (task_id, step_name) | |
| INDEX | (task_id, status) | |

#### **9. shelves (书架表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| name | VARCHAR(255) | NOT NULL |
| parent_shelf_id | UUID | FK -> shelves(id) ON DELETE CASCADE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |
| UNIQUE | (user_id, parent_shelf_id, name) | |

#### **10. book_shelves (书籍-书架关联表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| book_id | UUID | PK, FK -> books(id) ON DELETE CASCADE |
| shelf_id | UUID | PK, FK -> shelves(id) ON DELETE CASCADE |

#### **11. reading_progress (阅读进度表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| user_id | UUID | PK, FK -> users(id) |
| book_id | UUID | PK, FK -> books(id) |
| last_location | JSONB | 复合定位符（PDF/EPUB），示例：`{"type":"PDF","page":125,"zoom":1.5,"scrollTop":450}` 或 `{"type":"EPUB","cfi":"epubcfi(...)"}` |
| progress_percentage | FLOAT | 进度百分比, CHECK (progress_percentage >= 0 AND progress_percentage <= 1) |
| total_read_seconds | BIGINT | 累计阅读时长 (秒), DEFAULT 0 |
| last_read_at | TIMESTAMPTZ | 最后一次阅读的时间, INDEX（乐观锁关键字段） |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

#### **11.1. user_daily_reading_stats (用户每日阅读统计表)（新增）**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| user_id | UUID | PK, FK -> users(id), INDEX |
| date | DATE | PK（统计日期，按用户首选时区计算的本地日期），INDEX |
| total_seconds_read | BIGINT | 当日累计阅读时长（秒），NOT NULL, DEFAULT 0 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| UNIQUE | (user_id, date) | 保证每日唯一记录 |

RLS（行级安全）
```
-- 仅允许本人访问与写入
CREATE POLICY user_daily_reading_stats_rls ON user_daily_reading_stats
  USING (user_id = current_setting('app.user_id')::uuid)
  WITH CHECK (user_id = current_setting('app.user_id')::uuid);
```

#### **API变更（阅读进度同步）**
- 废除：`PUT /api/v1/progress/reading`（旧进度上报接口）。
- 新增：基于心跳会话的三接口：
  - `POST /api/v1/reading-sessions/start`
  - `POST /api/v1/reading-sessions/{sessionId}/heartbeat`
  - `POST /api/v1/reading-sessions/{sessionId}/end`
- 说明：所有心跳与结束接口的数据库写入操作需在单一事务内完成，并通过 `last_read_at` 实现乐观锁以避免多设备写冲突。

#### **时区与时间策略（全球化）**
- 存储统一：所有时间字段使用 `TIMESTAMPTZ`，以 UTC 写入与比较。
- 本地化展示：前端按用户首选时区（`users.timezone` 或 `X-Timezone`）进行格式化展示。
- 每日统计：`user_daily_reading_stats.date` 为用户本地日期，心跳逻辑对跨午夜的秒数进行拆分归档。
- DST与闰秒：通过 IANA 时区库（Python `zoneinfo`）转换本地时间；闰秒忽略，以UTC源时间为基准保证单调性。
- 会话时区：会话缓存携带 `timezone` 字段；心跳可用 `X-Timezone` 动态覆盖，后端以会话或请求头为准。
- 校验与回退：若 `X-Timezone` 非合法 IANA 时区，则回退到 `users.timezone`；若仍无效则使用 `UTC` 并记录告警（metrics+日志）。

#### **后端伪代码（阅读会话：事务+Redis+乐观锁）**
```python
# Redis 键：reading_session:{session_id}
# 字段：user_id, book_id, created_at, last_heartbeat_at, accumulated_seconds,
#       last_location_json, progress_percentage

def start_reading_session(user_id: UUID, book_id: UUID) -> UUID:
    session_id = uuid4()
    now = utc_now()
    # 选择时区：优先使用请求头 X-Timezone，否则回退用户首选时区（users.timezone）
    user_tz = request.headers.get("X-Timezone") or db.scalar("SELECT timezone FROM users WHERE id=:u", {"u": user_id}) or "UTC"
    redis.hset(f"reading_session:{session_id}", mapping={
        "user_id": str(user_id),
        "book_id": str(book_id),
        "created_at": now.isoformat(),
        "last_heartbeat_at": now.isoformat(),
        "accumulated_seconds": 0,
        "timezone": user_tz,
    })
    redis.expire(f"reading_session:{session_id}", seconds=3600)  # 1小时TTL
    return session_id

@db.transaction()  # 心跳必须在单一事务内完成
def heartbeat(session_id: UUID, last_location: dict, progress_percentage: float | None):
    key = f"reading_session:{session_id}"
    sess = redis.hgetall(key)
    assert sess, "SESSION_NOT_FOUND"
    now = utc_now()
    prev = parse_iso(sess["last_heartbeat_at"])  # 容错：若缺失则使用 created_at
    delta = clamp(int((now - prev).total_seconds()), min_value=0, max_value=120)
    new_acc = int(sess.get("accumulated_seconds", 0)) + delta
    # 客户端可携带 X-Timezone 动态覆盖；如未提供，沿用会话时区
    user_tz = request.headers.get("X-Timezone") or sess.get("timezone") or "UTC"
    tz = ZoneInfo(user_tz)
    prev_local = prev.astimezone(tz)
    now_local = now.astimezone(tz)
    # 跨午夜拆分统计：将 delta 按本地日期边界拆分为最多两段
    if prev_local.date() != now_local.date():
        # 计算到当天午夜的秒数
        midnight = datetime.combine(prev_local.date() + timedelta(days=1), time.min, tzinfo=tz)
        left = clamp(int((midnight - prev_local).total_seconds()), 0, delta)
        right = delta - left
        increments = [ (prev_local.date(), left), (now_local.date(), right) ]
    else:
        increments = [ (now_local.date(), delta) ]

    # 写回Redis（轻量）
    redis.hset(key, mapping={
        "last_heartbeat_at": now.isoformat(),
        "accumulated_seconds": new_acc,
        "last_location_json": json.dumps(last_location),
        "progress_percentage": progress_percentage if progress_percentage is not None else sess.get("progress_percentage"),
    })

    # 数据库写入（乐观锁基于 last_read_at）
    # 注意：仅当 incoming_ts(now) >= current.last_read_at 才更新位置/百分比
    # 并滚动当日统计
    rp = db.one("SELECT last_read_at FROM reading_progress WHERE user_id=:u AND book_id=:b FOR UPDATE",
                {"u": sess["user_id"], "b": sess["book_id"]})
    incoming_ts = now
    should_update = (rp is None) or (rp.last_read_at is None) or (incoming_ts >= rp.last_read_at)

    if should_update:
        db.exec("""
        INSERT INTO reading_progress(user_id, book_id, last_location, progress_percentage, total_read_seconds, last_read_at, updated_at)
        VALUES (:u, :b, :loc::jsonb, :pp, :inc_sec, :ts, now())
        ON CONFLICT (user_id, book_id) DO UPDATE SET
          last_location = EXCLUDED.last_location,
          progress_percentage = COALESCE(EXCLUDED.progress_percentage, reading_progress.progress_percentage),
          total_read_seconds = reading_progress.total_read_seconds + EXCLUDED.total_read_seconds,
          last_read_at = EXCLUDED.last_read_at,
          updated_at = now()
        WHERE reading_progress.last_read_at IS NULL OR EXCLUDED.last_read_at >= reading_progress.last_read_at
        """,
        {"u": sess["user_id"], "b": sess["book_id"], "loc": json.dumps(last_location), "pp": progress_percentage,
         "inc_sec": delta, "ts": incoming_ts})

    # 汇总每日统计（按用户本地日期）
    for local_date, inc in increments:
        if inc <= 0:
            continue
        db.exec("""
        INSERT INTO user_daily_reading_stats(user_id, date, total_seconds_read, created_at, updated_at)
        VALUES (:u, :d, :inc, now(), now())
        ON CONFLICT (user_id, date) DO UPDATE SET
          total_seconds_read = user_daily_reading_stats.total_seconds_read + EXCLUDED.total_seconds_read,
          updated_at = now()
        """, {"u": sess["user_id"], "d": local_date, "inc": inc})

@db.transaction()
def end_session(session_id: UUID, last_location: dict, progress_percentage: float | None):
    key = f"reading_session:{session_id}"
    sess = redis.hgetall(key)
    if not sess:
        return  # 幂等结束，无状态可忽略

    now = utc_now()
    prev = parse_iso(sess.get("last_heartbeat_at", sess.get("created_at")))
    delta = clamp(int((now - prev).total_seconds()), min_value=0, max_value=120)
    # 最后一跳合并入库（与心跳同样的乐观锁策略）
    heartbeat(session_id, last_location, progress_percentage)
    # 清理Redis
    redis.delete(key)
```

**并发与幂等注意事项**
- 心跳 `delta` 上限 120 秒，避免前端长时间挂起造成异常累加；负值归零。
- 事务中使用 `FOR UPDATE` 锁住 `reading_progress` 行，基于 `last_read_at` 比较实现乐观锁，避免多设备冲突覆盖。
- 结束接口调用 `heartbeat` 以合并最终时长与位置，保证幂等（重复结束不报错）。

#### **前端实现要点（心跳与OCR双层渲染）**
- 打开阅读器：`POST /reading-sessions/start` 获取 `session_id`；从 `reading_progress` 恢复 `last_location`。
- 心跳：`setInterval` 每 5–15 秒发送 `POST /{sessionId}/heartbeat`；携带复合定位符与可选进度百分比；网络异常重试指数退避。请求头附带 `X-Timezone = Intl.DateTimeFormat().resolvedOptions().timeZone`。
- 结束：`beforeunload` 使用 `navigator.sendBeacon()` 调用 `/end`；组件卸载时再调用一次以兜底。
- OCR双层渲染：
  - 视觉层：`react-pdf` 渲染原始页面。
  - 交互层：按 `GET /api/v1/ocr-results/{bookId}/{pageNumber}` 返回的 blocks，生成透明绝对定位的文本元素（或 Canvas/SVG）。
  - 高亮：监听文本选择，计算选区坐标并在叠加层绘制半透明矩形；调用 `POST /api/v1/highlights` 上报所选文本、颜色与页内坐标。

---

### **模块三：知识内化**

#### **12. highlights (高亮表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| book_id | UUID | FK -> books(id), NOT NULL, INDEX |
| locator | JSONB | [新增] 复合定位符，用于存储PDF坐标或EPUB CFI。NOT NULL。|
| text_content | TEXT | 高亮的文本, CHECK (length(text_content) > 0) |
| text_content_tsvector | TSVECTOR | 为全文检索生成的向量列, INDEX (GIN) |
| color | SMALLINT | 高亮颜色 (数字代表预设颜色) |
| chapter | VARCHAR(255) | 所在章节标题 |
| version | INTEGER | 乐观并发版本, NOT NULL, DEFAULT 1 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |
| INDEX | (user_id, book_id, created_at DESC) | |

```sql
ALTER TABLE reading_progress ENABLE ROW LEVEL SECURITY;
CREATE POLICY reading_progress_owner ON reading_progress FOR ALL USING (user_id = current_setting('app.user_id')::uuid) WITH CHECK (user_id = current_setting('app.user_id')::uuid);
CREATE INDEX IF NOT EXISTS idx_reading_progress_user_book_updated ON reading_progress (user_id, book_id, updated_at DESC);
```

**（补充）全文检索触发器（highlights）**
```sql
CREATE OR REPLACE FUNCTION highlights_tsvector_update() RETURNS trigger AS $$
BEGIN
  NEW.text_content_tsvector := to_tsvector('simple', coalesce(NEW.text_content,''));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_highlights_tsvector ON highlights;
CREATE TRIGGER trg_highlights_tsvector
BEFORE INSERT OR UPDATE OF text_content
ON highlights FOR EACH ROW
EXECUTE FUNCTION highlights_tsvector_update();

-- 索引
CREATE INDEX IF NOT EXISTS idx_highlights_tsvector ON highlights USING GIN (text_content_tsvector);
```

#### **13. notes (笔记表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| book_id | UUID | FK -> books(id), NULLABLE, INDEX |
| highlight_id | UUID | FK -> highlights(id) ON DELETE SET NULL, NULLABLE |
| title | TEXT | 笔记标题 |
| content_markdown | TEXT | 笔记内容 |
| content_tsvector | TSVECTOR | 为全文检索生成的向量列, INDEX (GIN) |
| chapter | VARCHAR(255) | 所在章节标题 |
| version | INTEGER | 乐观并发版本, NOT NULL, DEFAULT 1 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |
| INDEX | (user_id, book_id, created_at DESC) | |

**（补充）全文检索触发器（新增）**
```sql
-- 依赖扩展：pg_trgm、fuzzystrmatch（如需），并确保中文分词由上层完成
CREATE OR REPLACE FUNCTION notes_tsvector_update() RETURNS trigger AS $$
BEGIN
  NEW.content_tsvector := to_tsvector('simple', coalesce(NEW.title,'') || ' ' || coalesce(NEW.content_markdown,''));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_notes_tsvector ON notes;
CREATE TRIGGER trg_notes_tsvector
BEFORE INSERT OR UPDATE OF title, content_markdown
ON notes FOR EACH ROW
EXECUTE FUNCTION notes_tsvector_update();
```

#### **14. tags (标签表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL |
| name | VARCHAR(100) | 标签名称, NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |
| UNIQUE | (user_id, name) | |

#### **15. note_tags (笔记-标签关联表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| note_id | UUID | PK, FK -> notes(id) ON DELETE CASCADE |
| tag_id | UUID | PK, FK -> tags(id) ON DELETE CASCADE |

---

## **《Notes & Highlights 垂直切片（笔记与高亮）可执行规范（新增）》**

### 1. 目标与范围
- 覆盖高亮与笔记的创建、更新、删除、查询；支持标签绑定与筛选；支持全文检索与分页。
- 与阅读器交互：支持PDF/EPUB双定位（`PdfLocation`/`EpubLocation`），OCR叠加层产生的页内坐标用于高亮。
- 安全与隔离：JWT + RLS 强制按用户隔离；所有写操作遵循幂等与乐观并发（`version`）。
- 时区策略：所有时间字段 `TIMESTAMPTZ`（UTC存储）；前端按“时区与时间策略（全球化）”章节展示本地时间。

### 2. 数据库与约束（复核）
- 已定义表：`highlights`, `notes`, `tags`, `note_tags`, `highlight_tags`；均含 `created_at/updated_at/deleted_at` 与 `version`（乐观并发）。
```sql
ALTER TABLE public.highlights ENABLE ROW LEVEL SECURITY;
CREATE POLICY highlights_select ON public.highlights
  FOR SELECT USING (user_id = current_setting('app.user_id')::uuid);
CREATE POLICY highlights_insert ON public.highlights
  FOR INSERT WITH CHECK (user_id = current_setting('app.user_id')::uuid);
CREATE POLICY highlights_update ON public.highlights
  FOR UPDATE USING (user_id = current_setting('app.user_id')::uuid);
CREATE POLICY highlights_delete ON public.highlights
  FOR DELETE USING (user_id = current_setting('app.user_id')::uuid);
```
- 约束与索引：
  - `highlights.text_content_tsvector` 与 `notes.content_tsvector` 触发器已配置；GIN索引就绪。
  - 建议颜色检查（如采用预设色盘）：`CHECK (color BETWEEN 0 AND 15)`；章节名 `chapter` 最长 255。
  - 组合索引：`(user_id, book_id, created_at DESC)`；标签关联表设置 `(note_id, tag_id)` 与 `(highlight_id, tag_id)` 主键。
- RLS：依赖 `SET LOCAL app.user_id`/`app.role`；`tags`/`note_tags`/`highlight_tags` 已配置基于父资源的RLS策略。

### 3. REST API 契约（OpenAPI 3.0 摘录）
> 契约遵循“第六章：API标准与契约”。以下为关键端点摘录，完整规范以 `contracts/api/v1/*.yaml` 为准。

```yaml
openapi: 3.0.3
info: { title: Athena Notes & Highlights, version: 1.0.0 }
servers: [ { url: / } ]
security: [ { bearerAuth: [] } ]
tags:
  - name: notes
    description: 用户笔记
  - name: highlights
    description: 书内高亮

paths:
  /api/v1/highlights:
    get:
      tags: [highlights]
      summary: 列出高亮（支持筛选与分页）
      parameters:
        - in: query
          name: book_id
          schema: { type: string, format: uuid }
        - in: query
          name: tag_id
          schema: { type: string, format: uuid }
        - in: query
          name: q
          schema: { type: string }
          description: 关键词检索（ES优先，回退Postgres tsvector）
        - in: query
          name: limit
          schema: { type: integer, default: 20, maximum: 100 }
        - in: query
          name: cursor
          schema: { type: string }
      responses:
        '200': { description: OK }
    post:
      tags: [highlights]
      summary: 创建高亮（幂等）
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateHighlightRequest'
      responses:
        '201': { description: Created }

  /api/v1/highlights/{highlightId}:
    get:
      tags: [highlights]
      summary: 获取高亮详情
      parameters:
        - in: path
          name: highlightId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200': { description: OK, headers: { ETag: { schema: { type: string } } } }
        '404': { description: RESOURCE_NOT_FOUND }
    patch:
      tags: [highlights]
      summary: 更新高亮（颜色/文本/章节）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateHighlightRequest'
      responses:
        '200': { description: OK, headers: { ETag: { schema: { type: string } } } }
        '400': { description: If-Match 缺失或非法 }
        '409': { description: VERSION_CONFLICT }
    delete:
      tags: [highlights]
      summary: 软删除高亮
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }

  /api/v1/notes:
    get:
      tags: [notes]
      summary: 列出笔记（支持筛选与分页）
      parameters:
        - in: query
          name: book_id
          schema: { type: string, format: uuid }
        - in: query
          name: tag_id
          schema: { type: string, format: uuid }
        - in: query
          name: q
          schema: { type: string }
        - in: query
          name: limit
          schema: { type: integer, default: 20, maximum: 100 }
        - in: query
          name: cursor
          schema: { type: string }
      responses:
        '200': { description: OK }
    post:
      tags: [notes]
      summary: 创建笔记（可关联高亮）
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateNoteRequest'
      responses:
        '201': { description: Created }

  /api/v1/notes/{noteId}:
    get:
      tags: [notes]
      summary: 获取笔记详情
      parameters:
        - in: path
          name: noteId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200': { description: OK, headers: { ETag: { schema: { type: string } } } }
        '404': { description: RESOURCE_NOT_FOUND }
    patch:
      tags: [notes]
      summary: 更新笔记（标题/内容/章节）
      parameters:
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateNoteRequest'
      responses:
        '200': { description: OK, headers: { ETag: { schema: { type: string } } } }
        '400': { description: If-Match 缺失或非法 }
        '409': { description: VERSION_CONFLICT }
    delete:
      tags: [notes]
      summary: 软删除笔记
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }

components:
  securitySchemes:
    bearerAuth: { type: http, scheme: bearer, bearerFormat: JWT }
  schemas:
    PdfLocation:
      type: object
      properties:
        type: { type: string, enum: [PDF] }
        page: { type: integer }
        bbox: { type: array, items: { type: number }, minItems: 4, maxItems: 4 }
    EpubLocation:
      type: object
      properties:
        type: { type: string, enum: [EPUB] }
        cfi: { type: string }

    CreateHighlightRequest:
      type: object
      required: [book_id, locator, text_content]
      properties:
        book_id: { type: string, format: uuid }
        locator:
          oneOf:
            - $ref: '#/components/schemas/PdfLocation'
            - $ref: '#/components/schemas/EpubLocation'
        text_content: { type: string }
        color: { type: integer }
        chapter: { type: string }

    UpdateHighlightRequest:
      type: object
      properties:
        text_content: { type: string }
        color: { type: integer }
        chapter: { type: string }

    CreateNoteRequest:
      type: object
      required: [title, content_markdown]
      properties:
        book_id: { type: string, format: uuid, nullable: true }
        highlight_id: { type: string, format: uuid, nullable: true }
        title: { type: string }
        content_markdown: { type: string }
        chapter: { type: string }

    UpdateNoteRequest:
      type: object
      properties:
        title: { type: string }
        content_markdown: { type: string }
        chapter: { type: string }
```

### 4. 前端交互流程（React + TanStack Query）
- 高亮创建：
  - 用户在OCR叠加层选择文本 → 计算页内坐标（PDF）或CFI（EPUB）。
  - 调用 `POST /api/v1/highlights`（携带 `Idempotency-Key` 以防重复提交）。
  - 前端乐观更新列表；失败回滚并展示错误（指数退避重试仅限网络错误）。
- 从高亮创建笔记：
  - 在高亮卡片点击“添加笔记” → 打开编辑器（支持Markdown）。
  - 调用 `POST /api/v1/notes`（`highlight_id` 可选）。
  - 列表与搜索索引异步刷新（ES/Celery）。
- 标签绑定：使用已定义端点 `/notes/{noteId}/tags/{tagId}` 与 `/highlights/{highlightId}/tags/{tagId}` 幂等绑定/解绑。
- 列表与分页：统一 `limit/cursor`；缓存Key遵循资源+筛选参数；失效策略与“Tags & Search”章节一致。

### 5. 并发控制与幂等
- `version` 乐观并发：PATCH 必须携带 `If-Match: <version>`；不匹配返回 `409 VERSION_CONFLICT`。
- 幂等创建：前端提供 `Idempotency-Key`；服务端记录并防止重复插入（参考“强制校验规则”与幂等说明）。
- 软删除：写入 `deleted_at`；RLS与查询默认过滤 `deleted_at IS NULL`。

### 6. 权限与Scopes
- 访问控制：JWT必需；Scopes：`notes:read|write|delete`、`highlights:read|write|delete`、`tags:read|write|delete`。
- 资源绑定：所有跨表写入需校验同一 `user_id`，并在事务开始处设置 `SET LOCAL app.user_id/app.role`。

### 7. 错误码与校验
- `VALIDATION_ERROR`：必填缺失、定位符非法、颜色越界、标题/内容为空。
- `RESOURCE_NOT_FOUND`：目标笔记/高亮不存在或已删除。
- `AUTHORIZATION_ERROR`/`AUTHENTICATION_ERROR`：Token缺失/无效或越权访问。
- `RATE_LIMITED`：创建/更新频率过高触发限流（Traefik中间件）。

### 8. 分页 / 排序 / 过滤
- 策略：统一 `cursor-based`；默认 `limit=20`，最大 `100`；排序按 `created_at DESC`。
- 过滤：支持 `book_id`、`tag_id`、`q`（关键词）组合；字段选择 `fields=` 按需返回。

### 9. 契约测试与CI
- 前端消费者测试：Jest + Supertest 对主要端点进行契约与分页校验。
- 后端提供者测试：Pact 校验与 `fastapi-openapi-tester` 一致性对比；CI中强制执行。
- SQL迁移Lint：`sqlfluff lint`；确保索引与RLS策略就位。

### 10. 可观测性与审计
- 记录：关键操作写 `audit_logs`（资源ID、操作、耗时、用户ID）。
- 指标：创建/更新成功率、ES索引同步耗时、幂等回退次数、冲突率（409）。
- 日志：接入 Loki；错误捕获 Sentry；链路追踪 Jaeger。


#### **16. ai_conversations (AI对话记录表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL |
| title | TEXT | 对话标题 |
| related_context | JSONB | 关联的上下文 |
| conversation_history | JSONB | 存储完整的对话历史, INDEX (GIN with jsonb_path_ops) |
| mode | VARCHAR(20) | ENUM('KNOWLEDGE_BASE','GENERAL'), NOT NULL, DEFAULT 'KNOWLEDGE_BASE' |
| model_id | TEXT | 选用的模型ID（对应 ai_models.model_id），NOT NULL |
| total_credits_spent | NUMERIC(18,6) | 累计消耗信用点，NOT NULL, DEFAULT 0 |
| last_user_message_at | TIMESTAMPTZ | 最近一条用户消息时间 |
| version | INTEGER | 乐观并发版本号，NOT NULL，DEFAULT 1 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |

```sql
CREATE INDEX IF NOT EXISTS idx_ai_conversations_user_last ON ai_conversations (user_id, last_user_message_at DESC);
```

#### **17. dict_history (查词历史表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | BIGSERIAL | PK |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| book_id | UUID | FK -> books(id), NULLABLE |
| word | TEXT | 查询的单词 |
| chapter | VARCHAR(255) | 所在章节标题 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

```sql
ALTER TABLE dict_history ENABLE ROW LEVEL SECURITY;
CREATE POLICY dict_history_owner ON dict_history FOR ALL USING (user_id = current_setting('app.user_id')::uuid) WITH CHECK (user_id = current_setting('app.user_id')::uuid);
```

#### **18. vectors (向量表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| source_type | VARCHAR(20) | ENUM ('BOOK_CHUNK', 'NOTE', 'HIGHLIGHT'), NOT NULL |
| source_id | UUID | 对应源表的ID, NOT NULL |
| shared_vector_id | UUID | FK -> shared_vectors(id) ON DELETE RESTRICT, NOT NULL, INDEX |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |

---

## **《AI 垂直切片（对话与查询）可执行规范（新增）》**

### 1. 核心目标与产品哲学
- 一级核心功能：构建私有知识库深度整合的 AI 对话中心，定位为“智能知识伙伴”。
- 三大哲学：用户控制、隐私优先、价值透明。
- 透明计费与可追溯：每次调用明确显示模型基础成本与雅典娜服务费；引用片段可回到原文。
- 界面范式：采用“独立AI界面 + 上下文自适应模型”，由阅读器上下文驱动查询与生成。

### 2. 核心架构与全球化部署
- 网络架构（强制）：所有上游 AI 供应商调用（如 OpenRouter）必须经“海外VPS代理”转发；后端仅向代理发起请求。
- 配置（强制）：代理地址在管理员后台可配置，存储于 `system_settings.ai_proxy_url`，支持热切换与容灾。
- 供应商策略（强制）：后端集成 LiteLLM 等多供应商抽象；主供应商为 OpenRouter；至少配置一个备用（如 DeepInfra/Groq），主失败时自动故障切换。
- 用户归属（强制）：上游请求必须携带当前雅典娜用户标识（`Custom-Id` Header 或 `user` 字段），实现成本精确归因与风控。
- 全球化：所有时间字段使用 `TIMESTAMPTZ`（UTC存储）；前端传 `X-Timezone`，后端按用户本地时区展示账单与时间线。

### 3. 商业模式与计费系统
- 计费单位：唯一计费单位为“雅典娜信用点（Credits）”；用户通过支付网关（如 PingPong）购买 Credits。
- 计费模型（透明服务费）：每次调用 = ① 模型基础成本 + ② 雅典娜知识引擎服务费。
  - 基础成本：实时根据供应商返回的美元 cost 与后台汇率换算（`system_settings.usd_to_credit_rate`）。
  - 服务费：后台配置的百分比（`system_settings.ai_service_fee_percentage`）加收在基础成本之上。
- 前端显示：消费记录/账单中清晰列出两部分构成与合计。
- 动态定价：Celery 定时任务每日调用 OpenRouter `models` API 与货币汇率 API，更新 `ai_models` 与 `currencies`。
  - 失败重试：指数退避；连续失败>3次记录告警与错误日志。

### 4. 数据库变更（DDL/校验）
- 新建：`ai_models`
  ```sql
  CREATE TABLE IF NOT EXISTS ai_models (
    id BIGSERIAL PRIMARY KEY,
    model_id TEXT NOT NULL UNIQUE,
    friendly_name TEXT NOT NULL,
    provider TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    description TEXT,
    pricing_usd JSONB, -- 原始定价结构（输入/输出单价、单位等）
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deleted_at TIMESTAMPTZ
  );
  ```
- 新建/确认：`system_settings`（键值对）至少包含：
  - `ai_proxy_url`（海外VPS代理地址）
  - `ai_service_fee_percentage`（服务费百分比，如 0.20）
  - `usd_to_credit_rate`（美元到信用点的换算率，动态更新）
- 新建：`ai_conversation_contexts`（对话-书籍上下文持久化）
  ```sql
  CREATE TABLE IF NOT EXISTS ai_conversation_contexts (
    conversation_id UUID NOT NULL REFERENCES ai_conversations(id) ON DELETE CASCADE,
    book_id UUID NOT NULL REFERENCES books(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    PRIMARY KEY (conversation_id, book_id)
  );
  ```
- 复核：`users.timezone`、`users.language` 已存在且非空（默认 `UTC` 与 `en-US`/可配置）；`currencies.rate_to_base` 存在且按日更新。
- 规则：所有表启用 RLS；事务开始处强制 `SET LOCAL app.user_id/app.role`。
 - 字段新增：`ai_conversations.version INTEGER NOT NULL DEFAULT 1`（用于乐观并发；响应携带 `ETag: <version>`，更新必须提供 `If-Match`）。

### 5. 前端 UI/UX（AI对话主界面）
- 一级入口：主导航提供“AI对话”，进入独立全屏页面。
- 布局适配：
  - Web/桌面/Pad：三栏式（左：对话历史；中：主聊天区；右：上下文管理器）。
  - 移动端：默认显示主聊天区；左上角 Menu 图标滑出“对话历史”；右上角 Layers 图标从底部滑出工作表。
- 上下文管理器：
  - 永久可见：展示与管理当前对话的知识库范围；[+] 弹窗勾选一本或多本书籍加入上下文；已选书籍以 Tag 形式展示，可移除。
  - 自动恢复：从“对话历史”加载旧对话时，自动恢复当时的上下文（持久化于 `ai_conversation_contexts`）。
- “仅限知识库”开关：MVP阶段默认开启且UI不可见或禁用；所有AI对话强制运行于知识库模式；“通用聊天”作为未来预留。
  - 开启：请求 `mode=KNOWLEDGE_BASE`（后端亦强制该默认值）。
  - 关闭：暂不提供；前端不发送 `mode=GENERAL`。
- 模型选择：下拉菜单由 `GET /api/v1/ai/available-models` 动态填充（取 `ai_models.is_active=true`）。
- 引用追溯：回答中的 `[cite:...]` 渲染为可点击角标；点击弹出模态框，内嵌只读阅读器并直接跳转高亮原文片段。
 - 预设功能入口：输入框上方或旁边提供“灵感模板 (Inspiration Templates)”按钮，必须包含“为我推荐相关书籍”，并可包含“帮我寻找矛盾观点”等。

### 6. 核心后端逻辑（RAG 与 Prompt工程）
- 触发：MVP阶段服务端强制 `mode=KNOWLEDGE_BASE` 执行 RAG；`GENERAL` 预留，不对前端开放。
- 步骤一：查询重写（强制）
  - 组合“当前问题 + 最近几轮对话历史”，调用一次 LLM，将其改写为不依赖上下文的独立问题。
- 步骤二：并行检索
  - 向量数据库（pgvector，`shared_vectors`）：在选定书籍范围内执行相似度搜索，返回书籍原文片段。
  - Elasticsearch（`es.notes`、`es.highlights`）：在选定书籍范围内对用户“笔记/高亮”进行检索，融入个性化知识来源。
- 步骤三：重排序与筛选
  - 汇总所有检索结果；使用重排序模型（Re-ranker）二次打分；选出 Top-K 精华片段（K 动态）。
- 步骤四：构建最终 Prompt
  - 结构化 Prompt：包含系统角色、筛选出的精华片段（必须附带书名与作者）、重写后的问题；强制要求 LLM 在引用时使用 `[cite:...]`。
- 步骤五：调用 LLM
  - 通过海外代理调用主供应商；失败自动故障切换到备用供应商（DeepInfra/Groq）。

**预设功能：推荐新书（官方模板）**
- UI“为我推荐相关书籍”按钮；后端使用管理员可配置的 Prompt 模板。
- 逻辑：为当前选择的书籍生成核心标签，结合用户在这些书的“笔记/高亮”片段；完全基于用户选择的书籍元数据（含作者）、用户自己的笔记/高亮，以及 LLM 的通用知识进行推荐；不依赖任何外部书籍数据库或其他用户数据。

```text
你是一位资深阅读策展人。仅基于我选择的书籍元数据（书名、作者）和我在这些书中的笔记/高亮，以及你的通用知识，向我推荐 3–5 本相关书籍，并给出每本书的个性化理由。严禁使用任何外部书籍数据库或其他用户数据。

输入：
- 已选书籍元数据：{selected_books_metadata}
- 我的笔记与高亮片段：{user_notes_highlights}

输出要求：
- 使用 Markdown 列表；每项为“书名（作者） — 推荐理由；关联到哪些已选书籍（以标签说明）”。
- 避免重复与过度主观；理由需具体、可执行。
```

### 7. 管理员后台功能
- AI模型管理：从预设列表中勾选、激活或禁用向前端展示的模型（写 `ai_models.is_active`）。
- 商业参数配置：动态修改“服务费率（`ai_service_fee_percentage`）”“美元→信用点（`usd_to_credit_rate`）”。
- Prompt 模板管理：提供文本编辑器，管理员可随时调整系统级 Prompt 模板（含“推荐新书”模板）。

##### Prompt模板管理示例（MVP）
- 智能摘要：
```text
请基于以下原文片段，用中文生成 500 字以内的智能摘要，保留核心论点、关键数据与结论，避免主观臆断。原文：{selected_text}
```
- 生成笔记：
```text
请你扮演一位资深的知识管理专家，根据以下我提供的原文片段，为我生成一份结构化的、要点式的 Markdown 笔记，以便于我后续的复习和理解。原文如下：{selected_text}
```
- 提取关键词：
```text
从以下文本提取 5–10 个主题关键词，使用中文，按重要度降序，用逗号分隔；兼顾术语与概念。原文：{selected_text}
```
- 翻译：
```text
将以下文本翻译为简洁准确的中文；保留术语；在不改变原意的前提下优化可读性。原文：{selected_text}
```

### 8. 计费明细与记录（透明）
- 每次调用生成一条消费记录（写入 `credit_transactions`，type=`AI_CALL`）：
- 字段建议：`conversation_id`、`model_id`、`base_cost_usd`、`usd_to_credit_rate`、`service_fee_percentage`、`total_credits`
- 对话表 `ai_conversations.total_credits_spent` 累加；前端账单展示“基础成本 + 服务费”。
 - `credit_transactions.details`（JSONB）结构建议：
   ```json
   {
     "conversation_id": "uuid",
     "model_id": "anthropic/claude-3-opus",
     "prompt_tokens": 1200,
     "completion_tokens": 850,
     "base_cost_usd": 0.015,
     "service_fee_rate": 0.20,
     "usd_to_credit_rate": 16666.67,
     "total_credits_charged": 250000
   }
   ```

### 9. 契约（OpenAPI 摘录，SSOT 见 contracts）
```yaml
openapi: 3.0.3
info: { title: Athena AI Conversations, version: 1.0.0 }
servers: [ { url: / } ]
security: [ { bearerAuth: [] } ]
tags:
  - name: ai
    description: AI对话与查询
paths:
  /api/v1/ai/available-models:
    get:
      summary: 列出可用模型（管理员启用）
      responses: { '200': { description: OK } }

  /api/v1/ai/conversations:
    get: { summary: 列出对话, responses: { '200': { description: OK } } }
    post:
      summary: 新建对话（可选上下文与模式）
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title: { type: string }
                model_id: { type: string }
                mode: { type: string, enum: [KNOWLEDGE_BASE, GENERAL], default: KNOWLEDGE_BASE, description: MVP阶段强制KNOWLEDGE_BASE，GENERAL预留不开放 }
                book_ids: { type: array, items: { type: string, format: uuid } }
      responses: { '201': { description: Created } }

  /api/v1/ai/conversations/{conversationId}/messages:
    get: { summary: 列出消息, responses: { '200': { description: OK } } }
    post:
      summary: 发送消息（知识库模式走RAG）
      parameters:
        - in: header
          name: X-Timezone
          required: false
          schema: { type: string }
        - in: header
          name: If-Match
          required: true
          schema: { type: string }
          description: 会话版本号（乐观并发控制）
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
          description: 幂等键（防重复提交）
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [content]
              properties:
                content: { type: string }
      responses: { '200': { description: OK } }

  /api/v1/ai/conversations/{conversationId}/contexts:
    put:
      summary: 覆盖对话的书籍上下文集合
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                book_ids: { type: array, items: { type: string, format: uuid } }
      responses: { '204': { description: No Content } }
```

### 10. 定时任务与一致性
- Celery 任务：每日更新模型价格与汇率（写入 `ai_models.pricing_usd` 与 `currencies.rate_to_base`）。
- 失败与告警：连续失败报警（Prometheus + Alertmanager），日志入 Loki，错误捕获 Sentry。
- 合规与审计：所有上游调用携带 `user_id`（Custom-Id/user 字段）；对话与消费记录写入 `audit_logs`；链路追踪 Jaeger。
| INDEX | (user_id, source_type, source_id) | |

#### **18.1. shared_vectors (共享向量池表)（新增）**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| file_fingerprint | TEXT | 源文件指纹（SHA256），NOT NULL, INDEX |
| chunk_index | INTEGER | 片段索引，NOT NULL |
| vector | VECTOR(1536) | 使用pgvector类型，NOT NULL |
| text_snippet | TEXT | 原始文本片段，NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| UNIQUE | (file_fingerprint, chunk_index) | 保证同一文件相同片段唯一 |

**（补充）pgvector 索引选型与参数建议（新增）**
- **IVFFLAT（大规模召回）**：
  ```sql
  CREATE INDEX CONCURRENTLY idx_shared_vectors_ivfflat ON shared_vectors USING ivfflat (vector) WITH (lists = 100);
  -- 列表数量 lists ≈ N/1000（按数据规模调整）；建索引前务必 ANALYZE
  ```
- **HNSW（高精度与低延迟）**：
  ```sql
  CREATE INDEX CONCURRENTLY idx_vectors_hnsw ON vectors USING hnsw (vector) WITH (m = 16, ef_construction = 128);
  -- 查询时可设置 SET hnsw.ef_search = 64; 以优化召回
  ```
- **过滤与排序**：优先按 `user_id` 过滤，再执行向量检索；避免跨用户全表 ANN。
- **维护建议**：批量导入后 `VACUUM (ANALYZE) vectors;`；定期重建索引以维持召回质量。
 - **运维规范（新增）**：纳入周期性 `VACUUM (ANALYZE)` 与必要时 `REINDEX`；监控索引膨胀与统计信息；大批量写入后执行 `ANALYZE` 并评估 `lists/m` 参数是否需要调整。

#### **19. vector_meta (向量元数据表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| model_name | VARCHAR(100) | PK, e.g., 'BAAI/bge-base-en-v1.5' |
| dimensions | INTEGER | 向量维度, NOT NULL |
| is_active | BOOLEAN | 是否为当前默认模型, DEFAULT TRUE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

---

### **模块四：商业与全球化**

#### **21. plans (订阅计划表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| name | VARCHAR(50) | 计划名称, UNIQUE, NOT NULL |
| is_active | BOOLEAN | 计划是否可用, NOT NULL, DEFAULT TRUE |

#### **22. currencies (货币汇率表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| code | VARCHAR(3) | PK, 货币代码 |
| rate_to_base | DECIMAL(12, 6) | 兑换到基准货币的汇率 |
| updated_at | TIMESTAMPTZ | |

#### **23. regional_prices (区域定价表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| plan_id | INTEGER | PK, FK -> plans(id) |
| country_code | VARCHAR(2) | PK, 国家代码 |
| price | DECIMAL(10,2) | 当地价格, NOT NULL, CHECK (price >= 0) |
| currency_code | VARCHAR(3) | FK -> currencies(code), NOT NULL |
| interval | VARCHAR(10) | 计费周期 ('month', 'year'), NOT NULL |

#### **24. subscriptions (用户订阅表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), UNIQUE, NOT NULL |
| regional_price_id | INTEGER | FK -> regional_prices(id), NOT NULL |
| status | VARCHAR(20) | 状态 ('ACTIVE', 'CANCELED', 'PAST_DUE') |
| start_date | TIMESTAMPTZ | |
| end_date | TIMESTAMPTZ | |
| provider | VARCHAR(50) | 支付提供商 |
| provider_subscription_id | TEXT | 来自支付提供商的订阅ID, UNIQUE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| deleted_at | TIMESTAMPTZ | NULLABLE |

#### **25. payments (支付记录表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK |
| user_id | UUID | FK -> users(id), NOT NULL |
| subscription_id | UUID | FK -> subscriptions(id), NULLABLE |
| product_type | VARCHAR(50) | 商品类型 |
| amount | DECIMAL(10,2) | 支付金额, NOT NULL, CHECK (amount >= 0) |
| currency | VARCHAR(3) | 货币, NOT NULL |
| status | VARCHAR(20) | 支付状态 ('PENDING', 'SUCCESS', 'FAILED', 'REFUNDED') |
| provider | VARCHAR(50) | 支付网关标识（如 'pingpong', 'stripe'） |
| gateway_id | INTEGER | FK -> payment_gateways(id), NOT NULL |
| provider_payment_id | TEXT | 来自支付提供商的交易ID, UNIQUE |
| payment_info | JSONB | 支付接口返回的完整信息 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

```sql
CREATE INDEX IF NOT EXISTS idx_payments_gateway ON payments (gateway_id);
```

#### **25.1 payment_gateways (支付网关注册表)（新增）**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| provider_id | VARCHAR(50) | 核心标识符，如 'pingpong', 'stripe'；与后端适配器名称一致，UNIQUE |
| friendly_name | VARCHAR(100) | 对外显示名称，如“PingPong支付”、“Stripe信用卡” |
| is_globally_active | BOOLEAN | 全局总开关；FALSE 时支付系统不可用，NOT NULL, DEFAULT TRUE |
| is_active | BOOLEAN | 单个开关；控制该网关是否对用户可见与可用，NOT NULL, DEFAULT TRUE |
| config | JSONB | 网关配置，存储 API Key、商户ID、Webhook Secret 等（加密存储） |
| weight | INTEGER | 加权轮询权重，DEFAULT 100 |

```sql
ALTER TABLE payment_gateways ENABLE ROW LEVEL SECURITY;
CREATE POLICY payment_gateways_admin ON payment_gateways FOR ALL USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');
```

#### **26. credit_products (额度商品表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| name | VARCHAR(100) | 商品名称, e.g., 'OCR 100页加油包', NOT NULL |
| credit_type | VARCHAR(50) | 额度类型, ENUM('OCR_PAGES', 'BOOK_IMPORTS'), NOT NULL |
| amount | INTEGER | 包含的额度数量, NOT NULL |
| price | DECIMAL(10, 2) | 价格, NOT NULL |
| currency_code | VARCHAR(3) | FK -> currencies(code), NOT NULL |
| is_active | BOOLEAN | 是否上架, DEFAULT TRUE |

#### **27. credit_transactions (额度流水表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| transaction_type | VARCHAR(20) | **[新增]** 交易类型, ENUM('PURCHASE', 'GRANT', 'CONSUME', 'REFUND'), NOT NULL |
| credit_type | VARCHAR(50) | 额度类型, NOT NULL |
| amount | INTEGER | **[新增]** 变动数量 (正为增加, 负为消费), NOT NULL |
| balance_after | INTEGER | **[新增]** 交易后余额, NOT NULL |
| related_entity_type | VARCHAR(50) | 关联实体类型, e.g., 'payment', 'book' |
| related_entity_id | UUID | 关联实体ID |
| details | JSONB | 详细信息, e.g., '{"pages": 15, "book_title": "..."}' |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

- **details 字段（权威定义，AI调用）**：当 `transaction_type='CONSUME'` 且 `credit_type='AI_CALL'` 时，`details` 必须采用如下结构：
  ```json
  {
    "conversation_id": "uuid",
    "model_id": "anthropic/claude-3-opus",
    "prompt_tokens": 1200,
    "completion_tokens": 850,
    "base_cost_usd": 0.015,
    "service_fee_rate": 0.20,
    "usd_to_credit_rate": 16666.67,
    "total_credits_charged": 250000
  }
  ```

#### **28. user_credits (用户额度视图) (变更)**
-   **描述:** 不再是物理表，而是基于 `credit_transactions` 的物化视图，用于高性能查询。
-   **定义:**
    ```sql
    CREATE MATERIALIZED VIEW user_credits_mv AS
    SELECT
      user_id,
      SUM(CASE WHEN credit_type = 'OCR_PAGES' THEN amount ELSE 0 END) AS ocr_credits,
      SUM(CASE WHEN credit_type = 'BOOK_IMPORTS' THEN amount ELSE 0 END) AS book_import_credits
    FROM credit_transactions
    GROUP BY user_id;
    CREATE UNIQUE INDEX ON user_credits_mv (user_id);
    ```

- **刷新策略（新增）**：
  - 触发器在 `credit_transactions` 上 `AFTER INSERT OR UPDATE OR DELETE` 调用 `REFRESH MATERIALIZED VIEW CONCURRENTLY user_credits_mv;`，保障近实时一致性且不阻塞读写。
  - 示例：
    ```sql
    CREATE OR REPLACE FUNCTION refresh_user_credits_mv() RETURNS trigger AS $$
    BEGIN
      PERFORM pg_try_advisory_lock(12345); -- 避免并发刷新冲突（示例）
      REFRESH MATERIALIZED VIEW CONCURRENTLY user_credits_mv;
      PERFORM pg_advisory_unlock(12345);
      RETURN NULL;
    END;
    $$ LANGUAGE plpgsql;

    DROP TRIGGER IF EXISTS trg_refresh_user_credits_mv ON credit_transactions;
    CREATE TRIGGER trg_refresh_user_credits_mv
    AFTER INSERT OR UPDATE OR DELETE ON credit_transactions
    FOR EACH STATEMENT EXECUTE FUNCTION refresh_user_credits_mv();
    ```

#### **29. languages (支持语言表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| code | VARCHAR(10) | PK, 语言代码 |
| name | VARCHAR(50) | 语言名称 |
| is_active | BOOLEAN | 是否启用, NOT NULL, DEFAULT TRUE |

```sql
ALTER TABLE languages ENABLE ROW LEVEL SECURITY;
CREATE POLICY languages_admin ON languages FOR ALL USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');
```

#### **30. translations (翻译文本表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | BIGSERIAL | PK |
| lang_code | VARCHAR(10) | FK -> languages(code) |
| key | TEXT | 翻译键 |
| value | TEXT | 翻译后的文本 |
| UNIQUE | (lang_code, key) | |

```sql
CREATE INDEX IF NOT EXISTS idx_translations_lang ON translations(lang_code);
CREATE INDEX IF NOT EXISTS idx_translations_key ON translations(key);
ALTER TABLE translations ENABLE ROW LEVEL SECURITY;
CREATE POLICY translations_admin ON translations FOR ALL USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');
```

---

### **模块五：后端服务与运营**

#### **31. audit_logs (审计日志表) (优化)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | BIGSERIAL | PK |
| user_id | UUID | 操作者ID, INDEX |
| action | VARCHAR(100) | 操作类型, NOT NULL |
| entity_type | VARCHAR(50) | 被操作的实体类型 |
| entity_id | UUID | 被操作的实体ID |
| details | JSONB | 操作详情 |
| ip_address | INET | IP地址 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
-   **说明:** **使用 `pg_partman` 按 `created_at` 自动分区。**

#### **32. background_job_logs (后台任务日志表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, 任务ID |
| task_name | VARCHAR(255) | 任务名称 |
| status | VARCHAR(20) | 任务状态 |
| result | JSONB | 任务成功时的返回结果 |
| exception_info | TEXT | 任务失败时的异常信息 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| finished_at | TIMESTAMPTZ | |

#### **33. feature_flags (功能开关表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| name | VARCHAR(100) | 功能的唯一名称, UNIQUE |
| is_active | BOOLEAN | 是否全局开启, DEFAULT false |
| description | TEXT | 功能描述 |

#### **34. user_feature_flags (用户特定功能开关表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| user_id | UUID | PK, FK -> users(id) |
| feature_id | INTEGER | PK, FK -> feature_flags(id) |
| is_active | BOOLEAN | 对该用户是否开启 |

#### **35. ai_prompt_templates (AI提示词模板表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| name | VARCHAR(100) | 模板唯一名称, UNIQUE |
| template_content | TEXT | Prompt模板内容 |
| version | INTEGER | 版本号, DEFAULT 1 |
| is_active | BOOLEAN | 是否为当前激活的模板, DEFAULT TRUE |
| created_at | TIMESTAMPTZ | |
| updated_at | TIMESTAMPTZ | |

#### **36. user_onboarding_progress (新用户引导进度表)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| user_id | UUID | PK, FK -> users(id) |
| steps_completed | JSONB | 记录已完成的步骤 |
| updated_at | TIMESTAMPTZ | |

#### **37. user_reading_goals (用户阅读目标表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id), NOT NULL |
| goal_period | VARCHAR(10) | 目标周期, ENUM('DAILY', 'YEARLY'), NOT NULL |
| goal_type | VARCHAR(20) | 目标类型, ENUM('READING_MINUTES', 'BOOKS_COUNT'), NOT NULL |
| target_value | INTEGER | 目标值, NOT NULL |
| is_active | BOOLEAN | 是否启用, DEFAULT TRUE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

#### **38. user_daily_reading_stats (用户每日阅读统计表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| user_id | UUID | PK, FK -> users(id) |
| date | DATE | PK, NOT NULL |
| total_seconds_read | BIGINT | 当日总阅读时长(秒), DEFAULT 0 |
| books_finished | INTEGER | 当日读完的书籍数, DEFAULT 0 |
| notes_created | INTEGER | 当日创建的笔记数, DEFAULT 0 |
| highlights_created | INTEGER | 当日创建的高亮数, DEFAULT 0 |
| ai_queries_made | INTEGER | 当日AI提问次数, DEFAULT 0 |

#### **39. srs_reviews (智能复习表) (统一)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id), NOT NULL |
| source_type | VARCHAR(20) | ENUM('NOTE','HIGHLIGHT'), NOT NULL |
| source_id | UUID | 复习来源资源ID, NOT NULL |
| rating | INTEGER | 复习质量 (0-5), NOT NULL |
| ease_factor | FLOAT | 易度因子, DEFAULT 2.5 |
| interval_days | INTEGER | 复习间隔(天), DEFAULT 1 |
| repetitions | INTEGER | 复习次数, DEFAULT 0 |
| next_review_at | TIMESTAMPTZ | 下次复习时间, NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

#### **40. ai_usage_logs (AI使用日志表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| user_id | UUID | FK -> users(id), NOT NULL, INDEX |
| session_id | UUID | 会话ID, FK -> ai_conversations(id), NULLABLE |
| query_type | VARCHAR(50) | 查询类型, ENUM('CHAT', 'SUMMARIZE', 'EXPLAIN', 'SEARCH'), NOT NULL |
| input_tokens | INTEGER | 输入Token数量, NOT NULL |
| output_tokens | INTEGER | 输出Token数量, NOT NULL |
| model_name | VARCHAR(100) | 使用的AI模型, NOT NULL |
| response_time_ms | INTEGER | 响应时间(毫秒), NOT NULL |
| cost_usd | DECIMAL(10, 6) | 成本(美元), NOT NULL |
| cache_hit | BOOLEAN | 是否命中缓存, DEFAULT FALSE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| INDEX | (user_id, created_at DESC) | |
| INDEX | (model_name, created_at DESC) | |

#### **41. ai_query_cache (AI查询缓存表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| query_hash | VARCHAR(64) | 查询内容的SHA256哈希, UNIQUE, NOT NULL |
| query_type | VARCHAR(50) | 查询类型, ENUM('CHAT', 'SUMMARIZE', 'EXPLAIN', 'SEARCH'), NOT NULL |
| model_name | VARCHAR(100) | 使用的AI模型, NOT NULL |
| response_content | TEXT | AI响应内容, NOT NULL |
| input_tokens | INTEGER | 输入Token数量, NOT NULL |
| output_tokens | INTEGER | 输出Token数量, NOT NULL |
| hit_count | INTEGER | 缓存命中次数, DEFAULT 1 |
| last_hit_at | TIMESTAMPTZ | 最后一次命中时间 |
| expires_at | TIMESTAMPTZ | 缓存过期时间, NOT NULL |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| INDEX | (query_hash, model_name) | |
| INDEX | (expires_at) | |

#### **42. note_versions (笔记版本历史表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | UUID | PK, DEFAULT `uuid_generate_v4()` |
| note_id | UUID | FK -> notes(id) ON DELETE CASCADE, NOT NULL, INDEX |
| version_number | INTEGER | 版本号, NOT NULL |
| title | TEXT | 笔记标题 |
| content_markdown | TEXT | 笔记内容 |
| change_summary | TEXT | 变更摘要 |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| UNIQUE | (note_id, version_number) | |
| INDEX | (note_id, created_at DESC) | |

#### **43. idempotency_keys (幂等键表) (新增)**
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| key | VARCHAR(64) | PK，客户端幂等键，UNIQUE |
| user_id | UUID | FK -> users(id), NOT NULL |
| request_hash | VARCHAR(64) | 请求体哈希，NOT NULL |
| method | VARCHAR(10) | HTTP方法，NOT NULL |
| route | TEXT | 路由路径，NOT NULL |
| response_status | INTEGER | 响应状态码，NOT NULL |
| response_body | TEXT | 响应体副本（必要时存摘要），NULLABLE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| expires_at | TIMESTAMPTZ | 过期时间，索引 |
| INDEX | (user_id, expires_at) | |

---

## **《“雅典娜计划”AI知识内化引擎技术规范 v7.0》**

### **核心架构**

#### **1. AI服务架构**
- **模型层**：主接入 OpenRouter（路由聚合），支持多模型（Anthropic、OpenAI、DeepSeek 等）；Embedding 维持 Qwen-Embedding。
- **缓存层**: Redis实现查询结果缓存，降低API调用成本
- **限流层**: 基于用户和订阅级别的智能限流
- **监控层**: 实时监控API调用成本和响应时间

#### **2. 成本控制机制**
- **Token预算**: 根据用户订阅级别设置每日/每月Token使用上限
- **智能缓存**: 对相似查询进行缓存，减少重复API调用
- **模型选择**: 根据查询复杂度动态选择最适合的模型
- **成本预警**: 当用户接近预算上限时发送预警通知

#### **3. 滥用防御机制**
- **速率限制**: 基于用户、IP和设备的多维度速率限制
- **异常检测**: 识别异常查询模式，如大量重复查询或异常长查询
- **内容过滤**: 对输入内容进行安全过滤，防止恶意使用
- **黑名单机制**: 对违规用户实施临时或永久封禁

### **API设计规范**


### **开发规则**

#### **1. 查询优化**
- **预处理**: 对用户查询进行预处理，去除无关字符和格式
- **上下文限制**: 限制每次查询的上下文长度，避免Token超限
- **批量处理**: 对多个相关查询进行批量处理，提高效率
- **异步处理**: 对耗时查询采用异步处理，提升用户体验

#### **2. 缓存策略**
- **查询哈希**: 对查询内容进行哈希，实现精确缓存匹配
- **语义相似**: 对语义相似的查询实现模糊缓存匹配
- **分层缓存**: 实现内存缓存和持久化缓存的分层架构
- **缓存更新**: 定期更新缓存，确保内容时效性

##### **2.1 语义缓存实现（新增）**
- **签名组成**：`query_type + normalized_text + language + model_name + top_k + scope(bookIds/tags)`。
- **语义匹配流程**：
  1. 计算查询嵌入（Embedding）。
  2. 在 `vectors` 中按 `user_id` 过滤后进行 ANN 检索（HNSW 或 IVFFLAT）。
  3. 若最高相似度 ≥ `0.92` 且上下文来源（书籍/笔记）集合一致，则判定为“语义重复”。
  4. 命中 `ai_query_cache`：返回缓存响应并刷新 `last_hit_at`、`hit_count`。
- **TTL 与失效**：
  - 普通查询默认 TTL 24h，摘要类 12h，检索类 6h。
  - 发生笔记/高亮更新或重新索引时，找出受影响的 `vectors.source_id`，对应的缓存条目立即设置 `expires_at = now()`。
- **伪代码**：
  ```ts
  const sig = buildSignature(query)
  const hash = sha256(sig)
  const exact = db.cache.findByHash(hash)
  if (exact && exact.expires_at > now()) return exact
  const emb = embed(query.text)
  const neighbors = annSearch(userId, emb, topK)
  if (neighbors.maxSim >= 0.92 && scopeEquals(neighbors.scope, query.scope)) {
    const semantic = db.cache.findSimilar(neighbors.key)
    if (semantic && semantic.expires_at > now()) return semantic
  }
  const fresh = callAI(query)
  db.cache.upsert({ hash, response: fresh, ttl })
  return fresh
  ```
- **可观测性**：在 `ai_usage_logs` 记录 `cache_hit`、`response_time_ms`；仪表盘展示语义命中率与节省成本。

#### **3. 错误处理**
- **优雅降级**: 当AI服务不可用时，提供基础功能替代方案
- **错误分类**: 对不同类型的错误进行分类处理
- **重试机制**: 对临时性错误实现智能重试
- **用户反馈**: 收集用户对AI响应质量的反馈，持续优化

#### **4. 一致性与读隔离与缓存智能失效（新增）**
- **冲突域定义**：以资源为单位进行一致性控制（`notes`、`highlights`、`vectors.source_id`）。每个笔记的协同文档（Yjs Doc）维护单调递增的“修订号”（可映射到 `note_versions.version_number`），作为上下文快照的基线。
- **读隔离策略（AI读取）**：
  - 采用“快照读”+“提交栅栏”模型：当 Yjs 有编辑事件，服务端在 1.5s 安静窗口后生成快照（`context_revision`），AI仅在快照上运行，避免读到半成品。
  - 允许“可控陈旧度”：响应中携带 `stale_by_ms`（如 ≤ 3000ms），前端以 Banner 提示“基于最近快照的结果”。若用户需要最新内容，提供“一键重新总结”。
  - 并发检测：若客户端携带的 `X-Context-Revision` 与服务端最新修订不一致且偏差 > 10s，返回 `409 CONTEXT_STALE`，指引前端刷新上下文或后台重新生成。
- **语义签名扩展**：在“2.1 语义缓存实现”的签名中加入 `context_revision_set(noteId->version)`，确保缓存与阅读上下文一致。
- **智能失效（精确+合并）**：
  - 精确失效：Yjs 编辑事件生成受影响集合 `affected = {note_ids, highlight_ids}`，找出对应 `vectors.source_id` 与 `ai_query_cache` 条目，立即设置 `expires_at = now()`。
  - 演化失效：对“轻微改动”采用缩短TTL而非立即清空，依据“嵌入漂移阈值（embedding drift）”判定：`sim(prev_emb, next_emb) < 0.82` 则立即失效，否则将 TTL 减半。
  - 合并写入：在 1-2s 内高频编辑仅合并一次索引与失效操作，降低抖动与重建开销。
- **接口协同**：
  - 请求头：`X-Context-Revision: noteId=version,...`；响应头：`X-Context-Revision-Applied` 与可选 `X-Stale-By-Ms`。
  - 错误码：`CONTEXT_STALE`（409）、`CONTEXT_NOT_FOUND`（404），前端用“全局反馈”规范展示错误与重试。
- **可观测性**：在 `ai_usage_logs` 记录 `cache_hit`、`stale_by_ms`、`reindex_latency_ms`；仪表盘展示“失效触发来源（Yjs/手动/索引重建）”与“嵌入漂移分布”。
- **伪代码（服务端）**：
  ```ts
  function handleAIQuery(req: Query) {
    const ctxRev = parseHeader(req.headers['X-Context-Revision']) // noteId->version
    const latestRev = getLatestRevision(req.scope) // from note_versions / yjs clock
    if (diffTooLarge(ctxRev, latestRev, 10_000)) {
      return http409('CONTEXT_STALE')
    }
    const sig = buildSignature(req, ctxRev)
    const hash = sha256(sig)
    const exact = cache.find(hash)
    if (exact && exact.expires_at > now()) {
      return withHeaders(exact.response, { 'X-Context-Revision-Applied': serialize(ctxRev), 'X-Stale-By-Ms': 0 })
    }
    const result = callAI(snapshot(req.scope, ctxRev))
    cache.upsert({ hash, response: result, ttl: pickTtl(req) })
    return withHeaders(result, { 'X-Context-Revision-Applied': serialize(ctxRev) })
  }
  
  function onYjsEdit(event) {
    const affected = collectAffected(event) // note_ids, highlight_ids
    const drift = embeddingDrift(affected)
    const keys = cache.findByContext(affected)
    for (const k of keys) {
      if (drift[k] < 0.82) expireNow(k)
      else shortenTtl(k, 0.5)
    }
    scheduleReindexCoalesced(affected, 1500)
  }
  ```

### **性能指标**

#### **1. 响应时间**
- **简单查询**: < 2秒
- **复杂查询**: < 5秒
- **缓存命中**: < 500毫秒

#### **2. 成本控制**
- **免费用户**: 每日最多1000 Tokens
- **基础订阅**: 每日最多10000 Tokens
- **高级订阅**: 每日最多50000 Tokens

#### **3. 可用性**
- **服务可用性**: > 99.9%
- **缓存命中率**: > 60%
- **错误率**: < 0.1%

#### **4. SLO/SLI 与错误预算（新增）**
- 核心 API P95 延迟：≤ 800ms；峰值下不超过 1200ms。
- 月度可用性：≥ 99.9%；错误率：≤ 0.1%。
- 错误预算：按月计算；预算耗尽时暂停非必要发布，进行稳定性修复。

---

## **《AI 垂直切片（Query & Save Conversation）可执行规范（新增）》**

### 1. 数据库 DDL / RLS / 索引（v1）
- 前置：`ai_conversations`、`vectors`、`ai_usage_logs`、`ai_query_cache`、`idempotency_keys` 已定义。
- 字段修正（新增）：
  - `ai_conversations.version INTEGER NOT NULL DEFAULT 1`（乐观并发控制）。
  - 索引：`CREATE INDEX CONCURRENTLY idx_ai_conversations_user_created_at ON ai_conversations(user_id, created_at DESC);`
- RLS 策略（按用户隔离）：
  ```sql
  ALTER TABLE ai_conversations ENABLE ROW LEVEL SECURITY;
  CREATE POLICY ai_conversations_select ON ai_conversations
    FOR SELECT USING (user_id = current_setting('app.user_id')::uuid);
  CREATE POLICY ai_conversations_insert ON ai_conversations
    FOR INSERT WITH CHECK (user_id = current_setting('app.user_id')::uuid);
  CREATE POLICY ai_conversations_update ON ai_conversations
    FOR UPDATE USING (user_id = current_setting('app.user_id')::uuid);
  CREATE POLICY ai_conversations_delete ON ai_conversations
    FOR DELETE USING (user_id = current_setting('app.user_id')::uuid);
  -- 服务层每次请求：SET LOCAL app.user_id = '<uuid>'
  ```
- 幂等：所有写操作支持 `Idempotency-Key`；记录至 `idempotency_keys`。
- 一致性：响应携带 `ETag`（来源 `version`）；客户端更新使用 `If-Match`，冲突返回 `409 CONFLICT`。

### 2. REST API 契约（OpenAPI 3.0）
- 路径：新增 `contracts/api/v1/ai.yaml`（概要如下）。
 - 接口裁剪：废弃 `/api/v1/ai/query`；统一通过 `POST /api/v1/ai/conversations` 新建（可为临时会话）+ `POST /api/v1/ai/conversations/{id}/messages` 追加消息。后台定时清理仅一轮的临时会话。

```yaml
openapi: 3.0.3
info:
  title: Athena AI
  version: 1.0.0
paths:
  /api/v1/ai/conversations:
    get:
      summary: 列出会话
      parameters:
        - in: query
          name: cursor
          schema: { type: string }
        - in: query
          name: limit
          schema: { type: integer, default: 20, maximum: 100 }
      responses:
        '200':
          description: OK
    post:
      summary: 创建会话并保存首条消息
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [title, first_message]
              properties:
                title: { type: string }
                related_context: { type: object }
                first_message:
                  type: object
                  properties:
                    role: { type: string, enum: [user] }
                    text: { type: string }
                    refs:
                      type: array
                      items:
                        type: object
                        properties:
                          type: { type: string, enum: [highlight, note, location] }
                          cfi: { type: string }
                          bookId: { type: string, format: uuid }
      responses:
        '201': { description: Created }

  /api/v1/ai/conversations/{id}:
    get:
      summary: 获取会话详情
      responses:
        '200':
          description: OK
          headers:
            ETag: { schema: { type: string } }
    patch:
      summary: 修改标题或附加元数据
      parameters:
        - in: header
          name: If-Match
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title: { type: string }
                related_context: { type: object }
      responses:
        '200': { description: OK, headers: { ETag: { schema: { type: string } } } }
        '409': { description: 版本冲突 }
    delete:
      summary: 软删除会话
      parameters:
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      responses:
        '204': { description: No Content }

  /api/v1/ai/conversations/{id}/messages:
    post:
      summary: 追加消息（可触发流式回复）
      parameters:
        - in: header
          name: If-Match
          schema: { type: string }
        - in: header
          name: Idempotency-Key
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [message]
              properties:
                message:
                  type: object
                  properties:
                    role: { type: string, enum: [user, assistant] }
                    text: { type: string }
                    refs:
                      type: array
                      items:
                        type: object
                        properties:
                          type: { type: string, enum: [highlight, note, location] }
                          cfi: { type: string }
                          bookId: { type: string, format: uuid }
                streaming: { type: boolean, default: true }
      responses:
        '202': { description: 流式SSE }
        '200': { description: 非流式 }
        '409': { description: 版本冲突 }
```

### 3. 后端逻辑伪代码（FastAPI/SQLAlchemy）
```python
# 统一通过会话+消息端点触发AI（已移除一次性查询模式）

async def create_conversation(user_id, body, idempo_key):
    set_local_app_user(user_id)
    prev = await get_idempo(idempo_key, user_id, 'POST', '/api/v1/ai/conversations')
    if prev: return prev.response
    conv_id = uuid4()
    q = ai_conversations.insert().values({
        'id': conv_id,
        'user_id': user_id,
        'title': body['title'],
        'related_context': body.get('related_context'),
        'conversation_history': json.dumps([body['first_message']]),
        'version': 1
    }).returning(ai_conversations.c.id)
    row = await db.fetch_one(q)
    await put_idempo(db, idempo_key, user_id, 'POST', '/api/v1/ai/conversations', body, 201, {'id': row.id})
    return JSONResponse({'id': row.id}, status_code=201)

async def append_message(user_id, conv_id, msg, if_match_version, idempo_key, streaming):
    set_local_app_user(user_id)
    conv = await get_conversation(conv_id)
    if not conv: raise HTTPException(404)
    if if_match_version and int(if_match_version) != conv.version:
        raise HTTPException(409, detail={'code': 'VERSION_CONFLICT'})
    prev = await get_idempo(idempo_key, user_id, 'POST', f'/api/v1/ai/conversations/{conv_id}/messages')
    if prev: return prev.response

    hist = json.loads(conv.conversation_history)
    hist.append(msg)
    q = ai_conversations.update().where(ai_conversations.c.id == conv_id).values({
        'conversation_history': json.dumps(hist),
        'version': conv.version + 1,
        'updated_at': sa.func.now()
    }).returning(ai_conversations.c.version)
    new_ver = (await db.fetch_one(q)).version

    if msg['role'] == 'user':
        # 触发AI回复
        req = build_req_from_hist(hist)
        return await handle_ai_query(req, user_id) if streaming else await handle_ai_query(req, user_id)
    else:
        return JSONResponse({'version': new_ver})
```

### 4. 前端契约与交互
- 组件：`AIPanelProps`（已在示例中定义），补充：
  - 新增 `onStream(event)` 用于接收 `meta|delta|done|error`。
  - 会话资源使用 `ETag`，更新时携带 `If-Match`。
- 交互流程：
  - 发起查询：优先 SSE 流式；失败或不支持降级为非流式一次性响应。
  - 引用联动：AI输出中的引用点击后触发阅读器跳转与高亮。
  - 冲突处理：`409 VERSION_CONFLICT` 弹窗提示并自动刷新会话后重试追加消息。
  - 预算与节流：顶部显示当日 Token 使用与速率限制提示；到阈值降级为检索或摘要模式。

### 5. 合同测试与 E2E（必测）
- 合同测试：
  - `POST /ai/conversations`：幂等键重放返回 `201` 同一ID；RLS 隔离（跨用户不可见）。
  - `POST /ai/conversations/{id}/messages`：`If-Match` 错误返回 `409`；正确时 `version` 递增。
  - 读隔离：提供过期 `X-Context-Revision` 返回 `409 CONTEXT_STALE`。
  - 预算/限流：达到阈值返回 `429`，响应头含剩余配额提示。
- E2E 场景：
  - 成功对话：创建会话→用户消息→SSE 流式回复→保存至历史，引用可点击跳转。
  - 缓存命中：重复同签名查询 < TTL，首包在 500ms 内返回；`X-Cache-Hit: true`。
  - 并发冲突：两个客户端同时追加消息，第二个收到 `409` 后刷新ETag并重试成功。
  - 语义失效：编辑笔记触发向量更新后，相关缓存 `expires_at=now()`，重新查询命中新结果。

### 6. CI Gate
- OpenAPI 契约验证（`contracts/api/v1/ai.yaml`）。
- 迁移脚本校验：`ai_conversations.version` 增量迁移与 RLS 策略应用。
- 覆盖率：总覆盖率 ≥ 85%，改动文件 ≥ 80%。
- E2E 冒烟：SSE 流式、幂等、RLS、读隔离各一条用例必须通过。

### 7. 生成与集成建议
- SDK 生成：基于 `ai.yaml` 生成前后端模型与路由骨架；SSE 客户端封装。
- 模型选择策略：按 `query_type` 与预算动态选择（fast/default/accurate）。
- 缓存层：`ai_query_cache` 作为持久层，Redis 作为热层；签名包含 `context_revision_set`。
- 观测性：`ai_usage_logs` 汇总展示缓存命中率、平均响应时间与成本节省。

—— 以上规范与既有章节（语义缓存、一致性与读隔离等）保持一致，新增的 `version`、RLS 与契约细节用于落地 AI 会话保存与查询流程。


## **《Notes 垂直切片（Create & Read）可执行规范（新增）》**

### **1. 数据库 DDL / RLS / 索引（v1）**
- **执行前置**：已启用扩展 `uuid-ossp`, `pg_trgm`, `vector`；`notes` 表与 `trg_notes_tsvector` 触发器已存在。
- **RLS 策略**：按用户隔离；服务层每次请求必须执行：`SET LOCAL app.user_id = '<uuid>'`。

```sql
-- Notes RLS 与索引（v1）
ALTER TABLE public.notes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS notes_select ON public.notes;
CREATE POLICY notes_select ON public.notes
FOR SELECT
USING (user_id = current_setting('app.user_id')::uuid);

DROP POLICY IF EXISTS notes_insert ON public.notes;
CREATE POLICY notes_insert ON public.notes
FOR INSERT
WITH CHECK (user_id = current_setting('app.user_id')::uuid);

DROP POLICY IF EXISTS notes_update ON public.notes;
CREATE POLICY notes_update ON public.notes
FOR UPDATE
USING (user_id = current_setting('app.user_id')::uuid)
WITH CHECK (user_id = current_setting('app.user_id')::uuid);

DROP POLICY IF EXISTS notes_delete ON public.notes;
CREATE POLICY notes_delete ON public.notes
FOR DELETE
USING (user_id = current_setting('app.user_id')::uuid);

-- 索引优化（Cursor 分页 + 常用过滤）
CREATE INDEX IF NOT EXISTS idx_notes_user_created_desc
  ON public.notes (user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_notes_book_created_desc
  ON public.notes (book_id, created_at DESC);

-- 全文检索列索引（与触发器配合）
CREATE INDEX IF NOT EXISTS idx_notes_tsvector
  ON public.notes USING GIN (content_tsvector);
```

- **版本历史（服务层约定）**：创建笔记后同步写入 `note_versions(version_number=1)`，不使用数据库触发器，以保持与幂等重放一致。

---

### **2. REST API 契约（OpenAPI 3.0）**
- **路径**：生成文件至 `contracts/api/v1/notes.yaml`。
- **安全**：`JWT`（`Authorization: Bearer <token>`），范围 `notes:read/notes:write`。

```yaml
openapi: 3.0.3
info:
  title: Athena REST API v1 - Notes Slice
  version: 1.0.0
servers:
  - url: https://api.athena.local
    description: Local
  - url: https://api.athena.app
    description: Prod
security:
  - bearerAuth: []
paths:
  /api/v1/notes:
    post:
      operationId: createNote
      summary: Create a note
      description: 创建笔记，支持 Idempotency-Key 幂等重放。
      security:
        - bearerAuth: []
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema:
            type: string
            maxLength: 64
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateNoteRequest'
            examples:
              valid:
                value:
                  title: "读书摘要"
                  content_markdown: "内容..."
                  book_id: "11111111-1111-1111-1111-111111111111"
                  chapter: "Chapter 3"
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Note'
        '409':
          description: Conflict due to idempotency
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: Unauthorized
        '403':
          description: Forbidden
    get:
      operationId: listNotes
      summary: List notes
      description: 查询笔记列表，支持全文检索与筛选。
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: book_id
          schema:
            type: string
            format: uuid
        - in: query
          name: tag_id
          schema:
            type: string
            format: uuid
        - in: query
          name: search
          schema:
            type: string
            maxLength: 200
        - in: query
          name: chapter
          schema:
            type: string
            maxLength: 255
        - in: query
          name: cursor
          schema:
            type: string
        - in: query
          name: limit
          schema:
            type: integer
            minimum: 1
            maximum: 50
            default: 20
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListNotesResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '401':
          description: Unauthorized
        '403':
          description: Forbidden
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Note:
      type: object
      required: [id, content_markdown, version, created_at, updated_at]
      properties:
        id: { type: string, format: uuid }
        book_id: { type: string, format: uuid, nullable: true }
        highlight_id: { type: string, format: uuid, nullable: true }
        title: { type: string, nullable: true }
        content_markdown: { type: string }
        chapter: { type: string, nullable: true }
        version: { type: integer }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
    CreateNoteRequest:
      type: object
      required: [content_markdown]
      properties:
        title: { type: string, nullable: true, maxLength: 500 }
        content_markdown: { type: string }
        book_id: { type: string, format: uuid, nullable: true }
        highlight_id: { type: string, format: uuid, nullable: true }
        chapter: { type: string, nullable: true, maxLength: 255 }
    ListNotesResponse:
      type: object
      required: [items]
      properties:
        items:
          type: array
          items:
            $ref: '#/components/schemas/Note'
        next_cursor:
          type: string
          nullable: true
    Error:
      type: object
      required: [code, message]
      properties:
        code: { type: string }
        message: { type: string }
```

- **错误码映射**：`INVALID`(400)、`IDEMPOTENT_CONFLICT`(409)、`UNAUTHORIZED`(401)、`FORBIDDEN`(403)。

---

### **3. 后端逻辑伪代码（FastAPI + SQLAlchemy 2.0, 异步）**
- **依赖**：`db_session`、`current_user_id`、`idempotency_store`、`notes`、`note_versions` ORM 映射。

```python
# create_note
async def create_note(req, user_id, db, idem_store):
    if not req.content_markdown or not req.content_markdown.strip():
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"content_markdown required"})

    idem_key = req.headers.get("Idempotency-Key")
    if not idem_key:
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"Idempotency-Key required"})

    prev = await idem_store.find(idem_key, user_id, hash_body(req))
    if prev:
        if prev.response_status == 201:
            return prev.response_body
        raise HTTPException(status_code=409, detail={"code":"IDEMPOTENT_CONFLICT","message":"duplicate request"})

    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    note_id = uuid4()
    now = datetime.utcnow().replace(tzinfo=timezone.utc)
    await db.execute(sa.insert(notes).values({
        "id": note_id,
        "user_id": user_id,
        "book_id": req.book_id,
        "highlight_id": req.highlight_id,
        "title": req.title,
        "content_markdown": req.content_markdown,
        "chapter": req.chapter,
        "created_at": now,
        "updated_at": now,
    }))

    await db.execute(sa.insert(note_versions).values({
        "id": uuid4(),
        "note_id": note_id,
        "version_number": 1,
        "title": req.title,
        "content_markdown": req.content_markdown,
        "change_summary": "initial create",
        "created_at": now,
    }))

    body = {
        "id": str(note_id),
        "book_id": req.book_id,
        "highlight_id": req.highlight_id,
        "title": req.title,
        "content_markdown": req.content_markdown,
        "chapter": req.chapter,
        "version": 1,
        "created_at": now.isoformat(),
        "updated_at": now.isoformat(),
    }
    await idem_store.save(idem_key, user_id, hash_body(req), 201, body)
    return body


# get_notes
async def get_notes(params, user_id, db):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    q = sa.select(notes).where(notes.c.user_id == user_id).where(notes.c.deleted_at.is_(None))
    if params.book_id:
        q = q.where(notes.c.book_id == params.book_id)
    if params.chapter:
        q = q.where(notes.c.chapter == params.chapter)
    if params.tag_id:
        q = q.join(note_tags, note_tags.c.note_id == notes.c.id).where(note_tags.c.tag_id == params.tag_id)
    if params.search:
        q = q.where(notes.c.content_tsvector.op('@@')(sa.func.plainto_tsquery('simple', params.search)))

    q = q.order_by(notes.c.created_at.desc())
    q = apply_cursor(q, params.cursor, params.limit or 20)
    rows = await db.fetch_all(q)

    return {
        "items": [serialize_note(r) for r in rows],
        "next_cursor": next_cursor_of(rows)
    }
```

- **错误映射**：校验失败 → 400；幂等冲突 → 409；鉴权失败 → 401/403；RLS 拒绝（无权）→ 403。

---

### **4. 前端组件契约与页面组装（React + TypeScript）**
- **接口契约**：

```ts
export interface NoteListItemProps {
  id: string;
  title?: string;
  excerpt: string;
  bookTitle?: string;
  chapter?: string;
  updatedAt: string;
}

export interface NoteListProps {
  items: NoteListItemProps[];
}

type CreateNoteRequest = {
  title?: string;
  content_markdown: string;
  book_id?: string;
  highlight_id?: string;
  chapter?: string;
};

function NotesPage() {
  const [filters, setFilters] = useNotesStore();
  const { data, isLoading, isError } = useQuery({
    queryKey: ['notes', filters],
    queryFn: () => api.get('/api/v1/notes', { params: filters }).then(r => r.data),
  });

  const mutation = useMutation({
    mutationFn: (payload: CreateNoteRequest) =>
      api.post('/api/v1/notes', payload, { headers: { 'Idempotency-Key': crypto.randomUUID() } })
        .then(r => r.data),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['notes'] }),
  });

  // 渲染分支：Skeleton / Error / Empty / List
}
```

- **可访问性基线**：创建成功后将焦点移动至新项；列表项采用语义标签与可见焦点环；键盘支持（上下选择、回车打开）。

---

### **5. 契约测试与 E2E 冒烟（CI 门禁）**
- **契约测试（Jest/Pact）**：
  - POST `/api/v1/notes`：
    - 缺少 `Idempotency-Key` → 400。
    - 合法创建 → 201，返回对象字段齐全；`note_versions` 产生版本 1。
    - 相同幂等键重复 → 409，并不重复插入。
  - GET `/api/v1/notes`：
    - 基于 `cursor` 的分页、`search` 命中 `content_tsvector`、权限边界不泄露他人数据。

- **E2E 冒烟（Playwright）**：登录 → 进入“笔记” → 新建 → 列表出现新笔记 → 翻页与检索校验；耗时 ≤ 3 分钟。

- **门禁集成**：与“11.9 发布质量门禁”一致，新增：
  - OpenAPI 校验：`contracts/api/v1/notes.yaml` 必须通过架构校验。
  - 迁移脚本检查：RLS/索引执行不报错（在临时数据库）。
  - 覆盖率阈值：新增代码总体 ≥ 85%，变更文件 ≥ 80%。

---

### **6. 生成路径建议（供代码生成器使用）**
- `contracts/api/v1/notes.yaml`（自动生成前后端 SDK）
- `migrations/2025xxxx_notes_rls_indexes.sql`（数据库迁移脚本）
- `contracts/logic/notes.md`（服务端伪代码，驱动实现）
- `contracts/ui/notes.md`（组件与页面契约）
- `contracts/tests/notes.md`（契约测试与 E2E 用例纲要）

---

## **《Notes 垂直切片（Update & Delete）可执行规范（新增）》**

### **1. 数据库 DDL 与并发控制（v1）**
- **变更**：为 `notes` 表新增 `version INTEGER NOT NULL DEFAULT 1` 字段（见主白皮书已更新）。
- **迁移脚本**：`migrations/2025xxxx_notes_version.sql`

```sql
ALTER TABLE public.notes
  ADD COLUMN IF NOT EXISTS version INTEGER NOT NULL DEFAULT 1;
COMMENT ON COLUMN public.notes.version IS '乐观并发版本号';
```

- **并发更新要求**：所有更新必须在同一事务中以条件更新实现：
  - 条件：`WHERE id = :noteId AND user_id = :userId AND deleted_at IS NULL AND version = :ifMatch`
  - 递增：`SET version = version + 1, updated_at = now()`
  - 返回：`RETURNING id, version, title, content_markdown, chapter, updated_at`

- **RLS**：沿用既有 `notes_update`/`notes_delete` 策略，不需额外变更；服务层仍需执行 `SET LOCAL app.user_id = '<uuid>'`。

---

### **2. REST API 契约（OpenAPI 3.0）**
- **路径**：在 `contracts/api/v1/notes.yaml` 增加以下端点。

```yaml
paths:
  /api/v1/notes/{noteId}:
    patch:
      operationId: updateNote
      summary: Update a note (optimistic concurrency)
      description: 通过 If-Match=version 实现乐观并发更新。
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: noteId
          required: true
          schema:
            type: string
            format: uuid
        - in: header
          name: If-Match
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateNoteRequest'
            examples:
              valid:
                value:
                  title: "更新后的标题"
                  content_markdown: "更新后的内容..."
      responses:
        '200':
          description: OK
          headers:
            ETag:
              schema:
                type: string
              description: 新的版本号（字符串化）
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Note'
        '400':
          description: If-Match 缺失或非法
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
        '404':
          description: 资源不存在或已删除
        '409':
          description: 版本冲突（If-Match 与数据库 version 不一致）
        '401':
          description: Unauthorized
        '403':
          description: Forbidden
    delete:
      operationId: deleteNote
      summary: Soft delete a note (idempotent)
      description: 逻辑删除（软删除），支持 Idempotency-Key 幂等。
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: noteId
          required: true
          schema:
            type: string
            format: uuid
        - in: header
          name: Idempotency-Key
          required: true
          schema:
            type: string
            maxLength: 64
      responses:
        '204':
          description: No Content
        '401':
          description: Unauthorized
        '403':
          description: Forbidden
```

```yaml
components:
  schemas:
    UpdateNoteRequest:
      type: object
      properties:
        title: { type: string, nullable: true, maxLength: 500 }
        content_markdown: { type: string, nullable: true }
        chapter: { type: string, nullable: true, maxLength: 255 }
```

- **响应头**：PATCH 成功返回 `ETag: <version>`；GET 列表/详情返回的 `Note` 对象包含 `version` 字段。

---

### **3. 后端逻辑伪代码（并发与幂等）**

```python
# update_note
async def update_note(note_id, req, if_match_version, user_id, db):
    if if_match_version is None:
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"If-Match required"})

    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    now = datetime.utcnow().replace(tzinfo=timezone.utc)
    async with db.begin():
        q = sa.update(notes).where(
            sa.and_(
                notes.c.id == note_id,
                notes.c.user_id == user_id,
                notes.c.deleted_at.is_(None),
                notes.c.version == if_match_version,
            )
        ).values({
            "title": req.title if req.title is not None else sa.sql.expression.null(),
            "content_markdown": req.content_markdown if req.content_markdown is not None else sa.sql.expression.null(),
            "chapter": req.chapter if req.chapter is not None else sa.sql.expression.null(),
            "version": notes.c.version + 1,
            "updated_at": now,
        }).returning(notes.c.id, notes.c.version, notes.c.title, notes.c.content_markdown, notes.c.chapter, notes.c.updated_at)

        row = await db.fetch_one(q)
        if not row:
            # 检查是否存在该资源（决定返回 404 还是 409）
            exists = await db.fetch_one(sa.select(notes.c.id, notes.c.version, notes.c.deleted_at).where(sa.and_(notes.c.id == note_id, notes.c.user_id == user_id)))
            if not exists or exists.deleted_at is not None:
                raise HTTPException(status_code=404)
            raise HTTPException(status_code=409, detail={"code":"CONFLICT","message":"version mismatch"})

        new_version = row.version
        await db.execute(sa.insert(note_versions).values({
            "id": uuid4(),
            "note_id": note_id,
            "version_number": new_version,
            "title": row.title,
            "content_markdown": row.content_markdown,
            "change_summary": "update",
            "created_at": now,
        }))

    return with_headers({
        "id": str(note_id),
        "title": row.title,
        "content_markdown": row.content_markdown,
        "chapter": row.chapter,
        "version": int(new_version),
        "updated_at": row.updated_at.isoformat(),
    }, {"ETag": str(new_version)})


# delete_note (soft delete + idempotency)
async def delete_note(note_id, user_id, db, idem_store, idem_key):
    if not idem_key:
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"Idempotency-Key required"})

    prev = await idem_store.find(idem_key, user_id, hash_key(f"DELETE:/api/v1/notes/{note_id}"))
    if prev and prev.response_status == 204:
        return Response(status_code=204)

    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    async with db.begin():
        res = await db.execute(sa.update(notes).where(sa.and_(
            notes.c.id == note_id,
            notes.c.user_id == user_id,
            notes.c.deleted_at.is_(None),
        )).values({"deleted_at": sa.func.now() }))
        # 幂等：无论是否更新一行，都返回 204

    await idem_store.save(idem_key, user_id, hash_key(f"DELETE:/api/v1/notes/{note_id}"), 204, None)
    return Response(status_code=204)
```

---

### **4. 前端编辑交互与组件契约**
- **状态管理**：`useNotesStore` 应包含 `editingNote: { id, title, content_markdown, version }`，以及 `startEditing`, `updateEditing`, `cancelEditing`, `saveEditing`。
- **组件契约**：

```ts
export interface NoteEditorProps {
  initialTitle?: string;
  initialContent: string;
  version: number;
  onSave: (payload: { title?: string; content_markdown?: string; chapter?: string }) => void;
  onCancel: () => void;
}

// 保存时必须携带 If-Match: version
const saveEditing = async (noteId: string, editing: { version: number; title?: string; content_markdown?: string; chapter?: string }) => {
  try {
    await api.patch(`/api/v1/notes/${noteId}`, { title: editing.title, content_markdown: editing.content_markdown, chapter: editing.chapter }, {
      headers: { 'If-Match': editing.version.toString() }
    })
    // 刷新列表或详情，更新版本号
  } catch (err: any) {
    if (err.response?.status === 409) {
      showConflictBanner('内容已在别处更新，请刷新后重试')
      // 可选：拉取最新内容并展示 Diff（如使用 diff-match-patch）
    }
  }
}
```

- **UI 反馈**：409 时显示冲突提示与“查看差异”入口（P1 可选）；保存成功后焦点返回至最新项或编辑区域，读屏提示“保存成功”。

---

### **5. 测试与门禁（并发与幂等）**
- **契约/单元测试**：
  - PATCH 缺少 `If-Match` → 400；`If-Match` 与数据库版本不符 → 409。
  - 成功更新 → `notes.version` 递增；`note_versions` 新增记录且 `version_number` 正确。
  - DELETE 幂等 → 首次 204，重复调用携带相同 `Idempotency-Key` 仍 204。
  - RLS 边界 → 他人数据不可更新/删除，返回 403。

- **E2E 场景**：
  1) 会话 A 打开笔记；会话 B 更新同一笔记；会话 A 保存 → 409 冲突提示。
  2) 删除笔记 → 列表不再展示；重复删除 → 仍 204，无副作用。

- **CI 门禁**：
  - OpenAPI 校验通过；迁移脚本在临时数据库成功执行；
  - 新增/变更代码覆盖率达标（总 ≥ 85%、变更 ≥ 80%）；
  - E2E 冒烟包含并发冲突与幂等删除，耗时 ≤ 3 分钟。

---

## 《Highlights 垂直切片（CRUD）可执行规范（新增）》

### 1. 数据库（DDL/RLS/索引）
- 迁移脚本：`migrations/2025xxxx_highlights_version.sql`

```sql
ALTER TABLE public.highlights
  ADD COLUMN IF NOT EXISTS version INTEGER NOT NULL DEFAULT 1;
COMMENT ON COLUMN public.highlights.version IS '乐观并发版本号';

-- 建议索引（列表分页/过滤）：
CREATE INDEX IF NOT EXISTS idx_highlights_user_book_created_desc
  ON public.highlights (user_id, book_id, created_at DESC);
```

- 并发更新要求：所有更新必须以条件更新实现（同事务）：
  - 条件：`WHERE id = :highlightId AND user_id = :userId AND deleted_at IS NULL AND version = :ifMatch`
  - 递增：`SET version = version + 1, updated_at = now()`
  - 返回：`RETURNING id, book_id, locator, text_content, color, chapter, version, updated_at`

- RLS：沿用既有 `highlights_select`/`highlights_insert`/`highlights_update`/`highlights_delete` 策略；服务层执行 `SET LOCAL app.user_id = '<uuid>'`。
- 幂等：POST/DELETE 使用 `Idempotency-Key`；记录于 `idempotency_keys`（method、route、request_hash、response 快照）。

---

### 2. REST API 契约（OpenAPI 3.0）
- 路径：在 `contracts/api/v1/highlights.yaml` 增加以下端点。

```yaml
openapi: 3.0.3
info:
  title: Highlights API
  version: 1.0.0
paths:
  /api/v1/highlights:
    post:
      operationId: createHighlight
      summary: Create a highlight (idempotent)
      security:
        - bearerAuth: []
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string, minLength: 8, maxLength: 64 }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateHighlightRequest'
            examples:
              valid:
                value:
                  book_id: "6c7d7b2b-0e1e-4c2a-a2f5-9f2d2f8fb001"
                  locator:
                    type: "EPUB"
                    cfi: "epubcfi(/6/2[chapter]!/4/1:0)"
                  text_content: "要点摘录"
                  color: 1
                  chapter: "第三章"
      responses:
        '201':
          description: Created
          headers:
            ETag:
              schema: { type: string }
              description: 版本号（字符串化）
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Highlight'
        '400': { description: 请求不合法, content: { application/json: { schema: { $ref: '#/components/schemas/Error' } } } }
        '403': { description: 权限不足, content: { application/json: { schema: { $ref: '#/components/schemas/Error' } } } }
    get:
      operationId: listHighlights
      summary: List highlights (cursor pagination)
      security:
        - bearerAuth: []
      parameters:
        - in: query
          name: bookId
          schema: { type: string, format: uuid }
        - in: query
          name: search
          schema: { type: string, maxLength: 500 }
        - in: query
          name: cursor
          schema: { type: string, nullable: true }
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/Highlight' }
                  next_cursor: { type: string, nullable: true }
                  has_more: { type: boolean }
        '403': { description: 权限不足 }

  /api/v1/highlights/{highlightId}:
    get:
      operationId: getHighlight
      summary: Get a highlight by id
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: highlightId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200':
          description: OK
          headers:
            ETag:
              schema: { type: string }
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Highlight' }
        '404': { description: 不存在或已删除 }
    patch:
      operationId: updateHighlight
      summary: Update a highlight (optimistic concurrency)
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: highlightId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: If-Match
          required: true
          schema: { type: integer }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/UpdateHighlightRequest' }
      responses:
        '200':
          description: OK
          headers:
            ETag:
              schema: { type: string }
          content:
            application/json:
              schema: { $ref: '#/components/schemas/Highlight' }
        '400': { description: If-Match 缺失或非法 }
        '404': { description: 不存在或已删除 }
        '409': { description: 版本冲突 }
    delete:
      operationId: deleteHighlight
      summary: Soft delete a highlight (idempotent)
      security:
        - bearerAuth: []
      parameters:
        - in: path
          name: highlightId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string, minLength: 8, maxLength: 64 }
      responses:
        '204': { description: No Content }
        '404': { description: 不存在或无权访问 }

components:
  schemas:
    Highlight:
      type: object
      required: [id, book_id, locator, text_content, color, version, created_at, updated_at]
      properties:
        id: { type: string, format: uuid }
        book_id: { type: string, format: uuid }
        locator:
          oneOf:
            - $ref: '#/components/schemas/PdfLocation'
            - $ref: '#/components/schemas/EpubLocation'
        text_content: { type: string }
        color: { type: integer, minimum: 0, maximum: 9 }
        chapter: { type: string, nullable: true, maxLength: 255 }
        version: { type: integer }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
    CreateHighlightRequest:
      type: object
      required: [book_id, locator, text_content]
      properties:
        book_id: { type: string, format: uuid }
        locator:
          oneOf:
            - $ref: '#/components/schemas/PdfLocation'
            - $ref: '#/components/schemas/EpubLocation'
        text_content: { type: string }
        color: { type: integer, nullable: true }
        chapter: { type: string, nullable: true, maxLength: 255 }
    UpdateHighlightRequest:
      type: object
      properties:
        locator:
          oneOf:
            - $ref: '#/components/schemas/PdfLocation'
            - $ref: '#/components/schemas/EpubLocation'
          nullable: true
        text_content: { type: string, nullable: true }
        color: { type: integer, nullable: true }
        chapter: { type: string, nullable: true, maxLength: 255 }
    Error:
      type: object
      properties:
        code: { type: string }
        message: { type: string }
```

---

### 3. 后端逻辑伪代码（FastAPI/SQLAlchemy 2.0）

```python
# create_highlight (幂等)
async def create_highlight(req: CreateHighlightRequest, idempo_key: str, user_id: UUID, db):
    if not idempo_key:
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"Idempotency-Key required"})

    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    # 幂等回放
    prev = await get_idempo(db, idempo_key, user_id, method='POST', route='/api/v1/highlights', req=req)
    if prev:
        return replay(prev)

    now = datetime.utcnow().replace(tzinfo=timezone.utc)
    async with db.begin():
        q = sa.insert(highlights).values({
            "id": uuid4(),
            "user_id": user_id,
            "book_id": req.book_id,
            "locator": req.locator,
            "text_content": req.text_content,
            "color": req.color,
            "chapter": req.chapter,
            "version": 1,
            "created_at": now,
            "updated_at": now,
        }).returning(highlights.c.id, highlights.c.book_id, highlights.c.locator, highlights.c.text_content, highlights.c.color, highlights.c.chapter, highlights.c.version, highlights.c.created_at, highlights.c.updated_at)

        row = await db.fetch_one(q)
        await put_idempo(db, idempo_key, user_id, 'POST', '/api/v1/highlights', req, 201, row)
        return row


# list_highlights（游标分页）
async def list_highlights(book_id: UUID | None, search: str | None, cursor: str | None, limit: int, user_id: UUID, db):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    # 过滤删除
    cond = [highlights.c.user_id == user_id, highlights.c.deleted_at.is_(None)]
    if book_id:
        cond.append(highlights.c.book_id == book_id)
    if search:
        cond.append(highlights.c.text_content.ilike(f"%{search}%"))

    # 游标（created_at desc, id tiebreaker）
    if cursor:
        ts, hid = decode_cursor(cursor)
        cond.append(sa.or_(
            highlights.c.created_at < ts,
            sa.and_(highlights.c.created_at == ts, highlights.c.id < hid)
        ))

    q = sa.select(highlights).where(sa.and_(*cond)).order_by(highlights.c.created_at.desc(), highlights.c.id.desc()).limit(limit + 1)
    rows = await db.fetch_all(q)
    items = rows[:limit]
    next_cursor = encode_cursor(items[-1].created_at, items[-1].id) if len(rows) > limit else None
    return {"items": items, "next_cursor": next_cursor, "has_more": len(rows) > limit}


# get_highlight
async def get_highlight(highlight_id: UUID, user_id: UUID, db):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    row = await db.fetch_one(sa.select(highlights).where(sa.and_(highlights.c.id == highlight_id, highlights.c.user_id == user_id, highlights.c.deleted_at.is_(None))))
    if not row:
        raise HTTPException(status_code=404, detail={"code":"NOT_FOUND"})
    return row


# update_highlight（乐观并发）
async def update_highlight(highlight_id: UUID, req: UpdateHighlightRequest, if_match_version: int | None, user_id: UUID, db):
    if if_match_version is None:
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"If-Match required"})

    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    now = datetime.utcnow().replace(tzinfo=timezone.utc)
    async with db.begin():
        q = sa.update(highlights).where(sa.and_(
            highlights.c.id == highlight_id,
            highlights.c.user_id == user_id,
            highlights.c.deleted_at.is_(None),
            highlights.c.version == if_match_version,
        )).values({
            "locator": req.locator if req.locator is not None else sa.sql.expression.null(),
            "text_content": req.text_content if req.text_content is not None else sa.sql.expression.null(),
            "color": req.color if req.color is not None else sa.sql.expression.null(),
            "chapter": req.chapter if req.chapter is not None else sa.sql.expression.null(),
            "version": highlights.c.version + 1,
            "updated_at": now,
        }).returning(highlights.c.id, highlights.c.book_id, highlights.c.locator, highlights.c.text_content, highlights.c.color, highlights.c.chapter, highlights.c.version, highlights.c.updated_at)

        row = await db.fetch_one(q)
        if not row:
            # 判定 404 或 409
            exists = await db.fetch_one(sa.select(highlights.c.id, highlights.c.version, highlights.c.deleted_at).where(sa.and_(highlights.c.id == highlight_id, highlights.c.user_id == user_id)))
            if not exists or exists.deleted_at is not None:
                raise HTTPException(status_code=404, detail={"code":"NOT_FOUND"})
            raise HTTPException(status_code=409, detail={"code":"CONFLICT","message":"Version mismatch"})
        return row


# delete_highlight（软删除，幂等）
async def delete_highlight(highlight_id: UUID, idempo_key: str, user_id: UUID, db):
    if not idempo_key:
        raise HTTPException(status_code=400, detail={"code":"INVALID","message":"Idempotency-Key required"})

    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    prev = await get_idempo(db, idempo_key, user_id, method='DELETE', route=f'/api/v1/highlights/{highlight_id}', req=None)
    if prev:
        return Response(status_code=204)

    async with db.begin():
        q = sa.update(highlights).where(sa.and_(
            highlights.c.id == highlight_id,
            highlights.c.user_id == user_id,
            highlights.c.deleted_at.is_(None),
        )).values({"deleted_at": sa.func.now()}).returning(highlights.c.id)

        row = await db.fetch_one(q)
        if not row:
            raise HTTPException(status_code=404, detail={"code":"NOT_FOUND"})

        await put_idempo(db, idempo_key, user_id, 'DELETE', f'/api/v1/highlights/{highlight_id}', None, 204, None)
        return Response(status_code=204)
```

---

### 4. 前端契约与 Reader 集成

```ts
// 类型契约
export interface Highlight {
  id: string
  bookId: string
  cfiLocator: string
  textContent: string
  color: number
  chapter?: string
  version: number
  createdAt: string
  updatedAt: string
}

export interface CreateHighlightRequest {
  bookId: string
  cfiLocator: string
  textContent: string
  color?: number
  chapter?: string
}

export interface UpdateHighlightRequest {
  cfiLocator?: string
  textContent?: string
  color?: number
  chapter?: string
}

// Reader 事件总线（WebSocket）
type ReaderEvent =
  | { type: 'highlight.created'; payload: Highlight }
  | { type: 'highlight.updated'; payload: Highlight }
  | { type: 'highlight.deleted'; payload: { id: string; bookId: string } }

// 频道命名：reader:<bookId>:<userId>
// 订阅权限：仅该用户或被邀请协作者（若有协作模式）

// UI 交互要点：
// - 创建：选择文本 -> 工具条 -> POST，成功后 Overlay 渲染，缓存 ETag(version)
// - 更新：携带 If-Match(version)；409 时提示“已被更新”，自动拉取最新并允许重试
// - 删除：软删除，Overlay 立即移除；重复删除携带相同 Idempotency-Key 仍 204
// - 实时：收到 WebSocket 事件即增量更新 Overlay 与侧栏列表
```

---

### 5. 合同测试与 E2E

- 契约测试：
  - POST 幂等：同 `Idempotency-Key` 重放返回相同资源与 201。
  - PATCH 并发：`If-Match` 缺失 → 400；版本不符 → 409；成功返回新 `ETag`。
  - GET 列表：游标分页稳定且不包含软删除项；`bookId` 过滤正确。
  - GET 详情：返回对象与 `ETag` 一致；404 场景覆盖。
  - DELETE 幂等：首调 204；重复调用仍 204，无副作用。
  - RLS 边界：他人数据 403；不存在资源 404。

- E2E 场景：
  1) 会话 A 创建高亮；会话 B 收到 `highlight.created` 并渲染 Overlay。
  2) B 更新同一高亮；A 保存旧版 → 409；A 拉取最新后重试成功。
  3) 删除高亮 → 列表与 Overlay 同步移除；重复删除仍 204。

- CI 门禁：
  - OpenAPI 校验通过；迁移脚本在临时数据库成功执行；
  - 覆盖率：总 ≥ 85%、变更 ≥ 80%；
  - E2E 冒烟包含并发冲突、实时同步与幂等删除，耗时 ≤ 3 分钟。

---

### 6. 生成与集成建议
- 合同生成：`contracts/api/v1/highlights.yaml` → SDK（TS/py）与后端路由骨架。
- 迁移执行顺序：先 `highlights_version.sql`，再 API/后端逻辑；确保 RLS 已启用。
- Reader 联调：先本地 WebSocket 模拟事件，后接入真实频道；统一事件载荷结构。
- 向量索引（可选）：如需语义检索，可将 `text_content` 写入 `vectors(source_type='HIGHLIGHT')`，并在更新时合并写入。

---

## 《Books & Shelves 垂直切片（CRUD + 上传与任务流）可执行规范（新增）》

### 1. 数据库（DDL/RLS/索引）
- 现状确认：`books` 已含 `is_locally_available`、`file_fingerprint`、`minio_key` 字段；`book_processing_tasks` 与 `book_processing_step_logs` 已定义；`shelves`/`book_shelves` 完整。
- RLS：
  ```sql
  -- books 已在“6.10 Authorization 与 Scopes”章节示例启用RLS
  ALTER TABLE shelves ENABLE ROW LEVEL SECURITY;
  CREATE POLICY shelves_owner_policy ON shelves
    USING (user_id = current_setting('app.user_id')::uuid)
    WITH CHECK (user_id = current_setting('app.user_id')::uuid);

  ALTER TABLE book_shelves ENABLE ROW LEVEL SECURITY;
  CREATE POLICY book_shelves_owner_policy ON book_shelves
    USING (
      EXISTS(
        SELECT 1 FROM books b WHERE b.id = book_shelves.book_id AND b.user_id = current_setting('app.user_id')::uuid
      ) AND EXISTS(
        SELECT 1 FROM shelves s WHERE s.id = book_shelves.shelf_id AND s.user_id = current_setting('app.user_id')::uuid
      )
    ) WITH CHECK (TRUE);
  ```
- 索引建议：
  ```sql
  CREATE INDEX IF NOT EXISTS idx_books_user_created_desc ON books (user_id, created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_shelves_user_parent_name ON shelves (user_id, parent_shelf_id, name);
  CREATE INDEX IF NOT EXISTS idx_book_shelves_book ON book_shelves (book_id);
  CREATE INDEX IF NOT EXISTS idx_book_shelves_shelf ON book_shelves (shelf_id);
  ```
- 幂等与唯一性：`UNIQUE (user_id, file_fingerprint)` 防重复导入；所有写操作支持 `Idempotency-Key`。

---

### 2. REST API 契约（OpenAPI 3.0）
- 路径：在 `contracts/api/v1/books.yaml` 与 `contracts/api/v1/shelves.yaml` 定义如下端点。

```yaml
openapi: 3.0.3
info:
  title: Books & Shelves API
  version: 1.0.0
paths:
  /api/v1/books/upload-url:
    post:
      operationId: getBookUploadUrl
      summary: 获取预签名上传URL（按用户指纹检查）
      security: [ { bearerAuth: [] } ]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [filename, content_type, size_bytes, file_fingerprint]
              properties:
                filename: { type: string }
                content_type: { type: string }
                size_bytes: { type: integer, minimum: 1 }
                file_fingerprint: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  upload_url: { type: string }
                  original_minio_key: { type: string }
        '400': { description: 非法参数 }
        '409': { description: 当前用户已上传过该指纹文件 }

  /api/v1/books:
    post:
      operationId: createBook
      summary: 创建书籍记录并触发类型自检
      security: [ { bearerAuth: [] } ]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/FinalizeBookRequest'
      responses:
        '202':
          description: Accepted
          content:
            application/json:
              schema:
                type: object
                properties:
                  book_id: { type: string, format: uuid }
                  task_status: { type: string, enum: [ANALYZING, PENDING_USER_ACTION, ACTIVE, ARCHIVED, FAILED] }
        '409': { description: file_fingerprint 冲突 }
    get:
      operationId: listBooks
      summary: 列出书籍（游标分页，Elasticsearch检索）
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: query
          name: search
          schema: { type: string, maxLength: 500 }
        - in: query
          name: cursor
          schema: { type: string, nullable: true }
        - in: query
          name: limit
          schema: { type: integer, minimum: 1, maximum: 100, default: 20 }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items: { $ref: '#/components/schemas/Book' }
                  next_cursor: { type: string, nullable: true }
                  has_more: { type: boolean }

  /api/v1/books/{bookId}:
    get:
      operationId: getBook
      summary: 获取书籍详情
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: bookId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/Book' } } } }
        '404': { description: 不存在或已删除 }
    delete:
      operationId: deleteBook
      summary: 软删除（幂等）
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: bookId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }
        '404': { description: 不存在或无权访问 }

  /api/v1/books/{bookId}/download:
    post:
      operationId: getDownloadUrl
      summary: 获取预签名下载URL
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: bookId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: object
                properties:
                  download_url: { type: string }
        '404': { description: 不存在或已删除 }

  /api/v1/books/{bookId}/process:
    post:
      operationId: processBookDeeply
      summary: 用户发起深度处理（OCR/向量化）
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: bookId
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [actions]
              properties:
                actions:
                  type: array
                  items: { type: string, enum: [OCR, VECTORIZE] }
      responses:
        '202': { description: Accepted }
        '402': { description: 额度不足 }
        '404': { description: 书籍不存在或无权访问 }

  /api/v1/book-processing-tasks/{bookId}:
    get:
      operationId: getBookProcessingTask
      summary: 查询处理任务状态
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: bookId
          required: true
          schema: { type: string, format: uuid }
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/BookProcessingTask' } } } }
        '404': { description: 不存在 }

  /api/v1/ocr-results/{bookId}/{pageNumber}:
    get:
      operationId: getOcrPageResult
      summary: 获取指定页的OCR结果（按页懒加载，推荐方案A）
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: bookId
          required: true
          schema: { type: string, format: uuid }
        - in: path
          name: pageNumber
          required: true
          schema: { type: integer, minimum: 1 }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema: { $ref: '#/components/schemas/OcrPageResult' }
        '404': { description: 不存在或该页尚无OCR结果 }

  /api/v1/shelves:
    post:
      operationId: createShelf
      summary: 创建书架
      security: [ { bearerAuth: [] } ]
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/CreateShelfRequest' }
      responses:
        '201': { description: Created, content: { application/json: { schema: { $ref: '#/components/schemas/Shelf' } } } }
    get:
      operationId: listShelvesTree
      summary: 列出书架树
      security: [ { bearerAuth: [] } ]
      responses:
        '200': { description: OK, content: { application/json: { schema: { $ref: '#/components/schemas/ShelfTree' } } } }

  /api/v1/shelves/{shelfId}:
    patch:
      operationId: updateShelf
      summary: 重命名或移动（更改父节点）
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: shelfId
          required: true
          schema: { type: string, format: uuid }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: '#/components/schemas/UpdateShelfRequest' }
      responses:
        '200': { description: OK }
        '409': { description: 移动导致循环 }
    delete:
      operationId: deleteShelf
      summary: 删除（软删除）
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: path
          name: shelfId
          required: true
          schema: { type: string, format: uuid }
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }

  /api/v1/books/{bookId}/shelves/{shelfId}:
    post:
      operationId: addBookToShelf
      summary: 关联书籍到书架
      security: [ { bearerAuth: [] } ]
      responses:
        '204': { description: No Content }
    delete:
      operationId: removeBookFromShelf
      summary: 从书架移除关联
      security: [ { bearerAuth: [] } ]
      parameters:
        - in: header
          name: Idempotency-Key
          required: true
          schema: { type: string }
      responses:
        '204': { description: No Content }

components:
  schemas:
    Book:
      type: object
      required: [id, title, user_id, minio_key, format, file_fingerprint, is_locally_available, status, created_at]
      properties:
        id: { type: string, format: uuid }
        user_id: { type: string, format: uuid }
        title: { type: string }
        author: { type: string }
        publisher: { type: string }
        description: { type: string }
        language: { type: string }
        isbn: { type: string }
        cover_image_key: { type: string }
        ocr_result_key: { type: string, nullable: true }
        format: { type: string }
        file_size_bytes: { type: integer }
        page_count: { type: integer }
        file_fingerprint: { type: string }
        charset: { type: string }
        original_format: { type: string }
        is_image_based: { type: boolean }
        ocr_page_count: { type: integer }
        text_extraction_confidence: { type: number }
        is_locally_available: { type: boolean }
        status: { type: string }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
    OcrPageResult:
      type: object
      required: [book_id, page_number, blocks]
      properties:
        book_id: { type: string, format: uuid }
        page_number: { type: integer, minimum: 1 }
        width: { type: integer, description: '页面像素宽（用于坐标换算）', nullable: true }
        height: { type: integer, description: '页面像素高（用于坐标换算）', nullable: true }
        blocks:
          type: array
          items:
            type: object
            properties:
              text: { type: string }
              bbox:
                type: object
                properties:
                  x: { type: number }
                  y: { type: number }
                  width: { type: number }
                  height: { type: number }
                  unit: { type: string, enum: [px, ratio], default: px }
    FinalizeBookRequest:
      type: object
      required: [title, minio_key, original_format, file_fingerprint]
      properties:
        title: { type: string }
        author: { type: string }
        minio_key: { type: string }
        cover_image_key: { type: string }
        original_format: { type: string }
        file_fingerprint: { type: string }
        file_size_bytes: { type: integer }
    BookProcessingTask:
      type: object
      properties:
        book_id: { type: string, format: uuid }
        current_step: { type: string }
        step_progress: { type: integer }
        estimated_remaining_minutes: { type: integer, nullable: true }
        retry_count: { type: integer }
        error_code: { type: string, nullable: true }
        error_message: { type: string, nullable: true }
        started_at: { type: string, format: date-time, nullable: true }
        completed_at: { type: string, format: date-time, nullable: true }
    Shelf:
      type: object
      required: [id, user_id, name]
      properties:
        id: { type: string, format: uuid }
        user_id: { type: string, format: uuid }
        name: { type: string }
        parent_shelf_id: { type: string, format: uuid, nullable: true }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }
    CreateShelfRequest:
      type: object
      required: [name]
      properties:
        name: { type: string, maxLength: 255 }
        parent_shelf_id: { type: string, format: uuid, nullable: true }
    UpdateShelfRequest:
      type: object
      properties:
        name: { type: string, maxLength: 255, nullable: true }
        parent_shelf_id: { type: string, format: uuid, nullable: true }
    ShelfTree:
      type: object
      properties:
        roots:
          type: array
          items:
            type: object
            properties:
              shelf: { $ref: '#/components/schemas/Shelf' }
              children:
                type: array
                items: { $ref: '#/components/schemas/ShelfTree' }
```

---

### 3. 后端逻辑伪代码（上传/任务流/树操作）

```python
# getBookUploadUrl（逻辑微调：仅检查当前用户的指纹重复）
async def get_book_upload_url(req, user_id, db, minio):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    exists = await db.fetch_one(sa.text("SELECT 1 FROM books WHERE user_id = :u AND file_fingerprint = :f AND deleted_at IS NULL"), {"u": user_id, "f": req.file_fingerprint})
    if exists:
        raise HTTPException(status_code=409, detail={"code":"DUPLICATE","message":"file_fingerprint exists for user"})
    upload_id = uuid4()
    original_minio_key = f"uploads/{user_id}/{upload_id}"
    url = minio.presign_put(original_minio_key, expires=3600)
    return {"upload_url": url, "original_minio_key": original_minio_key}


# createBook（触发轻量分析任务）
async def create_book(req: FinalizeBookRequest, idem_key, user_id, db, celery):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})

    # 幂等回放
    prev = await get_idempo(db, idem_key, user_id, method='POST', route='/api/v1/books', req=req)
    if prev:
        return replay(prev)

    now = datetime.utcnow().replace(tzinfo=timezone.utc)
    async with db.begin():
        # 唯一约束避免重复导入
        try:
            row = await db.fetch_one(sa.insert(books).values({
                "id": uuid4(), "user_id": user_id,
                "title": req.title, "author": req.author,
                "minio_key": req.minio_key, "cover_image_key": req.cover_image_key,
                "original_format": req.original_format,
                "file_fingerprint": req.file_fingerprint,
                "file_size_bytes": req.file_size_bytes,
                "format": None,
                "is_locally_available": False,
                "status": "ANALYZING",
                "created_at": now, "updated_at": now
            }).returning(books.c.id, books.c.user_id, books.c.title, books.c.minio_key, books.c.file_fingerprint, books.c.status))
        except UniqueViolationError:
            raise HTTPException(status_code=409, detail={"code":"DUPLICATE","message":"file_fingerprint exists"})

        # 任务初始化为 ANALYZING（轻量）
        await db.execute(sa.insert(book_processing_tasks).values({
            "book_id": row.id,
            "current_step": "ANALYZING",
            "step_progress": 0,
            "retry_count": 0,
            "created_at": now,
            "updated_at": now
        }))

    # 触发轻量任务：类型自检
    tasks.analyze_book_type.apply_async(args=[row.id])

    await put_idempo(db, idem_key, user_id, 'POST', '/api/v1/books', req, 202, {"book_id": str(row.id), "task_status": "ANALYZING"})
    return Response(status_code=202, content={"book_id": str(row.id), "task_status": "ANALYZING"})

# 轻量任务：类型自检
@celery.task(name='tasks.analyze_book_type')
def analyze_book_type(book_id):
    db = get_db()
    minio = get_minio()
    # 读取书籍记录（仅必要字段）
    book = db.fetch_one(sa.text("SELECT id, original_minio_key, minio_key FROM books WHERE id = :id AND deleted_at IS NULL"), {"id": book_id})
    if not book:
        return
    # 从 MinIO 拉取文件头，快速判断图片型 vs 文本型
    key = book.original_minio_key or book.minio_key
    header = minio.get_object_header(key, first_bytes=8192)
    is_image_based = quick_probe_is_image_container(header)
    # 可解析格式快速抽样（EPUB/MOBI/TXT）
    initial_confidence = estimate_confidence_from_snippet(quick_extract_text_snippet(key, limit_bytes=16384)) if not is_image_based else 0.0

    # 更新 books 与任务状态
    db.execute(sa.text("UPDATE books SET is_image_based = :img, initial_digitalization_confidence = :conf, status = 'PENDING_USER_ACTION', updated_at = now() WHERE id = :id"), {"img": is_image_based, "conf": initial_confidence, "id": book_id})
    db.execute(sa.text("UPDATE book_processing_tasks SET current_step = 'PENDING_USER_ACTION', step_progress = 100, updated_at = now() WHERE book_id = :id"), {"id": book_id})

    # WebSocket 推送（简化示例）
    ws_broadcast(f"book:{book_id}", {"event": "ANALYZED", "is_image_based": is_image_based, "initial_confidence": initial_confidence})

    return {"book_id": str(book_id), "is_image_based": is_image_based, "initial_confidence": initial_confidence}

# 重量级任务：深度分析（标准化 + 权威判定）
@celery.task(name='tasks.deep_analyze_book')
def deep_analyze_book(book_id):
    db = get_db(); minio = get_minio()
    rec = db.fetch_one(sa.text("SELECT id, original_minio_key, minio_key FROM books WHERE id = :id AND deleted_at IS NULL"), {"id": book_id})
    if not rec:
        return
    key = rec.original_minio_key or rec.minio_key
    # 标准化为临时EPUB（必要时）
    std_key = ensure_epub_standardized(key)
    final_ok = deep_probe_text_density(std_key)
    report_key = write_digitalize_report(minio, book_id, final_ok)
    db.execute(sa.text("UPDATE books SET status = CASE WHEN :ok THEN 'ACTIVE' ELSE 'PENDING_USER_ACTION' END, updated_at = now() WHERE id = :id"), {"ok": final_ok, "id": book_id})
    db.execute(sa.text("UPDATE book_processing_tasks SET current_step = 'ANALYZING', step_progress = 100, updated_at = now() WHERE book_id = :id"), {"id": book_id})
    ws_broadcast(f"book:{book_id}", {"event": "DEEP_ANALYZED", "digitalized": final_ok, "report_key": report_key})
    return {"book_id": str(book_id), "digitalized": final_ok}

# 重量级任务：深度处理（OCR/向量化）
@celery.task(name='tasks.process_book_deeply')
def process_book_deeply(book_id, actions: list[str]):
    db = get_db(); minio = get_minio(); embed = get_embedder(); ocr = get_ocr()
    # 读取书籍与用户配置
    rec = db.fetch_one(sa.text("SELECT b.id, b.user_id, b.file_fingerprint, b.original_minio_key, b.minio_key, u.allow_shared_cache FROM books b JOIN users u ON b.user_id = u.id WHERE b.id = :id AND b.deleted_at IS NULL"), {"id": book_id})
    if not rec:
        return

    # 共享缓存命中：按 file_fingerprint 查询
    cached = db.fetch_all(sa.text("SELECT id, chunk_index FROM shared_vectors WHERE file_fingerprint = :f ORDER BY chunk_index"), {"f": rec.file_fingerprint})
    if cached and 'VECTORIZE' in actions and 'OCR' not in actions:
        # 直接建立引用
        for row in cached:
            db.execute(sa.text("INSERT INTO vectors(id, user_id, source_type, source_id, shared_vector_id, created_at, updated_at) VALUES (:id,:u,'BOOK_CHUNK',:src,:sv,now(),now())"), {"id": uuid4(), "u": rec.user_id, "src": compose_source_id(book_id, row.chunk_index), "sv": row.id})
    else:
        # 执行昂贵计算：Calibre转换、OCR、Embedding
        src_key = rec.original_minio_key or rec.minio_key
        if 'OCR' in actions:
            pages = ocr.extract_text(src_key)
        else:
            pages = extract_text_quick(src_key)
        chunks = chunk_pages(pages)
        vectors = []
        if 'VECTORIZE' in actions:
            for i, ch in enumerate(chunks):
                v = embed.embed(ch.text)
                vectors.append((i, v, ch.text))

        # 写入共享缓存（匿名）
        if rec.allow_shared_cache and vectors:
            for (i, v, txt) in vectors:
                db.execute(sa.text("INSERT INTO shared_vectors(id, file_fingerprint, chunk_index, vector, text_snippet, created_at, updated_at) VALUES (:id,:f,:idx,:vec,:txt,now(),now()) ON CONFLICT (file_fingerprint, chunk_index) DO NOTHING"), {"id": uuid4(), "f": rec.file_fingerprint, "idx": i, "vec": v, "txt": txt})

        # 建立用户私有引用
        if vectors:
            rows = db.fetch_all(sa.text("SELECT id, chunk_index FROM shared_vectors WHERE file_fingerprint = :f"), {"f": rec.file_fingerprint})
            for row in rows:
                db.execute(sa.text("INSERT INTO vectors(id, user_id, source_type, source_id, shared_vector_id, created_at, updated_at) VALUES (:id,:u,'BOOK_CHUNK',:src,:sv,now(),now()) ON CONFLICT DO NOTHING"), {"id": uuid4(), "u": rec.user_id, "src": compose_source_id(book_id, row.chunk_index), "sv": row.id})

    # 更新书籍状态为 ACTIVE
    db.execute(sa.text("UPDATE books SET status = 'ACTIVE', updated_at = now() WHERE id = :id"), {"id": book_id})
    db.execute(sa.text("UPDATE book_processing_tasks SET current_step = 'COMPLETED', step_progress = 100, updated_at = now() WHERE book_id = :id"), {"id": book_id})
    ws_broadcast(f"book:{book_id}", {"event": "PROCESSED", "status": "ACTIVE"})

    return {"book_id": str(book_id), "status": "ACTIVE"}

# 定时清理任务：原始文件保留策略
@celery.task(name='tasks.cleanup_original_files')
def cleanup_original_files():
    db = get_db(); minio = get_minio()
    days = int(db.fetch_val(sa.text("SELECT value FROM system_settings WHERE key = 'original_file_retention_days'")) or 30)
    cutoff = datetime.utcnow().replace(tzinfo=timezone.utc) - timedelta(days=days)
    rows = db.fetch_all(sa.text("SELECT id, original_minio_key FROM books WHERE original_minio_key IS NOT NULL AND updated_at < :cutoff AND deleted_at IS NULL"), {"cutoff": cutoff})
    for r in rows:
        try:
            minio.delete_object(r.original_minio_key)
            db.execute(sa.text("UPDATE books SET original_minio_key = NULL, updated_at = now() WHERE id = :id"), {"id": r.id})
        except Exception:
            continue

# getDownloadUrl
async def get_download_url(book_id, user_id, db, minio):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    book = await db.fetch_one(sa.select(books).where(sa.and_(books.c.id == book_id, books.c.user_id == user_id, books.c.deleted_at.is_(None))))
    if not book:
        raise HTTPException(status_code=404, detail={"code":"NOT_FOUND"})
    url = minio.presign_get(book.minio_key, expires=3600)
    return {"download_url": url}


# listShelvesTree（基于邻接表构建树）
async def list_shelves_tree(user_id, db):
    rows = await db.fetch_all(sa.select(shelves).where(sa.and_(shelves.c.user_id == user_id, shelves.c.deleted_at.is_(None))).order_by(shelves.c.created_at))
    return build_tree(rows)  # O(n), 使用 map[id]->children 聚合


# updateShelf（重命名或移动，防循环）
async def update_shelf(shelf_id, req, user_id, db):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    if req.parent_shelf_id:
        if introduces_cycle(shelf_id, req.parent_shelf_id, user_id, db):
            raise HTTPException(status_code=409, detail={"code":"CYCLE","message":"Moving causes cycle"})
    row = await db.fetch_one(sa.update(shelves).where(sa.and_(shelves.c.id == shelf_id, shelves.c.user_id == user_id, shelves.c.deleted_at.is_(None))).values({
        "name": req.name if req.name is not None else sa.sql.expression.null(),
        "parent_shelf_id": req.parent_shelf_id if req.parent_shelf_id is not None else sa.sql.expression.null(),
        "updated_at": sa.func.now()
    }).returning(shelves.c.id))
    if not row:
        raise HTTPException(status_code=404, detail={"code":"NOT_FOUND"})
    return row


# add/remove book to shelf
async def add_book_to_shelf(book_id, shelf_id, user_id, db):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    await db.execute(sa.insert(book_shelves).values({"book_id": book_id, "shelf_id": shelf_id}))
    return Response(status_code=204)

async def remove_book_from_shelf(book_id, shelf_id, user_id, db):
    await db.execute(text("SET LOCAL app.user_id = :uid"), {"uid": user_id})
    await db.execute(sa.delete(book_shelves).where(sa.and_(book_shelves.c.book_id == book_id, book_shelves.c.shelf_id == shelf_id)))
    return Response(status_code=204)
```

---

### 4. 前端契约与交互

```ts
// 类型契约
export interface Book {
  id: string
  userId: string
  title: string
  author?: string
  coverImageKey?: string
  format?: string
  fileFingerprint: string
  isLocallyAvailable: boolean
  status: 'UPLOADED' | 'ACTIVE' | 'ARCHIVED' | 'FAILED'
  createdAt: string
  updatedAt: string
}

export interface Shelf {
  id: string
  userId: string
  name: string
  parentShelfId?: string
  createdAt: string
  updatedAt: string
}

// 组件契约
export interface UploadBookModalProps {
  isOpen: boolean
  onClose: () => void
  onUploaded: (book: Book) => void
}

export interface ShelfTreeProps {
  tree: ShelfTree
  onMove: (shelfId: string, parentShelfId?: string) => void
  onRename: (shelfId: string, name: string) => void
}

// 任务进度 WS 频道：processing:<bookId>:<userId>
type ProcessingEvent = { type: 'task.update'; payload: { bookId: string; currentStep: string; progress: number; etaMinutes?: number } }
```

交互要点：
- 上传：`POST /books/uploads` 取预签名 → 浏览器直传 → `POST /books` finalize → 显示任务进度（WS/轮询）。
- 下载：`POST /books/{id}/download` 取预签名 → 写入 IndexedDB → 设置 `isLocallyAvailable=true`。
- 书架：树展示、拖拽移动（发送 `PATCH /shelves/{id}`）、关联书籍（POST/DELETE）。

---

### 5. 契约测试与 E2E

- 契约测试：
  - 上传幂等：同 `Idempotency-Key` 返回一致 `upload_id/upload_url`；finalize 幂等。
  - 唯一约束：重复 `file_fingerprint` → 409。
  - 列表分页：游标稳定；过滤软删除。
  - 下载：返回可用预签名；无权或不存在 → 404。
  - 书架：移动循环 → 409；增删关联 → 204。

- E2E 场景：
  1) 上传并完成 → Celery 启动任务流；前端显示进度并最终 ACTIVE。
  2) 失败重试 → `retry_count` 递增；达到 `max_retries` → FAILED；用户重试成功 → COMPLETED/ACTIVE。
  3) 书架树移动与关联书籍同步生效；关联变更后列表过滤正确。

- CI 门禁：
  - OpenAPI 校验通过；迁移/索引脚本在临时库执行成功；
  - 覆盖率：总 ≥ 85%、变更 ≥ 80%；
  - E2E 冒烟覆盖上传/任务流/下载/树操作，≤ 5 分钟。

---

### 6. 生成与集成建议
- 契约驱动生成：`books.yaml`/`shelves.yaml` → SDK（TS/py）与后端路由骨架。
- 任务链标准化：Celery 任务统一写入 `book_processing_tasks` 与 `book_processing_step_logs`；错误码与重试策略一致化。
- 搜索集成：书籍检索走 Elasticsearch；后端聚合返回基础字段与高亮摘要。
- 安全：所有路由在进入数据库前执行 `SET LOCAL app.user_id`；严格过滤 `deleted_at IS NULL`。
#### **13.10 设计通证资产化（新增）**
- 单一事实来源（SSOT）：所有 Design Tokens（色彩、字体、间距、圆角、阴影、动效）必须维护于 JSON 文件并存放在 `tokens/` 目录，例如：
  ```
  tokens/
    colors.json
    spacing.json
    typography.json
    radii.json
    shadows.json
    motion.json
  ```
- 示例（`tokens/colors.json`）：
  ```json
  {
    "systemBackground": { "light": "#FFFFFF", "dark": "#000000" },
    "secondarySystemBackground": { "light": "#F2F2F7", "dark": "#1C1C1E" },
    "tertiarySystemBackground": { "light": "#FFFFFF", "dark": "#2C2C2E" },
    "label": { "light": "rgba(0,0,0,0.85)", "dark": "rgba(255,255,255,0.85)" },
    "secondaryLabel": { "light": "rgba(60,60,67,0.6)", "dark": "rgba(235,235,245,0.6)" },
    "tertiaryLabel": { "light": "rgba(60,60,67,0.3)", "dark": "rgba(235,235,245,0.3)" },
    "quaternaryLabel": { "light": "rgba(60,60,67,0.18)", "dark": "rgba(235,235,245,0.18)" },
    "systemBlue": { "light": "#007AFF", "dark": "#0A84FF" },
    "systemGreen": { "light": "#34C759", "dark": "#30D158" },
    "systemRed": { "light": "#FF3B30", "dark": "#FF453A" },
    "systemPurple": { "light": "#5856D6", "dark": "#5E5CE6" },
    "separator": { "light": "rgba(60,60,67,0.29)", "dark": "rgba(84,84,88,0.6)" }
  }
  ```
- 构建与自动转换：在构建与 CI/CD 流水线中使用 Style Dictionary 或等效工具，自动生成各平台资产：
  - Web：输出 `frontend/src/styles/_tokens.css`（CSS 自定义属性），示例变量名：`--color-system-blue`、`--space-m`、`--radius-s`、`--shadow-m`、`--motion-duration-fast`。
  - iOS：输出 Swift（如 `ios/Tokens/Tokens.swift`）。
  - Android：输出 XML（如 `android/app/src/main/res/values/tokens.xml`）。
- 前端使用规范：禁止在代码中硬编码颜色/间距/圆角/阴影/动效值，统一通过 CSS 变量引用：
  - 示例：`color: var(--color-system-blue); margin: var(--space-m); border-radius: var(--radius-s); box-shadow: var(--shadow-m); transition-duration: var(--motion-duration-fast);`
- CI 集成（质量门禁扩展）：
  - Build Tokens：在质量门禁中新增“设计通证生成”步骤（先构建 tokens，再执行构建与测试）。
  - No Hardcode Lint：新增静态检查规则，拒绝出现未通过变量引用的十六进制颜色/裸 px 间距与阴影（允许少量第三方库样式文件豁免）。
## **《Billing 垂直切片（全球化支付与信用点系统）可执行规范（新增）》**

### 1. 数据库与核心架构
- 表复核（已存在并满足本切片需求；新增多网关注册表）：
  - `credit_products`（可购买的信用点商品套餐）
  - `credit_transactions`（信用点流水账本，唯一事实来源）
  - `payments`（支付记录，与支付网关交互）
  - `user_credits_mv`（用户余额物化视图，高性能查询）
  - `currencies`（货币与汇率）
  - `regional_prices`（区域化定价）
  - `payment_gateways`（支付网关注册与配置，见“25.1 payment_gateways”）
- 架构约束（强制）：
  - 支付网关：支持多提供商的模块化架构；具体可用网关由 `payment_gateways` 配置与启用状态决定。
  - Webhook 安全：各网关的 Webhook 端点必须实现签名严格校验；密钥与配置通过 Infisical 管理并安全注入。
  - 事务原子性：Webhook 验证与余额入账必须在单一事务中完成；`payments.status` 更新与 `credit_transactions` 写入同时成功或同时失败。

### 2. REST API 契约（OpenAPI 摘录，当前后端实现为准）
```yaml
openapi: 3.0.3
info: { title: Athena Billing (MVP), version: 1.0.0 }
servers: [ { url: / } ]
security: [ { bearerAuth: [] } ]
paths:
  /api/v1/billing/balance:
    get:
      summary: 查询当前用户信用点余额
      responses: { '200': { description: OK } }

  /api/v1/billing/ledger:
    get:
      summary: 查询信用点账本（分页）
      parameters:
        - in: query
          name: limit
          schema: { type: integer, default: 50, maximum: 100 }
        - in: query
          name: offset
          schema: { type: integer, default: 0, minimum: 0 }
      responses: { '200': { description: OK } }

  /api/v1/billing/sessions:
    post:
      summary: 创建支付会话
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [gateway, amount]
              properties:
                gateway: { type: string }
                amount: { type: integer, minimum: 1 }
                currency: { type: string, default: CNY }
      responses: { '200': { description: OK } }

  /api/v1/billing/webhook/{gateway}:
    post:
      summary: 网关回调（无JWT，严格签名）
      security: []
      parameters:
        - in: header
          name: x-signature
          schema: { type: string }
      responses:
        '200': { description: OK }
        '401': { description: BAD_SIGNATURE }
        '404': { description: SESSION_NOT_FOUND }

  /api/v1/billing/consume:
    post:
      summary: 消耗积分（扣费）
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [amount]
              properties:
                amount: { type: integer, minimum: 1 }
                reason: { type: string }
      responses: { '200': { description: OK }, '400': { description: INSUFFICIENT_BALANCE } }

  /api/v1/billing/exchange:
    post:
      summary: 钱包与积分互换
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [direction, amount]
              properties:
                direction: { type: string, enum: [wallet_to_credits, credits_to_wallet] }
                amount: { type: number, minimum: 0.01 }
      responses: { '200': { description: OK }, '400': { description: INSUFFICIENT_BALANCE } }

  /api/v1/billing/debug/grant-credits:
    post:
      summary: 开发态授予积分/钱包
      security: []
      responses: { '200': { description: OK }, '403': { description: FORBIDDEN } }
```

### 3. 后端核心逻辑（适配器模式）
- 适配器标准：定义 `PaymentGatewayAdapter` 抽象接口，包含：
  - `create_payment_session(amount, currency, user_id, athena_payment_id) -> { payment_url|client_secret, ... }`
  - `handle_webhook(request_body, request_headers) -> { event_type, athena_payment_id, ... }`
- 网关实现：为每个提供商实现具体适配器（如 `PingPongAdapter`、`StripeAdapter`），内部调用对应 SDK/API。
- 动态加载：`PaymentService` 根据 `payment_gateways` 的启用状态与前端传入 `gateway_provider_id` 加载适配器；未指定时可按 `weight` 加权选择。
- GET `/credit-products`：查询 `credit_products.is_active = TRUE`，返回 `{ id, name, credits_amount, price, currency_code }`。
- POST `/payments/create-session`：
  - 在 `payments` 写入 `PENDING`（带 `provider=gateway_provider_id` 与 `gateway_id`）；调用所选网关适配器创建订单，传递 `merchant_order_id = payment_id`；返回 `payment_url`/`client_secret` 与 `payment_id`。
  - 幂等：通过 `Idempotency-Key` 保证重复调用不创建多订单。
- POST `/webhooks/pingpong`：
  - 验证签名：校验请求头中的 PingPong 签名，不通过返回 400。
  - 幂等性：依据事件ID（如 `event_id`）判重，防止重复入账。
  - 在事务中处理 `payment.succeeded`：
    - 按 `merchant_order_id` 定位 `payment_id`，更新 `payments.status = SUCCESS`。
    - 在 `credit_transactions` 写入一条 `type='PURCHASE'` 的记录，增加 Credits 并记录 `balance_after`。
  - 返回 200。
- GET `/billing/balance`：查询 `user_credits_mv` 返回 `{ balance }`。
- GET `/billing/transactions`：按日期范围与类型筛选；游标分页返回交易明细（含 `details` 展开）。

### 4. 前端交互与 UI/UX（新增到“账户与计费/账单历史”）
- 充值页面（个人中心 → 账户与计费）：
  - 顶部展示余额（`GET /billing/balance`）；下方卡片展示套餐（`GET /credit-products`）。
  - 点击卡片 → 展示支付网关列表（`GET /payment-gateways/available`）→ 选择网关 → `POST /payments/create-session`（传 `gateway_provider_id`）→ 跳转所选网关收银台或唤起 SDK。
- 回调页面：
  - 成功页 `/payment/success`：显示“正在充值...”并轮询 `GET /billing/balance`，余额更新后提示“充值已到账”。
  - 失败/取消页 `/payment/canceled`：显示“支付已取消/失败”，提供返回充值页按钮。
- 账单页面（个人中心 → 账单历史）：
  - 表格/列表 + 日期筛选与分页；展示交易时间、类型（购买/AI消耗等）、Credits 变动与交易后余额；AI 消耗记录可展开 `details`（模型、Token、成本拆分）。

### 5. 管理员后台（补充至 Admin Panel 垂直切片）
- 商品管理：`credit_products` CRUD；上架/下架、价格与包含 Credits 数量可编辑。
- 定价与汇率管理：维护 `currencies` 汇率；支持区域化定价 `regional_prices` 的配置与生效策略。
- 交易审查：检索 `payments` 与 `credit_transactions`；支持争议处理（手动退款或补发 Credits），所有操作写入 `audit_logs`。
- 支付网关管理（新）：
  - 全局开关：控制 `is_globally_active`。
  - 网关列表：列出所有接入网关（如 pingpong、stripe）。
  - 单个开关：控制 `is_active`。
  - 配置编辑：表单维护 `config` 中的敏感项（API Key、Webhook Secret 等），入库前加密，展示时掩码；支持 `weight` 设置用于加权选择。

### 6. 安全与合规
- 签名头：Webhook 使用 `x-signature`（或兼容 `x_signature`）承载 HMAC-SHA256 签名；签名计算为 `hex(hmac(secret, raw_body, sha256))`。
- 密钥管理：各网关 Webhook 密钥通过环境变量注入：`PAY_{GATEWAY}_WEBHOOK_SECRET`。
- 事务一致性：Webhook处理全链路使用数据库事务；失败自动回滚，避免账本与支付记录不一致。
- 审计与幂等：关键写操作携带 `Idempotency-Key`；Webhook事件ID防重；操作入 `audit_logs`；错误与重试采用指数退避。

注：当前后端已实现的账本模型为 `credit_accounts/credit_ledger/payment_sessions/payment_webhook_events`，`external_id` 列通过 Alembic 迁移 `0102_ext_id_payment_sessions` 添加；更复杂的 `credit_products/credit_transactions` 设计留作后续迭代。

—— 本切片定义了从商品展示、下单与支付、Webhook入账、余额与账单到后台运营管理的完整闭环；满足全球化、透明计费与安全事务一致性要求。
## **《TTS & 词典/翻译 垂直切片（新增）》**

### 核心原则
- 平台原生优先：优先使用操作系统与浏览器内置能力，降低成本并提升性能。
- 用户高度可配置：声音、翻译引擎、模型均由用户在设置中自定义。
- 体验一致性：Web/桌面/移动端统一入口与交互逻辑。
- 价值对等：付费 AI 翻译必须提供语境感知、高价值的结果与明确计费。 

### 一、语音读书（TTS）
#### 1. 核心架构与技术选型（强制）
- Web：使用浏览器标准 Web Speech API（`window.speechSynthesis`）。
- 桌面（Tauri）：调用操作系统原生 TTS 能力（macOS NSSpeechSynthesizer / Windows SAPI / Linux Speech Dispatcher）。
- 移动端：调用 iOS/Android 原生 TTS SDK。
- MVP 禁止接入任何付费第三方 TTS API。

#### 2. 语言检测工作流（整合至书籍处理流程）
- 在 `tasks.process_book_deeply` 的“格式转换”之后新增步骤 `detect_and_verify_language`：
  - 使用可靠语言检测库（如 `cld3` 的 Python 实现）对抽取的书籍文本样本检测。
  - 决策规则：“自动检测为主、元数据为辅”，最终确定语言代码。
  - 将结果落库至 `books.language` 字段（已存在）。

#### 3. 进度同步（复用心跳会话）
- 前端在 TTS 朗读到新段落时，获取该段落定位符（CFI/坐标），调用 `POST /api/v1/reading-sessions/{sessionId}/heartbeat` 上报 `last_location` 与可选进度百分比。
- 心跳服务与阅读进度型号保持一致（参见“阅读器同步”章节）。

#### 4. 前端 UI/UX 与用户设置
- 功能入口：书架/书籍卡片的“更多操作（MoreHorizontal 图标）”菜单新增“语音读书”，点击打开阅读器并开始朗读。
- 阅读器 UI：朗读开始时底部浮现“朗读控制条”（播放/暂停、上一句/下一句、语速调节）。
- 用户设置（前端）：个人中心 → 设置 → “朗读设置”页面：
  - 首选声音性别：自动/男声/女声。
  - 语言修正：在朗读控制条显示当前语言，允许手动切换作为兜底（覆盖自动检测）。

### 二、词典与翻译（混合引擎模型）
#### 1. 核心架构
- 后端统一入口：采用 `/api/v1/dict` 与 `/api/v1/translate` 模块；前端根据用户设置选择引擎。
- 引擎类型：离线词典（Stardict）、在线翻译（Microsoft/Google）、AI 语境翻译（付费，消耗 Credits）。

#### 2. 用户前端设置（核心）
- 个人中心 → 设置 → “词典与翻译”页面：
  - 离线词典管理：展示管理员推荐的、版权合规的词典包（Stardict 格式），提供“下载/已下载/删除”。
  - 划词翻译首选引擎：下拉菜单（默认“离线词典优先”，可选 Microsoft Translator、Google Translate、AI 模型翻译）。
  - AI 翻译专用模型：独立下拉菜单由 `GET /api/v1/ai/available-models` 动态填充，仅作用于“AI翻译”，与“AI对话”默认模型隔离。
  - 语言对预设：支持多个常用翻译对（如英→中、 中→日）。

#### 3. 交互流程与后端逻辑
- 划词交互：用户划词后弹出统一设计的浮动卡片，依据首选引擎展示结果。
- 离线词典：首选为离线时，前端在本地已下载词典中查询（JS 解析库），不发起网络请求。
- 在线翻译（Google/Microsoft）：前端调用后端代理接口（预留）；当前实现为 `POST /api/v1/translate`，后端可根据配置调用第三方 API 或走内置模拟。
- 语境感知 AI 翻译（付费）：
  - API：`POST /api/v1/ai/translate`；请求体：`{ text, source_language, target_language, model_id, context: { book_title, book_author, chapter_title } }`。
  - 逻辑：根据 `model_id` 查询价格；使用后台可配置的“语境感知翻译” Prompt 模板，填充 `text` 与 `context`，通过 OpenRouter 调用模型；按 Token 与单价计算 Credits 并在 `credit_transactions` 记账（type='CONSUME', credit_type='AI_CALL'，details 结构参见账本规范）。
- 历史记录：所有成功的查词/翻译操作调用 `POST /api/v1/dict-history` 写入 `dict_history`。

#### 4. 管理员后台功能
- 离线词典管理：上传与管理可下载词典包（Stardict），含包元数据与对象存储地址。
- 在线 API 密钥配置：管理 Microsoft/Google 翻译 API 密钥（通过 Infisical 等密钥管理）。
- AI 翻译 Prompt 模板：在“Prompt 模板管理”中新增“语境感知翻译”模板的编辑入口。

### 三、REST API 契约（OpenAPI 摘录，当前后端实现为准）
```yaml
openapi: 3.0.3
info: { title: Athena TTS & Dictionary (MVP), version: 1.0.0 }
servers: [ { url: / } ]
security: [ { bearerAuth: [] } ]
paths:
  /api/v1/dict/packages/upload_init:
    post:
      summary: 词典包上传初始化（返回PUT URL）
      responses: { '200': { description: OK } }

  /api/v1/dict/packages/upload_complete:
    post:
      summary: 词典包上传完成
      responses: { '200': { description: OK }, '404': { description: NOT_FOUND } }

  /api/v1/dict/packages:
    get:
      summary: 列出我的词典包
      responses: { '200': { description: OK } }

  /api/v1/dict/lookup:
    post:
      summary: 查词
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [word]
              properties:
                word: { type: string }
                lang: { type: string, default: en }
                package_id: { type: string, format: uuid }
                book_id: { type: string, format: uuid }
      responses: { '200': { description: OK }, '400': { description: MISSING_WORD } }

  /api/v1/dict/history:
    get:
      summary: 查词历史（分页）
      responses: { '200': { description: OK } }

  /api/v1/translate:
    post:
      summary: 文本翻译（计费或模拟）
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [text]
              properties:
                text: { type: string }
                target_lang: { type: string, default: zh }
      responses: { '200': { description: OK }, '400': { description: INVALID_TEXT } }
```

### 四、数据库变更与扩展
#### dictionary_packages（离线词典包表）
| 字段名 | 类型 | 描述与约束 |
|---|---|---|
| id | SERIAL | PK |
| name | VARCHAR(100) | 词典包名称，NOT NULL |
| description | TEXT | 描述 |
| format | VARCHAR(20) | 词典格式（如 'stardict'），NOT NULL |
| object_storage_key | TEXT | 对象存储键，NOT NULL |
| is_active | BOOLEAN | 是否可用，NOT NULL, DEFAULT TRUE |
| created_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |
| updated_at | TIMESTAMPTZ | NOT NULL, DEFAULT now() |

```sql
ALTER TABLE dictionary_packages ENABLE ROW LEVEL SECURITY;
CREATE POLICY dictionary_packages_admin ON dictionary_packages FOR ALL USING (current_setting('app.role', true) = 'admin') WITH CHECK (current_setting('app.role', true) = 'admin');
CREATE INDEX IF NOT EXISTS idx_dictionary_packages_active ON dictionary_packages (is_active);
```
- `books.language`：由 `detect_and_verify_language` 步骤写入（字段已存在）。
- `dict_history`（扩展）：新增字段以支持翻译记录：
  - `engine VARCHAR(20)`（离线/在线/ai）
  - `source_language VARCHAR(10)`、`target_language VARCHAR(10)`
  - `result JSONB`（结构化的翻译/词典结果）
- 新增 `dictionary_packages`（离线词典包注册表）：
  - `id SERIAL PK`、`name VARCHAR(100)`、`description TEXT`、`format VARCHAR(20)`（如 `stardict`）
  - `object_storage_key TEXT`（MinIO/S3 Key）、`is_active BOOLEAN DEFAULT TRUE`
  - `created_at TIMESTAMPTZ DEFAULT now()`、`updated_at TIMESTAMPTZ DEFAULT now()`

### 五、安全与合规
- 密钥管理：Microsoft/Google 翻译密钥通过 Infisical 管理，后端读取；严禁前端暴露。
- 计费透明：AI 翻译的 Credits 扣除写入 `credit_transactions`，明细依据账本 `details` 结构；失败不扣费，异常回滚。
- RLS 与审计：所有用户数据读写遵循 RLS；关键写操作（历史记录、计费）写入 `audit_logs`。

### 六、测试与 CI Gate
- 单元测试：TTS 控件与语言切换、字典解析与代理调用、AI 翻译计费路径。
- 合同测试：OpenAPI 契约端点覆盖；错误码与边界。
- E2E：划词→浮动卡片→引擎选择→结果展示；AI 翻译成功后账本扣费与历史写入；回归检查 TTS 心跳同步。
- 安全扫描：密钥注入与前端资源校验；严禁密钥泄露。

—— 本切片定义了 TTS 与词典/翻译的端到端实现，从原生朗读与进度同步、离线/在线/AI 翻译引擎到历史与计费闭环，满足平台原生优先与全球化合规的产品原则。
```sql
CREATE INDEX IF NOT EXISTS idx_books_language ON books (language);
```

## 《Landing Page & Marketing Site 开发规范 v2.0（修正版）》

### 核心原则
- 品牌一致性：官网视觉与应用 UI/UX 采用同一 Design Tokens（颜色、字体、间距、圆角、阴影、动效）。
- 性能至上：优化 LCP/TTI 与资源体积；尽量零 JS，仅对交互岛加载所需 JS。
- SEO 友好：SSG、语义结构、完整 meta 与 sitemap/robots。
- 清晰转化路径：所有设计服务于注册登录与进入 Web 应用主域。
- 全球化原生（Global-First）：从第一天起支持多语言，URL、内容、SEO 与货币本地化全部一等公民。

---

### 第一章：技术栈与架构选型（含 i18n）
- 框架：Astro
  - 性能：零 JS（Islands Architecture），内容驱动站点首屏极优。
  - SEO：SSG 输出静态 HTML，搜索引擎抓取友好。
  - 生态：可无缝集成 React/Vue/Svelte 组件，复用应用内组件（Button、Card）。
  - i18n 路由：Astro 原生/生态方案支持 `/en/pricing`、`/jp/pricing` 等多语言 URL 结构，对国际 SEO 友好。
- 样式：Tailwind CSS
  - 高效原子化样式，易与 Design Tokens 结合；Astro 集成成熟。
- 部署：Vercel 或 Netlify
  - 全球化 CDN，原生 CI/CD，简化构建与缓存策略。
- 国际化框架：`astro-i18next` 或 Astro 官方 i18n 方案
  - 与 Astro SSG/Islands 深度集成，支持 JSON 翻译文件与无障碍的路由生成。
  - 行业标准 i18next 生态，易与翻译平台或后台联动；每种语言生成独立静态页面与 URL。

---

### 第二章：网站结构与核心页面（含语言切换）
- 主页（`src/pages/index.astro`）
  - Header：Logo、导航（特性/定价/Blog）、“登录”与主 CTA “开始使用”、语言切换器。
  - Hero：主标题（Slogan：把读过的每一本书，都变成你的知识资产。）、副标题、核心界面动态截图/短视频、显眼主 CTA “免费开始使用”。
  - 特性区：以卡片/滚动展示云同步、AI整合、极致笔记体验等核心功能。
  - 用户证言：展示内测用户评价与头像/身份标签。
  - 定价预览：简要对比“免费/Pro”，链接至定价页。
  - Footer：版权、条款、隐私、联系与社媒链接、语言切换器。
- 定价页（`src/pages/pricing.astro`）
  - 并排定价卡片：完整列出“免费/Pro”功能权益。
  - 月付/年付切换；突出年付折扣。
  - CTA：免费开始/升级到 Pro。
  - FAQ：支付、额度、退款与发票等常见问题。
  - 价格本地化：根据当前语言/地区，使用 `Intl.NumberFormat(locale, { style: 'currency', currency })` 本地化显示金额；与 `currencies/regional_prices` 联动从后台拉取正确货币与区域价格。
- 登录页（`src/pages/login.astro`）
  - 提供 OAuth（Google/Microsoft）与邮箱验证码登录入口。
  - 登录/注册后重定向至 Web 应用主域（如 `https://app.athena.com`），携带 `code/state` 等参数，由应用接管认证。
  - 明确安全与隐私提示；失败回退路径。
- 全局：
  - 统一 Header/Footer；导航清晰，CTA 位置固定；移动端底部留主 CTA。
  - 语言切换器：Header 与 Footer 均提供显眼的语言切换入口（下拉菜单 + 地球图标），列出语言如 English/简体中文/日本語；切换时无刷新或平滑过渡到对应语言 URL，并记录偏好（localStorage/Cookie）。

#### 2.4 单点登录（SSO）与状态同步（新增）
- 目标：官网（`youdomin.com`）与 Web 应用（`app.youdomin.com`）之间提供无缝单点登录体验。
- 状态共享：通过顶级域安全 Cookie（`Domain=.youdomin.com; SameSite=None; Secure`）或跨子域的安全存储策略，官网可检测用户登录状态。
- 动态 UI：用户已登录时，Header 自动将“登录/注册”替换为“进入应用（Launch App）”与用户头像/菜单；未登录时显示“登录/注册”。
- 无缝跳转：已登录用户点击“进入应用”，直接跳转到应用主界面，无需再次登录；失败回退至登录页并保留 `redirect` 参数。

---

### 第三章：开发与设计规范（含 i18n 工作流）
- 复用 Design Tokens（SSOT）
  - Tailwind 配置通过脚本读取 `tokens/*.json`（colors/spacing/typography/radii/shadows/motion）。
  - 构建时用 Style Dictionary 或等效工具生成 `_tokens.css`（CSS 变量）与平台资产；禁止在代码中硬编码颜色/间距等值。
- SEO 最佳实践
  - 每页唯一且描述性的 `<title>` 与 `<meta name="description">`。
  - 语义化标签：`<main>/<section>/<article>/<h1>-<h6>`；图片强制 `alt`。
  - 生成 `sitemap.xml` 与 `robots.txt`；规范 canonical 链接。
  - 为每个语言版本设置 `hreflang`：
    ```html
    <link rel="alternate" hreflang="en" href="https://athena.app/en/pricing" />
    <link rel="alternate" hreflang="zh-CN" href="https://athena.app/zh-CN/pricing" />
    <link rel="alternate" hreflang="x-default" href="https://athena.app/pricing" />
    ```
  - 3.5 动态 OG 图片生成：
    - 必须实现动态 Open Graph (OG) 图片，以提升社交分享效果与信息密度。
    - 为不同页面类型（主页、定价页、博客文章）设计不同分享卡片模板（基于 HTML/CSS 组件）。
    - 使用 Astro 生态（如 `@astrojs/satori`）在构建或服务端渲染卡片为图片；页面 `<head>` 中 `og:image` 指向对应动态图片 URL。
- 性能优化
  - 图片采用 AVIF/WebP 并压缩；启用懒加载与响应式尺寸（`srcset/sizes`）。
  - 关键资源 `preconnect/dns-prefetch`；严格控制第三方脚本与同步加载。
  - 指标与预算：LCP < 2.0s（3G/中端设备），TTI < 3.0s；主页体积预算 ≤ 150KB（Gzip）。
  - 仅对交互岛加载 JS；组件级按需 hydration。
- 无障碍与合规
  - 满足 WCAG AA（对比度、键盘可用性、焦点可见性）。
  - 隐私与条款链接显著；Cookie/第三方脚本符合地区合规要求。
- 国际化（i18n）工作流
  - 翻译文件：所有 UI 文本（按钮/标题/段落）严禁硬编码，统一通过翻译键（如 `homepage.hero.title`）引用。
  - 目录示例：
    ```
    src/locales/
      en/common.json
      zh-CN/common.json
      jp/common.json
    ```
  - 与后台联动：在管理员后台的 `translations` 表统一维护官网与应用的所有多语言内容；通过脚本或 CI 任务定期从后台导出官网所需的 JSON 翻译文件到 `src/locales/`，保持一致性与可控性。
  - 路由生成：依据语言清单自动生成 `/en/*`、`/zh-CN/*`、`/jp/*` 静态页面；语言优先级与默认语言通过配置设定。

---

### 第四章：Tokens 集成与示例
- 目录结构（示例）
  ```
  tokens/
    colors.json
    spacing.json
    typography.json
    radii.json
    shadows.json
    motion.json
  ```
- Tailwind 配置（示例）
  ```js
  // tailwind.config.js
  const fs = require('fs')
  const path = require('path')
  const colors = JSON.parse(fs.readFileSync(path.resolve('tokens/colors.json'), 'utf-8'))

  const toCssVars = (obj, prefix) => Object.fromEntries(
    Object.entries(obj).map(([k,v]) => [k, `var(--${prefix}-${k})`])
  )

  module.exports = {
    content: ['src/**/*.{astro,tsx,jsx,html}'],
    theme: {
      extend: {
        colors: {
          systemBlue: toCssVars(colors, 'color'),
        },
        spacing: {
          m: 'var(--space-m)',
        },
        borderRadius: {
          s: 'var(--radius-s)'
        },
        boxShadow: {
          m: 'var(--shadow-m)'
        },
        transitionDuration: {
          fast: 'var(--motion-duration-fast)'
        }
      }
    }
  }
  ```
- CSS 变量（示例）
  ```css
  :root{
    --color-system-blue: #007AFF;
    --space-m: 16px;
    --radius-s: 6px;
    --shadow-m: 0 4px 12px rgba(0,0,0,0.08);
    --motion-duration-fast: 150ms;
  }
  ```

---

### 第五章：页面模块规范（示例）
- Hero 模块
  - 结构：主标题（h1）+ 副标题（p）+ 媒体（picture/video）+ 主 CTA（button）。
  - 要求：首屏可见、媒资压缩、可访问性属性完整、移动端优先排版。
- 定价卡模块
  - 并排卡片：名称、价格（月/年）、权益清单、CTA；年付折扣明显；切换开关无障碍可操作。
- 登录模块
  - OAuth 按钮清晰；邮箱验证码表单具备校验与错误提示；跳转参数 `code/state` 完整。

---

### 第六章：部署与 CI/CD
- 平台：Vercel 或 Netlify，开启全局缓存与边缘网络。
- 流水线步骤：
  1) 安装依赖
  2) 生成 Design Tokens 资产（Style Dictionary）
  3) 构建 Astro（SSG）
  4) 产物审计：体积、LCP 预测、可访问性扫描（axe）
  5) 部署到生产或预览环境
- 站点地图与 robots：构建时自动生成 `sitemap.xml` 与 `robots.txt`。
- 安全与合规：设置 CSP、Referrer Policy、X-Content-Type-Options；隐私与条款页面可见。
 - 国际化产出：对每种语言独立生成静态 HTML 与 URL；构建环节输出对应 `hreflang` 与 `sitemap` 条目。

---

### 第七章：转化路径与度量
- 清晰 CTA：各页主 CTA 指向注册并进入 Web 应用；次 CTA 指向定价与 FAQ。
- 事件度量：注册点击、登录跳转、视频播放、定价切换与 FAQ 展开；用于漏斗分析与优化。
 - 多语言漏斗：按语言/地区分层统计主要转化事件，优化文案与引导逻辑。
#### **示例11: AccountSettings 组件（新增）**
- 位置：个人中心 → 账户设置。
- 行为：编辑昵称、时区、语言；保存时调用 `PATCH /api/v1/profile/me`，携带 `If-Match` 与 `Idempotency-Key`；成功后更新本地 `ETag`。
- Props (TypeScript):
```typescript
interface AccountSettingsProps {
  profile: { display_name: string; timezone: string; language: string; version: number };
  onSave: (payload: { display_name?: string; timezone?: string; language?: string }, headers: { ifMatch: string; idemKey: string }) => Promise<void>;
}
```
- 订阅与信用点：Pro 专业版订阅用户每月自动获赠一定数量的雅典娜信用点，用于 AI 对话、OCR 等增值服务；当月未用完额度在下月初清零；额度不足时可随时购买加油包。
### **变更日志（Changelog） v8.0**
- 可靠性：新增 Celery Broker 可靠性配置（`broker_heartbeat=30`、`broker_connection_retry_on_startup=true`、`task_acks_late=true`、`task_reject_on_worker_lost=true`），并再次强调任务幂等性。
- 协同编辑：新增 Yjs 冲突解决与版本快照策略（版本单调递增；100次更新或5分钟自动快照；服务端冲突检测与前端非阻塞恢复流程）。
- 域名策略：新增全局域名与子域名策略（`youdomin.com` 占位），对齐 SSO/CORS/CDN/i18n。
- 安全与合规：延续 v7.1 强化（RLS 全覆盖、密钥轮换、GDPR/CCPA 规划、CI 合规门禁）。

**最终审查声明（v8.0）**
- 经最终硬化与卓越升级，文档已达到世界级的异步任务可靠性与实时协同健壮性标准，连同安全、合规、SRE 指标与工程门禁，现已具备工业级封版条件，可作为项目开发与运维的最终依据。

### **变更日志（Changelog） v7.1**
- 安全：为 `user_sessions`、`reading_progress`、`dict_history` 启用 RLS；为 `payment_gateways`、`dictionary_packages` 启用 Admin RLS。
- 契约：新增 `contracts/api/v1/profile.yaml`（GET/PATCH `/api/v1/profile/me`，强制 `If-Match` 与 `Idempotency-Key`）。
- UI/UX：新增 `AccountSettings` 组件契约；图标体系继续遵循 Lucide 标准。
- 商业：在 Pro 专章明确订阅与信用点关系（每月赠送、当月清零）。
- SRE：新增 SLO/SLI 与错误预算；新增 DR 目标与备份/演练要求。
- 索引：补充 `reading_progress(user_id, book_id, updated_at)`、`ai_conversations(user_id, last_user_message_at)`、`payments(gateway_id)`。
- 安全与合规：新增密钥轮换策略；Admin Panel 增加 GDPR/CCPA 数据主体请求规划；CI 增加 Secret Scanning 与 OSS License 检查。

**最终审查声明**
- 经本次硬化与完善修订，文档已达到 100% 可执行、工业级封版状态；符合既定安全、可靠性与合规标准，可作为项目开发最终依据。
#### **Celery Broker 可靠性配置（新增）**
- 问题陈述：在生产环境中，Celery 消费者面对 Redis Broker 网络抖动或重启时，可能出现连接冻结、任务不再消费的风险。
- 可靠性配置（生产示例）：
  ```python
  celery_config = {
    "broker_url": "redis://<host>:6379/0",
    "result_backend": "redis://<host>:6379/1",
    "broker_heartbeat": 30,
    "broker_connection_retry_on_startup": True,
    "task_acks_late": True,
    "task_reject_on_worker_lost": True,
    "worker_prefetch_multiplier": 1,
  }
  ```
- 幂等性再强调：以上配置可能导致任务在故障与重试场景下被重复执行；所有 Celery 任务必须从业务逻辑层面支持幂等（例如：以 `idempotency_key` 或资源唯一约束校验是否已处理）。
#### **Yjs 冲突解决与版本快照（新增）**
- 版本控制：`note_versions.version_number` 单调递增；服务端持久化的最新版本号用于协同比对。
- 快照策略：满足其一即生成新快照（`note_versions` 记录）：
  - 累计收到 100 个 Yjs Update；
  - 距上次保存超过 5 分钟。
- 服务端冲突检测（伪代码）：
  ```python
  def on_yjs_update(note_id, client_version, update, state_vector_from_client):
      server_version = db.get_latest_note_version(note_id)
      if server_version > client_version:
          return ws_send(client_id, {
              "type": "conflict",
              "version_number": server_version,
              "state_vector": db.get_state_vector(note_id)
          })
      apply_update(note_id, update)
      maybe_snapshot(note_id)
  ```
- 前端冲突恢复（UI/UX 要求）：
  - 保存本地草稿：收到 `conflict` 消息时，立即将未同步修改保存到 IndexedDB“草稿区”。
  - 后台同步：使用服务端返回的 `state_vector` 与最新文档状态进行同步（Yjs 自动合并）。
  - 自动应用草稿：同步完成后，静默地将草稿重新应用到已同步文档。
  - 用户提示：仅展示非阻塞 Toast（如“您的内容已在别处更新，正在为您自动同步...”→“同步完成”）；绝不弹模态框中断编辑，确保无数据丢失。
## 1.3 前端基础项目结构完成（验证通过）
- PWA 配置：`web/vite.config.ts:3–20`，启用 `vite-plugin-pwa`，`registerType=autoUpdate`，缓存 `**/*.{js,css,html,ico,png,svg,json}`。
- Service Worker 注册：`web/src/main.tsx:5–6`，调用 `registerSW({ immediate: true })`。
- i18n 动态加载：`web/src/i18n.ts:3,6–19`，接入 `i18next-http-backend`，从 `VITE_LOCALES_BASE_URL` 加载 `{{lng}}/{{ns}}.json`，同时保留本地资源作为回退。
- 本地化资源：`web/public/locales/en/common.json:1–3`、`web/public/locales/zh-CN/common.json:1–3`；开发默认 `VITE_LOCALES_BASE_URL=/locales`（`web/.env:1`）。
- Lucide 规范示例：`web/src/App.tsx:2,7` 使用 `Menu` 图标，颜色遵循 Tokens（`var(--color-system-blue)`）。
- 质量门禁：`web/package.json:10–12` 脚本含 `lint/typecheck/i18n:no-hardcode`；`web/scripts/no-hardcode.cjs:1–29` 检测中文硬编码；TypeScript 类型补全见 `web/tsconfig.json:8`。
- 本地验证：`pnpm install`、`pnpm dev` 启动成功（预览 `http://localhost:5173/`）；`pnpm lint`、`pnpm typecheck`、`pnpm run i18n:no-hardcode` 全部通过。
## 1.4 监控与备份栈完成（验证通过）
- Prometheus 集成：`monitoring/prometheus.yml:1–9`，抓取 `api:8000/metrics`；Compose 增加 `prometheus` 服务并暴露 `9090`。
- Grafana 启动：Compose 增加 `grafana` 服务并暴露 `3000`，默认管理员 `admin/admin`（仅开发环境）。
- API 指标暴露：`api/requirements.txt:9` 添加 `prometheus-fastapi-instrumentator`；`api/app/main.py:6,13` 通过 `Instrumentator().instrument(app).expose(app)` 暴露 `/metrics`。
- 运行验证：
  - Prometheus Ready：`curl http://localhost:9090/-/ready` 返回 `200`。
  - Targets：`curl http://localhost:9090/api/v1/targets` 显示 `api` 目标 `health: up`。
  - API 日志：`docker compose logs api` 显示周期性 `GET /metrics 200`。
- 备份策略（开发态演练）：
  - 一次性备份：`docker compose run --rm backup`，生成 `f:\reader\Athena\backups\athena_YYYYMMDD_HHMM.sql.gz`（已验证）。
  - 计划任务：后续以 `cron`/CI 定时触发，满足 RPO≤15 分钟；恢复流程校验满足 RTO≤60 分钟。
- SRE 指标声明（新增）：
  - SLO/SLI：核心 API P95 延迟≤300ms，99% 可用性≥99.9%，错误率≤0.1%；指标采集与告警由 Prometheus+Grafana 统一管理。
  - DR 目标：RPO≤15 分钟，RTO≤60 分钟；每月恢复演练至少 1 次，演练报告归档。
## 2.1 账户与认证完成（开发态最小闭环）
- 契约对齐：实现 `contracts/api/v1/auth.yaml` 所列端点的最小可用版本。
- 路由位置：`api/app/auth.py:1–97`，经 `api/app/main.py:13–14` 注入。
- 流程：邮箱验证码登录→创建 `user_sessions`→签发 `JWT Access` 与 `Refresh`（Redis 存储）。
- 依赖与配置：`api/requirements.txt:10` 增加 `python-jose`；`.env` 可配置 `AUTH_SECRET/ACCESS_EXPIRE/REFRESH_EXPIRE/REDIS_HOST/REDIS_PORT`（开发默认值）。
- 数据库：`api/alembic/versions/0002_auth.py:1–15` 增加 `users` 表与 RLS `users_owner`；已执行 `alembic upgrade head`。
- 验证：
  - 发送验证码：`POST /api/v1/auth/email/send_code` 返回 `request_id`；验证码缓存在 Redis `email_code:{email}`。
  - 验证并登录：`POST /api/v1/auth/email/verify_code` 返回 `user/tokens/session`。
  - 刷新令牌：`POST /api/v1/auth/refresh` 返回新 `access_token/refresh_token`。
  - 会话查询：`GET /api/v1/auth/sessions` 基于 RLS 按 `app.user_id` 过滤。
- 运行证据：`docker compose logs api`、`curl` 实测返回均正确。
## 3.3 TTS & 词典 完成（开发态最小闭环）
- 路由：
  - TTS：`api/app/tts.py:13–72`（`GET /api/v1/tts/voices`、`POST /api/v1/tts/speak`、`GET /api/v1/tts/history`）
  - 词典：`api/app/dict.py:11–91`（`POST /api/v1/dict/packages/upload_init`、`POST /api/v1/dict/packages/upload_complete`、`GET /api/v1/dict/packages`、`POST /api/v1/dict/lookup`、`GET /api/v1/dict/history`）
  - 翻译：`api/app/translate.py:10–48`（`POST /api/v1/translate`、`GET /api/v1/translate/history`）
- 数据库与RLS：`api/alembic/versions/0008_tts_dict.py:1–118`（`tts_requests/translation_history/dictionary_packages/dict_history` 表及索引、RLS 全覆盖）
- 存储：`api/app/storage.py:24–30` 增加 `upload_bytes`，将 TTS 音频写入 MinIO，返回 `presigned_get` 下载地址；桶名默认 `athena`。
- 幂等：写接口支持 `Idempotency-Key` 头，Redis 键 `idem:{key}`；重放返回同一资源。
- 验证：
  - 合成：`POST /api/v1/tts/speak` 返回 `audio_url`；`GET /api/v1/tts/history` 可见记录。
  - 词典包：初始化上传→完成→列表；`lookup` 记录查询历史。
  - 翻译：`POST /api/v1/translate` 返回结果并入库；`GET /api/v1/translate/history` 可见记录。
- 可观测性：所有接口受 Prometheus 采集；错误通过 Sentry 捕获。
## 3.4 Admin Panel 完成（开发态最小闭环）
- 路由：`api/app/admin.py:9–163`（`GET /api/v1/admin/users`、`PATCH /api/v1/admin/users/{id}`、`GET/POST/PATCH /api/v1/admin/gateways`、`GET/POST/PATCH/DELETE /api/v1/admin/translations`、`GET /api/v1/admin/credits/accounts`、`GET /api/v1/admin/credits/ledger`）
- 迁移与RLS：`api/alembic/versions/0009_admin_core.py:1–116`（`users.version` 增加，并将 RLS 扩展至 admin；新增 `payment_gateways/prompt_templates/audit_logs/translations`，全部 admin-only RLS）
- 并发与幂等：更新接口强制 `If-Match`；新增翻译 `upsert` 支持冲突增量；创建类接口支持 `Idempotency-Key`（保留键位）。
- 管理鉴权：`ADMIN_TOKEN` 头 `X-Admin-Token` 校验；事务内 `SELECT set_config('app.role','admin',true)`。
- 登录补齐：`api/app/auth.py:57–59` 登录时写入 `users` 表。
## 3.5 Landing & Marketing 完成（开发态最小闭环）
- 页面与SEO：`web/index.html:3–15` 增加 `meta description/og/twitter` 与 `hreflang` alternate 链接；保留 PWA 与缓存策略。
- 文案与切换：`web/src/locales/en/common.json:1–5`、`web/src/locales/zh-CN/common.json:1–5` 补充标题/副标题/CTA/语言；`web/src/App.tsx:1–31` 增加语言切换与 CTA。
- robots 与 sitemap：`web/public/robots.txt:1–3`、`web/public/sitemap.xml:1–18`；满足搜索引擎抓取要求与多语言入口。
- 验证建议：本地 `pnpm dev` 后 Lighthouse 分数应>90；检查首页 `link[rel=alternate]` 与 `robots/sitemap` 可访问。
## 4.1 WebSocket/Yjs 完成（开发态最小闭环）
- 路由：`api/app/realtime.py:1–93` 提供 `GET ws://.../ws/notes/{note_id}?token=...`；消息格式：
  - `ready`: `{ type: "ready", version }`
  - `update`: `{ type: "update", client_version, update }`（`update` 为 Base64）
  - `apply`: `{ type: "apply", version, update }`
  - `conflict`: `{ type: "conflict", version }`
- 快照与版本：`api/alembic/versions/0010_yjs_snapshots.py:1–41` 新增 `note_versions(owner_id,note_id,version_number,update_data)`；阈值为累计 100 次或 5 分钟；服务端在事务内写入，RLS 按 `owner_id`。
- 冲突逻辑：当 `client_version < server_version` 返回 `conflict`，前端按示例 `f:\reader\Athena\雅典娜技术文档.md:6411–6421` 执行草稿保存与自动恢复。
## 4.2 国际化与支付全球化 完成（开发态最小闭环）
- 区域定价：`api/alembic/versions/0011_pricing.py:1–43` 新增 `regional_prices`，admin-only RLS；`api/app/admin.py:164–188` 管理端 upsert 列表。
- 定价API：`api/app/pricing.py:1–47` 提供 `GET /api/v1/pricing/currencies` 与 `GET /api/v1/pricing/plans?currency=`，无配置时按内置汇率转换返回。
- 同步脚本：`web/scripts/i18n-sync.cjs:1–53` 从 Admin 翻译拉取到 `web/public/locales/{lang}/common.json`；`web/package.json:7–13` 增加 `i18n:sync`。
- 前端展示：`web/src/Price.tsx:1–21` 基于 `Intl.NumberFormat` 按语言选择货币；`web/src/App.tsx:1–33` 集成价格区块，配合语言切换。
## 4.3 全项目 CI/CD 完成（开发态最小闭环）
- 工作流：`.github/workflows/main.yml:1–57`（web lint/typecheck/i18n:no-hardcode/build；api 语法编译；compose 配置校验）
- 契约工作流：`.github/workflows/contracts.yml:1–30` 手动触发，支持 `STAGING_BASE` 健康与核心接口冒烟。
- 验证：PR 提交可触发 CI，所有门禁通过；staging 环境提供后手动触发契约工作流。
## 4.4 E2E 与 SRE 指标 完成（开发态最小闭环）
- E2E：`web/cypress.config.ts:1–7`、`web/cypress/e2e/home.cy.ts:1–8`；CI 集成见 `.github/workflows/main.yml:34–40`。
- SRE 仪表：`monitoring/dashboards/api.json:1–26` 请求率/错误率/延迟P95；Grafana 导入后即可可视化。
- 错误预算：`monitoring/error_budget.py:1–10` 计算给定 SLO 与时长的预算分钟数。
## 4.5 P1 扩展（OCR/SRS）完成（开发态最小闭环）
- DDL 与 RLS：`api/alembic/versions/0012_ocr_srs.py:1–67` 新增 `ocr_jobs` 与 `srs_reviews`，RLS 覆盖 owner/admin。
- OCR API：`api/app/ocr.py:1–42` 预签名上传、完成处理、列表；当前为 Mock 文本，后续可接入实际 OCR 引擎。
- SRS API：`api/app/srs.py:1–74` 创建卡片、到期列表、答题调度与历史；调度基于简化 SM-2。
## 验收清单补齐（统一错误码与告警）
- 错误码契约：`contracts/errors.yaml:1–17`；统一错误响应封装于 `api/app/main.py:30–39`（`{"status":"error","error":{"code","message"}}`）。
- 告警规则：`monitoring/alerts.yml:1–17`（5xx 错误率与 P95 延迟阈值）；Prometheus 引用 `monitoring/prometheus.yml:1–10`；Compose 挂载 `docker-compose.yml:39–41`。
### 3.x 钱包与充值系统（新增）
- 概念：除“雅典娜信用点（Credits）”外，新增“钱包余额（Wallet）”，以用户当前货币（如 CNY/USD）计价，存储在 `credit_accounts(currency,balance)`；小额按“分/美分”等最小单位计量，避免浮点误差。
- 适用范围：
  - OCR（按页/字符计费）与向量化（按字数/段落/书籍计费）直接从钱包余额扣减；适合微小金额且无需汇率换算。
  - OpenRouter 等大模型调用仍以 Credits 为主计费；支持将钱包余额按汇率兑换为 Credits 使用。
- 兑换规则：
  - `POST /api/v1/billing/exchange`（规划中）：根据 `usd_to_credit_rate` 与当前货币汇率，将钱包余额扣减相应金额并增加 Credits；写入账本明细（type='EXCHANGE'）。
  - 汇率与费率源：`currencies` 与动态更新的 `usd_to_credit_rate`，透明展示于账单明细。
- 扣费示例：
  - 书籍向量化：20万汉字，单本定价 1.00 CNY → 从钱包扣 1.00 CNY，账本增加一条 `debit`（reason='vectorize_book'，details 包含字数与书籍ID）。
  - OCR：按页 0.02 CNY → 上传 50 页 → 钱包扣 1.00 CNY；若指定 Credits 则按照折算率先兑换后按 Credits 扣减。
- 账本与审计：
  - 钱包与 Credits 统一记入 `credit_ledger`（方向 `credit/debit`）；`details` 字段记录业务维度（OCR页数、字数、模型Token等）；所有写操作使用事务，失败回滚。
- 前端展示：
  - 个人中心“账户与计费”：余额（钱包/Credits）双栏展示与实时刷新；充值页支持网关选择与成功/失败回调页；账单列表支持筛选与展开 `details`。

### 3.y 定价规则（按服务/单位/货币，动态备注）（新增）
- 目标：管理员在后台自由配置“服务定价”，前端与账单根据当前规则动态展示“估算费用与备注”。
- 数据结构：`pricing_rules`
  - `id UUID`、`service_type ENUM('VECTORIZE','OCR','AI_CALL')`
  - `unit_type ENUM('CHARS','TOKENS','PAGES')`、`unit_size INTEGER`
  - `price_amount DECIMAL(10,2)`、`currency VARCHAR(10)`（如 CNY/USD）
  - `region VARCHAR(10)`（如 CN/US，可选）、`active_from/active_to TIMESTAMP`、`is_active BOOLEAN`
  - `remark_template TEXT`（动态备注模板，如：`向量化定价为每{unit_size}个汉字（约{approx_tokens}个Tokens）{price_amount}{currency}`）
- 计算规则：`cost = ceil(quantity / unit_size) * price_amount`，货币按规则中的 `currency`；`approx_tokens` 可按 1 汉字 ≈ 1.5 Tokens 估算。
- 接口（SSOT）：
  - 用户：`GET /api/v1/pricing/rules?service_type=VECTORIZE&region=CN` 返回当前有效规则与渲染后的 `remark`。
  - 管理：`GET/POST/PATCH/DELETE /api/v1/admin/pricing/rules`（ETag 并发）配置规则；变更后即时生效。
- 前端展示：
  - 充值/钱包/账单页：根据当前用户 `region/currency` 显示估算与备注；下单前提示“预估费用”。
- 示例（中国区）：
  - 向量化：管理员配置每 100,000 汉字 0.5 CNY；用户备注呈现（示例）：`向量化服务是指将您的书籍进行数字化，以更好地为您提供 AI 服务；雅典娜的向量化定价为每7万个汉字（约10万Tokens）0.5元人民币。`（由模板与单位动态渲染得出）。
  - OCR：管理员配置每 1 页 0.05 CNY（CN 供应商：合合 TextIn）；用户备注呈现（示例）：`OCR服务是指将您上传的图片形式的书籍转化成可复制，可搜索的文字信息并可由你自由下载保存。雅典娜的 OCR 定价为每页 0.05 元人民币（中国区），具体费用随管理后台配置与币种实时更新。`
权限说明（与后端一致）：开发态（`DEV_MODE=true`）允许绕过管理员校验；生产环境需 `ADMIN_USER_ID` 精确匹配方可操作。
### 修订记录（2025-11-23）

- 对象存储术语统一：使用“SeaweedFS（S3 兼容）”，保留 `MINIO_*` 前缀作为客户端兼容变量；公共域名重写由后端 `MINIO_PUBLIC_ENDPOINT` 控制
- 数据库 Schema 扩展：
  - `books.meta JSONB` 引入 `page_count` 字段作为 OCR 阶梯扣费依据，并建立表达式索引 `idx_books_meta_page`
  - 新增业务表：`notes/tags/highlights` 与关联表 `note_tags/highlight_tags`，外键 `ON DELETE CASCADE`，索引包含 `user_id+updated_at` 与 `GIN(tsv)`
  - 行级安全（RLS）：为上述业务表开启 RLS，用户仅能访问自身数据；管理/后台通过 `app.role='admin'` 绕过
  - 标签唯一约束：采用部分唯一索引 `UNIQUE(user_id,name) WHERE deleted_at IS NULL`，支持软删除后重建同名标签
  - 转换任务列名统一：`conversion_jobs` 统一使用 `user_id` 列（与迁移 0100 对齐）
  - 定价字段扩展：`pricing_rules` 增加 `platform/sku_id` 用于多平台差异化定价
- 业务流程更新：
  - 上传完成：写入占位 `meta.page_count=1` 与 `needs_manual=true`，后续深度分析与后台任务回填真实页数
  - 深度分析：若缺失页数字段，补写占位；生成 `digitalize_report_key` 便于审计
  - OCR 阶梯扣费：以 `meta.page_count` 判定扣费次数与策略（PRO 免费额度优先，超过阈值走加油包）；并发与优先级遵循单卡策略
- 开发与预览：前端 Vite 采用 `VITE_API_BASE_URL` 代理并启用 `hmr: { protocol: 'ws' }`；桌面 Tauri `devPath/CSP` 对齐
- PWA 离线：缓存键命名 `book-${bookId}-${etag}`，派生资产独立前缀；LRU 清理与离线管理页面；IndexedDB 队列+乐观并发，冲突生成 `note_versions`
- CI 门禁：axe 严重/高违规=0 与核心旅程 E2E 固化为质量门槛；测试环境采用 SeaweedFS/OpenSearch
